var __decorate = this && this.__decorate || function(e, t, i, r) {
		var n, o = arguments.length,
			s = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, i) : r;
		if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(e, t, i, r);
		else
			for (var a = e.length - 1; a >= 0; a--)(n = e[a]) && (s = (o < 3 ? n(s) : o > 3 ? n(t, i, s) : n(t, i)) || s);
		return o > 3 && s && Object.defineProperty(t, i, s), s
	},
	__extends = this && this.__extends || function(e, t) {
		function i() {
			this.constructor = e
		}
		for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r]);
		i.prototype = t.prototype, e.prototype = new i
	},
	BABYLON;
!(function(e) {
	e.ToGammaSpace = 1 / 2.2, e.ToLinearSpace = 2.2, e.Epsilon = .001;
	var t = (function() {
		function e() {}
		return e.WithinEpsilon = function(e, t, i) {
			void 0 === i && (i = 1.401298e-45);
			var r = e - t;
			return -i <= r && r <= i
		}, e.ToHex = function(e) {
			var t = e.toString(16);
			return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase()
		}, e.Sign = function(e) {
			return e = +e, 0 === e || isNaN(e) ? e : e > 0 ? 1 : -1
		}, e.Clamp = function(e, t, i) {
			return void 0 === t && (t = 0), void 0 === i && (i = 1), Math.min(i, Math.max(t, e))
		}, e
	})();
	e.MathTools = t;
	var i = (function() {
		function i(e, t, i) {
			void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 0), this.r = e, this.g = t, this.b = i
		}
		return i.prototype.toString = function() {
			return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}"
		}, i.prototype.getClassName = function() {
			return "Color3"
		}, i.prototype.getHashCode = function() {
			var e = this.r || 0;
			return e = 397 * e ^ (this.g || 0), e = 397 * e ^ (this.b || 0)
		}, i.prototype.toArray = function(e, t) {
			return void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this
		}, i.prototype.toColor4 = function(e) {
			return void 0 === e && (e = 1), new r(this.r, this.g, this.b, e)
		}, i.prototype.asArray = function() {
			var e = [];
			return this.toArray(e, 0), e
		}, i.prototype.toLuminance = function() {
			return .3 * this.r + .59 * this.g + .11 * this.b
		}, i.prototype.multiply = function(e) {
			return new i(this.r * e.r, this.g * e.g, this.b * e.b)
		}, i.prototype.multiplyToRef = function(e, t) {
			return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, this
		}, i.prototype.equals = function(e) {
			return e && this.r === e.r && this.g === e.g && this.b === e.b
		}, i.prototype.equalsFloats = function(e, t, i) {
			return this.r === e && this.g === t && this.b === i
		}, i.prototype.scale = function(e) {
			return new i(this.r * e, this.g * e, this.b * e)
		}, i.prototype.scaleToRef = function(e, t) {
			return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, this
		}, i.prototype.add = function(e) {
			return new i(this.r + e.r, this.g + e.g, this.b + e.b)
		}, i.prototype.addToRef = function(e, t) {
			return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, this
		}, i.prototype.subtract = function(e) {
			return new i(this.r - e.r, this.g - e.g, this.b - e.b)
		}, i.prototype.subtractToRef = function(e, t) {
			return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, this
		}, i.prototype.clone = function() {
			return new i(this.r, this.g, this.b)
		}, i.prototype.copyFrom = function(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this
		}, i.prototype.copyFromFloats = function(e, t, i) {
			return this.r = e, this.g = t, this.b = i, this
		}, i.prototype.toHexString = function() {
			var e = 255 * this.r | 0,
				i = 255 * this.g | 0,
				r = 255 * this.b | 0;
			return "#" + t.ToHex(e) + t.ToHex(i) + t.ToHex(r)
		}, i.prototype.toLinearSpace = function() {
			var e = new i;
			return this.toLinearSpaceToRef(e), e
		}, i.prototype.toLinearSpaceToRef = function(t) {
			return t.r = Math.pow(this.r, e.ToLinearSpace), t.g = Math.pow(this.g, e.ToLinearSpace), t.b = Math.pow(this.b, e.ToLinearSpace), this
		}, i.prototype.toGammaSpace = function() {
			var e = new i;
			return this.toGammaSpaceToRef(e), e
		}, i.prototype.toGammaSpaceToRef = function(t) {
			return t.r = Math.pow(this.r, e.ToGammaSpace), t.g = Math.pow(this.g, e.ToGammaSpace), t.b = Math.pow(this.b, e.ToGammaSpace), this
		}, i.FromHexString = function(e) {
			if ("#" !== e.substring(0, 1) || 7 !== e.length) return new i(0, 0, 0);
			var t = parseInt(e.substring(1, 3), 16),
				r = parseInt(e.substring(3, 5), 16),
				n = parseInt(e.substring(5, 7), 16);
			return i.FromInts(t, r, n)
		}, i.FromArray = function(e, t) {
			return void 0 === t && (t = 0), new i(e[t], e[t + 1], e[t + 2])
		}, i.FromInts = function(e, t, r) {
			return new i(e / 255, t / 255, r / 255)
		}, i.Lerp = function(e, t, r) {
			var n = e.r + (t.r - e.r) * r,
				o = e.g + (t.g - e.g) * r,
				s = e.b + (t.b - e.b) * r;
			return new i(n, o, s)
		}, i.Red = function() {
			return new i(1, 0, 0)
		}, i.Green = function() {
			return new i(0, 1, 0)
		}, i.Blue = function() {
			return new i(0, 0, 1)
		}, i.Black = function() {
			return new i(0, 0, 0)
		}, i.White = function() {
			return new i(1, 1, 1)
		}, i.Purple = function() {
			return new i(.5, 0, .5)
		}, i.Magenta = function() {
			return new i(1, 0, 1)
		}, i.Yellow = function() {
			return new i(1, 1, 0)
		}, i.Gray = function() {
			return new i(.5, .5, .5)
		}, i
	})();
	e.Color3 = i;
	var r = (function() {
		function e(e, t, i, r) {
			this.r = e, this.g = t, this.b = i, this.a = r
		}
		return e.prototype.addInPlace = function(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this
		}, e.prototype.asArray = function() {
			var e = [];
			return this.toArray(e, 0), e
		}, e.prototype.toArray = function(e, t) {
			return void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this
		}, e.prototype.add = function(t) {
			return new e(this.r + t.r, this.g + t.g, this.b + t.b, this.a + t.a)
		}, e.prototype.subtract = function(t) {
			return new e(this.r - t.r, this.g - t.g, this.b - t.b, this.a - t.a)
		}, e.prototype.subtractToRef = function(e, t) {
			return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, this
		}, e.prototype.scale = function(t) {
			return new e(this.r * t, this.g * t, this.b * t, this.a * t)
		}, e.prototype.scaleToRef = function(e, t) {
			return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, this
		}, e.prototype.multiply = function(t) {
			return new e(this.r * t.r, this.g * t.g, this.b * t.b, this.a * t.a)
		}, e.prototype.multiplyToRef = function(e, t) {
			return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t
		}, e.prototype.toString = function() {
			return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}"
		}, e.prototype.getClassName = function() {
			return "Color4"
		}, e.prototype.getHashCode = function() {
			var e = this.r || 0;
			return e = 397 * e ^ (this.g || 0), e = 397 * e ^ (this.b || 0), e = 397 * e ^ (this.a || 0)
		}, e.prototype.clone = function() {
			return new e(this.r, this.g, this.b, this.a)
		}, e.prototype.copyFrom = function(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this
		}, e.prototype.toHexString = function() {
			var e = 255 * this.r | 0,
				i = 255 * this.g | 0,
				r = 255 * this.b | 0,
				n = 255 * this.a | 0;
			return "#" + t.ToHex(e) + t.ToHex(i) + t.ToHex(r) + t.ToHex(n)
		}, e.FromHexString = function(t) {
			if ("#" !== t.substring(0, 1) || 9 !== t.length) return new e(0, 0, 0, 0);
			var i = parseInt(t.substring(1, 3), 16),
				r = parseInt(t.substring(3, 5), 16),
				n = parseInt(t.substring(5, 7), 16),
				o = parseInt(t.substring(7, 9), 16);
			return e.FromInts(i, r, n, o)
		}, e.Lerp = function(t, i, r) {
			var n = new e(0, 0, 0, 0);
			return e.LerpToRef(t, i, r, n), n
		}, e.LerpToRef = function(e, t, i, r) {
			r.r = e.r + (t.r - e.r) * i, r.g = e.g + (t.g - e.g) * i, r.b = e.b + (t.b - e.b) * i, r.a = e.a + (t.a - e.a) * i
		}, e.FromArray = function(t, i) {
			return void 0 === i && (i = 0), new e(t[i], t[i + 1], t[i + 2], t[i + 3])
		}, e.FromInts = function(t, i, r, n) {
			return new e(t / 255, i / 255, r / 255, n / 255)
		}, e.CheckColors4 = function(e, t) {
			if (e.length === 3 * t) {
				for (var i = [], r = 0; r < e.length; r += 3) {
					var n = r / 3 * 4;
					i[n] = e[r], i[n + 1] = e[r + 1], i[n + 2] = e[r + 2], i[n + 3] = 1
				}
				return i
			}
			return e
		}, e
	})();
	e.Color4 = r;
	var n = (function() {
		function i(e, t) {
			this.x = e, this.y = t
		}
		return i.prototype.toString = function() {
			return "{X: " + this.x + " Y:" + this.y + "}"
		}, i.prototype.getClassName = function() {
			return "Vector2"
		}, i.prototype.getHashCode = function() {
			var e = this.x || 0;
			return e = 397 * e ^ (this.y || 0)
		}, i.prototype.toArray = function(e, t) {
			return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, this
		}, i.prototype.asArray = function() {
			var e = [];
			return this.toArray(e, 0), e
		}, i.prototype.copyFrom = function(e) {
			return this.x = e.x, this.y = e.y, this
		}, i.prototype.copyFromFloats = function(e, t) {
			return this.x = e, this.y = t, this
		}, i.prototype.add = function(e) {
			return new i(this.x + e.x, this.y + e.y)
		}, i.prototype.addToRef = function(e, t) {
			return t.x = this.x + e.x, t.y = this.y + e.y, this
		}, i.prototype.addInPlace = function(e) {
			return this.x += e.x, this.y += e.y, this
		}, i.prototype.addVector3 = function(e) {
			return new i(this.x + e.x, this.y + e.y)
		}, i.prototype.subtract = function(e) {
			return new i(this.x - e.x, this.y - e.y)
		}, i.prototype.subtractToRef = function(e, t) {
			return t.x = this.x - e.x, t.y = this.y - e.y, this
		}, i.prototype.subtractInPlace = function(e) {
			return this.x -= e.x, this.y -= e.y, this
		}, i.prototype.multiplyInPlace = function(e) {
			return this.x *= e.x, this.y *= e.y, this
		}, i.prototype.multiply = function(e) {
			return new i(this.x * e.x, this.y * e.y)
		}, i.prototype.multiplyToRef = function(e, t) {
			return t.x = this.x * e.x, t.y = this.y * e.y, this
		}, i.prototype.multiplyByFloats = function(e, t) {
			return new i(this.x * e, this.y * t)
		}, i.prototype.divide = function(e) {
			return new i(this.x / e.x, this.y / e.y)
		}, i.prototype.divideToRef = function(e, t) {
			return t.x = this.x / e.x, t.y = this.y / e.y, this
		}, i.prototype.negate = function() {
			return new i((-this.x), (-this.y))
		}, i.prototype.scaleInPlace = function(e) {
			return this.x *= e, this.y *= e, this
		}, i.prototype.scale = function(e) {
			return new i(this.x * e, this.y * e)
		}, i.prototype.equals = function(e) {
			return e && this.x === e.x && this.y === e.y
		}, i.prototype.equalsWithEpsilon = function(i, r) {
			return void 0 === r && (r = e.Epsilon), i && t.WithinEpsilon(this.x, i.x, r) && t.WithinEpsilon(this.y, i.y, r)
		}, i.prototype.length = function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		}, i.prototype.lengthSquared = function() {
			return this.x * this.x + this.y * this.y
		}, i.prototype.normalize = function() {
			var e = this.length();
			if (0 === e) return this;
			var t = 1 / e;
			return this.x *= t, this.y *= t, this
		}, i.prototype.clone = function() {
			return new i(this.x, this.y)
		}, i.Zero = function() {
			return new i(0, 0)
		}, i.FromArray = function(e, t) {
			return void 0 === t && (t = 0), new i(e[t], e[t + 1])
		}, i.FromArrayToRef = function(e, t, i) {
			i.x = e[t], i.y = e[t + 1]
		}, i.CatmullRom = function(e, t, r, n, o) {
			var s = o * o,
				a = o * s,
				h = .5 * (2 * t.x + (-e.x + r.x) * o + (2 * e.x - 5 * t.x + 4 * r.x - n.x) * s + (-e.x + 3 * t.x - 3 * r.x + n.x) * a),
				c = .5 * (2 * t.y + (-e.y + r.y) * o + (2 * e.y - 5 * t.y + 4 * r.y - n.y) * s + (-e.y + 3 * t.y - 3 * r.y + n.y) * a);
			return new i(h, c)
		}, i.Clamp = function(e, t, r) {
			var n = e.x;
			n = n > r.x ? r.x : n, n = n < t.x ? t.x : n;
			var o = e.y;
			return o = o > r.y ? r.y : o, o = o < t.y ? t.y : o, new i(n, o)
		}, i.Hermite = function(e, t, r, n, o) {
			var s = o * o,
				a = o * s,
				h = 2 * a - 3 * s + 1,
				c = -2 * a + 3 * s,
				l = a - 2 * s + o,
				u = a - s,
				d = e.x * h + r.x * c + t.x * l + n.x * u,
				f = e.y * h + r.y * c + t.y * l + n.y * u;
			return new i(d, f)
		}, i.Lerp = function(e, t, r) {
			var n = e.x + (t.x - e.x) * r,
				o = e.y + (t.y - e.y) * r;
			return new i(n, o)
		}, i.Dot = function(e, t) {
			return e.x * t.x + e.y * t.y
		}, i.Normalize = function(e) {
			var t = e.clone();
			return t.normalize(), t
		}, i.Minimize = function(e, t) {
			var r = e.x < t.x ? e.x : t.x,
				n = e.y < t.y ? e.y : t.y;
			return new i(r, n)
		}, i.Maximize = function(e, t) {
			var r = e.x > t.x ? e.x : t.x,
				n = e.y > t.y ? e.y : t.y;
			return new i(r, n)
		}, i.Transform = function(e, t) {
			var r = i.Zero();
			return i.TransformToRef(e, t, r), r
		}, i.TransformToRef = function(e, t, i) {
			var r = e.x * t.m[0] + e.y * t.m[4] + t.m[12],
				n = e.x * t.m[1] + e.y * t.m[5] + t.m[13];
			i.x = r, i.y = n
		}, i.PointInTriangle = function(e, t, i, r) {
			var n = .5 * (-i.y * r.x + t.y * (-i.x + r.x) + t.x * (i.y - r.y) + i.x * r.y),
				o = n < 0 ? -1 : 1,
				s = (t.y * r.x - t.x * r.y + (r.y - t.y) * e.x + (t.x - r.x) * e.y) * o,
				a = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * o;
			return s > 0 && a > 0 && s + a < 2 * n * o
		}, i.Distance = function(e, t) {
			return Math.sqrt(i.DistanceSquared(e, t))
		}, i.DistanceSquared = function(e, t) {
			var i = e.x - t.x,
				r = e.y - t.y;
			return i * i + r * r
		}, i.Center = function(e, t) {
			var i = e.add(t);
			return i.scaleInPlace(.5), i
		}, i.DistanceOfPointFromSegment = function(e, t, r) {
			var n = i.DistanceSquared(t, r);
			if (0 === n) return i.Distance(e, t);
			var o = r.subtract(t),
				s = Math.max(0, Math.min(1, i.Dot(e.subtract(t), o) / n)),
				a = t.add(o.multiplyByFloats(s, s));
			return i.Distance(e, a)
		}, i
	})();
	e.Vector2 = n;
	var o = (function() {
		function i(e, t, i) {
			this.x = e, this.y = t, this.z = i
		}
		return i.prototype.toString = function() {
			return "{X: " + this.x + " Y:" + this.y + " Z:" + this.z + "}"
		}, i.prototype.getClassName = function() {
			return "Vector3"
		}, i.prototype.getHashCode = function() {
			var e = this.x || 0;
			return e = 397 * e ^ (this.y || 0), e = 397 * e ^ (this.z || 0)
		}, i.prototype.asArray = function() {
			var e = [];
			return this.toArray(e, 0), e
		}, i.prototype.toArray = function(e, t) {
			return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, this
		}, i.prototype.toQuaternion = function() {
			var e = new h(0, 0, 0, 1),
				t = Math.cos(.5 * (this.x + this.z)),
				i = Math.sin(.5 * (this.x + this.z)),
				r = Math.cos(.5 * (this.z - this.x)),
				n = Math.sin(.5 * (this.z - this.x)),
				o = Math.cos(.5 * this.y),
				s = Math.sin(.5 * this.y);
			return e.x = r * s, e.y = -n * s, e.z = i * o, e.w = t * o, e
		}, i.prototype.addInPlace = function(e) {
			return this.x += e.x, this.y += e.y, this.z += e.z, this
		}, i.prototype.add = function(e) {
			return new i(this.x + e.x, this.y + e.y, this.z + e.z)
		}, i.prototype.addToRef = function(e, t) {
			return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, this
		}, i.prototype.subtractInPlace = function(e) {
			return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
		}, i.prototype.subtract = function(e) {
			return new i(this.x - e.x, this.y - e.y, this.z - e.z)
		}, i.prototype.subtractToRef = function(e, t) {
			return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, this
		}, i.prototype.subtractFromFloats = function(e, t, r) {
			return new i(this.x - e, this.y - t, this.z - r)
		}, i.prototype.subtractFromFloatsToRef = function(e, t, i, r) {
			return r.x = this.x - e, r.y = this.y - t, r.z = this.z - i, this
		}, i.prototype.negate = function() {
			return new i((-this.x), (-this.y), (-this.z))
		}, i.prototype.scaleInPlace = function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		}, i.prototype.scale = function(e) {
			return new i(this.x * e, this.y * e, this.z * e)
		}, i.prototype.scaleToRef = function(e, t) {
			t.x = this.x * e, t.y = this.y * e, t.z = this.z * e
		}, i.prototype.equals = function(e) {
			return e && this.x === e.x && this.y === e.y && this.z === e.z
		}, i.prototype.equalsWithEpsilon = function(i, r) {
			return void 0 === r && (r = e.Epsilon), i && t.WithinEpsilon(this.x, i.x, r) && t.WithinEpsilon(this.y, i.y, r) && t.WithinEpsilon(this.z, i.z, r)
		}, i.prototype.equalsToFloats = function(e, t, i) {
			return this.x === e && this.y === t && this.z === i
		}, i.prototype.multiplyInPlace = function(e) {
			return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
		}, i.prototype.multiply = function(e) {
			return new i(this.x * e.x, this.y * e.y, this.z * e.z)
		}, i.prototype.multiplyToRef = function(e, t) {
			return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, this
		}, i.prototype.multiplyByFloats = function(e, t, r) {
			return new i(this.x * e, this.y * t, this.z * r)
		}, i.prototype.divide = function(e) {
			return new i(this.x / e.x, this.y / e.y, this.z / e.z)
		}, i.prototype.divideToRef = function(e, t) {
			return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, this
		}, i.prototype.MinimizeInPlace = function(e) {
			return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), this
		}, i.prototype.MaximizeInPlace = function(e) {
			return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), this
		}, i.prototype.length = function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		}, i.prototype.lengthSquared = function() {
			return this.x * this.x + this.y * this.y + this.z * this.z
		}, i.prototype.normalize = function() {
			var e = this.length();
			if (0 === e || 1 === e) return this;
			var t = 1 / e;
			return this.x *= t, this.y *= t, this.z *= t, this
		}, i.prototype.clone = function() {
			return new i(this.x, this.y, this.z)
		}, i.prototype.copyFrom = function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this
		}, i.prototype.copyFromFloats = function(e, t, i) {
			return this.x = e, this.y = t, this.z = i, this
		}, i.GetClipFactor = function(e, t, r, n) {
			var o = i.Dot(e, r) - n,
				s = i.Dot(t, r) - n,
				a = o / (o - s);
			return a
		}, i.FromArray = function(e, t) {
			return t || (t = 0), new i(e[t], e[t + 1], e[t + 2])
		}, i.FromFloatArray = function(e, t) {
			return t || (t = 0), new i(e[t], e[t + 1], e[t + 2])
		}, i.FromArrayToRef = function(e, t, i) {
			i.x = e[t], i.y = e[t + 1], i.z = e[t + 2]
		}, i.FromFloatArrayToRef = function(e, t, i) {
			i.x = e[t], i.y = e[t + 1], i.z = e[t + 2]
		}, i.FromFloatsToRef = function(e, t, i, r) {
			r.x = e, r.y = t, r.z = i
		}, i.Zero = function() {
			return new i(0, 0, 0)
		}, i.Up = function() {
			return new i(0, 1, 0)
		}, i.Forward = function() {
			return new i(0, 0, 1)
		}, i.Right = function() {
			return new i(1, 0, 0)
		}, i.Left = function() {
			return new i((-1), 0, 0)
		}, i.TransformCoordinates = function(e, t) {
			var r = i.Zero();
			return i.TransformCoordinatesToRef(e, t, r), r
		}, i.TransformCoordinatesToRef = function(e, t, i) {
			var r = e.x * t.m[0] + e.y * t.m[4] + e.z * t.m[8] + t.m[12],
				n = e.x * t.m[1] + e.y * t.m[5] + e.z * t.m[9] + t.m[13],
				o = e.x * t.m[2] + e.y * t.m[6] + e.z * t.m[10] + t.m[14],
				s = e.x * t.m[3] + e.y * t.m[7] + e.z * t.m[11] + t.m[15];
			i.x = r / s, i.y = n / s, i.z = o / s
		}, i.TransformCoordinatesFromFloatsToRef = function(e, t, i, r, n) {
			var o = e * r.m[0] + t * r.m[4] + i * r.m[8] + r.m[12],
				s = e * r.m[1] + t * r.m[5] + i * r.m[9] + r.m[13],
				a = e * r.m[2] + t * r.m[6] + i * r.m[10] + r.m[14],
				h = e * r.m[3] + t * r.m[7] + i * r.m[11] + r.m[15];
			n.x = o / h, n.y = s / h, n.z = a / h
		}, i.TransformNormal = function(e, t) {
			var r = i.Zero();
			return i.TransformNormalToRef(e, t, r), r
		}, i.TransformNormalToRef = function(e, t, i) {
			var r = e.x * t.m[0] + e.y * t.m[4] + e.z * t.m[8],
				n = e.x * t.m[1] + e.y * t.m[5] + e.z * t.m[9],
				o = e.x * t.m[2] + e.y * t.m[6] + e.z * t.m[10];
			i.x = r, i.y = n, i.z = o
		}, i.TransformNormalFromFloatsToRef = function(e, t, i, r, n) {
			n.x = e * r.m[0] + t * r.m[4] + i * r.m[8], n.y = e * r.m[1] + t * r.m[5] + i * r.m[9], n.z = e * r.m[2] + t * r.m[6] + i * r.m[10]
		}, i.CatmullRom = function(e, t, r, n, o) {
			var s = o * o,
				a = o * s,
				h = .5 * (2 * t.x + (-e.x + r.x) * o + (2 * e.x - 5 * t.x + 4 * r.x - n.x) * s + (-e.x + 3 * t.x - 3 * r.x + n.x) * a),
				c = .5 * (2 * t.y + (-e.y + r.y) * o + (2 * e.y - 5 * t.y + 4 * r.y - n.y) * s + (-e.y + 3 * t.y - 3 * r.y + n.y) * a),
				l = .5 * (2 * t.z + (-e.z + r.z) * o + (2 * e.z - 5 * t.z + 4 * r.z - n.z) * s + (-e.z + 3 * t.z - 3 * r.z + n.z) * a);
			return new i(h, c, l)
		}, i.Clamp = function(e, t, r) {
			var n = e.x;
			n = n > r.x ? r.x : n, n = n < t.x ? t.x : n;
			var o = e.y;
			o = o > r.y ? r.y : o, o = o < t.y ? t.y : o;
			var s = e.z;
			return s = s > r.z ? r.z : s, s = s < t.z ? t.z : s, new i(n, o, s)
		}, i.Hermite = function(e, t, r, n, o) {
			var s = o * o,
				a = o * s,
				h = 2 * a - 3 * s + 1,
				c = -2 * a + 3 * s,
				l = a - 2 * s + o,
				u = a - s,
				d = e.x * h + r.x * c + t.x * l + n.x * u,
				f = e.y * h + r.y * c + t.y * l + n.y * u,
				p = e.z * h + r.z * c + t.z * l + n.z * u;
			return new i(d, f, p)
		}, i.Lerp = function(e, t, r) {
			var n = e.x + (t.x - e.x) * r,
				o = e.y + (t.y - e.y) * r,
				s = e.z + (t.z - e.z) * r;
			return new i(n, o, s)
		}, i.Dot = function(e, t) {
			return e.x * t.x + e.y * t.y + e.z * t.z
		}, i.Cross = function(e, t) {
			var r = i.Zero();
			return i.CrossToRef(e, t, r), r
		}, i.CrossToRef = function(e, t, i) {
			P.Vector3[0].x = e.y * t.z - e.z * t.y, P.Vector3[0].y = e.z * t.x - e.x * t.z, P.Vector3[0].z = e.x * t.y - e.y * t.x, i.copyFrom(P.Vector3[0])
		}, i.Normalize = function(e) {
			var t = i.Zero();
			return i.NormalizeToRef(e, t), t
		}, i.NormalizeToRef = function(e, t) {
			t.copyFrom(e), t.normalize()
		}, i.Project = function(e, t, r, n) {
			var o = n.width,
				s = n.height,
				a = n.x,
				h = n.y,
				l = i._viewportMatrixCache ? i._viewportMatrixCache : i._viewportMatrixCache = new c;
			c.FromValuesToRef(o / 2, 0, 0, 0, 0, -s / 2, 0, 0, 0, 0, 1, 0, a + o / 2, s / 2 + h, 0, 1, l);
			var u = i._matrixCache ? i._matrixCache : i._matrixCache = new c;
			return t.multiplyToRef(r, u), u.multiplyToRef(l, u), i.TransformCoordinates(e, u)
		}, i.UnprojectFromTransform = function(e, r, n, o, s) {
			var a = i._matrixCache ? i._matrixCache : i._matrixCache = new c;
			o.multiplyToRef(s, a), a.invert(), e.x = e.x / r * 2 - 1, e.y = -(e.y / n * 2 - 1);
			var h = i.TransformCoordinates(e, a),
				l = e.x * a.m[3] + e.y * a.m[7] + e.z * a.m[11] + a.m[15];
			return t.WithinEpsilon(l, 1) && (h = h.scale(1 / l)), h
		}, i.Unproject = function(e, r, n, o, s, a) {
			var h = i._matrixCache ? i._matrixCache : i._matrixCache = new c;
			o.multiplyToRef(s, h), h.multiplyToRef(a, h), h.invert();
			var l = new i(e.x / r * 2 - 1, (-(e.y / n * 2 - 1)), e.z),
				u = i.TransformCoordinates(l, h),
				d = l.x * h.m[3] + l.y * h.m[7] + l.z * h.m[11] + h.m[15];
			return t.WithinEpsilon(d, 1) && (u = u.scale(1 / d)), u
		}, i.Minimize = function(e, t) {
			var i = e.clone();
			return i.MinimizeInPlace(t), i
		}, i.Maximize = function(e, t) {
			var i = e.clone();
			return i.MaximizeInPlace(t), i
		}, i.Distance = function(e, t) {
			return Math.sqrt(i.DistanceSquared(e, t))
		}, i.DistanceSquared = function(e, t) {
			var i = e.x - t.x,
				r = e.y - t.y,
				n = e.z - t.z;
			return i * i + r * r + n * n
		}, i.Center = function(e, t) {
			var i = e.add(t);
			return i.scaleInPlace(.5), i
		}, i.RotationFromAxis = function(e, t, r) {
			var n = i.Zero();
			return i.RotationFromAxisToRef(e, t, r, n), n
		}, i.RotationFromAxisToRef = function(r, n, o, s) {
			var a = r.normalize(),
				h = o.normalize(),
				c = f.X,
				l = f.Y,
				u = 0,
				d = 0,
				p = 0,
				m = 0,
				_ = 0,
				g = 0,
				v = 0,
				y = -1,
				x = 0,
				b = P.Vector3[0],
				T = 0,
				A = P.Vector3[1];
			t.WithinEpsilon(h.z, 0, e.Epsilon) ? g = 1 : t.WithinEpsilon(h.x, 0, e.Epsilon) ? m = 1 : (v = h.z / h.x, m = -v * Math.sqrt(1 / (1 + v * v)), g = Math.sqrt(1 / (1 + v * v))), A.x = m, A.y = _, A.z = g, A.normalize(), i.CrossToRef(a, A, b), b.normalize(), i.Dot(h, b) < 0 && (y = 1), T = i.Dot(a, A), T = Math.min(1, Math.max(-1, T)), p = Math.acos(T) * y, i.Dot(A, c) < 0 && (p = Math.PI + p, A = A.scaleInPlace(-1), x++);
			var E = P.Vector3[2],
				M = P.Vector3[3];
			m = 0, _ = 0, g = 0, y = -1, t.WithinEpsilon(h.z, 0, e.Epsilon) ? m = 1 : (v = A.z / A.x, m = -v * Math.sqrt(1 / (1 + v * v)), g = Math.sqrt(1 / (1 + v * v))), E.x = m, E.y = _, E.z = g, E.normalize(), i.CrossToRef(E, A, M), M.normalize(), i.CrossToRef(h, E, b), b.normalize(), i.Dot(A, b) < 0 && (y = 1), T = i.Dot(h, E), T = Math.min(1, Math.max(-1, T)), d = Math.acos(T) * y, i.Dot(M, l) < 0 && (d = Math.PI + d, x++), y = -1, i.CrossToRef(c, A, b), b.normalize(), i.Dot(b, l) < 0 && (y = 1), T = i.Dot(A, c), T = Math.min(1, Math.max(-1, T)), u = -Math.acos(T) * y, T < 0 && x < 2 && (u = Math.PI + u), s.x = d, s.y = u, s.z = p
		}, i
	})();
	e.Vector3 = o;
	var s = (function() {
		function i(e, t, i, r) {
			this.x = e, this.y = t, this.z = i, this.w = r
		}
		return i.prototype.toString = function() {
			return "{X: " + this.x + " Y:" + this.y + " Z:" + this.z + " W:" + this.w + "}"
		}, i.prototype.getClassName = function() {
			return "Vector4"
		}, i.prototype.getHashCode = function() {
			var e = this.x || 0;
			return e = 397 * e ^ (this.y || 0), e = 397 * e ^ (this.z || 0), e = 397 * e ^ (this.w || 0)
		}, i.prototype.asArray = function() {
			var e = [];
			return this.toArray(e, 0), e
		}, i.prototype.toArray = function(e, t) {
			return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this
		}, i.prototype.addInPlace = function(e) {
			return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
		}, i.prototype.add = function(e) {
			return new i(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w)
		}, i.prototype.addToRef = function(e, t) {
			return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, this
		}, i.prototype.subtractInPlace = function(e) {
			return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
		}, i.prototype.subtract = function(e) {
			return new i(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w)
		}, i.prototype.subtractToRef = function(e, t) {
			return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, this
		}, i.prototype.subtractFromFloats = function(e, t, r, n) {
			return new i(this.x - e, this.y - t, this.z - r, this.w - n)
		}, i.prototype.subtractFromFloatsToRef = function(e, t, i, r, n) {
			return n.x = this.x - e, n.y = this.y - t, n.z = this.z - i, n.w = this.w - r, this
		}, i.prototype.negate = function() {
			return new i((-this.x), (-this.y), (-this.z), (-this.w))
		}, i.prototype.scaleInPlace = function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
		}, i.prototype.scale = function(e) {
			return new i(this.x * e, this.y * e, this.z * e, this.w * e)
		}, i.prototype.scaleToRef = function(e, t) {
			t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e
		}, i.prototype.equals = function(e) {
			return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
		}, i.prototype.equalsWithEpsilon = function(i, r) {
			return void 0 === r && (r = e.Epsilon), i && t.WithinEpsilon(this.x, i.x, r) && t.WithinEpsilon(this.y, i.y, r) && t.WithinEpsilon(this.z, i.z, r) && t.WithinEpsilon(this.w, i.w, r)
		}, i.prototype.equalsToFloats = function(e, t, i, r) {
			return this.x === e && this.y === t && this.z === i && this.w === r
		}, i.prototype.multiplyInPlace = function(e) {
			return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
		}, i.prototype.multiply = function(e) {
			return new i(this.x * e.x, this.y * e.y, this.z * e.z, this.w * e.w)
		}, i.prototype.multiplyToRef = function(e, t) {
			return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, this
		}, i.prototype.multiplyByFloats = function(e, t, r, n) {
			return new i(this.x * e, this.y * t, this.z * r, this.w * n)
		}, i.prototype.divide = function(e) {
			return new i(this.x / e.x, this.y / e.y, this.z / e.z, this.w / e.w)
		}, i.prototype.divideToRef = function(e, t) {
			return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, this
		}, i.prototype.MinimizeInPlace = function(e) {
			return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this
		}, i.prototype.MaximizeInPlace = function(e) {
			return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this
		}, i.prototype.length = function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		}, i.prototype.lengthSquared = function() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
		}, i.prototype.normalize = function() {
			var e = this.length();
			if (0 === e) return this;
			var t = 1 / e;
			return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
		}, i.prototype.toVector3 = function() {
			return new o(this.x, this.y, this.z)
		}, i.prototype.clone = function() {
			return new i(this.x, this.y, this.z, this.w)
		}, i.prototype.copyFrom = function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this
		}, i.prototype.copyFromFloats = function(e, t, i, r) {
			return this.x = e, this.y = t, this.z = i, this.w = r, this
		}, i.FromArray = function(e, t) {
			return t || (t = 0), new i(e[t], e[t + 1], e[t + 2], e[t + 3])
		}, i.FromArrayToRef = function(e, t, i) {
			i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3]
		}, i.FromFloatArrayToRef = function(e, t, i) {
			i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3]
		}, i.FromFloatsToRef = function(e, t, i, r, n) {
			n.x = e, n.y = t, n.z = i, n.w = r
		}, i.Zero = function() {
			return new i(0, 0, 0, 0)
		}, i.Normalize = function(e) {
			var t = i.Zero();
			return i.NormalizeToRef(e, t), t
		}, i.NormalizeToRef = function(e, t) {
			t.copyFrom(e), t.normalize()
		}, i.Minimize = function(e, t) {
			var i = e.clone();
			return i.MinimizeInPlace(t), i
		}, i.Maximize = function(e, t) {
			var i = e.clone();
			return i.MaximizeInPlace(t), i
		}, i.Distance = function(e, t) {
			return Math.sqrt(i.DistanceSquared(e, t))
		}, i.DistanceSquared = function(e, t) {
			var i = e.x - t.x,
				r = e.y - t.y,
				n = e.z - t.z,
				o = e.w - t.w;
			return i * i + r * r + n * n + o * o
		}, i.Center = function(e, t) {
			var i = e.add(t);
			return i.scaleInPlace(.5), i
		}, i
	})();
	e.Vector4 = s;
	var a = (function() {
		function e(e, t) {
			this.width = e, this.height = t
		}
		return e.prototype.toString = function() {
			return "{W: " + this.width + ", H: " + this.height + "}"
		}, e.prototype.getClassName = function() {
			return "Size"
		}, e.prototype.getHashCode = function() {
			var e = this.width || 0;
			return e = 397 * e ^ (this.height || 0)
		}, e.prototype.copyFrom = function(e) {
			this.width = e.width, this.height = e.height
		}, e.prototype.copyFromFloats = function(e, t) {
			this.width = e, this.height = t
		}, e.prototype.multiplyByFloats = function(t, i) {
			return new e(this.width * t, this.height * i)
		}, e.prototype.clone = function() {
			return new e(this.width, this.height)
		}, e.prototype.equals = function(e) {
			return !!e && (this.width === e.width && this.height === e.height)
		}, Object.defineProperty(e.prototype, "surface", {
			get: function() {
				return this.width * this.height
			},
			enumerable: !0,
			configurable: !0
		}), e.Zero = function() {
			return new e(0, 0)
		}, e.prototype.add = function(t) {
			var i = new e(this.width + t.width, this.height + t.height);
			return i
		}, e.prototype.substract = function(t) {
			var i = new e(this.width - t.width, this.height - t.height);
			return i
		}, e.Lerp = function(t, i, r) {
			var n = t.width + (i.width - t.width) * r,
				o = t.height + (i.height - t.height) * r;
			return new e(n, o)
		}, e
	})();
	e.Size = a;
	var h = (function() {
		function e(e, t, i, r) {
			void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 1), this.x = e, this.y = t, this.z = i, this.w = r
		}
		return e.prototype.toString = function() {
			return "{X: " + this.x + " Y:" + this.y + " Z:" + this.z + " W:" + this.w + "}"
		}, e.prototype.getClassName = function() {
			return "Quaternion"
		}, e.prototype.getHashCode = function() {
			var e = this.x || 0;
			return e = 397 * e ^ (this.y || 0), e = 397 * e ^ (this.z || 0), e = 397 * e ^ (this.w || 0)
		}, e.prototype.asArray = function() {
			return [this.x, this.y, this.z, this.w]
		}, e.prototype.equals = function(e) {
			return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
		}, e.prototype.clone = function() {
			return new e(this.x, this.y, this.z, this.w)
		}, e.prototype.copyFrom = function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this
		}, e.prototype.copyFromFloats = function(e, t, i, r) {
			return this.x = e, this.y = t, this.z = i, this.w = r, this
		}, e.prototype.add = function(t) {
			return new e(this.x + t.x, this.y + t.y, this.z + t.z, this.w + t.w)
		}, e.prototype.subtract = function(t) {
			return new e(this.x - t.x, this.y - t.y, this.z - t.z, this.w - t.w)
		}, e.prototype.scale = function(t) {
			return new e(this.x * t, this.y * t, this.z * t, this.w * t)
		}, e.prototype.multiply = function(t) {
			var i = new e(0, 0, 0, 1);
			return this.multiplyToRef(t, i), i
		}, e.prototype.multiplyToRef = function(e, t) {
			var i = this.x * e.w + this.y * e.z - this.z * e.y + this.w * e.x,
				r = -this.x * e.z + this.y * e.w + this.z * e.x + this.w * e.y,
				n = this.x * e.y - this.y * e.x + this.z * e.w + this.w * e.z,
				o = -this.x * e.x - this.y * e.y - this.z * e.z + this.w * e.w;
			return t.copyFromFloats(i, r, n, o), this
		}, e.prototype.multiplyInPlace = function(e) {
			return this.multiplyToRef(e, this), this
		}, e.prototype.conjugateToRef = function(e) {
			return e.copyFromFloats(-this.x, -this.y, -this.z, this.w), this
		}, e.prototype.conjugateInPlace = function() {
			return this.x *= -1, this.y *= -1, this.z *= -1, this
		}, e.prototype.conjugate = function() {
			var t = new e((-this.x), (-this.y), (-this.z), this.w);
			return t
		}, e.prototype.length = function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		}, e.prototype.normalize = function() {
			var e = 1 / this.length();
			return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
		}, e.prototype.toEulerAngles = function(e) {
			void 0 === e && (e = "YZX");
			var t = o.Zero();
			return this.toEulerAnglesToRef(t, e), t
		}, e.prototype.toEulerAnglesToRef = function(e, t) {
			void 0 === t && (t = "YZX");
			var i = this.z,
				r = this.x,
				n = this.y,
				o = this.w,
				s = o * o,
				a = i * i,
				h = r * r,
				c = n * n,
				l = n * i - r * o,
				u = .4999999;
			return l < -u ? (e.y = 2 * Math.atan2(n, o), e.x = Math.PI / 2, e.z = 0) : l > u ? (e.y = 2 * Math.atan2(n, o), e.x = -Math.PI / 2, e.z = 0) : (e.z = Math.atan2(2 * (r * n + i * o), -a - h + c + s), e.x = Math.asin(-2 * (i * n - r * o)), e.y = Math.atan2(2 * (i * r + n * o), a - h - c + s)), this
		}, e.prototype.toRotationMatrix = function(e) {
			var t = this.x * this.x,
				i = this.y * this.y,
				r = this.z * this.z,
				n = this.x * this.y,
				o = this.z * this.w,
				s = this.z * this.x,
				a = this.y * this.w,
				h = this.y * this.z,
				c = this.x * this.w;
			return e.m[0] = 1 - 2 * (i + r), e.m[1] = 2 * (n + o), e.m[2] = 2 * (s - a), e.m[3] = 0, e.m[4] = 2 * (n - o), e.m[5] = 1 - 2 * (r + t), e.m[6] = 2 * (h + c), e.m[7] = 0, e.m[8] = 2 * (s + a), e.m[9] = 2 * (h - c), e.m[10] = 1 - 2 * (i + t), e.m[11] = 0, e.m[12] = 0, e.m[13] = 0, e.m[14] = 0, e.m[15] = 1, this
		}, e.prototype.fromRotationMatrix = function(t) {
			return e.FromRotationMatrixToRef(t, this), this
		}, e.FromRotationMatrix = function(t) {
			var i = new e;
			return e.FromRotationMatrixToRef(t, i), i
		}, e.FromRotationMatrixToRef = function(e, t) {
			var i, r = e.m,
				n = r[0],
				o = r[4],
				s = r[8],
				a = r[1],
				h = r[5],
				c = r[9],
				l = r[2],
				u = r[6],
				d = r[10],
				f = n + h + d;
			f > 0 ? (i = .5 / Math.sqrt(f + 1), t.w = .25 / i, t.x = (u - c) * i, t.y = (s - l) * i, t.z = (a - o) * i) : n > h && n > d ? (i = 2 * Math.sqrt(1 + n - h - d), t.w = (u - c) / i, t.x = .25 * i, t.y = (o + a) / i, t.z = (s + l) / i) : h > d ? (i = 2 * Math.sqrt(1 + h - n - d), t.w = (s - l) / i, t.x = (o + a) / i, t.y = .25 * i, t.z = (c + u) / i) : (i = 2 * Math.sqrt(1 + d - n - h), t.w = (a - o) / i, t.x = (s + l) / i, t.y = (c + u) / i, t.z = .25 * i)
		}, e.Inverse = function(t) {
			return new e((-t.x), (-t.y), (-t.z), t.w)
		}, e.Identity = function() {
			return new e(0, 0, 0, 1)
		}, e.RotationAxis = function(t, i) {
			return e.RotationAxisToRef(t, i, new e)
		}, e.RotationAxisToRef = function(e, t, i) {
			var r = Math.sin(t / 2);
			return e.normalize(), i.w = Math.cos(t / 2), i.x = e.x * r, i.y = e.y * r, i.z = e.z * r, i
		}, e.FromArray = function(t, i) {
			return i || (i = 0), new e(t[i], t[i + 1], t[i + 2], t[i + 3])
		}, e.RotationYawPitchRoll = function(t, i, r) {
			var n = new e;
			return e.RotationYawPitchRollToRef(t, i, r, n), n
		}, e.RotationYawPitchRollToRef = function(e, t, i, r) {
			var n = .5 * i,
				o = .5 * t,
				s = .5 * e,
				a = Math.sin(n),
				h = Math.cos(n),
				c = Math.sin(o),
				l = Math.cos(o),
				u = Math.sin(s),
				d = Math.cos(s);
			r.x = d * c * h + u * l * a, r.y = u * l * h - d * c * a, r.z = d * l * a - u * c * h, r.w = d * l * h + u * c * a
		}, e.RotationAlphaBetaGamma = function(t, i, r) {
			var n = new e;
			return e.RotationAlphaBetaGammaToRef(t, i, r, n), n
		}, e.RotationAlphaBetaGammaToRef = function(e, t, i, r) {
			var n = .5 * (i + e),
				o = .5 * (i - e),
				s = .5 * t;
			r.x = Math.cos(o) * Math.sin(s), r.y = Math.sin(o) * Math.sin(s), r.z = Math.sin(n) * Math.cos(s), r.w = Math.cos(n) * Math.cos(s)
		}, e.Slerp = function(t, i, r) {
			var n = e.Identity();
			return e.SlerpToRef(t, i, r, n), n
		}, e.SlerpToRef = function(e, t, i, r) {
			var n, o, s = i,
				a = e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w,
				h = !1;
			if (a < 0 && (h = !0, a = -a), a > .999999) o = 1 - s, n = h ? -s : s;
			else {
				var c = Math.acos(a),
					l = 1 / Math.sin(c);
				o = Math.sin((1 - s) * c) * l, n = h ? -Math.sin(s * c) * l : Math.sin(s * c) * l
			}
			r.x = o * e.x + n * t.x, r.y = o * e.y + n * t.y, r.z = o * e.z + n * t.z, r.w = o * e.w + n * t.w
		}, e
	})();
	e.Quaternion = h;
	var c = (function() {
		function e() {
			this.m = new Float32Array(16)
		}
		return e.prototype.isIdentity = function() {
			return 1 === this.m[0] && 1 === this.m[5] && 1 === this.m[10] && 1 === this.m[15] && (0 === this.m[1] && 0 === this.m[2] && 0 === this.m[3] && 0 === this.m[4] && 0 === this.m[6] && 0 === this.m[7] && 0 === this.m[8] && 0 === this.m[9] && 0 === this.m[11] && 0 === this.m[12] && 0 === this.m[13] && 0 === this.m[14])
		}, e.prototype.determinant = function() {
			var e = this.m[10] * this.m[15] - this.m[11] * this.m[14],
				t = this.m[9] * this.m[15] - this.m[11] * this.m[13],
				i = this.m[9] * this.m[14] - this.m[10] * this.m[13],
				r = this.m[8] * this.m[15] - this.m[11] * this.m[12],
				n = this.m[8] * this.m[14] - this.m[10] * this.m[12],
				o = this.m[8] * this.m[13] - this.m[9] * this.m[12];
			return this.m[0] * (this.m[5] * e - this.m[6] * t + this.m[7] * i) - this.m[1] * (this.m[4] * e - this.m[6] * r + this.m[7] * n) + this.m[2] * (this.m[4] * t - this.m[5] * r + this.m[7] * o) - this.m[3] * (this.m[4] * i - this.m[5] * n + this.m[6] * o)
		}, e.prototype.toArray = function() {
			return this.m
		}, e.prototype.asArray = function() {
			return this.toArray()
		}, e.prototype.invert = function() {
			return this.invertToRef(this), this
		}, e.prototype.reset = function() {
			for (var e = 0; e < 16; e++) this.m[e] = 0;
			return this
		}, e.prototype.add = function(t) {
			var i = new e;
			return this.addToRef(t, i), i
		}, e.prototype.addToRef = function(e, t) {
			for (var i = 0; i < 16; i++) t.m[i] = this.m[i] + e.m[i];
			return this
		}, e.prototype.addToSelf = function(e) {
			for (var t = 0; t < 16; t++) this.m[t] += e.m[t];
			return this
		}, e.prototype.invertToRef = function(e) {
			var t = this.m[0],
				i = this.m[1],
				r = this.m[2],
				n = this.m[3],
				o = this.m[4],
				s = this.m[5],
				a = this.m[6],
				h = this.m[7],
				c = this.m[8],
				l = this.m[9],
				u = this.m[10],
				d = this.m[11],
				f = this.m[12],
				p = this.m[13],
				m = this.m[14],
				_ = this.m[15],
				g = u * _ - d * m,
				v = l * _ - d * p,
				y = l * m - u * p,
				x = c * _ - d * f,
				b = c * m - u * f,
				T = c * p - l * f,
				A = s * g - a * v + h * y,
				E = -(o * g - a * x + h * b),
				P = o * v - s * x + h * T,
				M = -(o * y - s * b + a * T),
				S = 1 / (t * A + i * E + r * P + n * M),
				C = a * _ - h * m,
				R = s * _ - h * p,
				O = s * m - a * p,
				D = o * _ - h * f,
				I = o * m - a * f,
				w = o * p - s * f,
				L = a * d - h * u,
				B = s * d - h * l,
				F = s * u - a * l,
				V = o * d - h * c,
				N = o * u - a * c,
				z = o * l - s * c;
			return e.m[0] = A * S, e.m[4] = E * S, e.m[8] = P * S, e.m[12] = M * S, e.m[1] = -(i * g - r * v + n * y) * S, e.m[5] = (t * g - r * x + n * b) * S, e.m[9] = -(t * v - i * x + n * T) * S, e.m[13] = (t * y - i * b + r * T) * S, e.m[2] = (i * C - r * R + n * O) * S,
				e.m[6] = -(t * C - r * D + n * I) * S, e.m[10] = (t * R - i * D + n * w) * S, e.m[14] = -(t * O - i * I + r * w) * S, e.m[3] = -(i * L - r * B + n * F) * S, e.m[7] = (t * L - r * V + n * N) * S, e.m[11] = -(t * B - i * V + n * z) * S, e.m[15] = (t * F - i * N + r * z) * S, this
		}, e.prototype.setTranslation = function(e) {
			return this.m[12] = e.x, this.m[13] = e.y, this.m[14] = e.z, this
		}, e.prototype.getTranslation = function() {
			return new o(this.m[12], this.m[13], this.m[14])
		}, e.prototype.multiply = function(t) {
			var i = new e;
			return this.multiplyToRef(t, i), i
		}, e.prototype.copyFrom = function(e) {
			for (var t = 0; t < 16; t++) this.m[t] = e.m[t];
			return this
		}, e.prototype.copyToArray = function(e, t) {
			void 0 === t && (t = 0);
			for (var i = 0; i < 16; i++) e[t + i] = this.m[i];
			return this
		}, e.prototype.multiplyToRef = function(e, t) {
			return this.multiplyToArray(e, t.m, 0), this
		}, e.prototype.multiplyToArray = function(e, t, i) {
			var r = this.m[0],
				n = this.m[1],
				o = this.m[2],
				s = this.m[3],
				a = this.m[4],
				h = this.m[5],
				c = this.m[6],
				l = this.m[7],
				u = this.m[8],
				d = this.m[9],
				f = this.m[10],
				p = this.m[11],
				m = this.m[12],
				_ = this.m[13],
				g = this.m[14],
				v = this.m[15],
				y = e.m[0],
				x = e.m[1],
				b = e.m[2],
				T = e.m[3],
				A = e.m[4],
				E = e.m[5],
				P = e.m[6],
				M = e.m[7],
				S = e.m[8],
				C = e.m[9],
				R = e.m[10],
				O = e.m[11],
				D = e.m[12],
				I = e.m[13],
				w = e.m[14],
				L = e.m[15];
			return t[i] = r * y + n * A + o * S + s * D, t[i + 1] = r * x + n * E + o * C + s * I, t[i + 2] = r * b + n * P + o * R + s * w, t[i + 3] = r * T + n * M + o * O + s * L, t[i + 4] = a * y + h * A + c * S + l * D, t[i + 5] = a * x + h * E + c * C + l * I, t[i + 6] = a * b + h * P + c * R + l * w, t[i + 7] = a * T + h * M + c * O + l * L, t[i + 8] = u * y + d * A + f * S + p * D, t[i + 9] = u * x + d * E + f * C + p * I, t[i + 10] = u * b + d * P + f * R + p * w, t[i + 11] = u * T + d * M + f * O + p * L, t[i + 12] = m * y + _ * A + g * S + v * D, t[i + 13] = m * x + _ * E + g * C + v * I, t[i + 14] = m * b + _ * P + g * R + v * w, t[i + 15] = m * T + _ * M + g * O + v * L, this
		}, e.prototype.equals = function(e) {
			return e && this.m[0] === e.m[0] && this.m[1] === e.m[1] && this.m[2] === e.m[2] && this.m[3] === e.m[3] && this.m[4] === e.m[4] && this.m[5] === e.m[5] && this.m[6] === e.m[6] && this.m[7] === e.m[7] && this.m[8] === e.m[8] && this.m[9] === e.m[9] && this.m[10] === e.m[10] && this.m[11] === e.m[11] && this.m[12] === e.m[12] && this.m[13] === e.m[13] && this.m[14] === e.m[14] && this.m[15] === e.m[15]
		}, e.prototype.clone = function() {
			return e.FromValues(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5], this.m[6], this.m[7], this.m[8], this.m[9], this.m[10], this.m[11], this.m[12], this.m[13], this.m[14], this.m[15])
		}, e.prototype.getClassName = function() {
			return "Matrix"
		}, e.prototype.getHashCode = function() {
			for (var e = this.m[0] || 0, t = 1; t < 16; t++) e = 397 * e ^ (this.m[t] || 0);
			return e
		}, e.prototype.decompose = function(i, r, n) {
			n.x = this.m[12], n.y = this.m[13], n.z = this.m[14];
			var o = t.Sign(this.m[0] * this.m[1] * this.m[2] * this.m[3]) < 0 ? -1 : 1,
				s = t.Sign(this.m[4] * this.m[5] * this.m[6] * this.m[7]) < 0 ? -1 : 1,
				a = t.Sign(this.m[8] * this.m[9] * this.m[10] * this.m[11]) < 0 ? -1 : 1;
			return i.x = o * Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1] + this.m[2] * this.m[2]), i.y = s * Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5] + this.m[6] * this.m[6]), i.z = a * Math.sqrt(this.m[8] * this.m[8] + this.m[9] * this.m[9] + this.m[10] * this.m[10]), 0 === i.x || 0 === i.y || 0 === i.z ? (r.x = 0, r.y = 0, r.z = 0, r.w = 1, !1) : (e.FromValuesToRef(this.m[0] / i.x, this.m[1] / i.x, this.m[2] / i.x, 0, this.m[4] / i.y, this.m[5] / i.y, this.m[6] / i.y, 0, this.m[8] / i.z, this.m[9] / i.z, this.m[10] / i.z, 0, 0, 0, 0, 1, P.Matrix[0]), h.FromRotationMatrixToRef(P.Matrix[0], r), !0)
		}, e.prototype.getRotationMatrix = function() {
			var t = e.Identity();
			return this.getRotationMatrixToRef(t), t
		}, e.prototype.getRotationMatrixToRef = function(t) {
			var i = this.m,
				r = i[0] * i[1] * i[2] * i[3] < 0 ? -1 : 1,
				n = i[4] * i[5] * i[6] * i[7] < 0 ? -1 : 1,
				o = i[8] * i[9] * i[10] * i[11] < 0 ? -1 : 1,
				s = r * Math.sqrt(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]),
				a = n * Math.sqrt(i[4] * i[4] + i[5] * i[5] + i[6] * i[6]),
				h = o * Math.sqrt(i[8] * i[8] + i[9] * i[9] + i[10] * i[10]);
			e.FromValuesToRef(i[0] / s, i[1] / s, i[2] / s, 0, i[4] / a, i[5] / a, i[6] / a, 0, i[8] / h, i[9] / h, i[10] / h, 0, 0, 0, 0, 1, t)
		}, e.FromArray = function(t, i) {
			var r = new e;
			return i || (i = 0), e.FromArrayToRef(t, i, r), r
		}, e.FromArrayToRef = function(e, t, i) {
			for (var r = 0; r < 16; r++) i.m[r] = e[r + t]
		}, e.FromFloat32ArrayToRefScaled = function(e, t, i, r) {
			for (var n = 0; n < 16; n++) r.m[n] = e[n + t] * i
		}, e.FromValuesToRef = function(e, t, i, r, n, o, s, a, h, c, l, u, d, f, p, m, _) {
			_.m[0] = e, _.m[1] = t, _.m[2] = i, _.m[3] = r, _.m[4] = n, _.m[5] = o, _.m[6] = s, _.m[7] = a, _.m[8] = h, _.m[9] = c, _.m[10] = l, _.m[11] = u, _.m[12] = d, _.m[13] = f, _.m[14] = p, _.m[15] = m
		}, e.prototype.getRow = function(e) {
			if (e < 0 || e > 3) return null;
			var t = 4 * e;
			return new s(this.m[t + 0], this.m[t + 1], this.m[t + 2], this.m[t + 3])
		}, e.prototype.setRow = function(e, t) {
			if (e < 0 || e > 3) return this;
			var i = 4 * e;
			return this.m[i + 0] = t.x, this.m[i + 1] = t.y, this.m[i + 2] = t.z, this.m[i + 3] = t.w, this
		}, e.FromValues = function(t, i, r, n, o, s, a, h, c, l, u, d, f, p, m, _) {
			var g = new e;
			return g.m[0] = t, g.m[1] = i, g.m[2] = r, g.m[3] = n, g.m[4] = o, g.m[5] = s, g.m[6] = a, g.m[7] = h, g.m[8] = c, g.m[9] = l, g.m[10] = u, g.m[11] = d, g.m[12] = f, g.m[13] = p, g.m[14] = m, g.m[15] = _, g
		}, e.Compose = function(t, i, r) {
			var n = e.FromValues(t.x, 0, 0, 0, 0, t.y, 0, 0, 0, 0, t.z, 0, 0, 0, 0, 1),
				o = e.Identity();
			return i.toRotationMatrix(o), n = n.multiply(o), n.setTranslation(r), n
		}, e.Identity = function() {
			return e.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
		}, e.IdentityToRef = function(t) {
			e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t)
		}, e.Zero = function() {
			return e.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
		}, e.RotationX = function(t) {
			var i = new e;
			return e.RotationXToRef(t, i), i
		}, e.Invert = function(t) {
			var i = new e;
			return t.invertToRef(i), i
		}, e.RotationXToRef = function(e, t) {
			var i = Math.sin(e),
				r = Math.cos(e);
			t.m[0] = 1, t.m[15] = 1, t.m[5] = r, t.m[10] = r, t.m[9] = -i, t.m[6] = i, t.m[1] = 0, t.m[2] = 0, t.m[3] = 0, t.m[4] = 0, t.m[7] = 0, t.m[8] = 0, t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0
		}, e.RotationY = function(t) {
			var i = new e;
			return e.RotationYToRef(t, i), i
		}, e.RotationYToRef = function(e, t) {
			var i = Math.sin(e),
				r = Math.cos(e);
			t.m[5] = 1, t.m[15] = 1, t.m[0] = r, t.m[2] = -i, t.m[8] = i, t.m[10] = r, t.m[1] = 0, t.m[3] = 0, t.m[4] = 0, t.m[6] = 0, t.m[7] = 0, t.m[9] = 0, t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0
		}, e.RotationZ = function(t) {
			var i = new e;
			return e.RotationZToRef(t, i), i
		}, e.RotationZToRef = function(e, t) {
			var i = Math.sin(e),
				r = Math.cos(e);
			t.m[10] = 1, t.m[15] = 1, t.m[0] = r, t.m[1] = i, t.m[4] = -i, t.m[5] = r, t.m[2] = 0, t.m[3] = 0, t.m[6] = 0, t.m[7] = 0, t.m[8] = 0, t.m[9] = 0, t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0
		}, e.RotationAxis = function(t, i) {
			var r = e.Zero();
			return e.RotationAxisToRef(t, i, r), r
		}, e.RotationAxisToRef = function(e, t, i) {
			var r = Math.sin(-t),
				n = Math.cos(-t),
				o = 1 - n;
			e.normalize(), i.m[0] = e.x * e.x * o + n, i.m[1] = e.x * e.y * o - e.z * r, i.m[2] = e.x * e.z * o + e.y * r, i.m[3] = 0, i.m[4] = e.y * e.x * o + e.z * r, i.m[5] = e.y * e.y * o + n, i.m[6] = e.y * e.z * o - e.x * r, i.m[7] = 0, i.m[8] = e.z * e.x * o - e.y * r, i.m[9] = e.z * e.y * o + e.x * r, i.m[10] = e.z * e.z * o + n, i.m[11] = 0, i.m[15] = 1
		}, e.RotationYawPitchRoll = function(t, i, r) {
			var n = new e;
			return e.RotationYawPitchRollToRef(t, i, r, n), n
		}, e.RotationYawPitchRollToRef = function(e, t, i, r) {
			h.RotationYawPitchRollToRef(e, t, i, this._tempQuaternion), this._tempQuaternion.toRotationMatrix(r)
		}, e.Scaling = function(t, i, r) {
			var n = e.Zero();
			return e.ScalingToRef(t, i, r, n), n
		}, e.ScalingToRef = function(e, t, i, r) {
			r.m[0] = e, r.m[1] = 0, r.m[2] = 0, r.m[3] = 0, r.m[4] = 0, r.m[5] = t, r.m[6] = 0, r.m[7] = 0, r.m[8] = 0, r.m[9] = 0, r.m[10] = i, r.m[11] = 0, r.m[12] = 0, r.m[13] = 0, r.m[14] = 0, r.m[15] = 1
		}, e.Translation = function(t, i, r) {
			var n = e.Identity();
			return e.TranslationToRef(t, i, r, n), n
		}, e.TranslationToRef = function(t, i, r, n) {
			e.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, i, r, 1, n)
		}, e.Lerp = function(t, i, r) {
			for (var n = e.Zero(), o = 0; o < 16; o++) n.m[o] = t.m[o] * (1 - r) + i.m[o] * r;
			return n
		}, e.DecomposeLerp = function(t, i, r) {
			var n = new o(0, 0, 0),
				s = new h,
				a = new o(0, 0, 0);
			t.decompose(n, s, a);
			var c = new o(0, 0, 0),
				l = new h,
				u = new o(0, 0, 0);
			i.decompose(c, l, u);
			var d = o.Lerp(n, c, r),
				f = h.Slerp(s, l, r),
				p = o.Lerp(a, u, r);
			return e.Compose(d, f, p)
		}, e.LookAtLH = function(t, i, r) {
			var n = e.Zero();
			return e.LookAtLHToRef(t, i, r, n), n
		}, e.LookAtLHToRef = function(t, i, r, n) {
			i.subtractToRef(t, this._zAxis), this._zAxis.normalize(), o.CrossToRef(r, this._zAxis, this._xAxis), 0 === this._xAxis.lengthSquared() ? this._xAxis.x = 1 : this._xAxis.normalize(), o.CrossToRef(this._zAxis, this._xAxis, this._yAxis), this._yAxis.normalize();
			var s = -o.Dot(this._xAxis, t),
				a = -o.Dot(this._yAxis, t),
				h = -o.Dot(this._zAxis, t);
			return e.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, s, a, h, 1, n)
		}, e.LookAtRH = function(t, i, r) {
			var n = e.Zero();
			return e.LookAtRHToRef(t, i, r, n), n
		}, e.LookAtRHToRef = function(t, i, r, n) {
			t.subtractToRef(i, this._zAxis), this._zAxis.normalize(), o.CrossToRef(r, this._zAxis, this._xAxis), 0 === this._xAxis.lengthSquared() ? this._xAxis.x = 1 : this._xAxis.normalize(), o.CrossToRef(this._zAxis, this._xAxis, this._yAxis), this._yAxis.normalize();
			var s = -o.Dot(this._xAxis, t),
				a = -o.Dot(this._yAxis, t),
				h = -o.Dot(this._zAxis, t);
			return e.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, s, a, h, 1, n)
		}, e.OrthoLH = function(t, i, r, n) {
			var o = e.Zero();
			return e.OrthoLHToRef(t, i, r, n, o), o
		}, e.OrthoLHToRef = function(t, i, r, n, o) {
			var s = 2 / t,
				a = 2 / i,
				h = 1 / (n - r),
				c = r / (r - n);
			e.FromValuesToRef(s, 0, 0, 0, 0, a, 0, 0, 0, 0, h, 0, 0, 0, c, 1, o)
		}, e.OrthoOffCenterLH = function(t, i, r, n, o, s) {
			var a = e.Zero();
			return e.OrthoOffCenterLHToRef(t, i, r, n, o, s, a), a
		}, e.OrthoOffCenterLHToRef = function(e, t, i, r, n, o, s) {
			s.m[0] = 2 / (t - e), s.m[1] = s.m[2] = s.m[3] = 0, s.m[5] = 2 / (r - i), s.m[4] = s.m[6] = s.m[7] = 0, s.m[10] = 1 / (o - n), s.m[8] = s.m[9] = s.m[11] = 0, s.m[12] = (e + t) / (e - t), s.m[13] = (r + i) / (i - r), s.m[14] = -n / (o - n), s.m[15] = 1
		}, e.OrthoOffCenterRH = function(t, i, r, n, o, s) {
			var a = e.Zero();
			return e.OrthoOffCenterRHToRef(t, i, r, n, o, s, a), a
		}, e.OrthoOffCenterRHToRef = function(t, i, r, n, o, s, a) {
			e.OrthoOffCenterLHToRef(t, i, r, n, o, s, a), a.m[10] *= -1
		}, e.PerspectiveLH = function(t, i, r, n) {
			var o = e.Zero();
			return o.m[0] = 2 * r / t, o.m[1] = o.m[2] = o.m[3] = 0, o.m[5] = 2 * r / i, o.m[4] = o.m[6] = o.m[7] = 0, o.m[10] = -n / (r - n), o.m[8] = o.m[9] = 0, o.m[11] = 1, o.m[12] = o.m[13] = o.m[15] = 0, o.m[14] = r * n / (r - n), o
		}, e.PerspectiveFovLH = function(t, i, r, n) {
			var o = e.Zero();
			return e.PerspectiveFovLHToRef(t, i, r, n, o), o
		}, e.PerspectiveFovLHToRef = function(e, t, i, r, n, o) {
			void 0 === o && (o = !0);
			var s = 1 / Math.tan(.5 * e);
			o ? n.m[0] = s / t : n.m[0] = s, n.m[1] = n.m[2] = n.m[3] = 0, o ? n.m[5] = s : n.m[5] = s * t, n.m[4] = n.m[6] = n.m[7] = 0, n.m[8] = n.m[9] = 0, n.m[10] = r / (r - i), n.m[11] = 1, n.m[12] = n.m[13] = n.m[15] = 0, n.m[14] = -(i * r) / (r - i)
		}, e.PerspectiveFovRH = function(t, i, r, n) {
			var o = e.Zero();
			return e.PerspectiveFovRHToRef(t, i, r, n, o), o
		}, e.PerspectiveFovRHToRef = function(e, t, i, r, n, o) {
			void 0 === o && (o = !0);
			var s = 1 / Math.tan(.5 * e);
			o ? n.m[0] = s / t : n.m[0] = s, n.m[1] = n.m[2] = n.m[3] = 0, o ? n.m[5] = s : n.m[5] = s * t, n.m[4] = n.m[6] = n.m[7] = 0, n.m[8] = n.m[9] = 0, n.m[10] = r / (i - r), n.m[11] = -1, n.m[12] = n.m[13] = n.m[15] = 0, n.m[14] = i * r / (i - r)
		}, e.PerspectiveFovWebVRToRef = function(e, t, i, r, n) {
			void 0 === n && (n = !0);
			var o = Math.tan(e.upDegrees * Math.PI / 180),
				s = Math.tan(e.downDegrees * Math.PI / 180),
				a = Math.tan(e.leftDegrees * Math.PI / 180),
				h = Math.tan(e.rightDegrees * Math.PI / 180),
				c = 2 / (a + h),
				l = 2 / (o + s);
			r.m[0] = c, r.m[1] = r.m[2] = r.m[3] = r.m[4] = 0, r.m[5] = l, r.m[6] = r.m[7] = 0, r.m[8] = (a - h) * c * .5, r.m[9] = -((o - s) * l * .5), r.m[10] = -i / (t - i), r.m[11] = 1, r.m[12] = r.m[13] = r.m[15] = 0, r.m[14] = t * i / (t - i)
		}, e.GetFinalMatrix = function(t, i, r, n, o, s) {
			var a = t.width,
				h = t.height,
				c = t.x,
				l = t.y,
				u = e.FromValues(a / 2, 0, 0, 0, 0, -h / 2, 0, 0, 0, 0, s - o, 0, c + a / 2, h / 2 + l, o, 1);
			return i.multiply(r).multiply(n).multiply(u)
		}, e.GetAsMatrix2x2 = function(e) {
			return new Float32Array([e.m[0], e.m[1], e.m[4], e.m[5]])
		}, e.GetAsMatrix3x3 = function(e) {
			return new Float32Array([e.m[0], e.m[1], e.m[2], e.m[4], e.m[5], e.m[6], e.m[8], e.m[9], e.m[10]])
		}, e.Transpose = function(t) {
			var i = new e;
			return i.m[0] = t.m[0], i.m[1] = t.m[4], i.m[2] = t.m[8], i.m[3] = t.m[12], i.m[4] = t.m[1], i.m[5] = t.m[5], i.m[6] = t.m[9], i.m[7] = t.m[13], i.m[8] = t.m[2], i.m[9] = t.m[6], i.m[10] = t.m[10], i.m[11] = t.m[14], i.m[12] = t.m[3], i.m[13] = t.m[7], i.m[14] = t.m[11], i.m[15] = t.m[15], i
		}, e.Reflection = function(t) {
			var i = new e;
			return e.ReflectionToRef(t, i), i
		}, e.ReflectionToRef = function(e, t) {
			e.normalize();
			var i = e.normal.x,
				r = e.normal.y,
				n = e.normal.z,
				o = -2 * i,
				s = -2 * r,
				a = -2 * n;
			t.m[0] = o * i + 1, t.m[1] = s * i, t.m[2] = a * i, t.m[3] = 0, t.m[4] = o * r, t.m[5] = s * r + 1, t.m[6] = a * r, t.m[7] = 0, t.m[8] = o * n, t.m[9] = s * n, t.m[10] = a * n + 1, t.m[11] = 0, t.m[12] = o * e.d, t.m[13] = s * e.d, t.m[14] = a * e.d, t.m[15] = 1
		}, e.FromXYZAxesToRef = function(e, t, i, r) {
			r.m[0] = e.x, r.m[1] = e.y, r.m[2] = e.z, r.m[3] = 0, r.m[4] = t.x, r.m[5] = t.y, r.m[6] = t.z, r.m[7] = 0, r.m[8] = i.x, r.m[9] = i.y, r.m[10] = i.z, r.m[11] = 0, r.m[12] = 0, r.m[13] = 0, r.m[14] = 0, r.m[15] = 1
		}, e.FromQuaternionToRef = function(e, t) {
			var i = e.x * e.x,
				r = e.y * e.y,
				n = e.z * e.z,
				o = e.x * e.y,
				s = e.z * e.w,
				a = e.z * e.x,
				h = e.y * e.w,
				c = e.y * e.z,
				l = e.x * e.w;
			t.m[0] = 1 - 2 * (r + n), t.m[1] = 2 * (o + s), t.m[2] = 2 * (a - h), t.m[3] = 0, t.m[4] = 2 * (o - s), t.m[5] = 1 - 2 * (n + i), t.m[6] = 2 * (c + l), t.m[7] = 0, t.m[8] = 2 * (a + h), t.m[9] = 2 * (c - l), t.m[10] = 1 - 2 * (r + i), t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0, t.m[15] = 1
		}, e._tempQuaternion = new h, e._xAxis = o.Zero(), e._yAxis = o.Zero(), e._zAxis = o.Zero(), e
	})();
	e.Matrix = c;
	var l = (function() {
		function e(e, t, i, r) {
			this.normal = new o(e, t, i), this.d = r
		}
		return e.prototype.asArray = function() {
			return [this.normal.x, this.normal.y, this.normal.z, this.d]
		}, e.prototype.clone = function() {
			return new e(this.normal.x, this.normal.y, this.normal.z, this.d)
		}, e.prototype.getClassName = function() {
			return "Plane"
		}, e.prototype.getHashCode = function() {
			var e = this.normal.getHashCode();
			return e = 397 * e ^ (this.d || 0)
		}, e.prototype.normalize = function() {
			var e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z),
				t = 0;
			return 0 !== e && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this
		}, e.prototype.transform = function(t) {
			var i = c.Transpose(t),
				r = this.normal.x,
				n = this.normal.y,
				o = this.normal.z,
				s = this.d,
				a = r * i.m[0] + n * i.m[1] + o * i.m[2] + s * i.m[3],
				h = r * i.m[4] + n * i.m[5] + o * i.m[6] + s * i.m[7],
				l = r * i.m[8] + n * i.m[9] + o * i.m[10] + s * i.m[11],
				u = r * i.m[12] + n * i.m[13] + o * i.m[14] + s * i.m[15];
			return new e(a, h, l, u)
		}, e.prototype.dotCoordinate = function(e) {
			return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d
		}, e.prototype.copyFromPoints = function(e, t, i) {
			var r, n = t.x - e.x,
				o = t.y - e.y,
				s = t.z - e.z,
				a = i.x - e.x,
				h = i.y - e.y,
				c = i.z - e.z,
				l = o * c - s * h,
				u = s * a - n * c,
				d = n * h - o * a,
				f = Math.sqrt(l * l + u * u + d * d);
			return r = 0 !== f ? 1 / f : 0, this.normal.x = l * r, this.normal.y = u * r, this.normal.z = d * r, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this
		}, e.prototype.isFrontFacingTo = function(e, t) {
			var i = o.Dot(this.normal, e);
			return i <= t
		}, e.prototype.signedDistanceTo = function(e) {
			return o.Dot(e, this.normal) + this.d
		}, e.FromArray = function(t) {
			return new e(t[0], t[1], t[2], t[3])
		}, e.FromPoints = function(t, i, r) {
			var n = new e(0, 0, 0, 0);
			return n.copyFromPoints(t, i, r), n
		}, e.FromPositionAndNormal = function(t, i) {
			var r = new e(0, 0, 0, 0);
			return i.normalize(), r.normal = i, r.d = -(i.x * t.x + i.y * t.y + i.z * t.z), r
		}, e.SignedDistanceToPlaneFromPositionAndNormal = function(e, t, i) {
			var r = -(t.x * e.x + t.y * e.y + t.z * e.z);
			return o.Dot(i, t) + r
		}, e
	})();
	e.Plane = l;
	var u = (function() {
		function e(e, t, i, r) {
			this.x = e, this.y = t, this.width = i, this.height = r
		}
		return e.prototype.toGlobal = function(t, i) {
			return new e(this.x * t, this.y * i, this.width * t, this.height * i)
		}, e
	})();
	e.Viewport = u;
	var d = (function() {
		function e() {}
		return e.GetPlanes = function(t) {
			for (var i = [], r = 0; r < 6; r++) i.push(new l(0, 0, 0, 0));
			return e.GetPlanesToRef(t, i), i
		}, e.GetPlanesToRef = function(e, t) {
			t[0].normal.x = e.m[3] + e.m[2], t[0].normal.y = e.m[7] + e.m[6], t[0].normal.z = e.m[11] + e.m[10], t[0].d = e.m[15] + e.m[14], t[0].normalize(), t[1].normal.x = e.m[3] - e.m[2], t[1].normal.y = e.m[7] - e.m[6], t[1].normal.z = e.m[11] - e.m[10], t[1].d = e.m[15] - e.m[14], t[1].normalize(), t[2].normal.x = e.m[3] + e.m[0], t[2].normal.y = e.m[7] + e.m[4], t[2].normal.z = e.m[11] + e.m[8], t[2].d = e.m[15] + e.m[12], t[2].normalize(), t[3].normal.x = e.m[3] - e.m[0], t[3].normal.y = e.m[7] - e.m[4], t[3].normal.z = e.m[11] - e.m[8], t[3].d = e.m[15] - e.m[12], t[3].normalize(), t[4].normal.x = e.m[3] - e.m[1], t[4].normal.y = e.m[7] - e.m[5], t[4].normal.z = e.m[11] - e.m[9], t[4].d = e.m[15] - e.m[13], t[4].normalize(), t[5].normal.x = e.m[3] + e.m[1], t[5].normal.y = e.m[7] + e.m[5], t[5].normal.z = e.m[11] + e.m[9], t[5].d = e.m[15] + e.m[13], t[5].normalize()
		}, e
	})();
	e.Frustum = d, (function(e) {
		e[e.LOCAL = 0] = "LOCAL", e[e.WORLD = 1] = "WORLD"
	})(e.Space || (e.Space = {}));
	var f = (e.Space, (function() {
		function e() {}
		return e.X = new o(1, 0, 0), e.Y = new o(0, 1, 0), e.Z = new o(0, 0, 1), e
	})());
	e.Axis = f;
	var p = (function() {
		function e() {}
		return e.interpolate = function(e, t, i, r, n) {
			for (var o = 1 - 3 * r + 3 * t, s = 3 * r - 6 * t, a = 3 * t, h = e, c = 0; c < 5; c++) {
				var l = h * h,
					u = l * h,
					d = o * u + s * l + a * h,
					f = 1 / (3 * o * l + 2 * s * h + a);
				h -= (d - e) * f, h = Math.min(1, Math.max(0, h))
			}
			return 3 * Math.pow(1 - h, 2) * h * i + 3 * (1 - h) * Math.pow(h, 2) * n + Math.pow(h, 3)
		}, e
	})();
	e.BezierCurve = p, (function(e) {
		e[e.CW = 0] = "CW", e[e.CCW = 1] = "CCW"
	})(e.Orientation || (e.Orientation = {}));
	var m = e.Orientation,
		_ = (function() {
			function e(e) {
				var t = this;
				this.degrees = function() {
					return 180 * t._radians / Math.PI
				}, this.radians = function() {
					return t._radians
				}, this._radians = e, this._radians < 0 && (this._radians += 2 * Math.PI)
			}
			return e.BetweenTwoPoints = function(t, i) {
				var r = i.subtract(t),
					n = Math.atan2(r.y, r.x);
				return new e(n)
			}, e.FromRadians = function(t) {
				return new e(t)
			}, e.FromDegrees = function(t) {
				return new e(t * Math.PI / 180)
			}, e
		})();
	e.Angle = _;
	var g = (function() {
		function e(e, t, i) {
			this.startPoint = e, this.midPoint = t, this.endPoint = i;
			var r = Math.pow(t.x, 2) + Math.pow(t.y, 2),
				o = (Math.pow(e.x, 2) + Math.pow(e.y, 2) - r) / 2,
				s = (r - Math.pow(i.x, 2) - Math.pow(i.y, 2)) / 2,
				a = (e.x - t.x) * (t.y - i.y) - (t.x - i.x) * (e.y - t.y);
			this.centerPoint = new n((o * (t.y - i.y) - s * (e.y - t.y)) / a, ((e.x - t.x) * s - (t.x - i.x) * o) / a), this.radius = this.centerPoint.subtract(this.startPoint).length(), this.startAngle = _.BetweenTwoPoints(this.centerPoint, this.startPoint);
			var h = this.startAngle.degrees(),
				c = _.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees(),
				l = _.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
			c - h > 180 && (c -= 360), c - h < -180 && (c += 360), l - c > 180 && (l -= 360), l - c < -180 && (l += 360), this.orientation = c - h < 0 ? m.CW : m.CCW, this.angle = _.FromDegrees(this.orientation === m.CW ? h - l : l - h)
		}
		return e
	})();
	e.Arc2 = g;
	var v = (function() {
		function e(e, t) {
			this._points = new Array, this._length = 0, this.closed = !1, this._points.push(new n(e, t))
		}
		return e.prototype.addLineTo = function(e, t) {
			if (closed) return this;
			var i = new n(e, t),
				r = this._points[this._points.length - 1];
			return this._points.push(i), this._length += i.subtract(r).length(), this
		}, e.prototype.addArcTo = function(e, t, i, r, o) {
			if (void 0 === o && (o = 36), closed) return this;
			var s = this._points[this._points.length - 1],
				a = new n(e, t),
				h = new n(i, r),
				c = new g(s, a, h),
				l = c.angle.radians() / o;
			c.orientation === m.CW && (l *= -1);
			for (var u = c.startAngle.radians() + l, d = 0; d < o; d++) {
				var f = Math.cos(u) * c.radius + c.centerPoint.x,
					p = Math.sin(u) * c.radius + c.centerPoint.y;
				this.addLineTo(f, p), u += l
			}
			return this
		}, e.prototype.close = function() {
			return this.closed = !0, this
		}, e.prototype.length = function() {
			var e = this._length;
			if (!this.closed) {
				var t = this._points[this._points.length - 1],
					i = this._points[0];
				e += i.subtract(t).length()
			}
			return e
		}, e.prototype.getPoints = function() {
			return this._points
		}, e.prototype.getPointAtLengthPosition = function(e) {
			if (e < 0 || e > 1) return n.Zero();
			for (var t = e * this.length(), i = 0, r = 0; r < this._points.length; r++) {
				var o = (r + 1) % this._points.length,
					s = this._points[r],
					a = this._points[o],
					h = a.subtract(s),
					c = h.length() + i;
				if (t >= i && t <= c) {
					var l = h.normalize(),
						u = t - i;
					return new n(s.x + l.x * u, s.y + l.y * u)
				}
				i = c
			}
			return n.Zero()
		}, e.StartingAt = function(t, i) {
			return new e(t, i)
		}, e
	})();
	e.Path2 = v;
	var y = (function() {
		function i(e, t, i) {
			this.path = e, this._curve = new Array, this._distances = new Array, this._tangents = new Array, this._normals = new Array, this._binormals = new Array;
			for (var r = 0; r < e.length; r++) this._curve[r] = e[r].clone();
			this._raw = i || !1, this._compute(t)
		}
		return i.prototype.getCurve = function() {
			return this._curve
		}, i.prototype.getTangents = function() {
			return this._tangents
		}, i.prototype.getNormals = function() {
			return this._normals
		}, i.prototype.getBinormals = function() {
			return this._binormals
		}, i.prototype.getDistances = function() {
			return this._distances
		}, i.prototype.update = function(e, t) {
			for (var i = 0; i < e.length; i++) this._curve[i].x = e[i].x, this._curve[i].y = e[i].y, this._curve[i].z = e[i].z;
			return this._compute(t), this
		}, i.prototype._compute = function(e) {
			var t = this._curve.length;
			this._tangents[0] = this._getFirstNonNullVector(0), this._raw || this._tangents[0].normalize(), this._tangents[t - 1] = this._curve[t - 1].subtract(this._curve[t - 2]), this._raw || this._tangents[t - 1].normalize();
			var i = this._tangents[0],
				r = this._normalVector(this._curve[0], i, e);
			this._normals[0] = r, this._raw || this._normals[0].normalize(), this._binormals[0] = o.Cross(i, this._normals[0]), this._raw || this._binormals[0].normalize(), this._distances[0] = 0;
			for (var n, s, a, h, c = 1; c < t; c++) n = this._getLastNonNullVector(c), c < t - 1 && (s = this._getFirstNonNullVector(c), this._tangents[c] = n.add(s), this._tangents[c].normalize()), this._distances[c] = this._distances[c - 1] + n.length(), a = this._tangents[c], h = this._binormals[c - 1], this._normals[c] = o.Cross(h, a), this._raw || this._normals[c].normalize(), this._binormals[c] = o.Cross(a, this._normals[c]), this._raw || this._binormals[c].normalize()
		}, i.prototype._getFirstNonNullVector = function(e) {
			for (var t = 1, i = this._curve[e + t].subtract(this._curve[e]); 0 === i.length() && e + t + 1 < this._curve.length;) t++, i = this._curve[e + t].subtract(this._curve[e]);
			return i
		}, i.prototype._getLastNonNullVector = function(e) {
			for (var t = 1, i = this._curve[e].subtract(this._curve[e - t]); 0 === i.length() && e > t + 1;) t++, i = this._curve[e].subtract(this._curve[e - t]);
			return i
		}, i.prototype._normalVector = function(i, r, n) {
			var s, a = r.length();
			if (0 === a && (a = 1), void 0 === n || null === n) {
				var h;
				t.WithinEpsilon(Math.abs(r.y) / a, 1, e.Epsilon) ? t.WithinEpsilon(Math.abs(r.x) / a, 1, e.Epsilon) ? t.WithinEpsilon(Math.abs(r.z) / a, 1, e.Epsilon) || (h = new o(0, 0, 1)) : h = new o(1, 0, 0) : h = new o(0, (-1), 0), s = o.Cross(r, h)
			} else s = o.Cross(r, n), o.CrossToRef(s, r, s);
			return s.normalize(), s
		}, i
	})();
	e.Path3D = y;
	var x = (function() {
		function e(e) {
			this._length = 0, this._points = e, this._length = this._computeLength(e)
		}
		return e.CreateQuadraticBezier = function(t, i, r, n) {
			n = n > 2 ? n : 3;
			for (var s = new Array, a = function(e, t, i, r) {
					var n = (1 - e) * (1 - e) * t + 2 * e * (1 - e) * i + e * e * r;
					return n
				}, h = 0; h <= n; h++) s.push(new o(a(h / n, t.x, i.x, r.x), a(h / n, t.y, i.y, r.y), a(h / n, t.z, i.z, r.z)));
			return new e(s)
		}, e.CreateCubicBezier = function(t, i, r, n, s) {
			s = s > 3 ? s : 4;
			for (var a = new Array, h = function(e, t, i, r, n) {
					var o = (1 - e) * (1 - e) * (1 - e) * t + 3 * e * (1 - e) * (1 - e) * i + 3 * e * e * (1 - e) * r + e * e * e * n;
					return o
				}, c = 0; c <= s; c++) a.push(new o(h(c / s, t.x, i.x, r.x, n.x), h(c / s, t.y, i.y, r.y, n.y), h(c / s, t.z, i.z, r.z, n.z)));
			return new e(a)
		}, e.CreateHermiteSpline = function(t, i, r, n, s) {
			for (var a = new Array, h = 1 / s, c = 0; c <= s; c++) a.push(o.Hermite(t, i, r, n, c * h));
			return new e(a)
		}, e.prototype.getPoints = function() {
			return this._points
		}, e.prototype.length = function() {
			return this._length
		}, e.prototype["continue"] = function(t) {
			for (var i = this._points[this._points.length - 1], r = this._points.slice(), n = t.getPoints(), o = 1; o < n.length; o++) r.push(n[o].subtract(n[0]).add(i));
			var s = new e(r);
			return s
		}, e.prototype._computeLength = function(e) {
			for (var t = 0, i = 1; i < e.length; i++) t += e[i].subtract(e[i - 1]).length();
			return t
		}, e
	})();
	e.Curve3 = x;
	var b = (function() {
		function e() {
			this.L00 = o.Zero(), this.L1_1 = o.Zero(), this.L10 = o.Zero(), this.L11 = o.Zero(), this.L2_2 = o.Zero(), this.L2_1 = o.Zero(), this.L20 = o.Zero(), this.L21 = o.Zero(), this.L22 = o.Zero()
		}
		return e.prototype.addLight = function(e, t, i) {
			var r = new o(t.r, t.g, t.b),
				n = r.scale(i);
			this.L00 = this.L00.add(n.scale(.282095)), this.L1_1 = this.L1_1.add(n.scale(.488603 * e.y)), this.L10 = this.L10.add(n.scale(.488603 * e.z)), this.L11 = this.L11.add(n.scale(.488603 * e.x)), this.L2_2 = this.L2_2.add(n.scale(1.092548 * e.x * e.y)), this.L2_1 = this.L2_1.add(n.scale(1.092548 * e.y * e.z)), this.L21 = this.L21.add(n.scale(1.092548 * e.x * e.z)), this.L20 = this.L20.add(n.scale(.315392 * (3 * e.z * e.z - 1))), this.L22 = this.L22.add(n.scale(.546274 * (e.x * e.x - e.y * e.y)))
		}, e.prototype.scale = function(e) {
			this.L00 = this.L00.scale(e), this.L1_1 = this.L1_1.scale(e), this.L10 = this.L10.scale(e), this.L11 = this.L11.scale(e), this.L2_2 = this.L2_2.scale(e), this.L2_1 = this.L2_1.scale(e), this.L20 = this.L20.scale(e), this.L21 = this.L21.scale(e), this.L22 = this.L22.scale(e)
		}, e
	})();
	e.SphericalHarmonics = b;
	var T = (function() {
		function e() {
			this.x = o.Zero(), this.y = o.Zero(), this.z = o.Zero(), this.xx = o.Zero(), this.yy = o.Zero(), this.zz = o.Zero(), this.xy = o.Zero(), this.yz = o.Zero(), this.zx = o.Zero()
		}
		return e.prototype.addAmbient = function(e) {
			var t = new o(e.r, e.g, e.b);
			this.xx = this.xx.add(t), this.yy = this.yy.add(t), this.zz = this.zz.add(t)
		}, e.getSphericalPolynomialFromHarmonics = function(t) {
			var i = new e;
			return i.x = t.L11.scale(1.02333), i.y = t.L1_1.scale(1.02333), i.z = t.L10.scale(1.02333), i.xx = t.L00.scale(.886277).subtract(t.L20.scale(.247708)).add(t.L22.scale(.429043)), i.yy = t.L00.scale(.886277).subtract(t.L20.scale(.247708)).subtract(t.L22.scale(.429043)), i.zz = t.L00.scale(.886277).add(t.L20.scale(.495417)), i.yz = t.L2_1.scale(.858086), i.zx = t.L21.scale(.858086), i.xy = t.L2_2.scale(.858086), i
		}, e
	})();
	e.SphericalPolynomial = T;
	var A = (function() {
		function e(e, t) {
			void 0 === e && (e = o.Zero()), void 0 === t && (t = o.Up()), this.position = e, this.normal = t
		}
		return e.prototype.clone = function() {
			return new e(this.position.clone(), this.normal.clone())
		}, e
	})();
	e.PositionNormalVertex = A;
	var E = (function() {
		function e(e, t, i) {
			void 0 === e && (e = o.Zero()), void 0 === t && (t = o.Up()), void 0 === i && (i = n.Zero()), this.position = e, this.normal = t, this.uv = i
		}
		return e.prototype.clone = function() {
			return new e(this.position.clone(), this.normal.clone(), this.uv.clone())
		}, e
	})();
	e.PositionNormalTextureVertex = E;
	var P = (function() {
		function e() {}
		return e.Color3 = [i.Black(), i.Black(), i.Black()], e.Vector2 = [n.Zero(), n.Zero(), n.Zero()], e.Vector3 = [o.Zero(), o.Zero(), o.Zero(), o.Zero(), o.Zero(), o.Zero(), o.Zero(), o.Zero(), o.Zero()], e.Vector4 = [s.Zero(), s.Zero(), s.Zero()], e.Quaternion = [new h(0, 0, 0, 0)], e.Matrix = [c.Zero(), c.Zero(), c.Zero(), c.Zero(), c.Zero(), c.Zero(), c.Zero(), c.Zero()], e
	})();
	e.Tmp = P
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	function t(e, t) {
		return function(i, r) {
			i.__serializableMembers || (i.__serializableMembers = {}), i.__serializableMembers[r] || (i.__serializableMembers[r] = {
				type: e,
				sourceName: t
			})
		}
	}

	function i(e) {
		return t(0, e)
	}

	function r(e) {
		return t(1, e)
	}

	function n(e) {
		return t(2, e)
	}

	function o(e) {
		return t(3, e)
	}

	function s(e) {
		return t(4, e)
	}

	function a(e) {
		return t(5, e)
	}

	function h(e) {
		return t(6, e)
	}

	function c(e) {
		return t(7, e)
	}
	e.serialize = i, e.serializeAsTexture = r, e.serializeAsColor3 = n, e.serializeAsFresnelParameters = o, e.serializeAsVector2 = s, e.serializeAsVector3 = a, e.serializeAsMeshReference = h, e.serializeAsColorCurves = c;
	var l = (function() {
		function t() {}
		return t.Serialize = function(t, i) {
			i || (i = {}), i.tags = e.Tags.GetTags(t);
			for (var r in t.__serializableMembers) {
				var n = t.__serializableMembers[r],
					o = n.sourceName || r,
					s = n.type,
					a = t[r];
				if (void 0 !== a && null !== a) switch (s) {
					case 0:
						i[o] = a;
						break;
					case 1:
						i[o] = a.serialize();
						break;
					case 2:
						i[o] = a.asArray();
						break;
					case 3:
						i[o] = a.serialize();
						break;
					case 4:
						i[o] = a.asArray();
						break;
					case 5:
						i[o] = a.asArray();
						break;
					case 6:
						i[o] = a.id;
						break;
					case 7:
						i[o] = a.serialize()
				}
			}
			return i
		}, t.Parse = function(t, i, r, n) {
			var o = t();
			e.Tags.AddTagsTo(o, i.tags);
			for (var s in o.__serializableMembers) {
				var a = o.__serializableMembers[s],
					h = i[a.sourceName || s],
					c = a.type;
				if (void 0 !== h && null !== h) switch (c) {
					case 0:
						o[s] = h;
						break;
					case 1:
						o[s] = e.Texture.Parse(h, r, n);
						break;
					case 2:
						o[s] = e.Color3.FromArray(h);
						break;
					case 3:
						o[s] = e.FresnelParameters.Parse(h);
						break;
					case 4:
						o[s] = e.Vector2.FromArray(h);
						break;
					case 5:
						o[s] = e.Vector3.FromArray(h);
						break;
					case 6:
						o[s] = r.getLastMeshByID(h);
						break;
					case 7:
						o[s] = e.ColorCurves.Parse(h)
				}
			}
			return o
		}, t.Clone = function(t, i) {
			var r = t();
			e.Tags.AddTagsTo(r, i.tags);
			for (var n in r.__serializableMembers) {
				var o = r.__serializableMembers[n],
					s = i[n],
					a = o.type;
				if (void 0 !== s && null !== s) switch (a) {
					case 0:
					case 6:
						r[n] = s;
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 7:
						r[n] = s.clone()
				}
			}
			return r
		}, t
	})();
	e.SerializationHelper = l
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t) {
			void 0 === t && (t = !1), this.initalize(e, t)
		}
		return e.prototype.initalize = function(e, t) {
			return void 0 === t && (t = !1), this.mask = e, this.skipNextObservers = t, this
		}, e
	})();
	e.EventState = t;
	var i = (function() {
		function e(e, t) {
			this.callback = e, this.mask = t
		}
		return e
	})();
	e.Observer = i;
	var r = (function() {
		function e() {
			this._observers = new Array, this._eventState = new t(0)
		}
		return e.prototype.add = function(e, t, r) {
			if (void 0 === t && (t = -1), void 0 === r && (r = !1), !e) return null;
			var n = new i(e, t);
			return r ? this._observers.unshift(n) : this._observers.push(n), n
		}, e.prototype.remove = function(e) {
			var t = this._observers.indexOf(e);
			return t !== -1 && (this._observers.splice(t, 1), !0)
		}, e.prototype.removeCallback = function(e) {
			for (var t = 0; t < this._observers.length; t++)
				if (this._observers[t].callback === e) return this._observers.splice(t, 1), !0;
			return !1
		}, e.prototype.notifyObservers = function(e, t) {
			void 0 === t && (t = -1);
			var i = this._eventState;
			i.mask = t, i.skipNextObservers = !1;
			for (var r = 0, n = this._observers; r < n.length; r++) {
				var o = n[r];
				if (o.mask & t && o.callback(e, i), i.skipNextObservers) return !1
			}
			return !0
		}, e.prototype.hasObservers = function() {
			return this._observers.length > 0
		}, e.prototype.clear = function() {
			this._observers = new Array
		}, e.prototype.clone = function() {
			var t = new e;
			return t._observers = this._observers.slice(0), t
		}, e
	})();
	e.Observable = r
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, i) {
			this.idbFactory = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB, this.callbackManifestChecked = i, this.currentSceneUrl = t.ReturnFullUrlLocation(e), this.db = null, this.enableSceneOffline = !1, this.enableTexturesOffline = !1, this.manifestVersionFound = 0, this.mustUpdateRessources = !1, this.hasReachedQuota = !1, t.IDBStorageEnabled ? this.checkManifestFile() : this.callbackManifestChecked(!0)
		}
		return t.prototype.checkManifestFile = function() {
			function t() {
				r.enableSceneOffline = !1, r.enableTexturesOffline = !1, r.callbackManifestChecked(!1)
			}
			var i = this,
				r = this,
				n = !1,
				o = this.currentSceneUrl + ".manifest",
				s = new XMLHttpRequest;
			navigator.onLine && (n = !0, o = o + (null == o.match(/\?/) ? "?" : "&") + (new Date).getTime()), s.open("GET", o, !0), s.addEventListener("load", (function() {
				if (200 === s.status || e.Tools.ValidateXHRData(s, 1)) try {
					var r = JSON.parse(s.response);
					i.enableSceneOffline = r.enableSceneOffline, i.enableTexturesOffline = r.enableTexturesOffline, r.version && !isNaN(parseInt(r.version)) && (i.manifestVersionFound = r.version), i.callbackManifestChecked && i.callbackManifestChecked(!0)
				} catch (n) {
					t()
				} else t()
			}), !1), s.addEventListener("error", (function(e) {
				if (n) {
					n = !1;
					var r = i.currentSceneUrl + ".manifest";
					s.open("GET", r, !0), s.send()
				} else t()
			}), !1);
			try {
				s.send()
			} catch (a) {
				e.Tools.Error("Error on XHR send request."), r.callbackManifestChecked(!1)
			}
		}, t.prototype.openAsync = function(t, i) {
			function r() {
				o.isSupported = !1, i && i()
			}
			var n = this,
				o = this;
			if (this.idbFactory && (this.enableSceneOffline || this.enableTexturesOffline))
				if (this.db) t && t();
				else {
					this.hasReachedQuota = !1, this.isSupported = !0;
					var s = this.idbFactory.open("babylonjs", 1);
					s.onerror = function(e) {
						r()
					}, s.onblocked = function(t) {
						e.Tools.Error("IDB request blocked. Please reload the page."), r()
					}, s.onsuccess = function(e) {
						n.db = s.result, t()
					}, s.onupgradeneeded = function(t) {
						n.db = t.target.result;
						try {
							n.db.createObjectStore("scenes", {
								keyPath: "sceneUrl"
							}), n.db.createObjectStore("versions", {
								keyPath: "sceneUrl"
							}), n.db.createObjectStore("textures", {
								keyPath: "textureUrl"
							})
						} catch (i) {
							e.Tools.Error("Error while creating object stores. Exception: " + i.message), r()
						}
					}
				}
			else this.isSupported = !1, i && i()
		}, t.prototype.loadImageFromDB = function(e, i) {
			var r = this,
				n = t.ReturnFullUrlLocation(e),
				o = function() {
					r.hasReachedQuota || null === r.db ? i.src = e : r._saveImageIntoDBAsync(n, i)
				};
			this.mustUpdateRessources ? o() : this._loadImageFromDBAsync(n, i, o)
		}, t.prototype._loadImageFromDBAsync = function(t, i, r) {
			if (this.isSupported && null !== this.db) {
				var n, o = this.db.transaction(["textures"]);
				o.onabort = function(e) {
					i.src = t
				}, o.oncomplete = function(o) {
					var s;
					if (n) {
						var a = window.URL || window.webkitURL;
						s = a.createObjectURL(n.data, {
							oneTimeOnly: !0
						}), i.onerror = function() {
							e.Tools.Error("Error loading image from blob URL: " + s + " switching back to web url: " + t), i.src = t
						}, i.src = s
					} else r()
				};
				var s = o.objectStore("textures").get(t);
				s.onsuccess = function(e) {
					n = e.target.result
				}, s.onerror = function(r) {
					e.Tools.Error("Error loading texture " + t + " from DB."), i.src = t
				}
			} else e.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), i.src = t
		}, t.prototype._saveImageIntoDBAsync = function(i, r) {
			var n = this;
			if (this.isSupported) {
				var o = function() {
					var e;
					if (s) {
						var t = window.URL || window.webkitURL;
						try {
							e = t.createObjectURL(s, {
								oneTimeOnly: !0
							})
						} catch (i) {
							e = t.createObjectURL(s)
						}
					}
					r.src = e
				};
				if (t.IsUASupportingBlobStorage) {
					var s, a = new XMLHttpRequest;
					a.open("GET", i, !0), a.responseType = "blob", a.addEventListener("load", (function() {
						if (200 === a.status) {
							s = a.response;
							var e = n.db.transaction(["textures"], "readwrite");
							e.onabort = function(e) {
								try {
									e.srcElement.error && "QuotaExceededError" === e.srcElement.error.name && (n.hasReachedQuota = !0)
								} catch (t) {}
								o()
							}, e.oncomplete = function(e) {
								o()
							};
							var h = {
								textureUrl: i,
								data: s
							};
							try {
								var c = e.objectStore("textures").put(h);
								c.onsuccess = function(e) {}, c.onerror = function(e) {
									o()
								}
							} catch (l) {
								25 === l.code && (t.IsUASupportingBlobStorage = !1), r.src = i
							}
						} else r.src = i
					}), !1), a.addEventListener("error", (function(t) {
						e.Tools.Error("Error in XHR request in BABYLON.Database."), r.src = i
					}), !1), a.send()
				} else r.src = i
			} else e.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),
				r.src = i
		}, t.prototype._checkVersionFromDB = function(e, t) {
			var i = this,
				r = function(r) {
					i._saveVersionIntoDBAsync(e, t)
				};
			this._loadVersionFromDBAsync(e, t, r)
		}, t.prototype._loadVersionFromDBAsync = function(t, i, r) {
			var n = this;
			if (this.isSupported) {
				var o;
				try {
					var s = this.db.transaction(["versions"]);
					s.oncomplete = function(e) {
						o ? n.manifestVersionFound > o.data ? (n.mustUpdateRessources = !0, r()) : i(o.data) : (n.mustUpdateRessources = !0, r())
					}, s.onabort = function(e) {
						i(-1)
					};
					var a = s.objectStore("versions").get(t);
					a.onsuccess = function(e) {
						o = e.target.result
					}, a.onerror = function(r) {
						e.Tools.Error("Error loading version for scene " + t + " from DB."), i(-1)
					}
				} catch (h) {
					e.Tools.Error("Error while accessing 'versions' object store (READ OP). Exception: " + h.message), i(-1)
				}
			} else e.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), i(-1)
		}, t.prototype._saveVersionIntoDBAsync = function(t, i) {
			var r = this;
			if (this.isSupported && !this.hasReachedQuota) try {
				var n = this.db.transaction(["versions"], "readwrite");
				n.onabort = function(e) {
					try {
						e.srcElement.error && "QuotaExceededError" === e.srcElement.error.name && (r.hasReachedQuota = !0)
					} catch (t) {}
					i(-1)
				}, n.oncomplete = function(e) {
					i(r.manifestVersionFound)
				};
				var o = {
						sceneUrl: t,
						data: this.manifestVersionFound
					},
					s = n.objectStore("versions").put(o);
				s.onsuccess = function(e) {}, s.onerror = function(t) {
					e.Tools.Error("Error in DB add version request in BABYLON.Database.")
				}
			} catch (a) {
				e.Tools.Error("Error while accessing 'versions' object store (WRITE OP). Exception: " + a.message), i(-1)
			} else i(-1)
		}, t.prototype.loadFileFromDB = function(e, i, r, n, o) {
			var s = this,
				a = t.ReturnFullUrlLocation(e),
				h = function(e) {
					s._saveFileIntoDBAsync(a, i, r)
				};
			this._checkVersionFromDB(a, (function(e) {
				e !== -1 ? s.mustUpdateRessources ? s._saveFileIntoDBAsync(a, i, r, o) : s._loadFileFromDBAsync(a, i, h, o) : n()
			}))
		}, t.prototype._loadFileFromDBAsync = function(t, i, r, n) {
			if (this.isSupported) {
				var o;
				o = t.indexOf(".babylon") !== -1 ? "scenes" : "textures";
				var s, a = this.db.transaction([o]);
				a.oncomplete = function(e) {
					s ? i(s.data) : r()
				}, a.onabort = function(e) {
					r()
				};
				var h = a.objectStore(o).get(t);
				h.onsuccess = function(e) {
					s = e.target.result
				}, h.onerror = function(i) {
					e.Tools.Error("Error loading file " + t + " from DB."), r()
				}
			} else e.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), i()
		}, t.prototype._saveFileIntoDBAsync = function(t, i, r, n) {
			var o = this;
			if (this.isSupported) {
				var s;
				s = t.indexOf(".babylon") !== -1 ? "scenes" : "textures";
				var a, h = new XMLHttpRequest;
				h.open("GET", t, !0), n && (h.responseType = "arraybuffer"), h.onprogress = r, h.addEventListener("load", (function() {
					if (200 === h.status || e.Tools.ValidateXHRData(h, n ? 6 : 1))
						if (a = n ? h.response : h.responseText, o.hasReachedQuota) i(a);
						else {
							var r = o.db.transaction([s], "readwrite");
							r.onabort = function(e) {
								try {
									e.srcElement.error && "QuotaExceededError" === e.srcElement.error.name && (o.hasReachedQuota = !0)
								} catch (t) {}
								i(a)
							}, r.oncomplete = function(e) {
								i(a)
							};
							var c;
							c = "scenes" === s ? {
								sceneUrl: t,
								data: a,
								version: o.manifestVersionFound
							} : {
								textureUrl: t,
								data: a
							};
							try {
								var l = r.objectStore(s).put(c);
								l.onsuccess = function(e) {}, l.onerror = function(t) {
									e.Tools.Error("Error in DB add file request in BABYLON.Database.")
								}
							} catch (u) {
								i(a)
							}
						}
					else i()
				}), !1), h.addEventListener("error", (function(t) {
					e.Tools.Error("error on XHR request."), i()
				}), !1), h.send()
			} else e.Tools.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."), i()
		}, t.IsUASupportingBlobStorage = !0, t.IDBStorageEnabled = !0, t.parseURL = function(e) {
			var t = document.createElement("a");
			t.href = e;
			var i = e.substring(0, e.lastIndexOf("#")),
				r = e.substring(i.lastIndexOf("/") + 1, e.length),
				n = e.substring(0, e.indexOf(r, 0));
			return n
		}, t.ReturnFullUrlLocation = function(e) {
			return e.indexOf("http:/") === -1 ? t.parseURL(window.location.href) + e : e
		}, t
	})();
	e.Database = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
			function t() {}
			return t.GetTGAHeader = function(e) {
				var t = 0,
					i = {
						id_length: e[t++],
						colormap_type: e[t++],
						image_type: e[t++],
						colormap_index: e[t++] | e[t++] << 8,
						colormap_length: e[t++] | e[t++] << 8,
						colormap_size: e[t++],
						origin: [e[t++] | e[t++] << 8, e[t++] | e[t++] << 8],
						width: e[t++] | e[t++] << 8,
						height: e[t++] | e[t++] << 8,
						pixel_size: e[t++],
						flags: e[t++]
					};
				return i
			}, t.UploadContent = function(i, r) {
				if (r.length < 19) return void e.Tools.Error("Unable to load TGA file - Not enough data to contain header");
				var n = 18,
					o = t.GetTGAHeader(r);
				if (o.id_length + n > r.length) return void e.Tools.Error("Unable to load TGA file - Not enough data");
				n += o.id_length;
				var s = !1,
					a = !1,
					h = !1,
					c = !1;
				switch (o.image_type) {
					case t._TYPE_RLE_INDEXED:
						s = !0;
					case t._TYPE_INDEXED:
						a = !0;
						break;
					case t._TYPE_RLE_RGB:
						s = !0;
					case t._TYPE_RGB:
						h = !0;
						break;
					case t._TYPE_RLE_GREY:
						s = !0;
					case t._TYPE_GREY:
						c = !0
				}
				var l, u, d = (15 & o.flags, o.pixel_size >> 3),
					f = o.width * o.height * d;
				if (a && (u = r.subarray(n, n += o.colormap_length * (o.colormap_size >> 3))), s) {
					l = new Uint8Array(f);
					for (var p, m, _, g = 0, v = new Uint8Array(d); n < f && g < f;)
						if (p = r[n++], m = (127 & p) + 1, 128 & p) {
							for (_ = 0; _ < d; ++_) v[_] = r[n++];
							for (_ = 0; _ < m; ++_) l.set(v, g + _ * d);
							g += d * m
						} else {
							for (m *= d, _ = 0; _ < m; ++_) l[g + _] = r[n++];
							g += m
						}
				} else l = r.subarray(n, n += a ? o.width * o.height : f);
				var y, x, b, T, A, E;
				switch ((o.flags & t._ORIGIN_MASK) >> t._ORIGIN_SHIFT) {
					default:
						case t._ORIGIN_UL:
						y = 0,
					b = 1,
					E = o.width,
					x = 0,
					T = 1,
					A = o.height;
					break;
					case t._ORIGIN_BL:
							y = 0,
						b = 1,
						E = o.width,
						x = o.height - 1,
						T = -1,
						A = -1;
						break;
					case t._ORIGIN_UR:
							y = o.width - 1,
						b = -1,
						E = -1,
						x = 0,
						T = 1,
						A = o.height;
						break;
					case t._ORIGIN_BR:
							y = o.width - 1,
						b = -1,
						E = -1,
						x = o.height - 1,
						T = -1,
						A = -1
				}
				var P = "_getImageData" + (c ? "Grey" : "") + o.pixel_size + "bits",
					M = t[P](o, u, l, x, T, A, y, b, E);
				i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, o.width, o.height, 0, i.RGBA, i.UNSIGNED_BYTE, M)
			}, t._getImageData8bits = function(e, t, i, r, n, o, s, a, h) {
				var c, l, u, d = i,
					f = t,
					p = e.width,
					m = e.height,
					_ = 0,
					g = new Uint8Array(p * m * 4);
				for (u = r; u !== o; u += n)
					for (l = s; l !== h; l += a, _++) c = d[_], g[4 * (l + p * u) + 3] = 255, g[4 * (l + p * u) + 2] = f[3 * c + 0], g[4 * (l + p * u) + 1] = f[3 * c + 1], g[4 * (l + p * u) + 0] = f[3 * c + 2];
				return g
			}, t._getImageData16bits = function(e, t, i, r, n, o, s, a, h) {
				var c, l, u, d = i,
					f = e.width,
					p = e.height,
					m = 0,
					_ = new Uint8Array(f * p * 4);
				for (u = r; u !== o; u += n)
					for (l = s; l !== h; l += a, m += 2) c = d[m + 0] + (d[m + 1] << 8), _[4 * (l + f * u) + 0] = (31744 & c) >> 7, _[4 * (l + f * u) + 1] = (992 & c) >> 2, _[4 * (l + f * u) + 2] = (31 & c) >> 3, _[4 * (l + f * u) + 3] = 32768 & c ? 0 : 255;
				return _
			}, t._getImageData24bits = function(e, t, i, r, n, o, s, a, h) {
				var c, l, u = i,
					d = e.width,
					f = e.height,
					p = 0,
					m = new Uint8Array(d * f * 4);
				for (l = r; l !== o; l += n)
					for (c = s; c !== h; c += a, p += 3) m[4 * (c + d * l) + 3] = 255, m[4 * (c + d * l) + 2] = u[p + 0], m[4 * (c + d * l) + 1] = u[p + 1], m[4 * (c + d * l) + 0] = u[p + 2];
				return m
			}, t._getImageData32bits = function(e, t, i, r, n, o, s, a, h) {
				var c, l, u = i,
					d = e.width,
					f = e.height,
					p = 0,
					m = new Uint8Array(d * f * 4);
				for (l = r; l !== o; l += n)
					for (c = s; c !== h; c += a, p += 4) m[4 * (c + d * l) + 2] = u[p + 0], m[4 * (c + d * l) + 1] = u[p + 1], m[4 * (c + d * l) + 0] = u[p + 2], m[4 * (c + d * l) + 3] = u[p + 3];
				return m
			}, t._getImageDataGrey8bits = function(e, t, i, r, n, o, s, a, h) {
				var c, l, u, d = i,
					f = e.width,
					p = e.height,
					m = 0,
					_ = new Uint8Array(f * p * 4);
				for (u = r; u !== o; u += n)
					for (l = s; l !== h; l += a, m++) c = d[m], _[4 * (l + f * u) + 0] = c, _[4 * (l + f * u) + 1] = c, _[4 * (l + f * u) + 2] = c, _[4 * (l + f * u) + 3] = 255;
				return _
			}, t._getImageDataGrey16bits = function(e, t, i, r, n, o, s, a, h) {
				var c, l, u = i,
					d = e.width,
					f = e.height,
					p = 0,
					m = new Uint8Array(d * f * 4);
				for (l = r; l !== o; l += n)
					for (c = s; c !== h; c += a, p += 2) m[4 * (c + d * l) + 0] = u[p + 0], m[4 * (c + d * l) + 1] = u[p + 0], m[4 * (c + d * l) + 2] = u[p + 0], m[4 * (c + d * l) + 3] = u[p + 1];
				return m
			}, t._TYPE_NO_DATA = 0, t._TYPE_INDEXED = 1, t._TYPE_RGB = 2, t._TYPE_GREY = 3, t._TYPE_RLE_INDEXED = 9, t._TYPE_RLE_RGB = 10, t._TYPE_RLE_GREY = 11, t._ORIGIN_MASK = 48, t._ORIGIN_SHIFT = 4, t._ORIGIN_BL = 0, t._ORIGIN_BR = 1, t._ORIGIN_UL = 2, t._ORIGIN_UR = 3, t
		})();
		t.TGATools = i
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(t) {
			this.length = 0, this._duplicateId = 0, this.data = new Array(t), this._id = e._GlobalId++
		}
		return e.prototype.push = function(e) {
			this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2), e.__smartArrayFlags || (e.__smartArrayFlags = {}), e.__smartArrayFlags[this._id] = this._duplicateId
		}, e.prototype.pushNoDuplicate = function(e) {
			return (!e.__smartArrayFlags || e.__smartArrayFlags[this._id] !== this._duplicateId) && (this.push(e), !0)
		}, e.prototype.sort = function(e) {
			this.data.sort(e)
		}, e.prototype.reset = function() {
			this.length = 0, this._duplicateId++
		}, e.prototype.concat = function(e) {
			if (0 !== e.length) {
				this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));
				for (var t = 0; t < e.length; t++) this.data[this.length++] = (e.data || e)[t]
			}
		}, e.prototype.concatWithNoDuplicate = function(e) {
			if (0 !== e.length) {
				this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));
				for (var t = 0; t < e.length; t++) {
					var i = (e.data || e)[t];
					this.pushNoDuplicate(i)
				}
			}
		}, e.prototype.indexOf = function(e) {
			var t = this.data.indexOf(e);
			return t >= this.length ? -1 : t
		}, e._GlobalId = 0, e
	})();
	e.SmartArray = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {
			this._count = 0, this._data = {}
		}
		return e.prototype.copyFrom = function(e) {
			var t = this;
			this.clear(), e.forEach((function(e, i) {
				return t.add(e, i)
			}))
		}, e.prototype.get = function(e) {
			var t = this._data[e];
			if (void 0 !== t) return t
		}, e.prototype.getOrAddWithFactory = function(e, t) {
			var i = this.get(e);
			return void 0 !== i ? i : (i = t(e), i && this.add(e, i), i)
		}, e.prototype.getOrAdd = function(e, t) {
			var i = this.get(e);
			return void 0 !== i ? i : (this.add(e, t), t)
		}, e.prototype.contains = function(e) {
			return void 0 !== this._data[e]
		}, e.prototype.add = function(e, t) {
			return void 0 === this._data[e] && (this._data[e] = t, ++this._count, !0)
		}, e.prototype.set = function(e, t) {
			return void 0 !== this._data[e] && (this._data[e] = t, !0)
		}, e.prototype.getAndRemove = function(e) {
			var t = this.get(e);
			return void 0 !== t ? (delete this._data[e], --this._count, t) : null
		}, e.prototype.remove = function(e) {
			return !!this.contains(e) && (delete this._data[e], --this._count, !0)
		}, e.prototype.clear = function() {
			this._data = {}, this._count = 0
		}, Object.defineProperty(e.prototype, "count", {
			get: function() {
				return this._count
			},
			enumerable: !0,
			configurable: !0
		}), e.prototype.forEach = function(e) {
			for (var t in this._data) {
				var i = this._data[t];
				e(t, i)
			}
		}, e.prototype.first = function(e) {
			for (var t in this._data) {
				var i = this._data[t],
					r = e(t, i);
				if (r) return r
			}
			return null
		}, e
	})();
	e.StringDictionary = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	function t(e, t) {
		return function(i) {
			i.__bjsclassName__ = e, i.__bjsmoduleName__ = null != t ? t : null
		}
	}
	var i, r = function(t, i) {
			return t ? t instanceof e.Mesh ? null : t instanceof e.SubMesh ? t.clone(i) : t.clone ? t.clone() : null : null
		},
		n = (function() {
			function t() {}
			return t.Instantiate = function(e) {
				for (var t = e.split("."), i = window || this, r = 0, n = t.length; r < n; r++) i = i[t[r]];
				return "function" != typeof i ? null : i
			}, t.SetImmediate = function(e) {
				window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1)
			}, t.IsExponentOfTwo = function(e) {
				var t = 1;
				do t *= 2; while (t < e);
				return t === e
			}, t.GetExponentOfTwo = function(e, t) {
				var i = 1;
				do i *= 2; while (i < e);
				return i > t && (i = t), i
			}, t.GetFilename = function(e) {
				var t = e.lastIndexOf("/");
				return t < 0 ? e : e.substring(t + 1)
			}, t.GetDOMTextContent = function(e) {
				for (var t = "", i = e.firstChild; i;) 3 === i.nodeType && (t += i.textContent), i = i.nextSibling;
				return t
			}, t.ToDegrees = function(e) {
				return 180 * e / Math.PI
			}, t.ToRadians = function(e) {
				return e * Math.PI / 180
			}, t.EncodeArrayBufferTobase64 = function(e) {
				for (var t, i, r, n, o, s, a, h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", c = "", l = 0, u = new Uint8Array(e); l < u.length;) t = u[l++], i = l < u.length ? u[l++] : Number.NaN, r = l < u.length ? u[l++] : Number.NaN, n = t >> 2, o = (3 & t) << 4 | i >> 4, s = (15 & i) << 2 | r >> 6, a = 63 & r, isNaN(i) ? s = a = 64 : isNaN(r) && (a = 64), c += h.charAt(n) + h.charAt(o) + h.charAt(s) + h.charAt(a);
				return "data:image/png;base64," + c
			}, t.ExtractMinAndMaxIndexed = function(t, i, r, n, o) {
				void 0 === o && (o = null);
				for (var s = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), a = new e.Vector3((-Number.MAX_VALUE), (-Number.MAX_VALUE), (-Number.MAX_VALUE)), h = r; h < r + n; h++) {
					var c = new e.Vector3(t[3 * i[h]], t[3 * i[h] + 1], t[3 * i[h] + 2]);
					s = e.Vector3.Minimize(c, s), a = e.Vector3.Maximize(c, a)
				}
				return o && (s.x -= s.x * o.x + o.y, s.y -= s.y * o.x + o.y, s.z -= s.z * o.x + o.y, a.x += a.x * o.x + o.y, a.y += a.y * o.x + o.y, a.z += a.z * o.x + o.y), {
					minimum: s,
					maximum: a
				}
			}, t.ExtractMinAndMax = function(t, i, r, n, o) {
				void 0 === n && (n = null);
				var s = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
					a = new e.Vector3((-Number.MAX_VALUE), (-Number.MAX_VALUE), (-Number.MAX_VALUE));
				o || (o = 3);
				for (var h = i; h < i + r; h++) {
					var c = new e.Vector3(t[h * o], t[h * o + 1], t[h * o + 2]);
					s = e.Vector3.Minimize(c, s), a = e.Vector3.Maximize(c, a)
				}
				return n && (s.x -= s.x * n.x + n.y, s.y -= s.y * n.x + n.y, s.z -= s.z * n.x + n.y, a.x += a.x * n.x + n.y, a.y += a.y * n.x + n.y, a.z += a.z * n.x + n.y), {
					minimum: s,
					maximum: a
				}
			}, t.Vector2ArrayFeeder = function(t) {
				return function(i) {
					var r = void 0 !== t.BYTES_PER_ELEMENT,
						n = r ? t.length / 2 : t.length;
					if (i >= n) return null;
					if (r) {
						var o = t;
						return new e.Vector2(o[2 * i + 0], o[2 * i + 1])
					}
					var s = t;
					return s[i]
				}
			}, t.ExtractMinAndMaxVector2 = function(t, i) {
				void 0 === i && (i = null);
				for (var r = new e.Vector2(Number.MAX_VALUE, Number.MAX_VALUE), n = new e.Vector2((-Number.MAX_VALUE), (-Number.MAX_VALUE)), o = 0, s = t(o++); s;) r = e.Vector2.Minimize(s, r), n = e.Vector2.Maximize(s, n), s = t(o++);
				return i && (r.x -= r.x * i.x + i.y, r.y -= r.y * i.x + i.y, n.x += n.x * i.x + i.y, n.y += n.y * i.x + i.y), {
					minimum: r,
					maximum: n
				}
			}, t.MakeArray = function(e, t) {
				if (t === !0 || void 0 !== e && null != e) return Array.isArray(e) ? e : [e]
			}, t.GetPointerPrefix = function() {
				var e = "pointer";
				return window.PointerEvent || navigator.pointerEnabled || (e = "mouse"), e
			}, t.QueueNewFrame = function(e, t) {
				void 0 === t && (t = window), t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.msRequestAnimationFrame ? t.msRequestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.mozRequestAnimationFrame ? t.mozRequestAnimationFrame(e) : t.oRequestAnimationFrame ? t.oRequestAnimationFrame(e) : window.setTimeout(e, 16)
			}, t.RequestFullscreen = function(e) {
				var t = e.requestFullscreen || e.msRequestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen;
				t && t.call(e)
			}, t.ExitFullscreen = function() {
				document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.msCancelFullScreen && document.msCancelFullScreen()
			}, t.SetCorsBehavior = function(e, i) {
				if (t.CorsBehavior) switch (typeof t.CorsBehavior) {
					case "function":
						var r = t.CorsBehavior(e);
						if (r) return r;
						break;
					case "string":
					default:
						i.crossOrigin = t.CorsBehavior
				}
			}, t.CleanUrl = function(e) {
				return e = e.replace(/#/gm, "%23")
			}, t.LoadImage = function(i, r, n, o) {
				i instanceof ArrayBuffer && (i = t.EncodeArrayBufferTobase64(i)), i = t.CleanUrl(i);
				var s = new Image;
				"data:" !== i.substr(0, 5) && t.SetCorsBehavior(i, s), s.onload = function() {
					r(s)
				}, s.onerror = function(e) {
					t.Error("Error while trying to load texture: " + i), t.UseFallbackTexture ? (s.src = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z", r(s)) : n()
				};
				var a = function() {
						s.src = i
					},
					h = function() {
						o.loadImageFromDB(i, s)
					};
				if ("data:" !== i.substr(0, 5) && o && o.enableTexturesOffline && e.Database.IsUASupportingBlobStorage) o.openAsync(h, a);
				else if (i.indexOf("file:") === -1) a();
				else try {
					var c, l = i.substring(5).toLowerCase();
					try {
						c = URL.createObjectURL(e.FilesInput.FilesTextures[l], {
							oneTimeOnly: !0
						})
					} catch (u) {
						c = URL.createObjectURL(e.FilesInput.FilesTextures[l])
					}
					s.src = c
				} catch (d) {
					s.src = null
				}
				return s
			}, t.LoadFile = function(i, r, n, o, s, a) {
				i = t.CleanUrl(i);
				var h = function() {
						var e = new XMLHttpRequest,
							o = t.BaseUrl + i;
						e.open("GET", o, !0), s && (e.responseType = "arraybuffer"), e.onprogress = n, e.onreadystatechange = function() {
							if (4 === e.readyState)
								if (e.onreadystatechange = null, e.status >= 200 && e.status < 300 || navigator.isCocoonJS && 0 === e.status) r(s ? e.response : e.responseText);
								else {
									if (!a) throw new Error("Error status: " + e.status + " - Unable to load " + o);
									a()
								}
						}, e.send(null)
					},
					c = function() {
						o.loadFileFromDB(i, r, n, h, s)
					};
				if (i.indexOf("file:") !== -1) {
					var l = i.substring(5).toLowerCase();
					t.ReadFile(e.FilesInput.FilesToLoad[l], r, n, s)
				} else o && o.enableSceneOffline ? o.openAsync(c, h) : h()
			}, t.ReadFileAsDataURL = function(e, t, i) {
				var r = new FileReader;
				r.onload = function(e) {
					t(e.target.result)
				}, r.onprogress = i, r.readAsDataURL(e)
			}, t.ReadFile = function(e, i, r, n) {
				var o = new FileReader;
				o.onerror = function(r) {
					t.Log("Error while reading file: " + e.name), i(JSON.stringify({
						autoClear: !0,
						clearColor: [1, 0, 0],
						ambientColor: [0, 0, 0],
						gravity: [0, -9.807, 0],
						meshes: [],
						cameras: [],
						lights: []
					}))
				}, o.onload = function(e) {
					i(e.target.result)
				}, o.onprogress = r, n ? o.readAsArrayBuffer(e) : o.readAsText(e)
			}, t.FileAsURL = function(e) {
				var t = new Blob([e]),
					i = window.URL || window.webkitURL,
					r = i.createObjectURL(t);
				return r
			}, t.Format = function(e, t) {
				return void 0 === t && (t = 2), e.toFixed(t)
			}, t.CheckExtends = function(e, t, i) {
				e.x < t.x && (t.x = e.x), e.y < t.y && (t.y = e.y), e.z < t.z && (t.z = e.z), e.x > i.x && (i.x = e.x), e.y > i.y && (i.y = e.y), e.z > i.z && (i.z = e.z)
			}, t.DeepCopy = function(e, t, i, n) {
				for (var o in e)
					if (("_" !== o[0] || n && n.indexOf(o) !== -1) && (!i || i.indexOf(o) === -1)) {
						var s = e[o],
							a = typeof s;
						if ("function" !== a)
							if ("object" === a)
								if (s instanceof Array) {
									if (t[o] = [], s.length > 0)
										if ("object" == typeof s[0])
											for (var h = 0; h < s.length; h++) {
												var c = r(s[h], t);
												t[o].indexOf(c) === -1 && t[o].push(c)
											} else t[o] = s.slice(0)
								} else t[o] = r(s, t);
						else t[o] = s
					}
			}, t.IsEmpty = function(e) {
				for (var t in e) return !1;
				return !0
			}, t.RegisterTopRootEvents = function(e) {
				for (var t = 0; t < e.length; t++) {
					var i = e[t];
					window.addEventListener(i.name, i.handler, !1);
					try {
						window.parent && window.parent.addEventListener(i.name, i.handler, !1)
					} catch (r) {}
				}
			}, t.UnregisterTopRootEvents = function(e) {
				for (var t = 0; t < e.length; t++) {
					var i = e[t];
					window.removeEventListener(i.name, i.handler);
					try {
						window.parent && window.parent.removeEventListener(i.name, i.handler)
					} catch (r) {}
				}
			}, t.DumpFramebuffer = function(e, r, n, o, s) {
				void 0 === s && (s = "image/png");
				for (var a = 4 * e, h = r / 2, c = n.readPixels(0, 0, e, r), l = 0; l < h; l++)
					for (var u = 0; u < a; u++) {
						var d = u + l * a,
							f = r - l - 1,
							p = u + f * a,
							m = c[d];
						c[d] = c[p], c[p] = m
					}
				i || (i = document.createElement("canvas")), i.width = e, i.height = r;
				var _ = i.getContext("2d"),
					g = _.createImageData(e, r),
					v = g.data;
				v.set(c), _.putImageData(g, 0, 0), t.EncodeScreenshotCanvasData(o, s)
			}, t.EncodeScreenshotCanvasData = function(e, t) {
				void 0 === t && (t = "image/png");
				var r = i.toDataURL(t);
				if (e) e(r);
				else if ("download" in document.createElement("a")) {
					var n = window.document.createElement("a");
					n.href = r;
					var o = new Date,
						s = (o.getFullYear() + "-" + (o.getMonth() + 1)).slice(-2) + "-" + o.getDate() + "_" + o.getHours() + "-" + ("0" + o.getMinutes()).slice(-2);
					n.setAttribute("download", "screenshot_" + s + ".png"), window.document.body.appendChild(n), n.addEventListener("click", (function() {
						n.parentElement.removeChild(n)
					})), n.click()
				} else {
					var a = window.open(""),
						h = a.document.createElement("img");
					h.src = r, a.document.body.appendChild(h)
				}
			}, t.CreateScreenshot = function(e, r, n, o, s) {
				void 0 === s && (s = "image/png");
				var a, h;
				if (n.precision) a = Math.round(e.getRenderWidth() * n.precision), h = Math.round(a / e.getAspectRatio(r));
				else if (n.width && n.height) a = n.width, h = n.height;
				else if (n.width && !n.height) a = n.width, h = Math.round(a / e.getAspectRatio(r));
				else if (n.height && !n.width) h = n.height, a = Math.round(h * e.getAspectRatio(r));
				else {
					if (isNaN(n)) return void t.Error("Invalid 'size' parameter !");
					h = n, a = n
				}
				i || (i = document.createElement("canvas")), i.width = a, i.height = h;
				var c = i.getContext("2d");
				c.drawImage(e.getRenderingCanvas(), 0, 0, a, h), t.EncodeScreenshotCanvasData(o, s)
			}, t.CreateScreenshotUsingRenderTarget = function(i, r, n, o, s) {
				void 0 === s && (s = "image/png");
				var a, h;
				if (n.precision) a = Math.round(i.getRenderWidth() * n.precision), h = Math.round(a / i.getAspectRatio(r)), n = {
					width: a,
					height: h
				};
				else if (n.width && n.height) a = n.width, h = n.height;
				else if (n.width && !n.height) a = n.width, h = Math.round(a / i.getAspectRatio(r)), n = {
					width: a,
					height: h
				};
				else if (n.height && !n.width) h = n.height, a = Math.round(h * i.getAspectRatio(r)), n = {
					width: a,
					height: h
				};
				else {
					if (isNaN(n)) return void t.Error("Invalid 'size' parameter !");
					h = n, a = n
				}
				var c = r.getScene(),
					l = null;
				c.activeCamera !== r && (l = c.activeCamera, c.activeCamera = r);
				var u = new e.RenderTargetTexture("screenShot", n, c, (!1), (!1));
				u.renderList = c.meshes, u.onAfterRenderObservable.add((function() {
					t.DumpFramebuffer(a, h, i, o, s)
				})), c.incrementRenderId(), c.resetCachedMaterial(), u.render(!0), u.dispose(), l && (c.activeCamera = l), r.getProjectionMatrix(!0)
			}, t.ValidateXHRData = function(t, i) {
				void 0 === i && (i = 7);
				try {
					if (1 & i) {
						if (t.responseText && t.responseText.length > 0) return !0;
						if (1 === i) return !1
					}
					if (2 & i) {
						var r = e.Internals.TGATools.GetTGAHeader(t.response);
						if (r.width && r.height && r.width > 0 && r.height > 0) return !0;
						if (2 === i) return !1
					}
					if (4 & i) {
						var n = new Uint8Array(t.response, 0, 3);
						return 68 === n[0] && 68 === n[1] && 83 === n[2]
					}
				} catch (o) {}
				return !1
			}, t.RandomId = function() {
				return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
					var t = 16 * Math.random() | 0,
						i = "x" === e ? t : 3 & t | 8;
					return i.toString(16)
				}))
			}, Object.defineProperty(t, "NoneLogLevel", {
				get: function() {
					return t._NoneLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "MessageLogLevel", {
				get: function() {
					return t._MessageLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "WarningLogLevel", {
				get: function() {
					return t._WarningLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "ErrorLogLevel", {
				get: function() {
					return t._ErrorLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "AllLogLevel", {
				get: function() {
					return t._MessageLogLevel | t._WarningLogLevel | t._ErrorLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), t._AddLogEntry = function(e) {
				t._LogCache = e + t._LogCache, t.OnNewCacheEntry && t.OnNewCacheEntry(e)
			}, t._FormatMessage = function(e) {
				var t = function(e) {
						return e < 10 ? "0" + e : "" + e
					},
					i = new Date;
				return "[" + t(i.getHours()) + ":" + t(i.getMinutes()) + ":" + t(i.getSeconds()) + "]: " + e
			}, t._LogDisabled = function(e) {}, t._LogEnabled = function(e) {
				var i = t._FormatMessage(e);
				console.log("BJS - " + i);
				var r = "<div style='color:white'>" + i + "</div><br>";
				t._AddLogEntry(r)
			}, t._WarnDisabled = function(e) {}, t._WarnEnabled = function(e) {
				var i = t._FormatMessage(e);
				console.warn("BJS - " + i);
				var r = "<div style='color:orange'>" + i + "</div><br>";
				t._AddLogEntry(r)
			}, t._ErrorDisabled = function(e) {}, t._ErrorEnabled = function(e) {
				t.errorsCount++;
				var i = t._FormatMessage(e);
				console.error("BJS - " + i);
				var r = "<div style='color:red'>" + i + "</div><br>";
				t._AddLogEntry(r)
			}, Object.defineProperty(t, "LogCache", {
				get: function() {
					return t._LogCache
				},
				enumerable: !0,
				configurable: !0
			}), t.ClearLogCache = function() {
				t._LogCache = "", t.errorsCount = 0
			}, Object.defineProperty(t, "LogLevels", {
				set: function(e) {
					(e & t.MessageLogLevel) === t.MessageLogLevel ? t.Log = t._LogEnabled : t.Log = t._LogDisabled, (e & t.WarningLogLevel) === t.WarningLogLevel ? t.Warn = t._WarnEnabled : t.Warn = t._WarnDisabled, (e & t.ErrorLogLevel) === t.ErrorLogLevel ? t.Error = t._ErrorEnabled : t.Error = t._ErrorDisabled
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "PerformanceNoneLogLevel", {
				get: function() {
					return t._PerformanceNoneLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "PerformanceUserMarkLogLevel", {
				get: function() {
					return t._PerformanceUserMarkLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "PerformanceConsoleLogLevel", {
				get: function() {
					return t._PerformanceConsoleLogLevel
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t, "PerformanceLogLevel", {
				set: function(e) {
					return (e & t.PerformanceUserMarkLogLevel) === t.PerformanceUserMarkLogLevel ? (t.StartPerformanceCounter = t._StartUserMark, void(t.EndPerformanceCounter = t._EndUserMark)) : (e & t.PerformanceConsoleLogLevel) === t.PerformanceConsoleLogLevel ? (t.StartPerformanceCounter = t._StartPerformanceConsole, void(t.EndPerformanceCounter = t._EndPerformanceConsole)) : (t.StartPerformanceCounter = t._StartPerformanceCounterDisabled, void(t.EndPerformanceCounter = t._EndPerformanceCounterDisabled))
				},
				enumerable: !0,
				configurable: !0
			}), t._StartPerformanceCounterDisabled = function(e, t) {}, t._EndPerformanceCounterDisabled = function(e, t) {}, t._StartUserMark = function(e, i) {
				void 0 === i && (i = !0), i && t._performance.mark && t._performance.mark(e + "-Begin")
			}, t._EndUserMark = function(e, i) {
				void 0 === i && (i = !0), i && t._performance.mark && (t._performance.mark(e + "-End"), t._performance.measure(e, e + "-Begin", e + "-End"))
			}, t._StartPerformanceConsole = function(e, i) {
				void 0 === i && (i = !0), i && (t._StartUserMark(e, i), console.time && console.time(e))
			}, t._EndPerformanceConsole = function(e, i) {
				void 0 === i && (i = !0), i && (t._EndUserMark(e, i), console.time && console.timeEnd(e))
			}, Object.defineProperty(t, "Now", {
				get: function() {
					return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime()
				},
				enumerable: !0,
				configurable: !0
			}), t.getClassName = function(e, t) {
				void 0 === t && (t = !1);
				var i = null;
				if (!t && e.getClassName) i = e.getClassName();
				else {
					if (e instanceof Object) {
						var r = t ? e : Object.getPrototypeOf(e);
						i = r.constructor.__bjsclassName__
					}
					i || (i = typeof e)
				}
				return i
			}, t.first = function(e, t) {
				for (var i = 0, r = e; i < r.length; i++) {
					var n = r[i];
					if (t(n)) return n
				}
			}, t.getFullClassName = function(e, t) {
				void 0 === t && (t = !1);
				var i = null,
					r = null;
				if (!t && e.getClassName) i = e.getClassName();
				else {
					if (e instanceof Object) {
						var n = t ? e : Object.getPrototypeOf(e);
						i = n.constructor.__bjsclassName__, r = n.constructor.__bjsmoduleName__
					}
					i || (i = typeof e)
				}
				return i ? (null != r ? r + "." : "") + i : null
			}, t.arrayOrStringFeeder = function(e) {
				return function(i) {
					if (i >= e.length) return null;
					var r = e.charCodeAt ? e.charCodeAt(i) : e[i];
					return r && r.getHashCode && (r = r.getHashCode()), "string" == typeof r ? t.hashCodeFromStream(t.arrayOrStringFeeder(r)) : r
				}
			}, t.hashCodeFromStream = function(e) {
				for (var t = 0, i = 0, r = e(i++); null != r;) t = (t << 5) - t + r, t |= 0, r = e(i++);
				return t
			}, t.BaseUrl = "", t.CorsBehavior = "anonymous", t.UseFallbackTexture = !0, t._NoneLogLevel = 0, t._MessageLogLevel = 1, t._WarningLogLevel = 2, t._ErrorLogLevel = 4, t._LogCache = "", t.errorsCount = 0, t.Log = t._LogEnabled, t.Warn = t._WarnEnabled, t.Error = t._ErrorEnabled, t._PerformanceNoneLogLevel = 0, t._PerformanceUserMarkLogLevel = 1, t._PerformanceConsoleLogLevel = 2, t._performance = window.performance, t.StartPerformanceCounter = t._StartPerformanceCounterDisabled, t.EndPerformanceCounter = t._EndPerformanceCounterDisabled, t
		})();
	e.Tools = n;
	var o = (function() {
		function e() {
			this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0
		}
		return Object.defineProperty(e.prototype, "min", {
			get: function() {
				return this._min
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "max", {
			get: function() {
				return this._max
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "average", {
			get: function() {
				return this._average
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "lastSecAverage", {
			get: function() {
				return this._lastSecAverage
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "current", {
			get: function() {
				return this._current
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "total", {
			get: function() {
				return this._totalAccumulated
			},
			enumerable: !0,
			configurable: !0
		}), e.prototype.fetchNewFrame = function() {
			this._totalValueCount++, this._current = 0, this._lastSecValueCount++
		}, e.prototype.addCount = function(e, t) {
			this._current += e, t && this._fetchResult()
		}, e.prototype.beginMonitoring = function() {
			this._startMonitoringTime = n.Now
		}, e.prototype.endMonitoring = function(e) {
			void 0 === e && (e = !0), e && this.fetchNewFrame();
			var t = n.Now;
			this._current = t - this._startMonitoringTime, e && this._fetchResult()
		}, e.prototype._fetchResult = function() {
			this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount;
			var e = n.Now;
			e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0)
		}, e
	})();
	e.PerfCounter = o, e.className = t;
	var s = (function() {
		function e(e, t, i, r) {
			void 0 === r && (r = 0), this.iterations = e, this._fn = t, this._successCallback = i, this.index = r - 1, this._done = !1
		}
		return e.prototype.executeNext = function() {
			this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop())
		}, e.prototype.breakLoop = function() {
			this._done = !0, this._successCallback()
		}, e.Run = function(t, i, r, n) {
			void 0 === n && (n = 0);
			var o = new e(t, i, r, n);
			return o.executeNext(), o
		}, e.SyncAsyncForLoop = function(t, i, r, n, o, s) {
			void 0 === s && (s = 0), e.Run(Math.ceil(t / i), (function(e) {
				o && o() ? e.breakLoop() : setTimeout((function() {
					for (var n = 0; n < i; ++n) {
						var s = e.index * i + n;
						if (s >= t) break;
						if (r(s), o && o()) {
							e.breakLoop();
							break
						}
					}
					e.executeNext()
				}), s)
			}), n)
		}, e
	})();
	e.AsyncLoop = s
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(e) {
		var t = (function() {
			function e() {
				this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._alphaBlend = !1, this._blendFunctionParameters = new Array(4), this.reset()
			}
			return Object.defineProperty(e.prototype, "isDirty", {
				get: function() {
					return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "alphaBlend", {
				get: function() {
					return this._alphaBlend
				},
				set: function(e) {
					this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), e.prototype.setAlphaBlendFunctionParameters = function(e, t, i, r) {
				this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === r || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = i, this._blendFunctionParameters[3] = r, this._isBlendFunctionParametersDirty = !0)
			}, e.prototype.reset = function() {
				this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1
			}, e.prototype.apply = function(e) {
				this.isDirty && (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1))
			}, e
		})();
		e._AlphaState = t
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(e) {
		var t = (function() {
			function e() {
				this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this.reset()
			}
			return Object.defineProperty(e.prototype, "isDirty", {
				get: function() {
					return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "zOffset", {
				get: function() {
					return this._zOffset
				},
				set: function(e) {
					this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "cullFace", {
				get: function() {
					return this._cullFace
				},
				set: function(e) {
					this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "cull", {
				get: function() {
					return this._cull
				},
				set: function(e) {
					this._cull !== e && (this._cull = e, this._isCullDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "depthFunc", {
				get: function() {
					return this._depthFunc
				},
				set: function(e) {
					this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "depthMask", {
				get: function() {
					return this._depthMask
				},
				set: function(e) {
					this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(e.prototype, "depthTest", {
				get: function() {
					return this._depthTest
				},
				set: function(e) {
					this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), e.prototype.reset = function() {
				this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1
			}, e.prototype.apply = function(e) {
				this.isDirty && (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, 0)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1))
			}, e
		})();
		e._DepthCullingState = t
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
			function t() {
				this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.reset()
			}
			return Object.defineProperty(t.prototype, "isDirty", {
				get: function() {
					return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilFunc", {
				get: function() {
					return this._stencilFunc
				},
				set: function(e) {
					this._stencilFunc !== e && (this._stencilFunc = e, this._isStencilFuncDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilFuncRef", {
				get: function() {
					return this._stencilFuncRef
				},
				set: function(e) {
					this._stencilFuncRef !== e && (this._stencilFuncRef = e, this._isStencilFuncDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilFuncMask", {
				get: function() {
					return this._stencilFuncMask
				},
				set: function(e) {
					this._stencilFuncMask !== e && (this._stencilFuncMask = e, this._isStencilFuncDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilOpStencilFail", {
				get: function() {
					return this._stencilOpStencilFail
				},
				set: function(e) {
					this._stencilOpStencilFail !== e && (this._stencilOpStencilFail = e, this._isStencilOpDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilOpDepthFail", {
				get: function() {
					return this._stencilOpDepthFail
				},
				set: function(e) {
					this._stencilOpDepthFail !== e && (this._stencilOpDepthFail = e, this._isStencilOpDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilOpStencilDepthPass", {
				get: function() {
					return this._stencilOpStencilDepthPass
				},
				set: function(e) {
					this._stencilOpStencilDepthPass !== e && (this._stencilOpStencilDepthPass = e, this._isStencilOpDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilMask", {
				get: function() {
					return this._stencilMask
				},
				set: function(e) {
					this._stencilMask !== e && (this._stencilMask = e, this._isStencilMaskDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "stencilTest", {
				get: function() {
					return this._stencilTest
				},
				set: function(e) {
					this._stencilTest !== e && (this._stencilTest = e, this._isStencilTestDirty = !0)
				},
				enumerable: !0,
				configurable: !0
			}), t.prototype.reset = function() {
				this._stencilTest = !1, this._stencilMask = 255, this._stencilFunc = e.Engine.ALWAYS, this._stencilFuncRef = 1, this._stencilFuncMask = 255, this._stencilOpStencilFail = e.Engine.KEEP, this._stencilOpDepthFail = e.Engine.KEEP, this._stencilOpStencilDepthPass = e.Engine.REPLACE, this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0
			}, t.prototype.apply = function(e) {
				this.isDirty && (this._isStencilTestDirty && (this.stencilTest ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.stencilMask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.stencilFunc, this.stencilFuncRef, this.stencilFuncMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.stencilOpStencilFail, this.stencilOpDepthFail, this.stencilOpStencilDepthPass), this._isStencilOpDirty = !1))
			}, t
		})();
		t._StencilState = i
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = function(e, t, i, r) {
			var n = e.createShader("vertex" === i ? e.VERTEX_SHADER : e.FRAGMENT_SHADER);
			if (e.shaderSource(n, (r ? r + "\n" : "") + t), e.compileShader(n), !e.getShaderParameter(n, e.COMPILE_STATUS)) throw new Error(e.getShaderInfoLog(n));
			return n
		},
		i = 36193,
		r = function(e, t) {
			return t === l.TEXTURETYPE_FLOAT ? e.FLOAT : t === l.TEXTURETYPE_HALF_FLOAT ? i : e.UNSIGNED_BYTE
		},
		n = function(t, i, r) {
			var n = r.NEAREST,
				o = r.NEAREST;
			return t === e.Texture.BILINEAR_SAMPLINGMODE ? (n = r.LINEAR, o = i ? r.LINEAR_MIPMAP_NEAREST : r.LINEAR) : t === e.Texture.TRILINEAR_SAMPLINGMODE ? (n = r.LINEAR, o = i ? r.LINEAR_MIPMAP_LINEAR : r.LINEAR) : t === e.Texture.NEAREST_SAMPLINGMODE && (n = r.NEAREST, o = i ? r.NEAREST_MIPMAP_LINEAR : r.NEAREST), {
				min: o,
				mag: n
			}
		},
		o = function(t, i, r, o, s, a, h, c, l, u) {
			void 0 === u && (u = e.Texture.TRILINEAR_SAMPLINGMODE);
			var d = r.getEngine(),
				f = e.Tools.GetExponentOfTwo(o, d.getCaps().maxTextureSize),
				p = e.Tools.GetExponentOfTwo(s, d.getCaps().maxTextureSize);
			d._bindTextureDirectly(i.TEXTURE_2D, t), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, void 0 === a ? 1 : a ? 1 : 0), t._baseWidth = o, t._baseHeight = s, t._width = f, t._height = p, t.isReady = !0, l(f, p);
			var m = n(u, !h, i);
			i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, m.mag), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, m.min), h || c || i.generateMipmap(i.TEXTURE_2D), d._bindTextureDirectly(i.TEXTURE_2D, null), d.resetTextureCache(), r._removePendingData(t), t.onLoadedCallbacks.forEach((function(e) {
				e()
			})), t.onLoadedCallbacks = []
		},
		s = function(t, i, r, n, o, s) {
			void 0 === s && (s = null);
			var a, h = function() {
					r[i] = a, r._internalCount++, n._removePendingData(a), 6 === r._internalCount && o(r)
				},
				c = function() {
					n._removePendingData(a), s && s()
				};
			a = e.Tools.LoadImage(t, h, c, n.database), n._addPendingData(a)
		},
		a = function(e, t, i, r, n) {
			void 0 === n && (n = null);
			var o = [];
			o._internalCount = 0;
			for (var a = 0; a < 6; a++) s(r[a], a, o, t, i, n)
		},
		h = (function() {
			function e() {}
			return e
		})();
	e.InstancingAttributeInfo = h;
	var c = (function() {
		function e() {}
		return e
	})();
	e.EngineCapabilities = c;
	var l = (function() {
		function s(t, i, r, n) {
			var o = this;
			void 0 === n && (n = !0), this.isFullscreen = !1, this.isPointerLock = !1, this.cullBackFaces = !0, this.renderEvenInBackground = !0, this.enableOfflineSupport = !0, this.scenes = new Array, this._windowIsBackground = !1, this._webGLVersion = "1.0", this._badOS = !1, this._drawCalls = new e.PerfCounter, this._renderingQueueLaunched = !1, this._activeRenderLoops = [], this.fpsRange = 60, this.previousFramesDuration = [], this.fps = 60, this.deltaTime = 0, this._depthCullingState = new e.Internals._DepthCullingState, this._stencilState = new e.Internals._StencilState, this._alphaState = new e.Internals._AlphaState, this._alphaMode = s.ALPHA_DISABLE, this._loadedTexturesCache = new Array, this._maxTextureChannels = 16, this._activeTexturesCache = new Array(this._maxTextureChannels), this._compiledEffects = {}, this._vertexAttribArraysEnabled = [], this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array, this._currentBufferPointers = [], this._currentInstanceLocations = new Array, this._currentInstanceBuffers = new Array, this._texturesSupported = new Array, this._onVRFullScreenTriggered = function() {
				if (o._vrDisplayEnabled && o._vrDisplayEnabled.isPresenting) {
					o._oldSize = new e.Size(o.getRenderWidth(), o.getRenderHeight()), o._oldHardwareScaleFactor = o.getHardwareScalingLevel();
					var t = o._vrDisplayEnabled.getEyeParameters("left");
					o.setHardwareScalingLevel(1), o.setSize(2 * t.renderWidth, t.renderHeight)
				} else o.setHardwareScalingLevel(o._oldHardwareScaleFactor), o.setSize(o._oldSize.width, o._oldSize.height), o._vrDisplayEnabled = void 0
			}, this._renderingCanvas = t, this._externalData = new e.StringDictionary, r = r || {}, null != i && (r.antialias = i), void 0 === r.preserveDrawingBuffer && (r.preserveDrawingBuffer = !1);
			var a = this._canRenderToFloatTexture(),
				h = this._canRenderToHalfFloatTexture();
			if (!this._gl) {
				if (!t) throw new Error("The provided canvas is null or undefined.");
				try {
					this._gl = t.getContext("webgl", r) || t.getContext("experimental-webgl", r)
				} catch (l) {
					throw new Error("WebGL not supported")
				}
			}
			if (!this._gl) throw new Error("WebGL not supported");
			this._onBlur = function() {
				o._windowIsBackground = !0
			}, this._onFocus = function() {
				o._windowIsBackground = !1
			}, window.addEventListener("blur", this._onBlur), window.addEventListener("focus", this._onFocus);
			var u = r.limitDeviceRatio || window.devicePixelRatio || 1;
			this._hardwareScalingLevel = n ? 1 / Math.min(u, window.devicePixelRatio || 1) : 1, this.resize(), this._isStencilEnable = r.stencil, this._caps = new c, this._caps.maxTexturesImageUnits = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxTextureSize = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE), this._caps.maxCubemapTextureSize = this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.maxRenderTextureSize = this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE), this._caps.maxVertexAttribs = this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS), this._glVersion = this._gl.getParameter(this._gl.VERSION);
			var d = this._gl.getExtension("WEBGL_debug_renderer_info");
			if (null != d && (this._glRenderer = this._gl.getParameter(d.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(d.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = "Unknown vendor"), this._glRenderer || (this._glRenderer = "Unknown renderer"), this._caps.standardDerivatives = null !== this._gl.getExtension("OES_standard_derivatives"), this._caps.astc = this._gl.getExtension("WEBGL_compressed_texture_astc"), this._caps.s3tc = this._gl.getExtension("WEBGL_compressed_texture_s3tc"), this._caps.pvrtc = this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), this._caps.etc1 = this._gl.getExtension("WEBGL_compressed_texture_etc1"), this._caps.etc2 = this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"), this._caps.textureFloat = null !== this._gl.getExtension("OES_texture_float"), this._caps.textureAnisotropicFilterExtension = this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.instancedArrays = this._gl.getExtension("ANGLE_instanced_arrays"), this._caps.uintIndices = null !== this._gl.getExtension("OES_element_index_uint"), this._caps.fragmentDepthSupported = null !== this._gl.getExtension("EXT_frag_depth"), this._caps.highPrecisionShaderSupported = !0, this._caps.drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers"), this._caps.textureFloatLinearFiltering = this._gl.getExtension("OES_texture_float_linear"), this._caps.textureLOD = this._gl.getExtension("EXT_shader_texture_lod"), this._caps.textureFloatRender = a, this._caps.textureHalfFloat = null !== this._gl.getExtension("OES_texture_half_float"), this._caps.textureHalfFloatLinearFiltering = this._gl.getExtension("OES_texture_half_float_linear"), this._caps.textureHalfFloatRender = h, this._caps.astc && this.texturesSupported.push(".astc"), this._caps.s3tc && this.texturesSupported.push(".dds"), this._caps.pvrtc && this.texturesSupported.push(".pvr"), this._caps.etc2 && this.texturesSupported.push(".etc2"), this._caps.etc1 && this.texturesSupported.push(".etc1"), this._gl.getShaderPrecisionFormat) {
				var f = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
				this._caps.highPrecisionShaderSupported = 0 !== f.precision
			}
			this.setDepthBuffer(!0), this.setDepthFunctionToLessOrEqual(), this.setDepthWrite(!0), this._onFullscreenChange = function() {
				void 0 !== document.fullscreen ? o.isFullscreen = document.fullscreen : void 0 !== document.mozFullScreen ? o.isFullscreen = document.mozFullScreen : void 0 !== document.webkitIsFullScreen ? o.isFullscreen = document.webkitIsFullScreen : void 0 !== document.msIsFullScreen && (o.isFullscreen = document.msIsFullScreen), o.isFullscreen && o._pointerLockRequested && (t.requestPointerLock = t.requestPointerLock || t.msRequestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock && t.requestPointerLock())
			}, document.addEventListener("fullscreenchange", this._onFullscreenChange, !1), document.addEventListener("mozfullscreenchange", this._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, !1), document.addEventListener("msfullscreenchange", this._onFullscreenChange, !1), this._onPointerLockChange = function() {
				o.isPointerLock = document.mozPointerLockElement === t || document.webkitPointerLockElement === t || document.msPointerLockElement === t || document.pointerLockElement === t
			}, document.addEventListener("pointerlockchange", this._onPointerLockChange, !1), document.addEventListener("mspointerlockchange", this._onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", this._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, !1), e.AudioEngine && !s.audioEngine && (s.audioEngine = new e.AudioEngine), this._loadingScreen = new e.DefaultLoadingScreen(this._renderingCanvas), r.autoEnableWebVR && this.initWebVR();
			var p = /AppleWebKit.*10.[\d] Mobile/;
			this._badOS = p.test(navigator.userAgent), e.Tools.Log("Babylon.js engine (v" + s.Version + ") launched")
		}
		return Object.defineProperty(s, "NEVER", {
			get: function() {
				return s._NEVER
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALWAYS", {
			get: function() {
				return s._ALWAYS
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "LESS", {
			get: function() {
				return s._LESS
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "EQUAL", {
			get: function() {
				return s._EQUAL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "LEQUAL", {
			get: function() {
				return s._LEQUAL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "GREATER", {
			get: function() {
				return s._GREATER
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "GEQUAL", {
			get: function() {
				return s._GEQUAL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "NOTEQUAL", {
			get: function() {
				return s._NOTEQUAL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "KEEP", {
			get: function() {
				return s._KEEP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "REPLACE", {
			get: function() {
				return s._REPLACE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "INCR", {
			get: function() {
				return s._INCR
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "DECR", {
			get: function() {
				return s._DECR
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "INVERT", {
			get: function() {
				return s._INVERT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "INCR_WRAP", {
			get: function() {
				return s._INCR_WRAP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "DECR_WRAP", {
			get: function() {
				return s._DECR_WRAP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_DISABLE", {
			get: function() {
				return s._ALPHA_DISABLE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_ONEONE", {
			get: function() {
				return s._ALPHA_ONEONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_ADD", {
			get: function() {
				return s._ALPHA_ADD
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_COMBINE", {
			get: function() {
				return s._ALPHA_COMBINE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_SUBTRACT", {
			get: function() {
				return s._ALPHA_SUBTRACT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_MULTIPLY", {
			get: function() {
				return s._ALPHA_MULTIPLY
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "ALPHA_MAXIMIZED", {
			get: function() {
				return s._ALPHA_MAXIMIZED
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "DELAYLOADSTATE_NONE", {
			get: function() {
				return s._DELAYLOADSTATE_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "DELAYLOADSTATE_LOADED", {
			get: function() {
				return s._DELAYLOADSTATE_LOADED
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "DELAYLOADSTATE_LOADING", {
			get: function() {
				return s._DELAYLOADSTATE_LOADING
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "DELAYLOADSTATE_NOTLOADED", {
			get: function() {
				return s._DELAYLOADSTATE_NOTLOADED
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTUREFORMAT_ALPHA", {
			get: function() {
				return s._TEXTUREFORMAT_ALPHA
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTUREFORMAT_LUMINANCE", {
			get: function() {
				return s._TEXTUREFORMAT_LUMINANCE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTUREFORMAT_LUMINANCE_ALPHA", {
			get: function() {
				return s._TEXTUREFORMAT_LUMINANCE_ALPHA
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTUREFORMAT_RGB", {
			get: function() {
				return s._TEXTUREFORMAT_RGB
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTUREFORMAT_RGBA", {
			get: function() {
				return s._TEXTUREFORMAT_RGBA
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTURETYPE_UNSIGNED_INT", {
			get: function() {
				return s._TEXTURETYPE_UNSIGNED_INT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTURETYPE_FLOAT", {
			get: function() {
				return s._TEXTURETYPE_FLOAT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "TEXTURETYPE_HALF_FLOAT", {
			get: function() {
				return s._TEXTURETYPE_HALF_FLOAT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s, "Version", {
			get: function() {
				return "2.5"
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "texturesSupported", {
			get: function() {
				return this._texturesSupported
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "textureFormatInUse", {
			get: function() {
				return this._textureFormatInUse
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "webGLVersion", {
			get: function() {
				return this._webGLVersion
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "isStencilEnable", {
			get: function() {
				return this._isStencilEnable
			},
			enumerable: !0,
			configurable: !0
		}), s.prototype._prepareWorkingCanvas = function() {
			this._workingCanvas || (this._workingCanvas = document.createElement("canvas"), this._workingContext = this._workingCanvas.getContext("2d"))
		}, s.prototype.resetTextureCache = function() {
			for (var e = 0; e < this._maxTextureChannels; e++) this._activeTexturesCache[e] = null
		}, s.prototype.getGlInfo = function() {
			return {
				vendor: this._glVendor,
				renderer: this._glRenderer,
				version: this._glVersion
			}
		}, s.prototype.getAspectRatio = function(e, t) {
			void 0 === t && (t = !1);
			var i = e.viewport;
			return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height)
		}, s.prototype.getRenderWidth = function(e) {
			return void 0 === e && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget._width : this._renderingCanvas.width
		}, s.prototype.getRenderHeight = function(e) {
			return void 0 === e && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget._height : this._renderingCanvas.height
		}, s.prototype.getRenderingCanvas = function() {
			return this._renderingCanvas
		}, s.prototype.getRenderingCanvasClientRect = function() {
			return this._renderingCanvas.getBoundingClientRect()
		}, s.prototype.setHardwareScalingLevel = function(e) {
			this._hardwareScalingLevel = e, this.resize()
		}, s.prototype.getHardwareScalingLevel = function() {
			return this._hardwareScalingLevel
		}, s.prototype.getLoadedTexturesCache = function() {
			return this._loadedTexturesCache
		}, s.prototype.getCaps = function() {
			return this._caps
		}, Object.defineProperty(s.prototype, "drawCalls", {
			get: function() {
				return this._drawCalls.current
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "drawCallsPerfCounter", {
			get: function() {
				return this._drawCalls
			},
			enumerable: !0,
			configurable: !0
		}), s.prototype.getDepthFunction = function() {
			return this._depthCullingState.depthFunc
		}, s.prototype.setDepthFunction = function(e) {
			this._depthCullingState.depthFunc = e
		}, s.prototype.setDepthFunctionToGreater = function() {
			this._depthCullingState.depthFunc = this._gl.GREATER
		}, s.prototype.setDepthFunctionToGreaterOrEqual = function() {
			this._depthCullingState.depthFunc = this._gl.GEQUAL
		}, s.prototype.setDepthFunctionToLess = function() {
			this._depthCullingState.depthFunc = this._gl.LESS
		}, s.prototype.setDepthFunctionToLessOrEqual = function() {
			this._depthCullingState.depthFunc = this._gl.LEQUAL
		}, s.prototype.getStencilBuffer = function() {
			return this._stencilState.stencilTest
		}, s.prototype.setStencilBuffer = function(e) {
			this._stencilState.stencilTest = e
		}, s.prototype.getStencilMask = function() {
			return this._stencilState.stencilMask
		}, s.prototype.setStencilMask = function(e) {
			this._stencilState.stencilMask = e
		}, s.prototype.getStencilFunction = function() {
			return this._stencilState.stencilFunc
		}, s.prototype.getStencilFunctionReference = function() {
			return this._stencilState.stencilFuncRef
		}, s.prototype.getStencilFunctionMask = function() {
			return this._stencilState.stencilFuncMask
		}, s.prototype.setStencilFunction = function(e) {
			this._stencilState.stencilFunc = e
		}, s.prototype.setStencilFunctionReference = function(e) {
			this._stencilState.stencilFuncRef = e
		}, s.prototype.setStencilFunctionMask = function(e) {
			this._stencilState.stencilFuncMask = e
		}, s.prototype.getStencilOperationFail = function() {
			return this._stencilState.stencilOpStencilFail
		}, s.prototype.getStencilOperationDepthFail = function() {
			return this._stencilState.stencilOpDepthFail
		}, s.prototype.getStencilOperationPass = function() {
			return this._stencilState.stencilOpStencilDepthPass
		}, s.prototype.setStencilOperationFail = function(e) {
			this._stencilState.stencilOpStencilFail = e
		}, s.prototype.setStencilOperationDepthFail = function(e) {
			this._stencilState.stencilOpDepthFail = e
		}, s.prototype.setStencilOperationPass = function(e) {
			this._stencilState.stencilOpStencilDepthPass = e
		}, s.prototype.stopRenderLoop = function(e) {
			if (!e) return void(this._activeRenderLoops = []);
			var t = this._activeRenderLoops.indexOf(e);
			t >= 0 && this._activeRenderLoops.splice(t, 1)
		}, s.prototype._renderLoop = function() {
			var t = !0;
			if (!this.renderEvenInBackground && this._windowIsBackground && (t = !1), t) {
				this.beginFrame();
				for (var i = 0; i < this._activeRenderLoops.length; i++) {
					var r = this._activeRenderLoops[i];
					r()
				}
				this.endFrame()
			}
			this._activeRenderLoops.length > 0 ? e.Tools.QueueNewFrame(this._bindedRenderFunction, this._vrDisplayEnabled) : this._renderingQueueLaunched = !1
		}, s.prototype.runRenderLoop = function(t) {
			this._activeRenderLoops.indexOf(t) === -1 && (this._activeRenderLoops.push(t), this._renderingQueueLaunched || (this._renderingQueueLaunched = !0, this._bindedRenderFunction = this._renderLoop.bind(this), e.Tools.QueueNewFrame(this._bindedRenderFunction)))
		}, s.prototype.switchFullscreen = function(t) {
			this.isFullscreen ? e.Tools.ExitFullscreen() : (this._pointerLockRequested = t, e.Tools.RequestFullscreen(this._renderingCanvas))
		}, s.prototype.clear = function(e, t, i, r) {
			void 0 === r && (r = !1), this.applyStates();
			var n = 0;
			t && (this._gl.clearColor(e.r, e.g, e.b, void 0 !== e.a ? e.a : 1), n |= this._gl.COLOR_BUFFER_BIT), i && (this._gl.clearDepth(1), n |= this._gl.DEPTH_BUFFER_BIT), r && (this._gl.clearStencil(0), n |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(n)
		}, s.prototype.scissorClear = function(e, t, i, r, n) {
			var o = this._gl,
				s = o.getParameter(o.SCISSOR_TEST),
				a = o.getParameter(o.SCISSOR_BOX);
			o.enable(o.SCISSOR_TEST), o.scissor(e, t, i, r), this.clear(n, !0, !0, !0), o.scissor(a[0], a[1], a[2], a[3]), s === !0 ? o.enable(o.SCISSOR_TEST) : o.disable(o.SCISSOR_TEST)
		}, s.prototype.setViewport = function(e, t, i) {
			var r = t || (navigator.isCocoonJS ? window.innerWidth : this._renderingCanvas.width),
				n = i || (navigator.isCocoonJS ? window.innerHeight : this._renderingCanvas.height),
				o = e.x || 0,
				s = e.y || 0;
			this._cachedViewport = e, this._gl.viewport(o * r, s * n, r * e.width, n * e.height)
		}, s.prototype.setDirectViewport = function(e, t, i, r) {
			var n = this._cachedViewport;
			return this._cachedViewport = null, this._gl.viewport(e, t, i, r), n
		}, s.prototype.beginFrame = function() {
			this._measureFps()
		}, s.prototype.endFrame = function() {
			this._badOS && this.flushFramebuffer(), this._vrDisplayEnabled && this._vrDisplayEnabled.isPresenting && this._vrDisplayEnabled.submitFrame()
		}, s.prototype.resize = function() {
			var t = navigator.isCocoonJS ? window.innerWidth : this._renderingCanvas.clientWidth,
				i = navigator.isCocoonJS ? window.innerHeight : this._renderingCanvas.clientHeight;
			this.setSize(t / this._hardwareScalingLevel, i / this._hardwareScalingLevel);
			for (var r = 0; r < this.scenes.length; r++) {
				var n = this.scenes[r];
				e.DebugLayer && n.debugLayer.isVisible() && n.debugLayer._syncPositions()
			}
		}, s.prototype.setSize = function(e, t) {
			this._renderingCanvas.width = e, this._renderingCanvas.height = t;
			for (var i = 0; i < this.scenes.length; i++)
				for (var r = this.scenes[i], n = 0; n < r.cameras.length; n++) {
					var o = r.cameras[n];
					o._currentRenderId = 0
				}
		}, s.prototype.initWebVR = function() {
			this.vrDisplaysPromise || this._getVRDisplays()
		}, s.prototype.enableVR = function(e) {
			this._vrDisplayEnabled = e, this._vrDisplayEnabled.requestPresent([{
				source: this.getRenderingCanvas()
			}]).then(this._onVRFullScreenTriggered)
		}, s.prototype.disableVR = function() {
			this._vrDisplayEnabled && this._vrDisplayEnabled.exitPresent().then(this._onVRFullScreenTriggered)
		}, s.prototype._getVRDisplays = function() {
			var e = this,
				t = function(t) {
					var i = (t.length, 0);
					return e._vrDisplays = t.filter((function(e) {
						return t[i] instanceof VRDisplay
					})), e._vrDisplays
				};
			navigator.getVRDisplays && (this.vrDisplaysPromise = navigator.getVRDisplays().then(t))
		}, s.prototype.bindFramebuffer = function(e, t, i, r) {
			this._currentRenderTarget = e, this.bindUnboundFramebuffer(e._framebuffer);
			var n = this._gl;
			e.isCube && n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + t, e, 0), n.viewport(0, 0, i || e._width, r || e._height), this.wipeCaches()
		}, s.prototype.bindUnboundFramebuffer = function(e) {
			this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e)
		}, s.prototype.unBindFramebuffer = function(e, t) {
			if (void 0 === t && (t = !1), this._currentRenderTarget = null, e.generateMipMaps && !t) {
				var i = this._gl;
				this._bindTextureDirectly(i.TEXTURE_2D, e), i.generateMipmap(i.TEXTURE_2D), this._bindTextureDirectly(i.TEXTURE_2D, null)
			}
			this.bindUnboundFramebuffer(null)
		}, s.prototype.generateMipMapsForCubemap = function(e) {
			if (e.generateMipMaps) {
				var t = this._gl;
				this._bindTextureDirectly(t.TEXTURE_CUBE_MAP, e), t.generateMipmap(t.TEXTURE_CUBE_MAP), this._bindTextureDirectly(t.TEXTURE_CUBE_MAP, null)
			}
		}, s.prototype.flushFramebuffer = function() {
			this._gl.flush()
		}, s.prototype.restoreDefaultFramebuffer = function() {
			this._currentRenderTarget = null, this.bindUnboundFramebuffer(null), this.setViewport(this._cachedViewport), this.wipeCaches()
		}, s.prototype._resetVertexBufferBinding = function() {
			this.bindArrayBuffer(null), this._cachedVertexBuffers = null
		}, s.prototype.createVertexBuffer = function(e) {
			var t = this._gl.createBuffer();
			return this.bindArrayBuffer(t), e instanceof Float32Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), this._gl.STATIC_DRAW), this._resetVertexBufferBinding(), t.references = 1, t
		}, s.prototype.createDynamicVertexBuffer = function(e) {
			var t = this._gl.createBuffer();
			return this.bindArrayBuffer(t), e instanceof Float32Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), this._gl.DYNAMIC_DRAW), this._resetVertexBufferBinding(), t.references = 1, t
		}, s.prototype.updateDynamicVertexBuffer = function(e, t, i, r) {
			this.bindArrayBuffer(e), void 0 === i && (i = 0), void 0 === r ? t instanceof Float32Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, t) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, new Float32Array(t)) : t instanceof Float32Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t.subarray(i, i + r)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(t).subarray(i, i + r)), this._resetVertexBufferBinding()
		}, s.prototype._resetIndexBufferBinding = function() {
			this.bindIndexBuffer(null), this._cachedIndexBuffer = null
		}, s.prototype.createIndexBuffer = function(e) {
			var t = this._gl.createBuffer();
			this.bindIndexBuffer(t);
			var i, r = !1;
			if (this._caps.uintIndices) {
				for (var n = 0; n < e.length; n++)
					if (e[n] > 65535) {
						r = !0;
						break
					}
				i = r ? new Uint32Array(e) : new Uint16Array(e)
			} else i = new Uint16Array(e);
			return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, i, this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), t.references = 1, t.is32Bits = r, t
		}, s.prototype.bindArrayBuffer = function(e) {
			this.bindBuffer(e, this._gl.ARRAY_BUFFER)
		}, s.prototype.bindIndexBuffer = function(e) {
			this.bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER)
		}, s.prototype.bindBuffer = function(e, t) {
			this._currentBoundBuffer[t] !== e && (this._gl.bindBuffer(t, e), this._currentBoundBuffer[t] = e)
		}, s.prototype.updateArrayBuffer = function(e) {
			this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)
		}, s.prototype.vertexAttribPointer = function(e, t, i, r, n, o, s) {
			var a = this._currentBufferPointers[t],
				h = !1;
			a ? (a.buffer !== e && (a.buffer = e, h = !0), a.size !== i && (a.size = i, h = !0), a.type !== r && (a.type = r, h = !0), a.normalized !== n && (a.normalized = n, h = !0), a.stride !== o && (a.stride = o, h = !0), a.offset !== s && (a.offset = s, h = !0)) : (h = !0, this._currentBufferPointers[t] = {
				indx: t,
				size: i,
				type: r,
				normalized: n,
				stride: o,
				offset: s,
				buffer: e
			}), h && (this.bindArrayBuffer(e), this._gl.vertexAttribPointer(t, i, r, n, o, s))
		}, s.prototype.bindBuffersDirectly = function(e, t, i, r, n) {
			if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== n) {
				this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = n;
				for (var o = n.getAttributesCount(), s = 0, a = 0; a < o; a++)
					if (a < i.length) {
						var h = n.getAttributeLocation(a);
						h >= 0 && (this._vertexAttribArraysEnabled[h] || (this._gl.enableVertexAttribArray(h), this._vertexAttribArraysEnabled[h] = !0), this.vertexAttribPointer(e, h, i[a], this._gl.FLOAT, !1, r, s)), s += 4 * i[a]
					} else {
						var h = n.getAttributeLocation(a);
						this._vertexAttribArraysEnabled[h] && (this._gl.disableVertexAttribArray(h),
							this._vertexAttribArraysEnabled[h] = !1)
					}
			}
			this._cachedIndexBuffer !== t && (this._cachedIndexBuffer = t, this.bindIndexBuffer(t), this._uintIndicesCurrentlySet = t.is32Bits)
		}, s.prototype.bindBuffers = function(e, t, i) {
			if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== i) {
				this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = i;
				for (var r = i.getAttributesNames(), n = 0; n < r.length; n++) {
					var o = i.getAttributeLocation(n);
					if (o >= 0) {
						var s = e[r[n]];
						if (!s) {
							this._vertexAttribArraysEnabled[o] && (this._gl.disableVertexAttribArray(o), this._vertexAttribArraysEnabled[o] = !1);
							continue
						}
						this._vertexAttribArraysEnabled[o] || (this._gl.enableVertexAttribArray(o), this._vertexAttribArraysEnabled[o] = !0);
						var a = s.getBuffer();
						this.vertexAttribPointer(a, o, s.getSize(), this._gl.FLOAT, !1, 4 * s.getStrideSize(), 4 * s.getOffset()), s.getIsInstanced() && (this._caps.instancedArrays.vertexAttribDivisorANGLE(o, 1), this._currentInstanceLocations.push(o), this._currentInstanceBuffers.push(a))
					}
				}
			}
			null != t && this._cachedIndexBuffer !== t && (this._cachedIndexBuffer = t, this.bindIndexBuffer(t), this._uintIndicesCurrentlySet = t.is32Bits)
		}, s.prototype.unbindInstanceAttributes = function() {
			for (var e, t = 0, i = this._currentInstanceLocations.length; t < i; t++) {
				var r = this._currentInstanceBuffers[t];
				e != r && (e = r, this.bindArrayBuffer(r));
				var n = this._currentInstanceLocations[t];
				this._caps.instancedArrays.vertexAttribDivisorANGLE(n, 0)
			}
			this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0
		}, s.prototype._releaseBuffer = function(e) {
			return e.references--, 0 === e.references && (this._gl.deleteBuffer(e), !0)
		}, s.prototype.createInstancesBuffer = function(e) {
			var t = this._gl.createBuffer();
			return t.capacity = e, this.bindArrayBuffer(t), this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), t
		}, s.prototype.deleteInstancesBuffer = function(e) {
			this._gl.deleteBuffer(e)
		}, s.prototype.updateAndBindInstancesBuffer = function(e, t, i) {
			if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), void 0 !== i[0].index) {
				for (var r = 0, n = 0; n < i.length; n++) {
					var o = i[n];
					r += 4 * o.attributeSize
				}
				for (var n = 0; n < i.length; n++) {
					var o = i[n];
					this._vertexAttribArraysEnabled[o.index] || (this._gl.enableVertexAttribArray(o.index), this._vertexAttribArraysEnabled[o.index] = !0), this.vertexAttribPointer(e, o.index, o.attributeSize, o.attribyteType || this._gl.FLOAT, o.normalized || !1, r, o.offset), this._caps.instancedArrays.vertexAttribDivisorANGLE(o.index, 1), this._currentInstanceLocations.push(o.index), this._currentInstanceBuffers.push(e)
				}
			} else
				for (var s = 0; s < 4; s++) {
					var a = i[s];
					this._vertexAttribArraysEnabled[a] || (this._gl.enableVertexAttribArray(a), this._vertexAttribArraysEnabled[a] = !0), this.vertexAttribPointer(e, a, 4, this._gl.FLOAT, !1, 64, 16 * s), this._caps.instancedArrays.vertexAttribDivisorANGLE(a, 1), this._currentInstanceLocations.push(a), this._currentInstanceBuffers.push(e)
				}
		}, s.prototype.applyStates = function() {
			this._depthCullingState.apply(this._gl), this._stencilState.apply(this._gl), this._alphaState.apply(this._gl)
		}, s.prototype.draw = function(e, t, i, r) {
			this.applyStates(), this._drawCalls.addCount(1, !1);
			var n = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT,
				o = this._uintIndicesCurrentlySet ? 4 : 2;
			return r ? void this._caps.instancedArrays.drawElementsInstancedANGLE(e ? this._gl.TRIANGLES : this._gl.LINES, i, n, t * o, r) : void this._gl.drawElements(e ? this._gl.TRIANGLES : this._gl.LINES, i, n, t * o)
		}, s.prototype.drawPointClouds = function(e, t, i) {
			return this.applyStates(), this._drawCalls.addCount(1, !1), i ? void this._caps.instancedArrays.drawArraysInstancedANGLE(this._gl.POINTS, e, t, i) : void this._gl.drawArrays(this._gl.POINTS, e, t)
		}, s.prototype.drawUnIndexed = function(e, t, i, r) {
			return this.applyStates(), this._drawCalls.addCount(1, !1), r ? void this._caps.instancedArrays.drawArraysInstancedANGLE(e ? this._gl.TRIANGLES : this._gl.LINES, t, i, r) : void this._gl.drawArrays(e ? this._gl.TRIANGLES : this._gl.LINES, t, i)
		}, s.prototype._releaseEffect = function(e) {
			this._compiledEffects[e._key] && (delete this._compiledEffects[e._key], e.getProgram() && this._gl.deleteProgram(e.getProgram()))
		}, s.prototype.createEffect = function(t, i, r, n, o, s, a, h, c) {
			var l = t.vertexElement || t.vertex || t,
				u = t.fragmentElement || t.fragment || t,
				d = l + "+" + u + "@" + o;
			if (this._compiledEffects[d]) return this._compiledEffects[d];
			var f = new e.Effect(t, i, r, n, this, o, s, a, h, c);
			return f._key = d, this._compiledEffects[d] = f, f
		}, s.prototype.createEffectForParticles = function(e, t, i, r, n, o, s) {
			return void 0 === t && (t = []), void 0 === i && (i = []), void 0 === r && (r = ""), this.createEffect({
				vertex: "particles",
				fragmentElement: e
			}, ["position", "color", "options"], ["view", "projection"].concat(t), ["diffuseSampler"].concat(i), r, n, o, s)
		}, s.prototype.createShaderProgram = function(e, i, r, n) {
			n = n || this._gl;
			var o = t(n, e, "vertex", r),
				s = t(n, i, "fragment", r),
				a = n.createProgram();
			n.attachShader(a, o), n.attachShader(a, s), n.linkProgram(a);
			var h = n.getProgramParameter(a, n.LINK_STATUS);
			if (!h) {
				var c = n.getProgramInfoLog(a);
				if (c) throw new Error(c)
			}
			return n.deleteShader(o), n.deleteShader(s), a
		}, s.prototype.getUniforms = function(e, t) {
			for (var i = [], r = 0; r < t.length; r++) i.push(this._gl.getUniformLocation(e, t[r]));
			return i
		}, s.prototype.getAttributes = function(e, t) {
			for (var i = [], r = 0; r < t.length; r++) try {
				i.push(this._gl.getAttribLocation(e, t[r]))
			} catch (n) {
				i.push(-1)
			}
			return i
		}, s.prototype.enableEffect = function(e) {
			this.setProgram(e.getProgram()), this._currentEffect = e, e.onBind && e.onBind(e)
		}, s.prototype.setIntArray = function(e, t) {
			e && this._gl.uniform1iv(e, t)
		}, s.prototype.setIntArray2 = function(e, t) {
			e && t.length % 2 === 0 && this._gl.uniform2iv(e, t)
		}, s.prototype.setIntArray3 = function(e, t) {
			e && t.length % 3 === 0 && this._gl.uniform3iv(e, t)
		}, s.prototype.setIntArray4 = function(e, t) {
			e && t.length % 4 === 0 && this._gl.uniform4iv(e, t)
		}, s.prototype.setFloatArray = function(e, t) {
			e && this._gl.uniform1fv(e, t)
		}, s.prototype.setFloatArray2 = function(e, t) {
			e && t.length % 2 === 0 && this._gl.uniform2fv(e, t)
		}, s.prototype.setFloatArray3 = function(e, t) {
			e && t.length % 3 === 0 && this._gl.uniform3fv(e, t)
		}, s.prototype.setFloatArray4 = function(e, t) {
			e && t.length % 4 === 0 && this._gl.uniform4fv(e, t)
		}, s.prototype.setArray = function(e, t) {
			e && this._gl.uniform1fv(e, t)
		}, s.prototype.setArray2 = function(e, t) {
			e && t.length % 2 === 0 && this._gl.uniform2fv(e, t)
		}, s.prototype.setArray3 = function(e, t) {
			e && t.length % 3 === 0 && this._gl.uniform3fv(e, t)
		}, s.prototype.setArray4 = function(e, t) {
			e && t.length % 4 === 0 && this._gl.uniform4fv(e, t)
		}, s.prototype.setMatrices = function(e, t) {
			e && this._gl.uniformMatrix4fv(e, !1, t)
		}, s.prototype.setMatrix = function(e, t) {
			e && this._gl.uniformMatrix4fv(e, !1, t.toArray())
		}, s.prototype.setMatrix3x3 = function(e, t) {
			e && this._gl.uniformMatrix3fv(e, !1, t)
		}, s.prototype.setMatrix2x2 = function(e, t) {
			e && this._gl.uniformMatrix2fv(e, !1, t)
		}, s.prototype.setFloat = function(e, t) {
			e && this._gl.uniform1f(e, t)
		}, s.prototype.setFloat2 = function(e, t, i) {
			e && this._gl.uniform2f(e, t, i)
		}, s.prototype.setFloat3 = function(e, t, i, r) {
			e && this._gl.uniform3f(e, t, i, r)
		}, s.prototype.setBool = function(e, t) {
			e && this._gl.uniform1i(e, t)
		}, s.prototype.setFloat4 = function(e, t, i, r, n) {
			e && this._gl.uniform4f(e, t, i, r, n)
		}, s.prototype.setColor3 = function(e, t) {
			e && this._gl.uniform3f(e, t.r, t.g, t.b)
		}, s.prototype.setColor4 = function(e, t, i) {
			e && this._gl.uniform4f(e, t.r, t.g, t.b, i)
		}, s.prototype.setState = function(e, t, i, r) {
			void 0 === t && (t = 0), void 0 === r && (r = !1);
			var n = r ? this._gl.FRONT : this._gl.BACK,
				o = r ? this._gl.BACK : this._gl.FRONT,
				s = this.cullBackFaces ? n : o;
			(this._depthCullingState.cull !== e || i || this._depthCullingState.cullFace !== s) && (e ? (this._depthCullingState.cullFace = s, this._depthCullingState.cull = !0) : this._depthCullingState.cull = !1), this._depthCullingState.zOffset = t
		}, s.prototype.setDepthBuffer = function(e) {
			this._depthCullingState.depthTest = e
		}, s.prototype.getDepthWrite = function() {
			return this._depthCullingState.depthMask
		}, s.prototype.setDepthWrite = function(e) {
			this._depthCullingState.depthMask = e
		}, s.prototype.setColorWrite = function(e) {
			this._gl.colorMask(e, e, e, e)
		}, s.prototype.setAlphaMode = function(e, t) {
			if (void 0 === t && (t = !1), this._alphaMode !== e) {
				switch (e) {
					case s.ALPHA_DISABLE:
						this._alphaState.alphaBlend = !1;
						break;
					case s.ALPHA_COMBINE:
						this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
						break;
					case s.ALPHA_ONEONE:
						this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
						break;
					case s.ALPHA_ADD:
						this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
						break;
					case s.ALPHA_SUBTRACT:
						this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
						break;
					case s.ALPHA_MULTIPLY:
						this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
						break;
					case s.ALPHA_MAXIMIZED:
						this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0
				}
				t || this.setDepthWrite(e === s.ALPHA_DISABLE), this._alphaMode = e
			}
		}, s.prototype.getAlphaMode = function() {
			return this._alphaMode
		}, s.prototype.setAlphaTesting = function(e) {
			this._alphaTest = e
		}, s.prototype.getAlphaTesting = function() {
			return this._alphaTest
		}, s.prototype.wipeCaches = function() {
			this.resetTextureCache(), this._currentEffect = null, this._stencilState.reset(), this._depthCullingState.reset(), this.setDepthFunctionToLessOrEqual(), this._alphaState.reset(), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null
		}, s.prototype.setSamplingMode = function(t, i) {
			var r = this._gl;
			this._bindTextureDirectly(r.TEXTURE_2D, t);
			var n = r.NEAREST,
				o = r.NEAREST;
			i === e.Texture.BILINEAR_SAMPLINGMODE ? (n = r.LINEAR, o = r.LINEAR) : i === e.Texture.TRILINEAR_SAMPLINGMODE && (n = r.LINEAR, o = r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, n), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, o), this._bindTextureDirectly(r.TEXTURE_2D, null), t.samplingMode = i
		}, s.prototype.setTextureFormatToUse = function(e) {
			for (var t = 0, i = this.texturesSupported.length; t < i; t++)
				if (".astc" !== this._texturesSupported[t] && ".pvr" !== this._texturesSupported[t] && ".etc1" !== this._texturesSupported[t] && ".etc2" !== this._texturesSupported[t])
					for (var r = 0, n = e.length; r < n; r++)
						if (this._texturesSupported[t] === e[r].toLowerCase()) return this._textureFormatInUse = this._texturesSupported[t];
			return this._textureFormatInUse = null
		}, s.prototype.createTexture = function(t, i, r, n, s, a, h, c) {
			var l = this;
			void 0 === s && (s = e.Texture.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = null), void 0 === h && (h = null), void 0 === c && (c = null);
			var u, d = this._gl.createTexture(),
				f = !1;
			if ("data:" === t.substr(0, 5) && (f = !0), f) {
				var p = t;
				f = p.split(":"), t = p, u = f[1].substr(f[1].length - 4, 4).toLowerCase()
			} else {
				var m = t.lastIndexOf(".");
				u = t.substring(m).toLowerCase(), !this._textureFormatInUse || f || n.database || (u = this._textureFormatInUse, t = t.substring(0, m) + this._textureFormatInUse)
			}
			var _ = ".dds" === u,
				g = ".tga" === u;
			n._addPendingData(d), d.url = t, d.noMipmap = i, d.references = 1, d.samplingMode = s, d.onLoadedCallbacks = [a], this._loadedTexturesCache.push(d);
			var v, y = function() {
				n._removePendingData(d), h && h()
			};
			if (g) v = function(t) {
				var a = new Uint8Array(t),
					h = e.Internals.TGATools.GetTGAHeader(a);
				o(d, l._gl, n, h.width, h.height, r, i, !1, (function() {
					e.Internals.TGATools.UploadContent(l._gl, a)
				}), s)
			}, f instanceof Array ? v(c) : e.Tools.LoadFile(t, (function(e) {
				v(e)
			}), null, n.database, !0, y);
			else if (_) v = function(t) {
				var a = e.Internals.DDSTools.GetDDSInfo(t),
					h = (a.isRGB || a.isLuminance || a.mipmapCount > 1) && !i && a.width >> a.mipmapCount - 1 === 1;
				o(d, l._gl, n, a.width, a.height, r, !h, a.isFourCC, (function() {
					e.Internals.DDSTools.UploadDDSLevels(l._gl, l.getCaps().s3tc, t, a, h, 1)
				}), s)
			}, f instanceof Array ? v(c) : e.Tools.LoadFile(t, (function(e) {
				v(e)
			}), null, n.database, !0, y);
			else {
				var x = function(t) {
					o(d, l._gl, n, t.width, t.height, r, i, !1, (function(i, r) {
						var n = t.width === i && t.height === r;
						n || (l._prepareWorkingCanvas(), l._workingCanvas.width = i, l._workingCanvas.height = r, s === e.Texture.NEAREST_SAMPLINGMODE && (l._workingContext.imageSmoothingEnabled = !1, l._workingContext.mozImageSmoothingEnabled = !1, l._workingContext.oImageSmoothingEnabled = !1, l._workingContext.webkitImageSmoothingEnabled = !1, l._workingContext.msImageSmoothingEnabled = !1), l._workingContext.drawImage(t, 0, 0, t.width, t.height, 0, 0, i, r), s === e.Texture.NEAREST_SAMPLINGMODE && (l._workingContext.imageSmoothingEnabled = !0, l._workingContext.mozImageSmoothingEnabled = !0, l._workingContext.oImageSmoothingEnabled = !0, l._workingContext.webkitImageSmoothingEnabled = !0, l._workingContext.msImageSmoothingEnabled = !0)), l._gl.texImage2D(l._gl.TEXTURE_2D, 0, l._gl.RGBA, l._gl.RGBA, l._gl.UNSIGNED_BYTE, n ? t : l._workingCanvas)
					}), s)
				};
				f instanceof Array ? e.Tools.LoadImage(c, x, y, n.database) : e.Tools.LoadImage(t, x, y, n.database)
			}
			return d
		}, s.prototype._getInternalFormat = function(e) {
			var t = this._gl.RGBA;
			switch (e) {
				case s.TEXTUREFORMAT_ALPHA:
					t = this._gl.ALPHA;
					break;
				case s.TEXTUREFORMAT_LUMINANCE:
					t = this._gl.LUMINANCE;
					break;
				case s.TEXTUREFORMAT_LUMINANCE_ALPHA:
					t = this._gl.LUMINANCE_ALPHA;
					break;
				case s.TEXTUREFORMAT_RGB:
					t = this._gl.RGB;
					break;
				case s.TEXTUREFORMAT_RGBA:
					t = this._gl.RGBA
			}
			return t
		}, s.prototype.updateRawTexture = function(e, t, i, r, n) {
			void 0 === n && (n = null);
			var o = this._getInternalFormat(i);
			this._bindTextureDirectly(this._gl.TEXTURE_2D, e), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, void 0 === r ? 1 : r ? 1 : 0), e._width % 4 !== 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1), n ? this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[n], e._width, e._height, 0, t) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, o, e._width, e._height, 0, o, this._gl.UNSIGNED_BYTE, t), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this.resetTextureCache(), e.isReady = !0
		}, s.prototype.createRawTexture = function(e, t, i, r, o, s, a, h) {
			void 0 === h && (h = null);
			var c = this._gl.createTexture();
			c._baseWidth = t, c._baseHeight = i, c._width = t, c._height = i, c.references = 1, this.updateRawTexture(c, e, r, s, h), this._bindTextureDirectly(this._gl.TEXTURE_2D, c);
			var l = n(a, o, this._gl);
			return this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, l.mag), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, l.min), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), c.samplingMode = a, this._loadedTexturesCache.push(c), c
		}, s.prototype.createDynamicTexture = function(t, i, r, n) {
			var o = this._gl.createTexture();
			return o._baseWidth = t, o._baseHeight = i, r && (t = e.Tools.GetExponentOfTwo(t, this._caps.maxTextureSize), i = e.Tools.GetExponentOfTwo(i, this._caps.maxTextureSize)), this.resetTextureCache(), o._width = t, o._height = i, o.isReady = !1, o.generateMipMaps = r, o.references = 1, o.samplingMode = n, this.updateTextureSamplingMode(n, o), this._loadedTexturesCache.push(o), o
		}, s.prototype.updateTextureSamplingMode = function(e, t) {
			var i = n(e, t.generateMipMaps, this._gl);
			t.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, t), this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MAG_FILTER, i.mag), this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MIN_FILTER, i.min), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, t), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, i.mag), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, i.min), this._bindTextureDirectly(this._gl.TEXTURE_2D, null))
		}, s.prototype.updateDynamicTexture = function(e, t, i, r) {
			void 0 === r && (r = !1), this._bindTextureDirectly(this._gl.TEXTURE_2D, e), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, i ? 1 : 0), r && this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, t), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), r && this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), this.resetTextureCache(), e.isReady = !0
		}, s.prototype.updateVideoTexture = function(e, t, i) {
			if (!e._isDisabled) {
				this._bindTextureDirectly(this._gl.TEXTURE_2D, e), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, i ? 0 : 1);
				try {
					void 0 === this._videoTextureSupported && (this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, t), 0 !== this._gl.getError() ? this._videoTextureSupported = !1 : this._videoTextureSupported = !0), this._videoTextureSupported ? this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, t) : (e._workingCanvas || (e._workingCanvas = document.createElement("canvas"), e._workingContext = e._workingCanvas.getContext("2d"), e._workingCanvas.width = e._width, e._workingCanvas.height = e._height), e._workingContext.drawImage(t, 0, 0, t.videoWidth, t.videoHeight, 0, 0, e._width, e._height), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, e._workingCanvas)), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this.resetTextureCache(), e.isReady = !0
				} catch (r) {
					e._isDisabled = !0
				}
			}
		}, s.prototype.createRenderTargetTexture = function(t, i) {
			var o = !1,
				a = !0,
				h = !1,
				c = s.TEXTURETYPE_UNSIGNED_INT,
				l = e.Texture.TRILINEAR_SAMPLINGMODE;
			void 0 !== i && (o = void 0 === i.generateMipMaps ? i : i.generateMipMaps, a = void 0 === i.generateDepthBuffer || i.generateDepthBuffer, h = a && i.generateStencilBuffer, c = void 0 === i.type ? c : i.type, void 0 !== i.samplingMode && (l = i.samplingMode), c !== s.TEXTURETYPE_FLOAT || this._caps.textureFloatLinearFiltering ? c !== s.TEXTURETYPE_HALF_FLOAT || this._caps.textureHalfFloatLinearFiltering || (l = e.Texture.NEAREST_SAMPLINGMODE) : l = e.Texture.NEAREST_SAMPLINGMODE);
			var u = this._gl,
				d = u.createTexture();
			this._bindTextureDirectly(u.TEXTURE_2D, d);
			var f = t.width || t,
				p = t.height || t,
				m = n(l, o, u);
			c !== s.TEXTURETYPE_FLOAT || this._caps.textureFloat || (c = s.TEXTURETYPE_UNSIGNED_INT, e.Tools.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type")), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, m.mag), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, m.min), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, f, p, 0, u.RGBA, r(u, c), null);
			var _;
			h ? (_ = u.createRenderbuffer(), u.bindRenderbuffer(u.RENDERBUFFER, _), u.renderbufferStorage(u.RENDERBUFFER, u.DEPTH_STENCIL, f, p)) : a && (_ = u.createRenderbuffer(), u.bindRenderbuffer(u.RENDERBUFFER, _), u.renderbufferStorage(u.RENDERBUFFER, u.DEPTH_COMPONENT16, f, p));
			var g = u.createFramebuffer();
			return this.bindUnboundFramebuffer(g), h ? u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.RENDERBUFFER, _) : a && u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.RENDERBUFFER, _), u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, d, 0), o && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(u.TEXTURE_2D, null), u.bindRenderbuffer(u.RENDERBUFFER, null), this.bindUnboundFramebuffer(null), d._framebuffer = g, a && (d._depthBuffer = _), d._baseWidth = f, d._baseHeight = p, d._width = f, d._height = p, d.isReady = !0, d.generateMipMaps = o, d.references = 1, d.samplingMode = l, d.type = c, this.resetTextureCache(), this._loadedTexturesCache.push(d), d
		}, s.prototype.createRenderTargetCubeTexture = function(t, i) {
			var r = this._gl,
				o = r.createTexture(),
				s = !0,
				a = !0,
				h = !1,
				c = e.Texture.TRILINEAR_SAMPLINGMODE;
			void 0 !== i && (s = void 0 === i.generateMipMaps ? i : i.generateMipMaps, a = void 0 === i.generateDepthBuffer || i.generateDepthBuffer, h = a && i.generateStencilBuffer, void 0 !== i.samplingMode && (c = i.samplingMode)), o.isCube = !0, o.references = 1, o.generateMipMaps = s, o.references = 1, o.samplingMode = c;
			var l = n(c, s, r);
			this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, o);
			for (var u = 0; u < 6; u++) r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + u, 0, r.RGBA, t, t, 0, r.RGBA, r.UNSIGNED_BYTE, null);
			r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, l.mag), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, l.min), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE);
			var d;
			h ? (d = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, d), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t, t)) : a && (d = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, d), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_COMPONENT16, t, t));
			var f = r.createFramebuffer();
			return this.bindUnboundFramebuffer(f), h ? r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, d) : a && r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, d), o.generateMipMaps && (this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, o), r.generateMipmap(r.TEXTURE_CUBE_MAP)), this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, null), r.bindRenderbuffer(r.RENDERBUFFER, null), this.bindUnboundFramebuffer(null), o._framebuffer = f, a && (o._depthBuffer = d), o._width = t, o._height = t, o.isReady = !0, this.resetTextureCache(), this._loadedTexturesCache.push(o), o
		}, s.prototype.createCubeTexture = function(t, i, r, n, o, s) {
			var h = this;
			void 0 === o && (o = null), void 0 === s && (s = null);
			var c = this._gl,
				l = c.createTexture();
			l.isCube = !0, l.url = t, l.references = 1, l.onLoadedCallbacks = [];
			var u = t.substr(t.length - 4, 4).toLowerCase(),
				d = this.getCaps().s3tc && ".dds" === u;
			return d ? e.Tools.LoadFile(t, (function(t) {
				var i = e.Internals.DDSTools.GetDDSInfo(t),
					r = (i.isRGB || i.isLuminance || i.mipmapCount > 1) && !n;
				h._bindTextureDirectly(c.TEXTURE_CUBE_MAP, l), c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, 1), e.Internals.DDSTools.UploadDDSLevels(h._gl, h.getCaps().s3tc, t, i, r, 6), n || i.isFourCC || 1 !== i.mipmapCount || c.generateMipmap(c.TEXTURE_CUBE_MAP), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_MIN_FILTER, r ? c.LINEAR_MIPMAP_LINEAR : c.LINEAR), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), h._bindTextureDirectly(c.TEXTURE_CUBE_MAP, null), h.resetTextureCache(), l._width = i.width, l._height = i.height, l.isReady = !0
			}), null, null, !0, s) : a(t, i, (function(t) {
				var i = e.Tools.GetExponentOfTwo(t[0].width, h._caps.maxCubemapTextureSize),
					r = i;
				h._prepareWorkingCanvas(), h._workingCanvas.width = i, h._workingCanvas.height = r;
				var s = [c.TEXTURE_CUBE_MAP_POSITIVE_X, c.TEXTURE_CUBE_MAP_POSITIVE_Y, c.TEXTURE_CUBE_MAP_POSITIVE_Z, c.TEXTURE_CUBE_MAP_NEGATIVE_X, c.TEXTURE_CUBE_MAP_NEGATIVE_Y, c.TEXTURE_CUBE_MAP_NEGATIVE_Z];
				h._bindTextureDirectly(c.TEXTURE_CUBE_MAP, l), c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, 0);
				for (var a = 0; a < s.length; a++) h._workingContext.drawImage(t[a], 0, 0, t[a].width, t[a].height, 0, 0, i, r), c.texImage2D(s[a], 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, h._workingCanvas);
				n || c.generateMipmap(c.TEXTURE_CUBE_MAP), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_MIN_FILTER, n ? c.LINEAR : c.LINEAR_MIPMAP_LINEAR), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_CUBE_MAP, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), h._bindTextureDirectly(c.TEXTURE_CUBE_MAP, null), h.resetTextureCache(), l._width = i, l._height = r, l.isReady = !0, l.onLoadedCallbacks.forEach((function(e) {
					e()
				})), o && o()
			}), r, s), this._loadedTexturesCache.push(l), l
		}, s.prototype.updateTextureSize = function(e, t, i) {
			e._width = t, e._height = i, e._size = t * i, e._baseWidth = t, e._baseHeight = i
		}, s.prototype.createRawCubeTexture = function(t, r, n, o, a, h, c, l) {
			var u = this,
				d = this._gl,
				f = d.createTexture();
			r._addPendingData(f), f.isCube = !0, f.references = 1, f.url = t;
			var p = this._getInternalFormat(o),
				m = d.UNSIGNED_BYTE;
			a === s.TEXTURETYPE_FLOAT && (m = d.FLOAT);
			var _ = n,
				g = _,
				v = e.Tools.IsExponentOfTwo(_) && e.Tools.IsExponentOfTwo(g);
			f._width = _, f._height = g;
			var y = function() {
					r._removePendingData(f)
				},
				x = function(t) {
					var n = c(t),
						o = [d.TEXTURE_CUBE_MAP_POSITIVE_X, d.TEXTURE_CUBE_MAP_POSITIVE_Y, d.TEXTURE_CUBE_MAP_POSITIVE_Z, d.TEXTURE_CUBE_MAP_NEGATIVE_X, d.TEXTURE_CUBE_MAP_NEGATIVE_Y, d.TEXTURE_CUBE_MAP_NEGATIVE_Z];
					if (_ = f._width, g = f._height, v = e.Tools.IsExponentOfTwo(_) && e.Tools.IsExponentOfTwo(g), u._bindTextureDirectly(d.TEXTURE_CUBE_MAP, f), d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL, 0), !h && v)
						if (l) {
							var s = [];
							s.push(n[0]), s.push(n[3]), s.push(n[1]), s.push(n[4]), s.push(n[2]), s.push(n[5]);
							for (var a = l(s), y = 0; y < a.length; y++) {
								var x = _ >> y;
								d.texImage2D(o[0], y, p, x, x, 0, p, m, a[y][0]), d.texImage2D(o[1], y, p, x, x, 0, p, m, a[y][2]), d.texImage2D(o[2], y, p, x, x, 0, p, m, a[y][4]), d.texImage2D(o[3], y, p, x, x, 0, p, m, a[y][1]), d.texImage2D(o[4], y, p, x, x, 0, p, m, a[y][3]), d.texImage2D(o[5], y, p, x, x, 0, p, m, a[y][5])
							}
						} else {
							for (var b = 0; b < o.length; b++) {
								var T = n[b];
								d.texImage2D(o[b], 0, p, _, g, 0, p, m, T)
							}
							if (d.generateMipmap(d.TEXTURE_CUBE_MAP), m === d.FLOAT && p === d.RGB && 1282 === d.getError()) {
								e.Tools.Log("RGB32F not renderable on Firefox, trying fallback to RGBA32F.");
								for (var b = 0; b < o.length; b++) {
									for (var T = n[b], A = new Float32Array(_ * g * 4), E = 0; E < _; E++)
										for (var P = 0; P < g; P++) {
											var M = 3 * (P * _ + E),
												S = 4 * (P * _ + E);
											A[S + 0] = T[M + 0], A[S + 1] = T[M + 1], A[S + 2] = T[M + 2], A[S + 3] = 1
										}
									d.texImage2D(o[b], 0, d.RGBA, _, g, 0, d.RGBA, m, A)
								}
								d.generateMipmap(d.TEXTURE_CUBE_MAP)
							}
						}
					else h = !0;
					(m !== d.FLOAT || u._caps.textureFloatLinearFiltering) && (m !== i || u._caps.textureHalfFloatLinearFiltering) ? (d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MAG_FILTER, d.LINEAR), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MIN_FILTER, h ? d.LINEAR : d.LINEAR_MIPMAP_LINEAR)) : (d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MAG_FILTER, d.NEAREST), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_MIN_FILTER, d.NEAREST)), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_CUBE_MAP, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), u._bindTextureDirectly(d.TEXTURE_CUBE_MAP, null), f.isReady = !0, u.resetTextureCache(), r._removePendingData(f)
				};
			return e.Tools.LoadFile(t, (function(e) {
				x(e)
			}), y, r.database, !0), f
		}, s.prototype._releaseTexture = function(e) {
			var t = this._gl;
			e._framebuffer && t.deleteFramebuffer(e._framebuffer), e._depthBuffer && t.deleteRenderbuffer(e._depthBuffer), t.deleteTexture(e), this.unbindAllTextures();
			var i = this._loadedTexturesCache.indexOf(e);
			i !== -1 && this._loadedTexturesCache.splice(i, 1)
		}, s.prototype.setProgram = function(e) {
			this._currentProgram !== e && (this._gl.useProgram(e), this._currentProgram = e)
		}, s.prototype.bindSamplers = function(e) {
			this.setProgram(e.getProgram());
			for (var t = e.getSamplers(), i = 0; i < t.length; i++) {
				var r = e.getUniform(t[i]);
				this._gl.uniform1i(r, i)
			}
			this._currentEffect = null
		}, s.prototype.activateTexture = function(e) {
			this._activeTexture !== e && (this._gl.activeTexture(e), this._activeTexture = e)
		}, s.prototype._bindTextureDirectly = function(e, t) {
			this._activeTexturesCache[this._activeTexture] !== t && (this._gl.bindTexture(e, t), this._activeTexturesCache[this._activeTexture] = t)
		}, s.prototype._bindTexture = function(e, t) {
			e < 0 || (this.activateTexture(this._gl["TEXTURE" + e]), this._bindTextureDirectly(this._gl.TEXTURE_2D, t))
		}, s.prototype.setTextureFromPostProcess = function(e, t) {
			this._bindTexture(e, t._textures.data[t._currentRenderTextureInd])
		}, s.prototype.unbindAllTextures = function() {
			for (var e = 0; e < this._caps.maxTexturesImageUnits; e++) this.activateTexture(this._gl["TEXTURE" + e]), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)
		}, s.prototype.setTexture = function(e, t, i) {
			e < 0 || (this._gl.uniform1i(t, e), this._setTexture(e, i))
		}, s.prototype._setTexture = function(t, i) {
			if (!i || !i.isReady()) return void(null != this._activeTexturesCache[t] && (this.activateTexture(this._gl["TEXTURE" + t]), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)));
			var r = !1;
			if (i instanceof e.VideoTexture) this.activateTexture(this._gl["TEXTURE" + t]), r = !0, i.update();
			else if (i.delayLoadState === s.DELAYLOADSTATE_NOTLOADED) return void i.delayLoad();
			var n = i.getInternalTexture();
			if (this._activeTexturesCache[t] !== n)
				if (r || this.activateTexture(this._gl["TEXTURE" + t]), n.isCube) {
					if (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, n), n._cachedCoordinatesMode !== i.coordinatesMode) {
						n._cachedCoordinatesMode = i.coordinatesMode;
						var o = i.coordinatesMode !== e.Texture.CUBIC_MODE && i.coordinatesMode !== e.Texture.SKYBOX_MODE ? this._gl.REPEAT : this._gl.CLAMP_TO_EDGE;
						this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_S, o), this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_T, o)
					}
					this._setAnisotropicLevel(this._gl.TEXTURE_CUBE_MAP, i)
				} else {
					if (this._bindTextureDirectly(this._gl.TEXTURE_2D, n), n._cachedWrapU !== i.wrapU) switch (n._cachedWrapU = i.wrapU, i.wrapU) {
						case e.Texture.WRAP_ADDRESSMODE:
							this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT);
							break;
						case e.Texture.CLAMP_ADDRESSMODE:
							this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
							break;
						case e.Texture.MIRROR_ADDRESSMODE:
							this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.MIRRORED_REPEAT)
					}
					if (n._cachedWrapV !== i.wrapV) switch (n._cachedWrapV = i.wrapV, i.wrapV) {
						case e.Texture.WRAP_ADDRESSMODE:
							this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT);
							break;
						case e.Texture.CLAMP_ADDRESSMODE:
							this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
							break;
						case e.Texture.MIRROR_ADDRESSMODE:
							this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.MIRRORED_REPEAT)
					}
					this._setAnisotropicLevel(this._gl.TEXTURE_2D, i)
				}
		}, s.prototype.setTextureArray = function(e, t, i) {
			if (!(e < 0)) {
				this._textureUnits && this._textureUnits.length === i.length || (this._textureUnits = new Int32Array(i.length));
				for (var r = 0; r < i.length; r++) this._textureUnits[r] = e + r;
				this._gl.uniform1iv(t, this._textureUnits);
				for (var n = 0; n < i.length; n++) this._setTexture(e + n, i[n])
			}
		}, s.prototype._setAnisotropicLevel = function(t, i) {
			var r = this._caps.textureAnisotropicFilterExtension,
				n = i.anisotropicFilteringLevel;
			i.getInternalTexture().samplingMode === e.Texture.NEAREST_SAMPLINGMODE && (n = 1), r && i._cachedAnisotropicFilteringLevel !== n && (this._gl.texParameterf(t, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(n, this._caps.maxAnisotropy)), i._cachedAnisotropicFilteringLevel = n)
		}, s.prototype.readPixels = function(e, t, i, r) {
			var n = new Uint8Array(r * i * 4);
			return this._gl.readPixels(e, t, i, r, this._gl.RGBA, this._gl.UNSIGNED_BYTE, n), n
		}, s.prototype.addExternalData = function(e, t) {
			return this._externalData.add(e, t)
		}, s.prototype.getExternalData = function(e) {
			return this._externalData.get(e)
		}, s.prototype.getOrAddExternalDataWithFactory = function(e, t) {
			return this._externalData.getOrAddWithFactory(e, t)
		}, s.prototype.removeExternalData = function(e) {
			return this._externalData.remove(e)
		}, s.prototype.releaseInternalTexture = function(e) {
			if (e && (e.references--, 0 === e.references)) {
				var t = this.getLoadedTexturesCache(),
					i = t.indexOf(e);
				i > -1 && t.splice(i, 1), this._releaseTexture(e)
			}
		}, s.prototype.unbindAllAttributes = function() {
			for (var e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++) e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || (this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1)
		}, s.prototype.dispose = function() {
			for (this.hideLoadingUI(), this.stopRenderLoop(); this.scenes.length;) this.scenes[0].dispose();
			s.audioEngine.dispose();
			for (var e in this._compiledEffects) this._gl.deleteProgram(this._compiledEffects[e]._program);
			this.unbindAllAttributes(), this._gl = null, this.disableVR(), window.removeEventListener("blur", this._onBlur), window.removeEventListener("focus", this._onFocus), document.removeEventListener("fullscreenchange", this._onFullscreenChange), document.removeEventListener("mozfullscreenchange", this._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange), document.removeEventListener("msfullscreenchange", this._onFullscreenChange), document.removeEventListener("pointerlockchange", this._onPointerLockChange), document.removeEventListener("mspointerlockchange", this._onPointerLockChange), document.removeEventListener("mozpointerlockchange", this._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange)
		}, s.prototype.displayLoadingUI = function() {
			this._loadingScreen.displayLoadingUI()
		}, s.prototype.hideLoadingUI = function() {
			this._loadingScreen.hideLoadingUI()
		}, Object.defineProperty(s.prototype, "loadingScreen", {
			get: function() {
				return this._loadingScreen
			},
			set: function(e) {
				this._loadingScreen = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "loadingUIText", {
			set: function(e) {
				this._loadingScreen.loadingUIText = e;
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(s.prototype, "loadingUIBackgroundColor", {
			set: function(e) {
				this._loadingScreen.loadingUIBackgroundColor = e
			},
			enumerable: !0,
			configurable: !0
		}), s.prototype.attachContextLostEvent = function(e) {
			this._renderingCanvas.addEventListener("webglcontextlost", e, !1)
		}, s.prototype.attachContextRestoredEvent = function(e) {
			this._renderingCanvas.addEventListener("webglcontextrestored", e, !1)
		}, s.prototype.getVertexShaderSource = function(e) {
			var t = this._gl.getAttachedShaders(e);
			return this._gl.getShaderSource(t[0])
		}, s.prototype.getFragmentShaderSource = function(e) {
			var t = this._gl.getAttachedShaders(e);
			return this._gl.getShaderSource(t[1])
		}, s.prototype.getFps = function() {
			return this.fps
		}, s.prototype.getDeltaTime = function() {
			return this.deltaTime
		}, s.prototype._measureFps = function() {
			this.previousFramesDuration.push(e.Tools.Now);
			var t = this.previousFramesDuration.length;
			if (t >= 2 && (this.deltaTime = this.previousFramesDuration[t - 1] - this.previousFramesDuration[t - 2]), t >= this.fpsRange) {
				t > this.fpsRange && (this.previousFramesDuration.splice(0, 1), t = this.previousFramesDuration.length);
				for (var i = 0, r = 0; r < t - 1; r++) i += this.previousFramesDuration[r + 1] - this.previousFramesDuration[r];
				this.fps = 1e3 / (i / (t - 1))
			}
		}, s.prototype._canRenderToFloatTexture = function() {
			return this._canRenderToTextureOfType(e.Engine.TEXTURETYPE_FLOAT, "OES_texture_float")
		}, s.prototype._canRenderToHalfFloatTexture = function() {
			return this._canRenderToTextureOfType(e.Engine.TEXTURETYPE_HALF_FLOAT, "OES_texture_half_float")
		}, s.prototype._canRenderToTextureOfType = function(t, i) {
			var n = document.createElement("canvas");
			n.height = 16, n.width = 16;
			var o = n.getContext("webgl") || n.getContext("experimental-webgl"),
				s = o.getExtension(i);
			if (!s) return !1;
			var a = "attribute vec4 a_position;\n                void main() {\n                    gl_Position = a_position;\n                }",
				h = "precision mediump float;\n                uniform vec4 u_color;\n                uniform sampler2D u_texture;\n\n                void main() {\n                    gl_FragColor = texture2D(u_texture, vec2(0.5, 0.5)) * u_color;\n                }",
				c = this.createShaderProgram(a, h, null, o);
			o.useProgram(c);
			var l = o.getAttribLocation(c, "a_position"),
				u = o.getUniformLocation(c, "u_color"),
				d = o.createBuffer();
			o.bindBuffer(o.ARRAY_BUFFER, d), o.bufferData(o.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), o.STATIC_DRAW), o.enableVertexAttribArray(l), o.vertexAttribPointer(l, 2, o.FLOAT, !1, 0, 0);
			var f = o.createTexture();
			o.bindTexture(o.TEXTURE_2D, f), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, 1, 1, 0, o.RGBA, o.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));
			var p = o.createTexture();
			o.bindTexture(o.TEXTURE_2D, p), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, 1, 1, 0, o.RGBA, r(o, t), null), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST);
			var m = o.createFramebuffer();
			o.bindFramebuffer(o.FRAMEBUFFER, m), o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, p, 0);
			var _ = function() {
					o.deleteProgram(c), o.disableVertexAttribArray(l), o.deleteBuffer(d), o.deleteFramebuffer(m), o.deleteTexture(f), o.deleteTexture(p)
				},
				g = o.checkFramebufferStatus(o.FRAMEBUFFER);
			if (g !== o.FRAMEBUFFER_COMPLETE) return e.Tools.Log("GL Support: can **NOT** render to " + t + " texture"), _(), !1;
			o.bindTexture(o.TEXTURE_2D, f), o.uniform4fv(u, [0, 10, 20, 1]), o.drawArrays(o.TRIANGLES, 0, 6), o.bindTexture(o.TEXTURE_2D, p), o.bindFramebuffer(o.FRAMEBUFFER, null), o.clearColor(1, 0, 0, 1), o.clear(o.COLOR_BUFFER_BIT), o.uniform4fv(u, [0, .1, .05, 1]), o.drawArrays(o.TRIANGLES, 0, 6);
			var v = new Uint8Array(4);
			return o.readPixels(0, 0, 1, 1, o.RGBA, o.UNSIGNED_BYTE, v), 0 !== v[0] || v[1] < 248 || v[2] < 248 || v[3] < 254 ? (e.Tools.Log("GL Support: Was not able to actually render to " + t + " texture"), _(), !1) : (_(), !0)
		}, s.isSupported = function() {
			try {
				if (navigator.isCocoonJS) return !0;
				var e = document.createElement("canvas"),
					t = e.getContext("webgl") || e.getContext("experimental-webgl");
				return null != t && !!window.WebGLRenderingContext
			} catch (i) {
				return !1
			}
		}, s._ALPHA_DISABLE = 0, s._ALPHA_ADD = 1, s._ALPHA_COMBINE = 2, s._ALPHA_SUBTRACT = 3, s._ALPHA_MULTIPLY = 4, s._ALPHA_MAXIMIZED = 5, s._ALPHA_ONEONE = 6, s._DELAYLOADSTATE_NONE = 0, s._DELAYLOADSTATE_LOADED = 1, s._DELAYLOADSTATE_LOADING = 2, s._DELAYLOADSTATE_NOTLOADED = 4, s._TEXTUREFORMAT_ALPHA = 0, s._TEXTUREFORMAT_LUMINANCE = 1, s._TEXTUREFORMAT_LUMINANCE_ALPHA = 2, s._TEXTUREFORMAT_RGB = 4, s._TEXTUREFORMAT_RGBA = 5, s._TEXTURETYPE_UNSIGNED_INT = 0, s._TEXTURETYPE_FLOAT = 1, s._TEXTURETYPE_HALF_FLOAT = 2, s._NEVER = 512, s._ALWAYS = 519, s._LESS = 513, s._EQUAL = 514, s._LEQUAL = 515, s._GREATER = 516, s._GEQUAL = 518, s._NOTEQUAL = 517, s._KEEP = 7680, s._REPLACE = 7681, s._INCR = 7682, s._DECR = 7683, s._INVERT = 5386, s._INCR_WRAP = 34055, s._DECR_WRAP = 34056, s.CollisionsEpsilon = .001, s.CodeRepository = "src/", s.ShadersRepository = "src/Shaders/", s
	})();
	e.Engine = l
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			this.state = "", this.metadata = null, this.doNotSerialize = !1, this.animations = new Array, this._ranges = {}, this._childrenFlag = -1, this._isEnabled = !0, this._isReady = !0, this._currentRenderId = -1, this._parentRenderId = -1, this.onDisposeObservable = new e.Observable, this.name = t, this.id = t, this._scene = i, this._initCache()
		}
		return Object.defineProperty(t.prototype, "parent", {
			get: function() {
				return this._parentNode
			},
			set: function(e) {
				if (this._parentNode !== e) {
					if (this._parentNode) {
						var t = this._parentNode._children.indexOf(this);
						t !== -1 && this._parentNode._children.splice(t, 1)
					}
					this._parentNode = e, this._parentNode && (this._parentNode._children || (this._parentNode._children = new Array), this._parentNode._children.push(this))
				}
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onDispose", {
			set: function(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.getEngine = function() {
			return this._scene.getEngine()
		}, t.prototype.getWorldMatrix = function() {
			return e.Matrix.Identity()
		}, t.prototype._initCache = function() {
			this._cache = {}, this._cache.parent = void 0
		}, t.prototype.updateCache = function(e) {
			!e && this.isSynchronized() || (this._cache.parent = this.parent, this._updateCache())
		}, t.prototype._updateCache = function(e) {}, t.prototype._isSynchronized = function() {
			return !0
		}, t.prototype._markSyncedWithParent = function() {
			this._parentRenderId = this.parent._currentRenderId
		}, t.prototype.isSynchronizedWithParent = function() {
			return !this.parent || this._parentRenderId === this.parent._currentRenderId && this.parent.isSynchronized()
		}, t.prototype.isSynchronized = function(e) {
			var t = this.hasNewParent();
			return t = t || !this.isSynchronizedWithParent(), t = t || !this._isSynchronized(), e && this.updateCache(!0), !t
		}, t.prototype.hasNewParent = function(e) {
			return this._cache.parent !== this.parent && (e && (this._cache.parent = this.parent), !0)
		}, t.prototype.isReady = function() {
			return this._isReady
		}, t.prototype.isEnabled = function() {
			return !!this._isEnabled && (!this.parent || this.parent.isEnabled())
		}, t.prototype.setEnabled = function(e) {
			this._isEnabled = e
		}, t.prototype.isDescendantOf = function(e) {
			return !!this.parent && (this.parent === e || this.parent.isDescendantOf(e))
		}, t.prototype._getDescendants = function(e, t, i) {
			if (void 0 === t && (t = !1), this._children)
				for (var r = 0; r < this._children.length; r++) {
					var n = this._children[r];
					i && !i(n) || e.push(n), t || n._getDescendants(e, !1, i)
				}
		}, t.prototype.getDescendants = function(e, t) {
			var i = [];
			return this._getDescendants(i, e, t), i
		}, t.prototype.getChildren = function(e) {
			return this.getDescendants(!0, e)
		}, t.prototype.getChildMeshes = function(t, i) {
			var r = [];
			return this._getDescendants(r, t, (function(t) {
				return (!i || i(t)) && t instanceof e.AbstractMesh
			})), r
		}, t.prototype._setReady = function(e) {
			if (e !== this._isReady) {
				if (!e) return void(this._isReady = !1);
				this._isReady = !0, this.onReady && this.onReady(this)
			}
		}, t.prototype.getAnimationByName = function(e) {
			for (var t = 0; t < this.animations.length; t++) {
				var i = this.animations[t];
				if (i.name === e) return i
			}
			return null
		}, t.prototype.createAnimationRange = function(t, i, r) {
			if (!this._ranges[t]) {
				this._ranges[t] = new e.AnimationRange(t, i, r);
				for (var n = 0, o = this.animations.length; n < o; n++) this.animations[n] && this.animations[n].createRange(t, i, r)
			}
		}, t.prototype.deleteAnimationRange = function(e, t) {
			void 0 === t && (t = !0);
			for (var i = 0, r = this.animations.length; i < r; i++) this.animations[i] && this.animations[i].deleteRange(e, t);
			this._ranges[e] = void 0
		}, t.prototype.getAnimationRange = function(e) {
			return this._ranges[e]
		}, t.prototype.beginAnimation = function(e, t, i, r) {
			var n = this.getAnimationRange(e);
			return n ? void this._scene.beginAnimation(this, n.from, n.to, t, i, r) : null
		}, t.prototype.serializeAnimationRanges = function() {
			var e = [];
			for (var t in this._ranges) {
				var i = {};
				i.name = t, i.from = this._ranges[t].from, i.to = this._ranges[t].to, e.push(i)
			}
			return e
		}, t.prototype.dispose = function() {
			this.parent = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear()
		}, t.ParseAnimationRanges = function(e, t, i) {
			if (t.ranges)
				for (var r = 0; r < t.ranges.length; r++) {
					var n = t.ranges[r];
					e.createAnimationRange(n.name, n.from, n.to)
				}
		}, __decorate([e.serialize()], t.prototype, "name", void 0), __decorate([e.serialize()], t.prototype, "id", void 0), __decorate([e.serialize()], t.prototype, "uniqueId", void 0), __decorate([e.serialize()], t.prototype, "state", void 0), __decorate([e.serialize()], t.prototype, "metadata", void 0), t
	})();
	e.Node = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i, r, n, o, s, a) {
			this._engine = e, this._canvas = i, this._currentScene = t, this._sceneLoadedCallback = r, this._progressCallback = n, this._additionnalRenderLoopLogicCallback = o, this._textureLoadingCallback = s, this._startingProcessingFilesCallback = a
		}
		return t.prototype.monitorElementForDragNDrop = function(e) {
			var t = this;
			e && (this._elementToMonitor = e, this._elementToMonitor.addEventListener("dragenter", (function(e) {
				t.drag(e)
			}), !1), this._elementToMonitor.addEventListener("dragover", (function(e) {
				t.drag(e)
			}), !1), this._elementToMonitor.addEventListener("drop", (function(e) {
				t.drop(e)
			}), !1))
		}, t.prototype.renderFunction = function() {
			if (this._additionnalRenderLoopLogicCallback && this._additionnalRenderLoopLogicCallback(), this._currentScene) {
				if (this._textureLoadingCallback) {
					var e = this._currentScene.getWaitingItemsCount();
					e > 0 && this._textureLoadingCallback(e)
				}
				this._currentScene.render()
			}
		}, t.prototype.drag = function(e) {
			e.stopPropagation(), e.preventDefault()
		}, t.prototype.drop = function(e) {
			e.stopPropagation(), e.preventDefault(), this.loadFiles(e)
		}, t.prototype.loadFiles = function(e) {
			if (this._startingProcessingFilesCallback && this._startingProcessingFilesCallback(), e && e.dataTransfer && e.dataTransfer.files && (this._filesToLoad = e.dataTransfer.files), e && e.target && e.target.files && (this._filesToLoad = e.target.files), this._filesToLoad && this._filesToLoad.length > 0) {
				for (var i = 0; i < this._filesToLoad.length; i++) switch (this._filesToLoad[i].type) {
					case "image/jpeg":
					case "image/png":
					case "image/bmp":
						t.FilesTextures[this._filesToLoad[i].name.toLowerCase()] = this._filesToLoad[i];
						break;
					case "image/targa":
					case "image/vnd.ms-dds":
					case "audio/wav":
					case "audio/x-wav":
					case "audio/mp3":
					case "audio/mpeg":
					case "audio/mpeg3":
					case "audio/x-mpeg-3":
					case "audio/ogg":
						t.FilesToLoad[this._filesToLoad[i].name.toLowerCase()] = this._filesToLoad[i];
						break;
					default:
						this._filesToLoad[i].name.indexOf(".mtl") !== -1 ? t.FilesToLoad[this._filesToLoad[i].name.toLowerCase()] = this._filesToLoad[i] : this._filesToLoad[i].name.indexOf(".babylon") === -1 && this._filesToLoad[i].name.indexOf(".stl") === -1 && this._filesToLoad[i].name.indexOf(".obj") === -1 || this._filesToLoad[i].name.indexOf(".manifest") !== -1 || this._filesToLoad[i].name.indexOf(".incremental") !== -1 || this._filesToLoad[i].name.indexOf(".babylonmeshdata") !== -1 || this._filesToLoad[i].name.indexOf(".babylongeometrydata") !== -1 || this._filesToLoad[i].name.indexOf(".babylonbinarymeshdata") !== -1 || this._filesToLoad[i].name.indexOf(".binary.babylon") !== -1 || (this._sceneFileToLoad = this._filesToLoad[i])
				}
				this.reload()
			}
		}, t.prototype.reload = function() {
			var t = this,
				i = this;
			this._sceneFileToLoad ? (this._currentScene && (e.Tools.errorsCount > 0 && (e.Tools.ClearLogCache(), e.Tools.Log("Babylon.js engine (v" + e.Engine.Version + ") launched")), this._engine.stopRenderLoop(), this._currentScene.dispose()), e.SceneLoader.Load("file:", this._sceneFileToLoad, this._engine, (function(e) {
				i._currentScene = e, i._currentScene.executeWhenReady((function() {
					i._currentScene.activeCamera && 0 !== i._currentScene.lights.length || i._currentScene.createDefaultCameraOrLight(), i._currentScene.activeCamera.attachControl(i._canvas), i._sceneLoadedCallback && i._sceneLoadedCallback(t._sceneFileToLoad, i._currentScene), i._engine.runRenderLoop((function() {
						i.renderFunction()
					}))
				}))
			}), (function(e) {
				t._progressCallback && t._progressCallback(e)
			}))) : e.Tools.Error("Please provide a valid .babylon file.")
		}, t.FilesTextures = new Array, t.FilesToLoad = new Array, t
	})();
	e.FilesInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t, i) {
			this.bu = e, this.bv = t, this.distance = i, this.faceId = 0, this.subMeshId = 0
		}
		return e
	})();
	e.IntersectionInfo = t;
	var i = (function() {
		function t() {
			this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshId = 0, this.pickedSprite = null
		}
		return t.prototype.getNormal = function(t, i) {
			if (void 0 === t && (t = !1), void 0 === i && (i = !0), !this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(e.VertexBuffer.NormalKind)) return null;
			var r, n = this.pickedMesh.getIndices();
			if (i) {
				var o = this.pickedMesh.getVerticesData(e.VertexBuffer.NormalKind),
					s = e.Vector3.FromArray(o, 3 * n[3 * this.faceId]),
					a = e.Vector3.FromArray(o, 3 * n[3 * this.faceId + 1]),
					h = e.Vector3.FromArray(o, 3 * n[3 * this.faceId + 2]);
				s = s.scale(this.bu), a = a.scale(this.bv), h = h.scale(1 - this.bu - this.bv), r = new e.Vector3(s.x + a.x + h.x, s.y + a.y + h.y, s.z + a.z + h.z)
			} else {
				var c = this.pickedMesh.getVerticesData(e.VertexBuffer.PositionKind),
					l = e.Vector3.FromArray(c, 3 * n[3 * this.faceId]),
					u = e.Vector3.FromArray(c, 3 * n[3 * this.faceId + 1]),
					d = e.Vector3.FromArray(c, 3 * n[3 * this.faceId + 2]),
					f = l.subtract(u),
					p = d.subtract(u);
				r = e.Vector3.Cross(f, p)
			}
			return t && (r = e.Vector3.TransformNormal(r, this.pickedMesh.getWorldMatrix())), e.Vector3.Normalize(r)
		}, t.prototype.getTextureCoordinates = function() {
			if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(e.VertexBuffer.UVKind)) return null;
			var t = this.pickedMesh.getIndices(),
				i = this.pickedMesh.getVerticesData(e.VertexBuffer.UVKind),
				r = e.Vector2.FromArray(i, 2 * t[3 * this.faceId]),
				n = e.Vector2.FromArray(i, 2 * t[3 * this.faceId + 1]),
				o = e.Vector2.FromArray(i, 2 * t[3 * this.faceId + 2]);
			return r = r.scale(1 - this.bu - this.bv), n = n.scale(this.bu), o = o.scale(this.bv), new e.Vector2(r.x + n.x + o.x, r.y + n.y + o.y)
		}, t
	})();
	e.PickingInfo = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			this.minimum = t, this.maximum = i, this._tempRadiusVector = e.Vector3.Zero();
			var r = e.Vector3.Distance(t, i);
			this.center = e.Vector3.Lerp(t, i, .5), this.radius = .5 * r, this.centerWorld = e.Vector3.Zero(), this._update(e.Matrix.Identity())
		}
		return t.prototype._update = function(t) {
			e.Vector3.TransformCoordinatesToRef(this.center, t, this.centerWorld), e.Vector3.TransformNormalFromFloatsToRef(1, 1, 1, t, this._tempRadiusVector), this.radiusWorld = Math.max(Math.abs(this._tempRadiusVector.x), Math.abs(this._tempRadiusVector.y), Math.abs(this._tempRadiusVector.z)) * this.radius
		}, t.prototype.isInFrustum = function(e) {
			for (var t = 0; t < 6; t++)
				if (e[t].dotCoordinate(this.centerWorld) <= -this.radiusWorld) return !1;
			return !0
		}, t.prototype.intersectsPoint = function(t) {
			var i = this.centerWorld.x - t.x,
				r = this.centerWorld.y - t.y,
				n = this.centerWorld.z - t.z,
				o = Math.sqrt(i * i + r * r + n * n);
			return !(Math.abs(this.radiusWorld - o) < e.Epsilon)
		}, t.Intersects = function(e, t) {
			var i = e.centerWorld.x - t.centerWorld.x,
				r = e.centerWorld.y - t.centerWorld.y,
				n = e.centerWorld.z - t.centerWorld.z,
				o = Math.sqrt(i * i + r * r + n * n);
			return !(e.radiusWorld + t.radiusWorld < o)
		}, t
	})();
	e.BoundingSphere = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			this.minimum = t, this.maximum = i, this.vectors = new Array, this.vectorsWorld = new Array, this.vectors.push(this.minimum.clone()), this.vectors.push(this.maximum.clone()), this.vectors.push(this.minimum.clone()), this.vectors[2].x = this.maximum.x, this.vectors.push(this.minimum.clone()), this.vectors[3].y = this.maximum.y, this.vectors.push(this.minimum.clone()), this.vectors[4].z = this.maximum.z, this.vectors.push(this.maximum.clone()), this.vectors[5].z = this.minimum.z, this.vectors.push(this.maximum.clone()), this.vectors[6].x = this.minimum.x, this.vectors.push(this.maximum.clone()), this.vectors[7].y = this.minimum.y, this.center = this.maximum.add(this.minimum).scale(.5), this.extendSize = this.maximum.subtract(this.minimum).scale(.5), this.directions = [e.Vector3.Zero(), e.Vector3.Zero(), e.Vector3.Zero()];
			for (var r = 0; r < this.vectors.length; r++) this.vectorsWorld[r] = e.Vector3.Zero();
			this.minimumWorld = e.Vector3.Zero(), this.maximumWorld = e.Vector3.Zero(), this._update(e.Matrix.Identity())
		}
		return t.prototype.getWorldMatrix = function() {
			return this._worldMatrix
		}, t.prototype.setWorldMatrix = function(e) {
			return this._worldMatrix.copyFrom(e), this
		}, t.prototype._update = function(t) {
			e.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimumWorld), e.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximumWorld);
			for (var i = 0; i < this.vectors.length; i++) {
				var r = this.vectorsWorld[i];
				e.Vector3.TransformCoordinatesToRef(this.vectors[i], t, r), r.x < this.minimumWorld.x && (this.minimumWorld.x = r.x), r.y < this.minimumWorld.y && (this.minimumWorld.y = r.y), r.z < this.minimumWorld.z && (this.minimumWorld.z = r.z), r.x > this.maximumWorld.x && (this.maximumWorld.x = r.x), r.y > this.maximumWorld.y && (this.maximumWorld.y = r.y), r.z > this.maximumWorld.z && (this.maximumWorld.z = r.z)
			}
			this.maximumWorld.addToRef(this.minimumWorld, this.center), this.center.scaleInPlace(.5), e.Vector3.FromFloatArrayToRef(t.m, 0, this.directions[0]), e.Vector3.FromFloatArrayToRef(t.m, 4, this.directions[1]), e.Vector3.FromFloatArrayToRef(t.m, 8, this.directions[2]), this._worldMatrix = t
		}, t.prototype.isInFrustum = function(e) {
			return t.IsInFrustum(this.vectorsWorld, e)
		}, t.prototype.isCompletelyInFrustum = function(e) {
			return t.IsCompletelyInFrustum(this.vectorsWorld, e)
		}, t.prototype.intersectsPoint = function(t) {
			var i = -e.Epsilon;
			return !(this.maximumWorld.x - t.x < i || i > t.x - this.minimumWorld.x) && (!(this.maximumWorld.y - t.y < i || i > t.y - this.minimumWorld.y) && !(this.maximumWorld.z - t.z < i || i > t.z - this.minimumWorld.z))
		}, t.prototype.intersectsSphere = function(e) {
			return t.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld)
		}, t.prototype.intersectsMinMax = function(e, t) {
			return !(this.maximumWorld.x < e.x || this.minimumWorld.x > t.x) && (!(this.maximumWorld.y < e.y || this.minimumWorld.y > t.y) && !(this.maximumWorld.z < e.z || this.minimumWorld.z > t.z))
		}, t.Intersects = function(e, t) {
			return !(e.maximumWorld.x < t.minimumWorld.x || e.minimumWorld.x > t.maximumWorld.x) && (!(e.maximumWorld.y < t.minimumWorld.y || e.minimumWorld.y > t.maximumWorld.y) && !(e.maximumWorld.z < t.minimumWorld.z || e.minimumWorld.z > t.maximumWorld.z))
		}, t.IntersectsSphere = function(t, i, r, n) {
			var o = e.Vector3.Clamp(r, t, i),
				s = e.Vector3.DistanceSquared(r, o);
			return s <= n * n
		}, t.IsCompletelyInFrustum = function(e, t) {
			for (var i = 0; i < 6; i++)
				for (var r = 0; r < 8; r++)
					if (t[i].dotCoordinate(e[r]) < 0) return !1;
			return !0
		}, t.IsInFrustum = function(e, t) {
			for (var i = 0; i < 6; i++) {
				for (var r = 8, n = 0; n < 8 && t[i].dotCoordinate(e[n]) < 0; n++) --r;
				if (0 === r) return !1
			}
			return !0
		}, t
	})();
	e.BoundingBox = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = function(t, i) {
			var r = e.Vector3.Dot(i.center, t),
				n = Math.abs(e.Vector3.Dot(i.directions[0], t)) * i.extendSize.x,
				o = Math.abs(e.Vector3.Dot(i.directions[1], t)) * i.extendSize.y,
				s = Math.abs(e.Vector3.Dot(i.directions[2], t)) * i.extendSize.z,
				a = n + o + s;
			return {
				min: r - a,
				max: r + a
			}
		},
		i = function(e, t, i, r) {
			return !(e > r || i > t)
		},
		r = function(e, r, n) {
			var o = t(e, r),
				s = t(e, n);
			return i(o.min, o.max, s.min, s.max)
		},
		n = (function() {
			function t(t, i) {
				this.minimum = t, this.maximum = i, this._isLocked = !1, this.boundingBox = new e.BoundingBox(t, i), this.boundingSphere = new e.BoundingSphere(t, i)
			}
			return Object.defineProperty(t.prototype, "isLocked", {
				get: function() {
					return this._isLocked
				},
				set: function(e) {
					this._isLocked = e
				},
				enumerable: !0,
				configurable: !0
			}), t.prototype.update = function(e) {
				this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e))
			}, t.prototype.isInFrustum = function(e) {
				return !!this.boundingSphere.isInFrustum(e) && this.boundingBox.isInFrustum(e)
			}, t.prototype.isCompletelyInFrustum = function(e) {
				return this.boundingBox.isCompletelyInFrustum(e)
			}, t.prototype._checkCollision = function(e) {
				return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld)
			}, t.prototype.intersectsPoint = function(e) {
				return !!this.boundingSphere.centerWorld && (!!this.boundingSphere.intersectsPoint(e) && !!this.boundingBox.intersectsPoint(e))
			}, t.prototype.intersects = function(t, i) {
				if (!this.boundingSphere.centerWorld || !t.boundingSphere.centerWorld) return !1;
				if (!e.BoundingSphere.Intersects(this.boundingSphere, t.boundingSphere)) return !1;
				if (!e.BoundingBox.Intersects(this.boundingBox, t.boundingBox)) return !1;
				if (!i) return !0;
				var n = this.boundingBox,
					o = t.boundingBox;
				return !!r(n.directions[0], n, o) && (!!r(n.directions[1], n, o) && (!!r(n.directions[2], n, o) && (!!r(o.directions[0], n, o) && (!!r(o.directions[1], n, o) && (!!r(o.directions[2], n, o) && (!!r(e.Vector3.Cross(n.directions[0], o.directions[0]), n, o) && (!!r(e.Vector3.Cross(n.directions[0], o.directions[1]), n, o) && (!!r(e.Vector3.Cross(n.directions[0], o.directions[2]), n, o) && (!!r(e.Vector3.Cross(n.directions[1], o.directions[0]), n, o) && (!!r(e.Vector3.Cross(n.directions[1], o.directions[1]), n, o) && (!!r(e.Vector3.Cross(n.directions[1], o.directions[2]), n, o) && (!!r(e.Vector3.Cross(n.directions[2], o.directions[0]), n, o) && (!!r(e.Vector3.Cross(n.directions[2], o.directions[1]), n, o) && !!r(e.Vector3.Cross(n.directions[2], o.directions[2]), n, o))))))))))))))
			}, t
		})();
	e.BoundingInfo = n
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i) {
			void 0 === i && (i = Number.MAX_VALUE), this.origin = e, this.direction = t, this.length = i, this._show = !1
		}
		return t.prototype.intersectsBoxMinMax = function(e, t) {
			var i, r, n, o, s = 0,
				a = Number.MAX_VALUE;
			if (Math.abs(this.direction.x) < 1e-7) {
				if (this.origin.x < e.x || this.origin.x > t.x) return !1
			} else if (i = 1 / this.direction.x, r = (e.x - this.origin.x) * i, n = (t.x - this.origin.x) * i, n === -(1 / 0) && (n = 1 / 0), r > n && (o = r, r = n, n = o), s = Math.max(r, s), a = Math.min(n, a), s > a) return !1;
			if (Math.abs(this.direction.y) < 1e-7) {
				if (this.origin.y < e.y || this.origin.y > t.y) return !1
			} else if (i = 1 / this.direction.y, r = (e.y - this.origin.y) * i, n = (t.y - this.origin.y) * i, n === -(1 / 0) && (n = 1 / 0), r > n && (o = r, r = n, n = o), s = Math.max(r, s), a = Math.min(n, a), s > a) return !1;
			if (Math.abs(this.direction.z) < 1e-7) {
				if (this.origin.z < e.z || this.origin.z > t.z) return !1
			} else if (i = 1 / this.direction.z, r = (e.z - this.origin.z) * i, n = (t.z - this.origin.z) * i, n === -(1 / 0) && (n = 1 / 0), r > n && (o = r, r = n, n = o), s = Math.max(r, s), a = Math.min(n, a), s > a) return !1;
			return !0
		}, t.prototype.intersectsBox = function(e) {
			return this.intersectsBoxMinMax(e.minimum, e.maximum)
		}, t.prototype.intersectsSphere = function(e) {
			var t = e.center.x - this.origin.x,
				i = e.center.y - this.origin.y,
				r = e.center.z - this.origin.z,
				n = t * t + i * i + r * r,
				o = e.radius * e.radius;
			if (n <= o) return !0;
			var s = t * this.direction.x + i * this.direction.y + r * this.direction.z;
			if (s < 0) return !1;
			var a = n - s * s;
			return a <= o
		}, t.prototype.intersectsTriangle = function(t, i, r) {
			this._edge1 || (this._edge1 = e.Vector3.Zero(), this._edge2 = e.Vector3.Zero(), this._pvec = e.Vector3.Zero(), this._tvec = e.Vector3.Zero(), this._qvec = e.Vector3.Zero()), i.subtractToRef(t, this._edge1), r.subtractToRef(t, this._edge2), e.Vector3.CrossToRef(this.direction, this._edge2, this._pvec);
			var n = e.Vector3.Dot(this._edge1, this._pvec);
			if (0 === n) return null;
			var o = 1 / n;
			this.origin.subtractToRef(t, this._tvec);
			var s = e.Vector3.Dot(this._tvec, this._pvec) * o;
			if (s < 0 || s > 1) return null;
			e.Vector3.CrossToRef(this._tvec, this._edge1, this._qvec);
			var a = e.Vector3.Dot(this.direction, this._qvec) * o;
			if (a < 0 || s + a > 1) return null;
			var h = e.Vector3.Dot(this._edge2, this._qvec) * o;
			return h > this.length ? null : new e.IntersectionInfo(s, a, h)
		}, t.prototype.intersectsPlane = function(t) {
			var i, r = e.Vector3.Dot(t.normal, this.direction);
			if (Math.abs(r) < 9.99999997475243e-7) return null;
			var n = e.Vector3.Dot(t.normal, this.origin);
			return i = (-t.d - n) / r, i < 0 ? i < -9.99999997475243e-7 ? null : 0 : i
		}, t.prototype.intersectsMesh = function(i, r) {
			var n = e.Tmp.Matrix[0];
			return i.getWorldMatrix().invertToRef(n), this._tmpRay ? t.TransformToRef(this, n, this._tmpRay) : this._tmpRay = t.Transform(this, n), i.intersects(this._tmpRay, r)
		}, t.prototype.show = function(t, i) {
			this._show || (this._renderFunction = this._render.bind(this), this._show = !0, this._scene = t, this._renderPoints = [this.origin, this.origin.add(this.direction.scale(this.length))], this._renderLine = e.Mesh.CreateLines("ray", this._renderPoints, t, !0), this._scene.registerBeforeRender(this._renderFunction)), i && this._renderLine.color.copyFrom(i)
		}, t.prototype.hide = function() {
			this._show && (this._show = !1, this._scene.unregisterBeforeRender(this._renderFunction)), this._renderLine && (this._renderLine.dispose(), this._renderLine = null, this._renderPoints = null)
		}, t.prototype._render = function() {
			var t = this._renderPoints[1];
			t.copyFrom(this.direction), t.scaleInPlace(this.length), t.addInPlace(this.origin), e.Mesh.CreateLines("ray", this._renderPoints, this._scene, !0, this._renderLine)
		}, t.prototype.intersectionSegment = function(i, r, n) {
			var o, s, a, h, c = this.origin.add(this.direction.multiplyByFloats(t.rayl, t.rayl, t.rayl)),
				l = r.subtract(i),
				u = c.subtract(this.origin),
				d = i.subtract(this.origin),
				f = e.Vector3.Dot(l, l),
				p = e.Vector3.Dot(l, u),
				m = e.Vector3.Dot(u, u),
				_ = e.Vector3.Dot(l, d),
				g = e.Vector3.Dot(u, d),
				v = f * m - p * p,
				y = v,
				x = v;
			v < t.smallnum ? (s = 0, y = 1, h = g, x = m) : (s = p * g - m * _, h = f * g - p * _, s < 0 ? (s = 0, h = g, x = m) : s > y && (s = y, h = g + p, x = m)), h < 0 ? (h = 0, -_ < 0 ? s = 0 : -_ > f ? s = y : (s = -_, y = f)) : h > x && (h = x, -_ + p < 0 ? s = 0 : -_ + p > f ? s = y : (s = -_ + p, y = f)), o = Math.abs(s) < t.smallnum ? 0 : s / y, a = Math.abs(h) < t.smallnum ? 0 : h / x;
			var b = u.multiplyByFloats(a, a, a),
				T = d.add(l.multiplyByFloats(o, o, o)).subtract(b),
				A = a > 0 && a <= this.length && T.lengthSquared() < n * n;
			return A ? b.length() : -1
		}, t.CreateNew = function(i, r, n, o, s, a, h) {
			var c = e.Vector3.Unproject(new e.Vector3(i, r, 0), n, o, s, a, h),
				l = e.Vector3.Unproject(new e.Vector3(i, r, 1), n, o, s, a, h),
				u = l.subtract(c);
			return u.normalize(), new t(c, u)
		}, t.CreateNewFromTo = function(i, r, n) {
			void 0 === n && (n = e.Matrix.Identity());
			var o = r.subtract(i),
				s = Math.sqrt(o.x * o.x + o.y * o.y + o.z * o.z);
			return o.normalize(), t.Transform(new t(i, o, s), n)
		}, t.Transform = function(i, r) {
			var n = e.Vector3.TransformCoordinates(i.origin, r),
				o = e.Vector3.TransformNormal(i.direction, r);
			return o.normalize(), new t(n, o, i.length)
		}, t.TransformToRef = function(t, i, r) {
			e.Vector3.TransformCoordinatesToRef(t.origin, i, r.origin), e.Vector3.TransformNormalToRef(t.direction, i, r.direction), t.direction.normalize()
		}, t.smallnum = 1e-8, t.rayl = 1e9, t
	})();
	e.Ray = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(r, n) {
			var o = this;
			t.call(this, r, n), this.onCollideObservable = new e.Observable, this.onCollisionPositionChangeObservable = new e.Observable, this.onAfterWorldMatrixUpdateObservable = new e.Observable, this.definedFacingForward = !0, this.position = new e.Vector3(0, 0, 0), this._rotation = new e.Vector3(0, 0, 0), this._scaling = new e.Vector3(1, 1, 1), this.billboardMode = i.BILLBOARDMODE_NONE, this.visibility = 1, this.alphaIndex = Number.MAX_VALUE, this.infiniteDistance = !1, this.isVisible = !0, this.isPickable = !0, this.showBoundingBox = !1, this.showSubMeshesBoundingBox = !1, this.isBlocker = !1, this.renderingGroupId = 0, this.receiveShadows = !1, this.renderOutline = !1, this.outlineColor = e.Color3.Red(), this.outlineWidth = .02, this.renderOverlay = !1, this.overlayColor = e.Color3.Red(), this.overlayAlpha = .5, this.hasVertexAlpha = !1, this.useVertexColors = !0, this.applyFog = !0, this.computeBonesUsingShaders = !0, this.scalingDeterminant = 1, this.numBoneInfluencers = 4, this.useOctreeForRenderingSelection = !0, this.useOctreeForPicking = !0, this.useOctreeForCollisions = !0, this.layerMask = 268435455, this.alwaysSelectAsActiveMesh = !1, this._checkCollisions = !1, this.ellipsoid = new e.Vector3(.5, 1, .5), this.ellipsoidOffset = new e.Vector3(0, 0, 0), this._collider = new e.Collider, this._oldPositionForCollisions = new e.Vector3(0, 0, 0), this._diffPositionForCollisions = new e.Vector3(0, 0, 0), this._newPositionForCollisions = new e.Vector3(0, 0, 0), this.edgesWidth = 1, this.edgesColor = new e.Color4(1, 0, 0, 1), this._localWorld = e.Matrix.Zero(), this._worldMatrix = e.Matrix.Zero(), this._rotateYByPI = e.Matrix.RotationY(Math.PI), this._absolutePosition = e.Vector3.Zero(), this._collisionsTransformMatrix = e.Matrix.Zero(), this._collisionsScalingMatrix = e.Matrix.Zero(), this._isDirty = !1, this._pivotMatrix = e.Matrix.Identity(), this._isDisposed = !1, this._renderId = 0, this._intersectionsInProgress = new Array, this._isWorldMatrixFrozen = !1, this._unIndexed = !1, this._onCollisionPositionChange = function(t, i, r) {
				void 0 === r && (r = null), o.getScene().workerCollisions && i.multiplyInPlace(o._collider.radius), i.subtractToRef(o._oldPositionForCollisions, o._diffPositionForCollisions), o._diffPositionForCollisions.length() > e.Engine.CollisionsEpsilon && o.position.addInPlace(o._diffPositionForCollisions), r && o.onCollideObservable.notifyObservers(r), o.onCollisionPositionChangeObservable.notifyObservers(o.position)
			}, n.addMesh(this)
		}
		return __extends(i, t), Object.defineProperty(i, "BILLBOARDMODE_NONE", {
			get: function() {
				return i._BILLBOARDMODE_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "BILLBOARDMODE_X", {
			get: function() {
				return i._BILLBOARDMODE_X
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "BILLBOARDMODE_Y", {
			get: function() {
				return i._BILLBOARDMODE_Y
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "BILLBOARDMODE_Z", {
			get: function() {
				return i._BILLBOARDMODE_Z
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "BILLBOARDMODE_ALL", {
			get: function() {
				return i._BILLBOARDMODE_ALL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onCollide", {
			set: function(e) {
				this._onCollideObserver && this.onCollideObservable.remove(this._onCollideObserver), this._onCollideObserver = this.onCollideObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onCollisionPositionChange", {
			set: function(e) {
				this._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._onCollisionPositionChangeObserver), this._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "skeleton", {
			get: function() {
				return this._skeleton
			},
			set: function(e) {
				this._skeleton && this._skeleton.needInitialSkinMatrix && this._skeleton._unregisterMeshWithPoseMatrix(this), e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this), this._skeleton = e, this._skeleton || (this._bonesTransformMatrices = null)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.toString = function(t) {
			var i = "Name: " + this.name + ", isInstance: " + (this instanceof e.InstancedMesh ? "YES" : "NO");
			return i += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0), this._skeleton && (i += ", skeleton: " + this._skeleton.name), t && (i += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode], i += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingFreezeWorldMatrix ? "YES" : "NO")), i
		}, Object.defineProperty(i.prototype, "rotation", {
			get: function() {
				return this._rotation
			},
			set: function(e) {
				this._rotation = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "scaling", {
			get: function() {
				return this._scaling
			},
			set: function(e) {
				this._scaling = e, this.physicsImpostor && this.physicsImpostor.forceUpdate()
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "rotationQuaternion", {
			get: function() {
				return this._rotationQuaternion
			},
			set: function(e) {
				this._rotationQuaternion = e, e && this.rotation.length() && this.rotation.copyFromFloats(0, 0, 0)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.updatePoseMatrix = function(e) {
			this._poseMatrix.copyFrom(e)
		}, i.prototype.getPoseMatrix = function() {
			return this._poseMatrix
		}, i.prototype.disableEdgesRendering = function() {
			void 0 !== this._edgesRenderer && (this._edgesRenderer.dispose(), this._edgesRenderer = void 0)
		}, i.prototype.enableEdgesRendering = function(t, i) {
			void 0 === t && (t = .95), void 0 === i && (i = !1), this.disableEdgesRendering(), this._edgesRenderer = new e.EdgesRenderer(this, t, i)
		}, Object.defineProperty(i.prototype, "isBlocked", {
			get: function() {
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getLOD = function(e) {
			return this
		}, i.prototype.getTotalVertices = function() {
			return 0
		}, i.prototype.getIndices = function() {
			return null
		}, i.prototype.getVerticesData = function(e) {
			return null
		}, i.prototype.isVerticesDataPresent = function(e) {
			return !1
		}, i.prototype.getBoundingInfo = function() {
			return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfo || this._updateBoundingInfo(), this._boundingInfo)
		}, i.prototype.setBoundingInfo = function(e) {
			this._boundingInfo = e
		}, Object.defineProperty(i.prototype, "useBones", {
			get: function() {
				return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(e.VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(e.VertexBuffer.MatricesWeightsKind)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._preActivate = function() {}, i.prototype._preActivateForIntermediateRendering = function(e) {}, i.prototype._activate = function(e) {
			this._renderId = e
		}, i.prototype.getWorldMatrix = function() {
			return this._masterMesh ? this._masterMesh.getWorldMatrix() : (this._currentRenderId !== this.getScene().getRenderId() && this.computeWorldMatrix(), this._worldMatrix)
		}, Object.defineProperty(i.prototype, "worldMatrixFromCache", {
			get: function() {
				return this._worldMatrix
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "absolutePosition", {
			get: function() {
				return this._absolutePosition
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.freezeWorldMatrix = function() {
			this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this._isWorldMatrixFrozen = !0
		}, i.prototype.unfreezeWorldMatrix = function() {
			this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0)
		}, Object.defineProperty(i.prototype, "isWorldMatrixFrozen", {
			get: function() {
				return this._isWorldMatrixFrozen
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.rotate = function(t, r, n) {
			t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = e.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation = e.Vector3.Zero());
			var o;
			if (n && n !== e.Space.LOCAL) {
				if (this.parent) {
					var s = this.parent.getWorldMatrix().clone();
					s.invert(), t = e.Vector3.TransformNormal(t, s)
				}
				o = e.Quaternion.RotationAxisToRef(t, r, i._rotationAxisCache), o.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion)
			} else o = e.Quaternion.RotationAxisToRef(t, r, i._rotationAxisCache), this.rotationQuaternion.multiplyToRef(o, this.rotationQuaternion)
		}, i.prototype.translate = function(t, i, r) {
			var n = t.scale(i);
			if (r && r !== e.Space.LOCAL) this.setAbsolutePosition(this.getAbsolutePosition().add(n));
			else {
				var o = this.getPositionExpressedInLocalSpace().add(n);
				this.setPositionWithLocalVector(o)
			}
		}, i.prototype.getAbsolutePosition = function() {
			return this.computeWorldMatrix(), this._absolutePosition
		}, i.prototype.setAbsolutePosition = function(t) {
			if (t) {
				var i, r, n;
				if (void 0 === t.x) {
					if (arguments.length < 3) return;
					i = arguments[0], r = arguments[1], n = arguments[2]
				} else i = t.x, r = t.y, n = t.z;
				if (this.parent) {
					var o = this.parent.getWorldMatrix().clone();
					o.invert();
					var s = new e.Vector3(i, r, n);
					this.position = e.Vector3.TransformCoordinates(s, o)
				} else this.position.x = i, this.position.y = r, this.position.z = n
			}
		}, i.prototype.movePOV = function(e, t, i) {
			this.position.addInPlace(this.calcMovePOV(e, t, i))
		}, i.prototype.calcMovePOV = function(t, i, r) {
			var n = new e.Matrix,
				o = this.rotationQuaternion ? this.rotationQuaternion : e.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
			o.toRotationMatrix(n);
			var s = e.Vector3.Zero(),
				a = this.definedFacingForward ? -1 : 1;
			return e.Vector3.TransformCoordinatesFromFloatsToRef(t * a, i, r * a, n, s), s
		}, i.prototype.rotatePOV = function(e, t, i) {
			this.rotation.addInPlace(this.calcRotatePOV(e, t, i))
		}, i.prototype.calcRotatePOV = function(t, i, r) {
			var n = this.definedFacingForward ? 1 : -1;
			return new e.Vector3(t * n, i, r * n)
		}, i.prototype.setPivotMatrix = function(e) {
			this._pivotMatrix = e, this._cache.pivotMatrixUpdated = !0
		}, i.prototype.getPivotMatrix = function() {
			return this._pivotMatrix
		}, i.prototype._isSynchronized = function() {
			return !this._isDirty && (this.billboardMode === this._cache.billboardMode && this.billboardMode === i.BILLBOARDMODE_NONE && (!this._cache.pivotMatrixUpdated && (!this.infiniteDistance && (!!this._cache.position.equals(this.position) && (!(this.rotationQuaternion && !this._cache.rotationQuaternion.equals(this.rotationQuaternion)) && (!!this._cache.rotation.equals(this.rotation) && !!this._cache.scaling.equals(this.scaling)))))))
		}, i.prototype._initCache = function() {
			t.prototype._initCache.call(this), this._cache.localMatrixUpdated = !1, this._cache.position = e.Vector3.Zero(), this._cache.scaling = e.Vector3.Zero(), this._cache.rotation = e.Vector3.Zero(), this._cache.rotationQuaternion = new e.Quaternion(0, 0, 0, 0), this._cache.billboardMode = -1
		}, i.prototype.markAsDirty = function(e) {
			"rotation" === e && (this.rotationQuaternion = null), this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0
		}, i.prototype._updateBoundingInfo = function() {
			this._boundingInfo = this._boundingInfo || new e.BoundingInfo(this.absolutePosition, this.absolutePosition), this._boundingInfo.update(this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)
		}, i.prototype._updateSubMeshesBoundingInfo = function(e) {
			if (this.subMeshes)
				for (var t = 0; t < this.subMeshes.length; t++) {
					var i = this.subMeshes[t];
					i.IsGlobal || i.updateBoundingInfo(e)
				}
		}, i.prototype.computeWorldMatrix = function(t) {
			if (this._isWorldMatrixFrozen) return this._worldMatrix;
			if (!t && (this._currentRenderId === this.getScene().getRenderId() || this.isSynchronized(!0))) return this._currentRenderId = this.getScene().getRenderId(), this._worldMatrix;
			if (this._cache.position.copyFrom(this.position), this._cache.scaling.copyFrom(this.scaling), this._cache.pivotMatrixUpdated = !1, this._cache.billboardMode = this.billboardMode, this._currentRenderId = this.getScene().getRenderId(), this._isDirty = !1, e.Matrix.ScalingToRef(this.scaling.x * this.scalingDeterminant, this.scaling.y * this.scalingDeterminant, this.scaling.z * this.scalingDeterminant, e.Tmp.Matrix[1]), this.rotationQuaternion) {
				var r = this.rotation.length();
				r && (this.rotationQuaternion.multiplyInPlace(e.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)), this.rotation.copyFromFloats(0, 0, 0))
			}
			if (this.rotationQuaternion ? (this.rotationQuaternion.toRotationMatrix(e.Tmp.Matrix[0]), this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (e.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, e.Tmp.Matrix[0]), this._cache.rotation.copyFrom(this.rotation)), this.infiniteDistance && !this.parent) {
				var n = this.getScene().activeCamera;
				if (n) {
					var o = n.getWorldMatrix(),
						s = new e.Vector3(o.m[12], o.m[13], o.m[14]);
					e.Matrix.TranslationToRef(this.position.x + s.x, this.position.y + s.y, this.position.z + s.z, e.Tmp.Matrix[2])
				}
			} else e.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, e.Tmp.Matrix[2]);
			if (this._pivotMatrix.multiplyToRef(e.Tmp.Matrix[1], e.Tmp.Matrix[4]), e.Tmp.Matrix[4].multiplyToRef(e.Tmp.Matrix[0], e.Tmp.Matrix[5]), this.billboardMode !== i.BILLBOARDMODE_NONE && this.getScene().activeCamera) {
				e.Tmp.Vector3[0].copyFrom(this.position);
				var a = e.Tmp.Vector3[0];
				if (this.parent && this.parent.getWorldMatrix) {
					this._markSyncedWithParent();
					var h;
					this._meshToBoneReferal ? (this.parent.getWorldMatrix().multiplyToRef(this._meshToBoneReferal.getWorldMatrix(), e.Tmp.Matrix[6]), h = e.Tmp.Matrix[6]) : h = this.parent.getWorldMatrix(), e.Vector3.TransformNormalToRef(a, h, e.Tmp.Vector3[1]), a = e.Tmp.Vector3[1]
				}
				var c = this.getScene().activeCamera.globalPosition.clone();
				this.parent && this.parent.position && (a.addInPlace(this.parent.position), e.Matrix.TranslationToRef(a.x, a.y, a.z, e.Tmp.Matrix[2])), (this.billboardMode & i.BILLBOARDMODE_ALL) !== i.BILLBOARDMODE_ALL && (this.billboardMode & i.BILLBOARDMODE_X && (c.x = a.x + e.Epsilon), this.billboardMode & i.BILLBOARDMODE_Y && (c.y = a.y + e.Epsilon), this.billboardMode & i.BILLBOARDMODE_Z && (c.z = a.z + e.Epsilon)), e.Matrix.LookAtLHToRef(a, c, e.Vector3.Up(), e.Tmp.Matrix[3]), e.Tmp.Matrix[3].m[12] = e.Tmp.Matrix[3].m[13] = e.Tmp.Matrix[3].m[14] = 0, e.Tmp.Matrix[3].invert(), e.Tmp.Matrix[5].multiplyToRef(e.Tmp.Matrix[3], this._localWorld), this._rotateYByPI.multiplyToRef(this._localWorld, e.Tmp.Matrix[5])
			}
			return e.Tmp.Matrix[5].multiplyToRef(e.Tmp.Matrix[2], this._localWorld), this.parent && this.parent.getWorldMatrix && this.billboardMode === i.BILLBOARDMODE_NONE ? (this._markSyncedWithParent(), this._meshToBoneReferal ? (this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), e.Tmp.Matrix[6]), e.Tmp.Matrix[6].multiplyToRef(this._meshToBoneReferal.getWorldMatrix(), this._worldMatrix)) : this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix)) : this._worldMatrix.copyFrom(this._localWorld), this._updateBoundingInfo(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = e.Matrix.Invert(this._worldMatrix)), this._worldMatrix
		}, i.prototype.registerAfterWorldMatrixUpdate = function(e) {
			this.onAfterWorldMatrixUpdateObservable.add(e)
		}, i.prototype.unregisterAfterWorldMatrixUpdate = function(e) {
			this.onAfterWorldMatrixUpdateObservable.removeCallback(e)
		}, i.prototype.setPositionWithLocalVector = function(t) {
			this.computeWorldMatrix(), this.position = e.Vector3.TransformNormal(t, this._localWorld)
		}, i.prototype.getPositionExpressedInLocalSpace = function() {
			this.computeWorldMatrix();
			var t = this._localWorld.clone();
			return t.invert(), e.Vector3.TransformNormal(this.position, t)
		}, i.prototype.locallyTranslate = function(t) {
			this.computeWorldMatrix(!0), this.position = e.Vector3.TransformCoordinates(t, this._localWorld)
		}, i.prototype.lookAt = function(t, r, n, o, s) {
			void 0 === r && (r = 0), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === s && (s = e.Space.LOCAL);
			var a = i._lookAtVectorCache,
				h = s === e.Space.LOCAL ? this.position : this.getAbsolutePosition();
			t.subtractToRef(h, a);
			var c = -Math.atan2(a.z, a.x) - Math.PI / 2,
				l = Math.sqrt(a.x * a.x + a.z * a.z),
				u = Math.atan2(a.y, l);
			this.rotationQuaternion = this.rotationQuaternion || new e.Quaternion, e.Quaternion.RotationYawPitchRollToRef(c + r, u + n, o, this.rotationQuaternion)
		}, i.prototype.attachToBone = function(e, t) {
			this._meshToBoneReferal = t, this.parent = e, e.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1)
		}, i.prototype.detachFromBone = function() {
			this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._meshToBoneReferal = null, this.parent = null
		}, i.prototype.isInFrustum = function(e) {
			return this._boundingInfo.isInFrustum(e)
		}, i.prototype.isCompletelyInFrustum = function(e) {
			return this._boundingInfo.isCompletelyInFrustum(e)
		}, i.prototype.intersectsMesh = function(e, t) {
			return !(!this._boundingInfo || !e._boundingInfo) && this._boundingInfo.intersects(e._boundingInfo, t)
		}, i.prototype.intersectsPoint = function(e) {
			return !!this._boundingInfo && this._boundingInfo.intersectsPoint(e)
		}, i.prototype.setPhysicsState = function(t, i) {
			return t.impostor && (i = t, t = t.impostor), this.physicsImpostor = new e.PhysicsImpostor(this, t, i, this.getScene()), this.physicsImpostor.physicsBody
		}, i.prototype.getPhysicsImpostor = function() {
			return this.physicsImpostor
		}, i.prototype.getPhysicsMass = function() {
			return this.physicsImpostor.getParam("mass")
		}, i.prototype.getPhysicsFriction = function() {
			return this.physicsImpostor.getParam("friction")
		}, i.prototype.getPhysicsRestitution = function() {
			return this.physicsImpostor.getParam("restitution")
		}, i.prototype.getPositionInCameraSpace = function(t) {
			return t || (t = this.getScene().activeCamera), e.Vector3.TransformCoordinates(this.absolutePosition, t.getViewMatrix())
		}, i.prototype.getDistanceToCamera = function(e) {
			return e || (e = this.getScene().activeCamera), this.absolutePosition.subtract(e.position).length()
		}, i.prototype.applyImpulse = function(e, t) {
			this.physicsImpostor && this.physicsImpostor.applyImpulse(e, t)
		}, i.prototype.setPhysicsLinkWith = function(t, i, r, n) {
			this.physicsImpostor && t.physicsImpostor && this.physicsImpostor.createJoint(t.physicsImpostor, e.PhysicsJoint.HingeJoint, {
				mainPivot: i,
				connectedPivot: r,
				nativeParams: n
			})
		}, i.prototype.updatePhysicsBodyPosition = function() {
			e.Tools.Warn("updatePhysicsBodyPosition() is deprecated, please use updatePhysicsBody()"), this.updatePhysicsBody()
		}, i.prototype.updatePhysicsBody = function() {}, Object.defineProperty(i.prototype, "checkCollisions", {
			get: function() {
				return this._checkCollisions
			},
			set: function(e) {
				this._checkCollisions = e, this.getScene().workerCollisions && this.getScene().collisionCoordinator.onMeshUpdated(this)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.moveWithCollisions = function(e) {
			var t = this.getAbsolutePosition();
			t.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPositionForCollisions), this._oldPositionForCollisions.addInPlace(this.ellipsoidOffset), this._collider.radius = this.ellipsoid, this.getScene().collisionCoordinator.getNewPosition(this._oldPositionForCollisions, e, this._collider, 3, this, this._onCollisionPositionChange, this.uniqueId)
		}, i.prototype.createOrUpdateSubmeshesOctree = function(t, i) {
			void 0 === t && (t = 64), void 0 === i && (i = 2), this._submeshesOctree || (this._submeshesOctree = new e.Octree(e.Octree.CreationFuncForSubMeshes, t, i)), this.computeWorldMatrix(!0);
			var r = this.getBoundingInfo().boundingBox;
			return this._submeshesOctree.update(r.minimumWorld, r.maximumWorld, this.subMeshes), this._submeshesOctree
		}, i.prototype._collideForSubMesh = function(t, i, r) {
			if (this._generatePointsArray(), !t._lastColliderWorldVertices || !t._lastColliderTransformMatrix.equals(i)) {
				t._lastColliderTransformMatrix = i.clone(), t._lastColliderWorldVertices = [], t._trianglePlanes = [];
				for (var n = t.verticesStart, o = t.verticesStart + t.verticesCount, s = n; s < o; s++) t._lastColliderWorldVertices.push(e.Vector3.TransformCoordinates(this._positions[s], i))
			}
			r._collide(t._trianglePlanes, t._lastColliderWorldVertices, this.getIndices(), t.indexStart, t.indexStart + t.indexCount, t.verticesStart, !!t.getMaterial()), r.collisionFound && (r.collidedMesh = this)
		}, i.prototype._processCollisionsForSubMeshes = function(e, t) {
			var i, r;
			if (this._submeshesOctree && this.useOctreeForCollisions) {
				var n = e.velocityWorldLength + Math.max(e.radius.x, e.radius.y, e.radius.z),
					o = this._submeshesOctree.intersects(e.basePointWorld, n);
				r = o.length, i = o.data
			} else i = this.subMeshes, r = i.length;
			for (var s = 0; s < r; s++) {
				var a = i[s];
				r > 1 && !a._checkCollision(e) || this._collideForSubMesh(a, t, e)
			}
		}, i.prototype._checkCollision = function(t) {
			this._boundingInfo._checkCollision(t) && (e.Matrix.ScalingToRef(1 / t.radius.x, 1 / t.radius.y, 1 / t.radius.z, this._collisionsScalingMatrix), this.worldMatrixFromCache.multiplyToRef(this._collisionsScalingMatrix, this._collisionsTransformMatrix), this._processCollisionsForSubMeshes(t, this._collisionsTransformMatrix))
		}, i.prototype._generatePointsArray = function() {
			return !1
		}, i.prototype.intersects = function(t, i) {
			var r = new e.PickingInfo;
			if (!(this.subMeshes && this._boundingInfo && t.intersectsSphere(this._boundingInfo.boundingSphere) && t.intersectsBox(this._boundingInfo.boundingBox))) return r;
			if (!this._generatePointsArray()) return r;
			var n, o, s = null;
			if (this._submeshesOctree && this.useOctreeForPicking) {
				var a = e.Ray.Transform(t, this.getWorldMatrix()),
					h = this._submeshesOctree.intersectsRay(a);
				o = h.length, n = h.data
			} else n = this.subMeshes, o = n.length;
			for (var c = 0; c < o; c++) {
				var l = n[c];
				if (!(o > 1) || l.canIntersects(t)) {
					var u = l.intersects(t, this._positions, this.getIndices(), i);
					if (u && (i || !s || u.distance < s.distance) && (s = u, s.subMeshId = c, i)) break
				}
			}
			if (s) {
				var d = this.getWorldMatrix(),
					f = e.Vector3.TransformCoordinates(t.origin, d),
					p = t.direction.clone();
				p = p.scale(s.distance);
				var m = e.Vector3.TransformNormal(p, d),
					_ = f.add(m);
				return r.hit = !0, r.distance = e.Vector3.Distance(f, _), r.pickedPoint = _, r.pickedMesh = this, r.bu = s.bu, r.bv = s.bv, r.faceId = s.faceId, r.subMeshId = s.subMeshId, r
			}
			return r
		}, i.prototype.clone = function(e, t, i) {
			return null
		}, i.prototype.releaseSubMeshes = function() {
			if (this.subMeshes)
				for (; this.subMeshes.length;) this.subMeshes[0].dispose();
			else this.subMeshes = new Array
		}, i.prototype.dispose = function(e) {
			var i, r = this;
			for (this.actionManager && (this.actionManager.dispose(), this.actionManager = null), this.skeleton = null, this.getScene().stopAnimation(this), this.physicsImpostor && this.physicsImpostor.dispose(), i = 0; i < this._intersectionsInProgress.length; i++) {
				var n = this._intersectionsInProgress[i],
					o = n._intersectionsInProgress.indexOf(this);
				n._intersectionsInProgress.splice(o, 1)
			}
			this._intersectionsInProgress = [];
			var s = this.getScene().lights;
			if (s.forEach((function(e) {
					var t = e.includedOnlyMeshes.indexOf(r);
					t !== -1 && e.includedOnlyMeshes.splice(t, 1), t = e.excludedMeshes.indexOf(r), t !== -1 && e.excludedMeshes.splice(t, 1);
					var i = e.getShadowGenerator();
					i && (t = i.getShadowMap().renderList.indexOf(r), t !== -1 && i.getShadowMap().renderList.splice(t, 1))
				})), this._edgesRenderer && (this._edgesRenderer.dispose(), this._edgesRenderer = null), this.releaseSubMeshes(), this.getScene().getEngine().unbindAllAttributes(), this.getScene().removeMesh(this), e) {
				var a = this.getChildMeshes(!0);
				for (i = 0; i < a.length; i++) {
					var h = a[i];
					h.parent = null, h.computeWorldMatrix(!0)
				}
			} else {
				for (i = 0; i < this.getScene().particleSystems.length; i++) this.getScene().particleSystems[i].emitter === this && (this.getScene().particleSystems[i].dispose(), i--);
				var c = this.getDescendants(!0);
				for (i = 0; i < c.length; i++) c[i].dispose()
			}
			this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this._isDisposed = !0, t.prototype.dispose.call(this)
		}, i.prototype.getDirection = function(t) {
			var i = e.Vector3.Zero();
			return this.getDirectionToRef(t, i), i
		}, i.prototype.getDirectionToRef = function(t, i) {
			e.Vector3.TransformNormalToRef(t, this.getWorldMatrix(), i)
		}, i.prototype.setPivotPoint = function(t, i) {
			void 0 === i && (i = e.Space.LOCAL), 0 == this.getScene().getRenderId() && this.computeWorldMatrix(!0);
			var r = this.getWorldMatrix();
			if (i == e.Space.WORLD) {
				var n = e.Tmp.Matrix[0];
				r.invertToRef(n), t = e.Vector3.TransformCoordinates(t, n)
			}
			e.Vector3.TransformCoordinatesToRef(t, r, this.position), this._pivotMatrix.m[12] = -t.x, this._pivotMatrix.m[13] = -t.y, this._pivotMatrix.m[14] = -t.z, this._cache.pivotMatrixUpdated = !0
		}, i.prototype.getPivotPoint = function() {
			var t = e.Vector3.Zero();
			return this.getPivotPointToRef(t), t
		}, i.prototype.getPivotPointToRef = function(e) {
			e.x = -this._pivotMatrix.m[12], e.y = -this._pivotMatrix.m[13], e.z = -this._pivotMatrix.m[14]
		}, i.prototype.getAbsolutePivotPoint = function() {
			var t = e.Vector3.Zero();
			return this.getAbsolutePivotPointToRef(t), t
		}, i.prototype.getAbsolutePivotPointToRef = function(t) {
			t.x = this._pivotMatrix.m[12], t.y = this._pivotMatrix.m[13], t.z = this._pivotMatrix.m[14], this.getPivotPointToRef(t), e.Vector3.TransformCoordinatesToRef(t, this.getWorldMatrix(), t)
		}, i._BILLBOARDMODE_NONE = 0, i._BILLBOARDMODE_X = 1, i._BILLBOARDMODE_Y = 2, i._BILLBOARDMODE_Z = 4, i._BILLBOARDMODE_ALL = 7, i._rotationAxisCache = new e.Quaternion, i._lookAtVectorCache = new e.Vector3(0, 0, 0), i
	})(e.Node);
	e.AbstractMesh = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r) {
			t.call(this, i, r), this.diffuse = new e.Color3(1, 1, 1), this.specular = new e.Color3(1, 1, 1), this.intensity = 1, this.range = Number.MAX_VALUE, this.includeOnlyWithLayerMask = 0, this.includedOnlyMeshes = new Array, this.excludedMeshes = new Array, this.excludeWithLayerMask = 0, this.lightmapMode = 0, this.radius = 1e-5, this._excludedMeshesIds = new Array, this._includedOnlyMeshesIds = new Array, r.addLight(this)
		}
		return __extends(i, t), Object.defineProperty(i, "LIGHTMAP_DEFAULT", {
			get: function() {
				return i._LIGHTMAP_DEFAULT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "LIGHTMAP_SPECULAR", {
			get: function() {
				return i._LIGHTMAP_SPECULAR
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "LIGHTMAP_SHADOWSONLY", {
			get: function() {
				return i._LIGHTMAP_SHADOWSONLY
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.toString = function(e) {
			var t = "Name: " + this.name;
			if (t += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()], this.animations)
				for (var i = 0; i < this.animations.length; i++) t += ", animation[0]: " + this.animations[i].toString(e);
			return t
		}, i.prototype.getShadowGenerator = function() {
			return this._shadowGenerator
		}, i.prototype.getAbsolutePosition = function() {
			return e.Vector3.Zero()
		}, i.prototype.transferToEffect = function(e, t, i) {}, i.prototype._getWorldMatrix = function() {
			return e.Matrix.Identity()
		}, i.prototype.canAffectMesh = function(e) {
			return !e || !(this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(e) === -1) && (!(this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(e) !== -1) && ((0 === this.includeOnlyWithLayerMask || 0 !== (this.includeOnlyWithLayerMask & e.layerMask)) && !(0 !== this.excludeWithLayerMask && this.excludeWithLayerMask & e.layerMask)))
		}, i.prototype.getWorldMatrix = function() {
			this._currentRenderId = this.getScene().getRenderId();
			var t = this._getWorldMatrix();
			return this.parent && this.parent.getWorldMatrix ? (this._parentedWorldMatrix || (this._parentedWorldMatrix = e.Matrix.Identity()), t.multiplyToRef(this.parent.getWorldMatrix(), this._parentedWorldMatrix), this._markSyncedWithParent(), this._parentedWorldMatrix) : t
		}, i.prototype.dispose = function() {
			this._shadowGenerator && (this._shadowGenerator.dispose(), this._shadowGenerator = null), this.getScene().stopAnimation(this), this.getScene().removeLight(this), t.prototype.dispose.call(this)
		}, i.prototype.getTypeID = function() {
			return 0
		}, i.prototype.clone = function(t) {
			return e.SerializationHelper.Clone(i.GetConstructorFromName(this.getTypeID(), t, this.getScene()), this)
		}, i.prototype.serialize = function() {
			var t = e.SerializationHelper.Serialize(this);
			return t.type = this.getTypeID(), this.parent && (t.parentId = this.parent.id), this.excludedMeshes.length > 0 && (t.excludedMeshesIds = [], this.excludedMeshes.forEach((function(e) {
				t.excludedMeshesIds.push(e.id)
			}))), this.includedOnlyMeshes.length > 0 && (t.includedOnlyMeshesIds = [], this.includedOnlyMeshes.forEach((function(e) {
				t.includedOnlyMeshesIds.push(e.id)
			}))), e.Animation.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t
		}, i.GetConstructorFromName = function(t, i, r) {
			switch (t) {
				case 0:
					return function() {
						return new e.PointLight(i, e.Vector3.Zero(), r)
					};
				case 1:
					return function() {
						return new e.DirectionalLight(i, e.Vector3.Zero(), r)
					};
				case 2:
					return function() {
						return new e.SpotLight(i, e.Vector3.Zero(), e.Vector3.Zero(), 0, 0, r)
					};
				case 3:
					return function() {
						return new e.HemisphericLight(i, e.Vector3.Zero(), r)
					}
			}
		}, i.Parse = function(t, r) {
			var n = e.SerializationHelper.Parse(i.GetConstructorFromName(t.type, t.name, r), t, r);
			if (t.excludedMeshesIds && (n._excludedMeshesIds = t.excludedMeshesIds), t.includedOnlyMeshesIds && (n._includedOnlyMeshesIds = t.includedOnlyMeshesIds), t.parentId && (n._waitingParentId = t.parentId), t.animations) {
				for (var o = 0; o < t.animations.length; o++) {
					var s = t.animations[o];
					n.animations.push(e.Animation.Parse(s))
				}
				e.Node.ParseAnimationRanges(n, t, r)
			}
			return t.autoAnimate && r.beginAnimation(n, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), n
		}, i._LIGHTMAP_DEFAULT = 0, i._LIGHTMAP_SPECULAR = 1, i._LIGHTMAP_SHADOWSONLY = 2, __decorate([e.serializeAsColor3()], i.prototype, "diffuse", void 0), __decorate([e.serializeAsColor3()], i.prototype, "specular", void 0), __decorate([e.serialize()], i.prototype, "intensity", void 0), __decorate([e.serialize()], i.prototype, "range", void 0), __decorate([e.serialize()], i.prototype, "includeOnlyWithLayerMask", void 0), __decorate([e.serialize()], i.prototype, "excludeWithLayerMask", void 0), __decorate([e.serialize()], i.prototype, "lightmapMode", void 0), __decorate([e.serialize()], i.prototype, "radius", void 0), i
	})(e.Node);
	e.Light = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r) {
			t.call(this, e, r), this.position = i
		}
		return __extends(i, t), i.prototype.getAbsolutePosition = function() {
			return this.transformedPosition ? this.transformedPosition : this.position
		}, i.prototype.computeTransformedPosition = function() {
			return !(!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition || (this.transformedPosition = e.Vector3.Zero()), e.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), !0)
		}, i.prototype.transferToEffect = function(e, t) {
			return this.parent && this.parent.getWorldMatrix ? (this.computeTransformedPosition(), void e.setFloat4(t, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0)) : void e.setFloat4(t, this.position.x, this.position.y, this.position.z, 0)
		}, i.prototype.needCube = function() {
			return !0
		}, i.prototype.supportsVSM = function() {
			return !1
		}, i.prototype.needRefreshPerFrame = function() {
			return !1
		}, i.prototype.getShadowDirection = function(t) {
			switch (t) {
				case 0:
					return new e.Vector3(1, 0, 0);
				case 1:
					return new e.Vector3((-1), 0, 0);
				case 2:
					return new e.Vector3(0, (-1), 0);
				case 3:
					return new e.Vector3(0, 1, 0);
				case 4:
					return new e.Vector3(0, 0, 1);
				case 5:
					return new e.Vector3(0, 0, (-1))
			}
			return e.Vector3.Zero()
		}, i.prototype.setShadowProjectionMatrix = function(t, i, r) {
			var n = this.getScene().activeCamera;
			e.Matrix.PerspectiveFovLHToRef(Math.PI / 2, 1, n.minZ, n.maxZ, t)
		}, i.prototype._getWorldMatrix = function() {
			return this._worldMatrix || (this._worldMatrix = e.Matrix.Identity()), e.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this._worldMatrix
		}, i.prototype.getTypeID = function() {
			return 0
		}, __decorate([e.serializeAsVector3()], i.prototype, "position", void 0), i
	})(e.Light);
	e.PointLight = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r, n, o, s) {
			t.call(this, e, s), this.position = i, this.direction = r, this.angle = n, this.exponent = o
		}
		return __extends(i, t), i.prototype.getAbsolutePosition = function() {
			return this.transformedPosition ? this.transformedPosition : this.position
		}, i.prototype.setShadowProjectionMatrix = function(t, i, r) {
			var n = this.getScene().activeCamera;
			e.Matrix.PerspectiveFovLHToRef(this.angle, 1, n.minZ, n.maxZ, t)
		}, i.prototype.needCube = function() {
			return !1
		}, i.prototype.supportsVSM = function() {
			return !0
		}, i.prototype.needRefreshPerFrame = function() {
			return !1
		}, i.prototype.getShadowDirection = function(e) {
			return this.direction
		}, i.prototype.setDirectionToTarget = function(t) {
			return this.direction = e.Vector3.Normalize(t.subtract(this.position)), this.direction
		}, i.prototype.computeTransformedPosition = function() {
			return !(!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition || (this.transformedPosition = e.Vector3.Zero()), e.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), !0)
		}, i.prototype.transferToEffect = function(t, i, r) {
			var n;
			this.parent && this.parent.getWorldMatrix ? (this._transformedDirection || (this._transformedDirection = e.Vector3.Zero()), this.computeTransformedPosition(), e.Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this._transformedDirection), t.setFloat4(i, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent), n = e.Vector3.Normalize(this._transformedDirection)) : (t.setFloat4(i, this.position.x, this.position.y, this.position.z, this.exponent), n = e.Vector3.Normalize(this.direction)), t.setFloat4(r, n.x, n.y, n.z, Math.cos(.5 * this.angle))
		}, i.prototype._getWorldMatrix = function() {
			return this._worldMatrix || (this._worldMatrix = e.Matrix.Identity()), e.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this._worldMatrix
		}, i.prototype.getTypeID = function() {
			return 2
		}, i.prototype.getRotation = function() {
			this.direction.normalize();
			var t = e.Vector3.Cross(this.direction, e.Axis.Y),
				i = e.Vector3.Cross(t, this.direction);
			return e.Vector3.RotationFromAxis(t, i, this.direction)
		}, __decorate([e.serializeAsVector3()], i.prototype, "position", void 0), __decorate([e.serializeAsVector3()], i.prototype, "direction", void 0), __decorate([e.serialize()], i.prototype, "angle", void 0), __decorate([e.serialize()], i.prototype, "exponent", void 0), i
	})(e.Light);
	e.SpotLight = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n) {
			t.call(this, i, n), this.groundColor = new e.Color3(0, 0, 0), this.direction = r
		}
		return __extends(i, t), i.prototype.setDirectionToTarget = function(t) {
			return this.direction = e.Vector3.Normalize(t.subtract(e.Vector3.Zero())), this.direction
		}, i.prototype.getShadowGenerator = function() {
			return null
		}, i.prototype.transferToEffect = function(t, i, r) {
			var n = e.Vector3.Normalize(this.direction);
			t.setFloat4(i, n.x, n.y, n.z, 0), t.setColor3(r, this.groundColor.scale(this.intensity))
		}, i.prototype._getWorldMatrix = function() {
			return this._worldMatrix || (this._worldMatrix = e.Matrix.Identity()), this._worldMatrix
		}, i.prototype.getTypeID = function() {
			return 3
		}, __decorate([e.serializeAsColor3()], i.prototype, "groundColor", void 0), __decorate([e.serializeAsVector3()], i.prototype, "direction", void 0), i
	})(e.Light);
	e.HemisphericLight = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r) {
			t.call(this, e, r), this.shadowOrthoScale = .5, this.autoUpdateExtends = !0, this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE, this.position = i.scale(-1), this.direction = i
		}
		return __extends(i, t), i.prototype.getAbsolutePosition = function() {
			return this.transformedPosition ? this.transformedPosition : this.position
		}, i.prototype.setDirectionToTarget = function(t) {
			return this.direction = e.Vector3.Normalize(t.subtract(this.position)), this.direction
		}, i.prototype.setShadowProjectionMatrix = function(t, i, r) {
			var n = this.getScene().activeCamera;
			if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
				var o = e.Vector3.Zero();
				this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE;
				for (var s = 0; s < r.length; s++) {
					var a = r[s];
					if (a) {
						var h = a.getBoundingInfo();
						if (h)
							for (var c = h.boundingBox, l = 0; l < c.vectorsWorld.length; l++) e.Vector3.TransformCoordinatesToRef(c.vectorsWorld[l], i, o), o.x < this._orthoLeft && (this._orthoLeft = o.x), o.y < this._orthoBottom && (this._orthoBottom = o.y), o.x > this._orthoRight && (this._orthoRight = o.x), o.y > this._orthoTop && (this._orthoTop = o.y)
					}
				}
			}
			var u = this._orthoRight - this._orthoLeft,
				d = this._orthoTop - this._orthoBottom;
			e.Matrix.OrthoOffCenterLHToRef(this._orthoLeft - u * this.shadowOrthoScale, this._orthoRight + u * this.shadowOrthoScale, this._orthoBottom - d * this.shadowOrthoScale, this._orthoTop + d * this.shadowOrthoScale, -n.maxZ, n.maxZ, t)
		}, i.prototype.supportsVSM = function() {
			return !0
		}, i.prototype.needRefreshPerFrame = function() {
			return !0
		}, i.prototype.needCube = function() {
			return !1
		}, i.prototype.getShadowDirection = function(e) {
			return this.direction
		}, i.prototype.computeTransformedPosition = function() {
			return !(!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition || (this.transformedPosition = e.Vector3.Zero()), e.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), !0)
		}, i.prototype.transferToEffect = function(t, i) {
			return this.parent && this.parent.getWorldMatrix ? (this._transformedDirection || (this._transformedDirection = e.Vector3.Zero()), e.Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this._transformedDirection), void t.setFloat4(i, this._transformedDirection.x, this._transformedDirection.y, this._transformedDirection.z, 1)) : void t.setFloat4(i, this.direction.x, this.direction.y, this.direction.z, 1)
		}, i.prototype._getWorldMatrix = function() {
			return this._worldMatrix || (this._worldMatrix = e.Matrix.Identity()), e.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this._worldMatrix
		}, i.prototype.getTypeID = function() {
			return 1
		}, __decorate([e.serializeAsVector3()], i.prototype, "position", void 0), __decorate([e.serializeAsVector3()], i.prototype, "direction", void 0), __decorate([e.serialize()], i.prototype, "shadowOrthoScale", void 0), __decorate([e.serialize()], i.prototype, "autoUpdateExtends", void 0), i
	})(e.Light);
	e.DirectionalLight = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(i, r) {
			var n = this;
			this._filter = t.FILTER_NONE, this.blurScale = 2, this._blurBoxOffset = 0, this._bias = 5e-5, this._lightDirection = e.Vector3.Zero(), this.forceBackFacesOnly = !1, this._darkness = 0, this._transparencyShadow = !1, this._viewMatrix = e.Matrix.Zero(), this._projectionMatrix = e.Matrix.Zero(), this._transformMatrix = e.Matrix.Zero(), this._worldViewProjection = e.Matrix.Zero(), this._currentFaceIndex = 0, this._currentFaceIndexCache = 0, this._useFullFloat = !0, this._light = r, this._scene = r.getScene(), this._mapSize = i, r._shadowGenerator = this;
			var o, s = this._scene.getEngine().getCaps();
			s.textureFloat && s.textureFloatLinearFiltering && s.textureFloatRender ? (this._useFullFloat = !0, o = e.Engine.TEXTURETYPE_FLOAT) : (this._useFullFloat = !1, o = e.Engine.TEXTURETYPE_UNSIGNED_INT), this._shadowMap = new e.RenderTargetTexture(r.name + "_shadowMap", i, this._scene, (!1), (!0), o, r.needCube()),
				this._shadowMap.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode(e.Texture.NEAREST_SAMPLINGMODE), this._shadowMap.renderParticles = !1, this._shadowMap.onBeforeRenderObservable.add((function(e) {
					n._currentFaceIndex = e
				})), this._shadowMap.onAfterUnbindObservable.add((function() {
					n.useBlurVarianceShadowMap && (n._shadowMap2 || (n._shadowMap2 = new e.RenderTargetTexture(r.name + "_shadowMap", i, n._scene, (!1), (!0), o), n._shadowMap2.wrapU = e.Texture.CLAMP_ADDRESSMODE, n._shadowMap2.wrapV = e.Texture.CLAMP_ADDRESSMODE, n._shadowMap2.updateSamplingMode(e.Texture.TRILINEAR_SAMPLINGMODE), n._downSamplePostprocess = new e.PassPostProcess("downScale", 1 / n.blurScale, null, e.Texture.BILINEAR_SAMPLINGMODE, n._scene.getEngine()), n._downSamplePostprocess.onApplyObservable.add((function(e) {
						e.setTexture("textureSampler", n._shadowMap)
					})), n.blurBoxOffset = 1), n._scene.postProcessManager.directRender([n._downSamplePostprocess, n._boxBlurPostprocess], n._shadowMap2.getInternalTexture()))
				}));
			var a = function(t) {
				var i = t.getRenderingMesh(),
					r = n._scene,
					o = r.getEngine();
				o.setState(t.getMaterial().backFaceCulling);
				var s = i._getInstancesRenderList(t._id);
				if (!s.mustReturn) {
					var a = null !== o.getCaps().instancedArrays && null !== s.visibleInstances[t._id] && void 0 !== s.visibleInstances[t._id];
					if (n.isReady(t, a)) {
						o.enableEffect(n._effect), i._bind(t, n._effect, e.Material.TriangleFillMode);
						var h = t.getMaterial();
						if (n._effect.setMatrix("viewProjection", n.getTransformMatrix()), n._effect.setVector3("lightPosition", n.getLight().position), n.getLight().needCube() && n._effect.setFloat2("depthValues", r.activeCamera.minZ, r.activeCamera.maxZ), h && h.needAlphaTesting()) {
							var c = h.getAlphaTestTexture();
							n._effect.setTexture("diffuseSampler", c), n._effect.setMatrix("diffuseMatrix", c.getTextureMatrix())
						}
						i.useBones && i.computeBonesUsingShaders && n._effect.setMatrices("mBones", i.skeleton.getTransformMatrices(i)), n.forceBackFacesOnly && o.setState(!0, 0, !1, !0), i._processRendering(t, n._effect, e.Material.TriangleFillMode, s, a, (function(e, t) {
							return n._effect.setMatrix("world", t)
						})), n.forceBackFacesOnly && o.setState(!0, 0, !1, !1)
					} else n._shadowMap.resetRefreshCounter()
				}
			};
			this._shadowMap.customRenderFunction = function(e, t, i) {
				var r;
				for (r = 0; r < e.length; r++) a(e.data[r]);
				for (r = 0; r < t.length; r++) a(t.data[r]);
				if (n._transparencyShadow)
					for (r = 0; r < i.length; r++) a(i.data[r])
			}, this._shadowMap.onClearObservable.add((function(t) {
				n.useBlurVarianceShadowMap || n.useVarianceShadowMap ? t.clear(new e.Color4(0, 0, 0, 0), !0, !0, !0) : t.clear(new e.Color4(1, 1, 1, 1), !0, !0, !0)
			}))
		}
		return Object.defineProperty(t, "FILTER_NONE", {
			get: function() {
				return t._FILTER_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "FILTER_VARIANCESHADOWMAP", {
			get: function() {
				return t._FILTER_VARIANCESHADOWMAP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "FILTER_POISSONSAMPLING", {
			get: function() {
				return t._FILTER_POISSONSAMPLING
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "FILTER_BLURVARIANCESHADOWMAP", {
			get: function() {
				return t._FILTER_BLURVARIANCESHADOWMAP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "bias", {
			get: function() {
				return this._bias
			},
			set: function(e) {
				this._bias = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "blurBoxOffset", {
			get: function() {
				return this._blurBoxOffset
			},
			set: function(t) {
				var i = this;
				this._blurBoxOffset !== t && (this._blurBoxOffset = t, this._boxBlurPostprocess && this._boxBlurPostprocess.dispose(), this._boxBlurPostprocess = new e.PostProcess("DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1 / this.blurScale, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1), "#define OFFSET " + t), this._boxBlurPostprocess.onApplyObservable.add((function(e) {
					e.setFloat2("screenSize", i._mapSize / i.blurScale, i._mapSize / i.blurScale)
				})))
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "filter", {
			get: function() {
				return this._filter
			},
			set: function(t) {
				this._filter !== t && (this._filter = t, this.useVarianceShadowMap || this.useBlurVarianceShadowMap || this.usePoissonSampling ? (this._shadowMap.anisotropicFilteringLevel = 16, this._shadowMap.updateSamplingMode(e.Texture.BILINEAR_SAMPLINGMODE)) : (this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode(e.Texture.NEAREST_SAMPLINGMODE)))
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "useVarianceShadowMap", {
			get: function() {
				return this.filter === t.FILTER_VARIANCESHADOWMAP && this._light.supportsVSM()
			},
			set: function(e) {
				this.filter = e ? t.FILTER_VARIANCESHADOWMAP : t.FILTER_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "usePoissonSampling", {
			get: function() {
				return this.filter === t.FILTER_POISSONSAMPLING || !this._light.supportsVSM() && (this.filter === t.FILTER_VARIANCESHADOWMAP || this.filter === t.FILTER_BLURVARIANCESHADOWMAP)
			},
			set: function(e) {
				this.filter = e ? t.FILTER_POISSONSAMPLING : t.FILTER_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "useBlurVarianceShadowMap", {
			get: function() {
				return this.filter === t.FILTER_BLURVARIANCESHADOWMAP && this._light.supportsVSM()
			},
			set: function(e) {
				this.filter = e ? t.FILTER_BLURVARIANCESHADOWMAP : t.FILTER_NONE
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.isReady = function(t, i) {
			var r = [];
			this._useFullFloat && r.push("#define FULLFLOAT"), (this.useVarianceShadowMap || this.useBlurVarianceShadowMap) && r.push("#define VSM"), this.getLight().needCube() && r.push("#define CUBEMAP");
			var n = [e.VertexBuffer.PositionKind],
				o = t.getMesh(),
				s = t.getMaterial();
			if (s && s.needAlphaTesting() && (r.push("#define ALPHATEST"), o.isVerticesDataPresent(e.VertexBuffer.UVKind) && (n.push(e.VertexBuffer.UVKind), r.push("#define UV1")), o.isVerticesDataPresent(e.VertexBuffer.UV2Kind))) {
				var a = s.getAlphaTestTexture();
				1 === a.coordinatesIndex && (n.push(e.VertexBuffer.UV2Kind), r.push("#define UV2"))
			}
			o.useBones && o.computeBonesUsingShaders ? (n.push(e.VertexBuffer.MatricesIndicesKind), n.push(e.VertexBuffer.MatricesWeightsKind), o.numBoneInfluencers > 4 && (n.push(e.VertexBuffer.MatricesIndicesExtraKind), n.push(e.VertexBuffer.MatricesWeightsExtraKind)), r.push("#define NUM_BONE_INFLUENCERS " + o.numBoneInfluencers), r.push("#define BonesPerMesh " + (o.skeleton.bones.length + 1))) : r.push("#define NUM_BONE_INFLUENCERS 0"), i && (r.push("#define INSTANCES"), n.push("world0"), n.push("world1"), n.push("world2"), n.push("world3"));
			var h = r.join("\n");
			return this._cachedDefines !== h && (this._cachedDefines = h, this._effect = this._scene.getEngine().createEffect("shadowMap", n, ["world", "mBones", "viewProjection", "diffuseMatrix", "lightPosition", "depthValues"], ["diffuseSampler"], h)), this._effect.isReady()
		}, t.prototype.getShadowMap = function() {
			return this._shadowMap
		}, t.prototype.getShadowMapForRendering = function() {
			return this._shadowMap2 ? this._shadowMap2 : this._shadowMap
		}, t.prototype.getLight = function() {
			return this._light
		}, t.prototype.getTransformMatrix = function() {
			var t = this._scene;
			if (this._currentRenderID === t.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) return this._transformMatrix;
			this._currentRenderID = t.getRenderId(), this._currentFaceIndexCache = this._currentFaceIndex;
			var i = this._light.position;
			return e.Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection), 1 === Math.abs(e.Vector3.Dot(this._lightDirection, e.Vector3.Up())) && (this._lightDirection.z = 1e-13), this._light.computeTransformedPosition() && (i = this._light.transformedPosition), !this._light.needRefreshPerFrame() && this._cachedPosition && this._cachedDirection && i.equals(this._cachedPosition) && this._lightDirection.equals(this._cachedDirection) || (this._cachedPosition = i.clone(), this._cachedDirection = this._lightDirection.clone(), e.Matrix.LookAtLHToRef(i, i.add(this._lightDirection), e.Vector3.Up(), this._viewMatrix), this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, this.getShadowMap().renderList), this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix)), this._transformMatrix
		}, t.prototype.getDarkness = function() {
			return this._darkness
		}, t.prototype.setDarkness = function(e) {
			e >= 1 ? this._darkness = 1 : e <= 0 ? this._darkness = 0 : this._darkness = e
		}, t.prototype.setTransparencyShadow = function(e) {
			this._transparencyShadow = e
		}, t.prototype._packHalf = function(t) {
			var i = 255 * t,
				r = i - Math.floor(i);
			return new e.Vector2(t - r / 255, r)
		}, t.prototype.dispose = function() {
			this._shadowMap.dispose(), this._shadowMap2 && this._shadowMap2.dispose(), this._downSamplePostprocess && this._downSamplePostprocess.dispose(), this._boxBlurPostprocess && this._boxBlurPostprocess.dispose()
		}, t.prototype.serialize = function() {
			var e = {};
			e.lightId = this._light.id, e.mapSize = this.getShadowMap().getRenderSize(), e.useVarianceShadowMap = this.useVarianceShadowMap, e.usePoissonSampling = this.usePoissonSampling, e.forceBackFacesOnly = this.forceBackFacesOnly, e.renderList = [];
			for (var t = 0; t < this.getShadowMap().renderList.length; t++) {
				var i = this.getShadowMap().renderList[t];
				e.renderList.push(i.id)
			}
			return e
		}, t.Parse = function(e, i) {
			for (var r = i.getLightByID(e.lightId), n = new t(e.mapSize, r), o = 0; o < e.renderList.length; o++) {
				var s = i.getMeshesByID(e.renderList[o]);
				s.forEach((function(e) {
					n.getShadowMap().renderList.push(e)
				}))
			}
			return e.usePoissonSampling ? n.usePoissonSampling = !0 : e.useVarianceShadowMap ? n.useVarianceShadowMap = !0 : e.useBlurVarianceShadowMap && (n.useBlurVarianceShadowMap = !0, e.blurScale && (n.blurScale = e.blurScale), e.blurBoxOffset && (n.blurBoxOffset = e.blurBoxOffset)), void 0 !== e.bias && (n.bias = e.bias), n.forceBackFacesOnly = e.forceBackFacesOnly, n
		}, t._FILTER_NONE = 0, t._FILTER_VARIANCESHADOWMAP = 1, t._FILTER_POISSONSAMPLING = 2, t._FILTER_BLURVARIANCESHADOWMAP = 3, t
	})();
	e.ShadowGenerator = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = function(e, t, i, r) {
			return !(e.x > i.x + r) && (!(i.x - r > t.x) && (!(e.y > i.y + r) && (!(i.y - r > t.y) && (!(e.z > i.z + r) && !(i.z - r > t.z)))))
		},
		i = (function() {
			var e = {
				root: 0,
				found: !1
			};
			return function(t, i, r, n) {
				e.root = 0, e.found = !1;
				var o = i * i - 4 * t * r;
				if (o < 0) return e;
				var s = Math.sqrt(o),
					a = (-i - s) / (2 * t),
					h = (-i + s) / (2 * t);
				if (a > h) {
					var c = h;
					h = a, a = c
				}
				return a > 0 && a < n ? (e.root = a, e.found = !0, e) : h > 0 && h < n ? (e.root = h, e.found = !0, e) : e
			}
		})(),
		r = (function() {
			function r() {
				this.radius = new e.Vector3(1, 1, 1), this.retry = 0, this.basePointWorld = e.Vector3.Zero(), this.velocityWorld = e.Vector3.Zero(), this.normalizedVelocity = e.Vector3.Zero(), this._collisionPoint = e.Vector3.Zero(), this._planeIntersectionPoint = e.Vector3.Zero(), this._tempVector = e.Vector3.Zero(), this._tempVector2 = e.Vector3.Zero(), this._tempVector3 = e.Vector3.Zero(), this._tempVector4 = e.Vector3.Zero(), this._edge = e.Vector3.Zero(), this._baseToVertex = e.Vector3.Zero(), this._destinationPoint = e.Vector3.Zero(), this._slidePlaneNormal = e.Vector3.Zero(), this._displacementVector = e.Vector3.Zero()
			}
			return r.prototype._initialize = function(t, i, r) {
				this.velocity = i, e.Vector3.NormalizeToRef(i, this.normalizedVelocity), this.basePoint = t, t.multiplyToRef(this.radius, this.basePointWorld), i.multiplyToRef(this.radius, this.velocityWorld), this.velocityWorldLength = this.velocityWorld.length(), this.epsilon = r, this.collisionFound = !1
			}, r.prototype._checkPointInTriangle = function(t, i, r, n, o) {
				i.subtractToRef(t, this._tempVector), r.subtractToRef(t, this._tempVector2), e.Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);
				var s = e.Vector3.Dot(this._tempVector4, o);
				return !(s < 0) && (n.subtractToRef(t, this._tempVector3), e.Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4), s = e.Vector3.Dot(this._tempVector4, o), !(s < 0) && (e.Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4), s = e.Vector3.Dot(this._tempVector4, o), s >= 0))
			}, r.prototype._canDoCollision = function(i, r, n, o) {
				var s = e.Vector3.Distance(this.basePointWorld, i),
					a = Math.max(this.radius.x, this.radius.y, this.radius.z);
				return !(s > this.velocityWorldLength + a + r) && !!t(n, o, this.basePointWorld, this.velocityWorldLength + a)
			}, r.prototype._testTriangle = function(t, r, n, o, s, a) {
				var h, c = !1;
				r || (r = []), r[t] || (r[t] = new e.Plane(0, 0, 0, 0), r[t].copyFromPoints(n, o, s));
				var l = r[t];
				if (a || l.isFrontFacingTo(this.normalizedVelocity, 0)) {
					var u = l.signedDistanceTo(this.basePoint),
						d = e.Vector3.Dot(l.normal, this.velocity);
					if (0 == d) {
						if (Math.abs(u) >= 1) return;
						c = !0, h = 0
					} else {
						h = (-1 - u) / d;
						var f = (1 - u) / d;
						if (h > f) {
							var p = f;
							f = h, h = p
						}
						if (h > 1 || f < 0) return;
						h < 0 && (h = 0), h > 1 && (h = 1)
					}
					this._collisionPoint.copyFromFloats(0, 0, 0);
					var m = !1,
						_ = 1;
					if (c || (this.basePoint.subtractToRef(l.normal, this._planeIntersectionPoint), this.velocity.scaleToRef(h, this._tempVector), this._planeIntersectionPoint.addInPlace(this._tempVector), this._checkPointInTriangle(this._planeIntersectionPoint, n, o, s, l.normal) && (m = !0, _ = h, this._collisionPoint.copyFrom(this._planeIntersectionPoint))), !m) {
						var g = this.velocity.lengthSquared(),
							v = g;
						this.basePoint.subtractToRef(n, this._tempVector);
						var y = 2 * e.Vector3.Dot(this.velocity, this._tempVector),
							x = this._tempVector.lengthSquared() - 1,
							b = i(v, y, x, _);
						b.found && (_ = b.root, m = !0, this._collisionPoint.copyFrom(n)), this.basePoint.subtractToRef(o, this._tempVector), y = 2 * e.Vector3.Dot(this.velocity, this._tempVector), x = this._tempVector.lengthSquared() - 1, b = i(v, y, x, _), b.found && (_ = b.root, m = !0, this._collisionPoint.copyFrom(o)), this.basePoint.subtractToRef(s, this._tempVector), y = 2 * e.Vector3.Dot(this.velocity, this._tempVector), x = this._tempVector.lengthSquared() - 1, b = i(v, y, x, _), b.found && (_ = b.root, m = !0, this._collisionPoint.copyFrom(s)), o.subtractToRef(n, this._edge), n.subtractToRef(this.basePoint, this._baseToVertex);
						var T = this._edge.lengthSquared(),
							A = e.Vector3.Dot(this._edge, this.velocity),
							E = e.Vector3.Dot(this._edge, this._baseToVertex);
						if (v = T * -g + A * A, y = T * (2 * e.Vector3.Dot(this.velocity, this._baseToVertex)) - 2 * A * E, x = T * (1 - this._baseToVertex.lengthSquared()) + E * E, b = i(v, y, x, _), b.found) {
							var P = (A * b.root - E) / T;
							P >= 0 && P <= 1 && (_ = b.root, m = !0, this._edge.scaleInPlace(P), n.addToRef(this._edge, this._collisionPoint))
						}
						s.subtractToRef(o, this._edge), o.subtractToRef(this.basePoint, this._baseToVertex), T = this._edge.lengthSquared(), A = e.Vector3.Dot(this._edge, this.velocity), E = e.Vector3.Dot(this._edge, this._baseToVertex), v = T * -g + A * A, y = T * (2 * e.Vector3.Dot(this.velocity, this._baseToVertex)) - 2 * A * E, x = T * (1 - this._baseToVertex.lengthSquared()) + E * E, b = i(v, y, x, _), b.found && (P = (A * b.root - E) / T, P >= 0 && P <= 1 && (_ = b.root, m = !0, this._edge.scaleInPlace(P), o.addToRef(this._edge, this._collisionPoint))), n.subtractToRef(s, this._edge), s.subtractToRef(this.basePoint, this._baseToVertex), T = this._edge.lengthSquared(), A = e.Vector3.Dot(this._edge, this.velocity), E = e.Vector3.Dot(this._edge, this._baseToVertex), v = T * -g + A * A, y = T * (2 * e.Vector3.Dot(this.velocity, this._baseToVertex)) - 2 * A * E, x = T * (1 - this._baseToVertex.lengthSquared()) + E * E, b = i(v, y, x, _), b.found && (P = (A * b.root - E) / T, P >= 0 && P <= 1 && (_ = b.root, m = !0, this._edge.scaleInPlace(P), s.addToRef(this._edge, this._collisionPoint)))
					}
					if (m) {
						var M = _ * this.velocity.length();
						(!this.collisionFound || M < this.nearestDistance) && (this.intersectionPoint ? this.intersectionPoint.copyFrom(this._collisionPoint) : this.intersectionPoint = this._collisionPoint.clone(), this.nearestDistance = M, this.collisionFound = !0)
					}
				}
			}, r.prototype._collide = function(e, t, i, r, n, o, s) {
				for (var a = r; a < n; a += 3) {
					var h = t[i[a] - o],
						c = t[i[a + 1] - o],
						l = t[i[a + 2] - o];
					this._testTriangle(a, e, l, c, h, s)
				}
			}, r.prototype._getResponse = function(t, i) {
				t.addToRef(i, this._destinationPoint), i.scaleInPlace(this.nearestDistance / i.length()), this.basePoint.addToRef(i, t), t.subtractToRef(this.intersectionPoint, this._slidePlaneNormal), this._slidePlaneNormal.normalize(), this._slidePlaneNormal.scaleToRef(this.epsilon, this._displacementVector), t.addInPlace(this._displacementVector), this.intersectionPoint.addInPlace(this._displacementVector), this._slidePlaneNormal.scaleInPlace(e.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint)), this._destinationPoint.subtractInPlace(this._slidePlaneNormal), this._destinationPoint.subtractToRef(this.intersectionPoint, i)
			}, r
		})();
	e.Collider = r
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	e.CollisionWorker = "", (function(e) {
		e[e.INIT = 0] = "INIT", e[e.UPDATE = 1] = "UPDATE", e[e.COLLIDE = 2] = "COLLIDE"
	})(e.WorkerTaskType || (e.WorkerTaskType = {}));
	var t = e.WorkerTaskType;
	!(function(e) {
		e[e.SUCCESS = 0] = "SUCCESS", e[e.UNKNOWN_ERROR = 1] = "UNKNOWN_ERROR"
	})(e.WorkerReplyType || (e.WorkerReplyType = {}));
	var i = e.WorkerReplyType,
		r = (function() {
			function r() {
				var n = this;
				this._scaledPosition = e.Vector3.Zero(), this._scaledVelocity = e.Vector3.Zero(), this.onMeshUpdated = function(e) {
					n._addUpdateMeshesList[e.uniqueId] = r.SerializeMesh(e)
				}, this.onGeometryUpdated = function(e) {
					n._addUpdateGeometriesList[e.id] = r.SerializeGeometry(e)
				}, this._afterRender = function() {
					if (n._init && !(0 == n._toRemoveGeometryArray.length && 0 == n._toRemoveMeshesArray.length && 0 == Object.keys(n._addUpdateGeometriesList).length && 0 == Object.keys(n._addUpdateMeshesList).length || n._runningUpdated > 4)) {
						++n._runningUpdated;
						var e = {
								updatedMeshes: n._addUpdateMeshesList,
								updatedGeometries: n._addUpdateGeometriesList,
								removedGeometries: n._toRemoveGeometryArray,
								removedMeshes: n._toRemoveMeshesArray
							},
							i = {
								payload: e,
								taskType: t.UPDATE
							},
							r = [];
						for (var o in e.updatedGeometries) e.updatedGeometries.hasOwnProperty(o) && (r.push(i.payload.updatedGeometries[o].indices.buffer), r.push(i.payload.updatedGeometries[o].normals.buffer), r.push(i.payload.updatedGeometries[o].positions.buffer));
						n._worker.postMessage(i, r), n._addUpdateMeshesList = {}, n._addUpdateGeometriesList = {}, n._toRemoveGeometryArray = [], n._toRemoveMeshesArray = []
					}
				}, this._onMessageFromWorker = function(r) {
					var o = r.data;
					if (o.error != i.SUCCESS) return void e.Tools.Warn("error returned from worker!");
					switch (o.taskType) {
						case t.INIT:
							n._init = !0, n._scene.meshes.forEach((function(e) {
								n.onMeshAdded(e)
							})), n._scene.getGeometries().forEach((function(e) {
								n.onGeometryAdded(e)
							}));
							break;
						case t.UPDATE:
							n._runningUpdated--;
							break;
						case t.COLLIDE:
							n._runningCollisionTask = !1;
							var s = o.payload;
							if (!n._collisionsCallbackArray[s.collisionId]) return;
							n._collisionsCallbackArray[s.collisionId](s.collisionId, e.Vector3.FromArray(s.newPosition), n._scene.getMeshByUniqueID(s.collidedMeshUniqueId)), n._collisionsCallbackArray[s.collisionId] = void 0
					}
				}, this._collisionsCallbackArray = [], this._init = !1, this._runningUpdated = 0, this._runningCollisionTask = !1, this._addUpdateMeshesList = {}, this._addUpdateGeometriesList = {}, this._toRemoveGeometryArray = [], this._toRemoveMeshesArray = []
			}
			return r.prototype.getNewPosition = function(e, i, r, n, o, s, a) {
				if (this._init && !this._collisionsCallbackArray[a] && !this._collisionsCallbackArray[a + 1e5]) {
					e.divideToRef(r.radius, this._scaledPosition), i.divideToRef(r.radius, this._scaledVelocity), this._collisionsCallbackArray[a] = s;
					var h = {
							collider: {
								position: this._scaledPosition.asArray(),
								velocity: this._scaledVelocity.asArray(),
								radius: r.radius.asArray()
							},
							collisionId: a,
							excludedMeshUniqueId: o ? o.uniqueId : null,
							maximumRetry: n
						},
						c = {
							payload: h,
							taskType: t.COLLIDE
						};
					this._worker.postMessage(c)
				}
			}, r.prototype.init = function(i) {
				this._scene = i, this._scene.registerAfterRender(this._afterRender);
				var r = e.WorkerIncluded ? e.Engine.CodeRepository + "Collisions/babylon.collisionWorker.js" : URL.createObjectURL(new Blob([e.CollisionWorker], {
					type: "application/javascript"
				}));
				this._worker = new Worker(r), this._worker.onmessage = this._onMessageFromWorker;
				var n = {
					payload: {},
					taskType: t.INIT
				};
				this._worker.postMessage(n)
			}, r.prototype.destroy = function() {
				this._scene.unregisterAfterRender(this._afterRender), this._worker.terminate()
			}, r.prototype.onMeshAdded = function(e) {
				e.registerAfterWorldMatrixUpdate(this.onMeshUpdated), this.onMeshUpdated(e)
			}, r.prototype.onMeshRemoved = function(e) {
				this._toRemoveMeshesArray.push(e.uniqueId)
			}, r.prototype.onGeometryAdded = function(e) {
				e.onGeometryUpdated = this.onGeometryUpdated, this.onGeometryUpdated(e)
			}, r.prototype.onGeometryDeleted = function(e) {
				this._toRemoveGeometryArray.push(e.id)
			}, r.SerializeMesh = function(t) {
				var i = [];
				t.subMeshes && (i = t.subMeshes.map((function(e, t) {
					return {
						position: t,
						verticesStart: e.verticesStart,
						verticesCount: e.verticesCount,
						indexStart: e.indexStart,
						indexCount: e.indexCount,
						hasMaterial: !!e.getMaterial(),
						sphereCenter: e.getBoundingInfo().boundingSphere.centerWorld.asArray(),
						sphereRadius: e.getBoundingInfo().boundingSphere.radiusWorld,
						boxMinimum: e.getBoundingInfo().boundingBox.minimumWorld.asArray(),
						boxMaximum: e.getBoundingInfo().boundingBox.maximumWorld.asArray()
					}
				})));
				var r = null;
				return t instanceof e.Mesh ? r = t.geometry ? t.geometry.id : null : t instanceof e.InstancedMesh && (r = t.sourceMesh && t.sourceMesh.geometry ? t.sourceMesh.geometry.id : null), {
					uniqueId: t.uniqueId,
					id: t.id,
					name: t.name,
					geometryId: r,
					sphereCenter: t.getBoundingInfo().boundingSphere.centerWorld.asArray(),
					sphereRadius: t.getBoundingInfo().boundingSphere.radiusWorld,
					boxMinimum: t.getBoundingInfo().boundingBox.minimumWorld.asArray(),
					boxMaximum: t.getBoundingInfo().boundingBox.maximumWorld.asArray(),
					worldMatrixFromCache: t.worldMatrixFromCache.asArray(),
					subMeshes: i,
					checkCollisions: t.checkCollisions
				}
			}, r.SerializeGeometry = function(t) {
				return {
					id: t.id,
					positions: new Float32Array(t.getVerticesData(e.VertexBuffer.PositionKind) || []),
					normals: new Float32Array(t.getVerticesData(e.VertexBuffer.NormalKind) || []),
					indices: new Int32Array(t.getIndices() || [])
				}
			}, r
		})();
	e.CollisionCoordinatorWorker = r;
	var n = (function() {
		function t() {
			this._scaledPosition = e.Vector3.Zero(), this._scaledVelocity = e.Vector3.Zero(), this._finalPosition = e.Vector3.Zero()
		}
		return t.prototype.getNewPosition = function(e, t, i, r, n, o, s) {
			e.divideToRef(i.radius, this._scaledPosition), t.divideToRef(i.radius, this._scaledVelocity), i.collidedMesh = null, i.retry = 0, i.initialVelocity = this._scaledVelocity, i.initialPosition = this._scaledPosition, this._collideWithWorld(this._scaledPosition, this._scaledVelocity, i, r, this._finalPosition, n), this._finalPosition.multiplyInPlace(i.radius), o(s, this._finalPosition, i.collidedMesh)
		}, t.prototype.init = function(e) {
			this._scene = e
		}, t.prototype.destroy = function() {}, t.prototype.onMeshAdded = function(e) {}, t.prototype.onMeshUpdated = function(e) {}, t.prototype.onMeshRemoved = function(e) {}, t.prototype.onGeometryAdded = function(e) {}, t.prototype.onGeometryUpdated = function(e) {}, t.prototype.onGeometryDeleted = function(e) {}, t.prototype._collideWithWorld = function(t, i, r, n, o, s) {
			void 0 === s && (s = null);
			var a = 10 * e.Engine.CollisionsEpsilon;
			if (r.retry >= n) return void o.copyFrom(t);
			r._initialize(t, i, a);
			for (var h = 0; h < this._scene.meshes.length; h++) {
				var c = this._scene.meshes[h];
				c.isEnabled() && c.checkCollisions && c.subMeshes && c !== s && c._checkCollision(r)
			}
			return r.collisionFound ? (0 === i.x && 0 === i.y && 0 === i.z || r._getResponse(t, i), i.length() <= a ? void o.copyFrom(t) : (r.retry++, void this._collideWithWorld(t, i, r, n, o, s))) : void t.addToRef(i, o)
		}, t
	})();
	e.CollisionCoordinatorLegacy = n
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(r, n, o) {
			t.call(this, r, o), this.upVector = e.Vector3.Up(), this.orthoLeft = null, this.orthoRight = null, this.orthoBottom = null, this.orthoTop = null, this.fov = .8, this.minZ = 1, this.maxZ = 1e4, this.inertia = .9, this.mode = i.PERSPECTIVE_CAMERA, this.isIntermediate = !1, this.viewport = new e.Viewport(0, 0, 1, 1), this.layerMask = 268435455, this.fovMode = i.FOVMODE_VERTICAL_FIXED, this.cameraRigMode = i.RIG_MODE_NONE, this._rigCameras = new Array, this._computedViewMatrix = e.Matrix.Identity(), this._projectionMatrix = new e.Matrix, this._doNotComputeProjectionMatrix = !1, this._postProcesses = new Array, this._transformMatrix = e.Matrix.Zero(), this._webvrViewMatrix = e.Matrix.Identity(), this._activeMeshes = new e.SmartArray(256), this._globalPosition = e.Vector3.Zero(), this._refreshFrustumPlanes = !0, o.addCamera(this), o.activeCamera || (o.activeCamera = this), this.position = n
		}
		return __extends(i, t), Object.defineProperty(i, "PERSPECTIVE_CAMERA", {
			get: function() {
				return i._PERSPECTIVE_CAMERA
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ORTHOGRAPHIC_CAMERA", {
			get: function() {
				return i._ORTHOGRAPHIC_CAMERA
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "FOVMODE_VERTICAL_FIXED", {
			get: function() {
				return i._FOVMODE_VERTICAL_FIXED
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "FOVMODE_HORIZONTAL_FIXED", {
			get: function() {
				return i._FOVMODE_HORIZONTAL_FIXED
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_NONE", {
			get: function() {
				return i._RIG_MODE_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_STEREOSCOPIC_ANAGLYPH", {
			get: function() {
				return i._RIG_MODE_STEREOSCOPIC_ANAGLYPH
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL", {
			get: function() {
				return i._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED", {
			get: function() {
				return i._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_STEREOSCOPIC_OVERUNDER", {
			get: function() {
				return i._RIG_MODE_STEREOSCOPIC_OVERUNDER
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_VR", {
			get: function() {
				return i._RIG_MODE_VR
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "RIG_MODE_WEBVR", {
			get: function() {
				return i._RIG_MODE_WEBVR
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.toString = function(e) {
			var t = "Name: " + this.name;
			if (t += ", type: " + this.getTypeName(), this.animations)
				for (var i = 0; i < this.animations.length; i++) t += ", animation[0]: " + this.animations[i].toString(e);
			return t
		}, Object.defineProperty(i.prototype, "globalPosition", {
			get: function() {
				return this._globalPosition
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getActiveMeshes = function() {
			return this._activeMeshes
		}, i.prototype.isActiveMesh = function(e) {
			return this._activeMeshes.indexOf(e) !== -1
		}, i.prototype._initCache = function() {
			t.prototype._initCache.call(this), this._cache.position = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0
		}, i.prototype._updateCache = function(e) {
			e || t.prototype._updateCache.call(this);
			var i = this.getEngine();
			this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector), this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._cache.fov = this.fov, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = i.getAspectRatio(this), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.renderWidth = i.getRenderWidth(), this._cache.renderHeight = i.getRenderHeight()
		}, i.prototype._updateFromScene = function() {
			this.updateCache(), this.update()
		}, i.prototype._isSynchronized = function() {
			return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix()
		}, i.prototype._isSynchronizedViewMatrix = function() {
			return !!t.prototype._isSynchronized.call(this) && (this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent())
		}, i.prototype._isSynchronizedProjectionMatrix = function() {
			var e = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
			if (!e) return !1;
			var t = this.getEngine();
			return e = this.mode === i.PERSPECTIVE_CAMERA ? this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === t.getAspectRatio(this) : this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === t.getRenderWidth() && this._cache.renderHeight === t.getRenderHeight()
		}, i.prototype.attachControl = function(e, t) {}, i.prototype.detachControl = function(e) {}, i.prototype.update = function() {
			this.cameraRigMode !== i.RIG_MODE_NONE && this._updateRigCameras(), this._checkInputs()
		}, i.prototype._checkInputs = function() {}, i.prototype._cascadePostProcessesToRigCams = function() {
			this._postProcesses.length > 0 && this._postProcesses[0].markTextureDirty();
			for (var t = 0, i = this._rigCameras.length; t < i; t++) {
				var r = this._rigCameras[t],
					n = r._rigPostProcess;
				if (n) {
					var o = n instanceof e.PassPostProcess;
					o && (r.isIntermediate = 0 === this._postProcesses.length), r._postProcesses = this._postProcesses.slice(0).concat(n), n.markTextureDirty()
				} else r._postProcesses = this._postProcesses.slice(0)
			}
		}, i.prototype.attachPostProcess = function(t, i) {
			return void 0 === i && (i = null), !t.isReusable() && this._postProcesses.indexOf(t) > -1 ? (e.Tools.Error("You're trying to reuse a post process not defined as reusable."), 0) : (null == i || i < 0 ? this._postProcesses.push(t) : this._postProcesses.splice(i, 0, t), this._cascadePostProcessesToRigCams(), this._postProcesses.indexOf(t))
		}, i.prototype.detachPostProcess = function(e, t) {
			void 0 === t && (t = null);
			var i, r, n = [];
			if (t)
				for (t = t instanceof Array ? t : [t], i = t.length - 1; i >= 0; i--) this._postProcesses[t[i]] === e ? this._postProcesses.splice(r, 1) : n.push(i);
			else {
				var o = this._postProcesses.indexOf(e);
				o !== -1 && this._postProcesses.splice(o, 1)
			}
			return this._cascadePostProcessesToRigCams(), n
		}, i.prototype.getWorldMatrix = function() {
			this._worldMatrix || (this._worldMatrix = e.Matrix.Identity());
			var t = this.getViewMatrix();
			return t.invertToRef(this._worldMatrix), this._worldMatrix
		}, i.prototype._getViewMatrix = function() {
			return e.Matrix.Identity()
		}, i.prototype.getViewMatrix = function(t) {
			return this._computedViewMatrix = this._computeViewMatrix(t), !t && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this._refreshFrustumPlanes = !0, this.parent && this.parent.getWorldMatrix ? (this._worldMatrix || (this._worldMatrix = e.Matrix.Identity()), this._computedViewMatrix.invertToRef(this._worldMatrix), this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._computedViewMatrix), this._globalPosition.copyFromFloats(this._computedViewMatrix.m[12], this._computedViewMatrix.m[13], this._computedViewMatrix.m[14]), this._computedViewMatrix.invert(), this._markSyncedWithParent()) : this._globalPosition.copyFrom(this.position), this._currentRenderId = this.getScene().getRenderId(), this._computedViewMatrix)
		}, i.prototype._computeViewMatrix = function(e) {
			return !e && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._computedViewMatrix)
		}, i.prototype.freezeProjectionMatrix = function(e) {
			this._doNotComputeProjectionMatrix = !0, void 0 !== e && (this._projectionMatrix = e)
		}, i.prototype.unfreezeProjectionMatrix = function() {
			this._doNotComputeProjectionMatrix = !1
		}, i.prototype.getProjectionMatrix = function(t) {
			if (this._doNotComputeProjectionMatrix || !t && this._isSynchronizedProjectionMatrix()) return this._projectionMatrix;
			this._refreshFrustumPlanes = !0;
			var r = this.getEngine(),
				n = this.getScene();
			if (this.mode === i.PERSPECTIVE_CAMERA) return this.minZ <= 0 && (this.minZ = .1), n.useRightHandedSystem ? e.Matrix.PerspectiveFovRHToRef(this.fov, r.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === i.FOVMODE_VERTICAL_FIXED) : e.Matrix.PerspectiveFovLHToRef(this.fov, r.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === i.FOVMODE_VERTICAL_FIXED), this._projectionMatrix;
			var o = r.getRenderWidth() / 2,
				s = r.getRenderHeight() / 2;
			return n.useRightHandedSystem ? e.Matrix.OrthoOffCenterRHToRef(this.orthoLeft || -o, this.orthoRight || o, this.orthoBottom || -s, this.orthoTop || s, this.minZ, this.maxZ, this._projectionMatrix) : e.Matrix.OrthoOffCenterLHToRef(this.orthoLeft || -o, this.orthoRight || o, this.orthoBottom || -s, this.orthoTop || s, this.minZ, this.maxZ, this._projectionMatrix), this._projectionMatrix
		}, i.prototype.getTranformationMatrix = function() {
			return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix
		}, i.prototype.updateFrustumPlanes = function() {
			this._refreshFrustumPlanes && (this.getTranformationMatrix(), this._frustumPlanes ? e.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = e.Frustum.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1)
		}, i.prototype.isInFrustum = function(e) {
			return this.updateFrustumPlanes(), e.isInFrustum(this._frustumPlanes)
		}, i.prototype.isCompletelyInFrustum = function(e) {
			return this.updateFrustumPlanes(), e.isCompletelyInFrustum(this._frustumPlanes)
		}, i.prototype.dispose = function() {
			for (this.getScene().stopAnimation(this), this.getScene().removeCamera(this); this._rigCameras.length > 0;) this._rigCameras.pop().dispose();
			for (var e = 0; e < this._postProcesses.length; ++e) this._postProcesses[e].dispose(this);
			t.prototype.dispose.call(this)
		}, i.prototype.setCameraRigMode = function(t, r) {
			for (; this._rigCameras.length > 0;) this._rigCameras.pop().dispose();
			switch (this.cameraRigMode = t, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = r.interaxialDistance || .0637, this._cameraRigParams.stereoHalfAngle = e.Tools.ToRadians(this._cameraRigParams.interaxialDistance / .0637), this.cameraRigMode !== i.RIG_MODE_NONE && (this._rigCameras.push(this.createRigCamera(this.name + "_L", 0)), this._rigCameras.push(this.createRigCamera(this.name + "_R", 1))), this.cameraRigMode) {
				case i.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
					this._rigCameras[0]._rigPostProcess = new e.PassPostProcess(this.name + "_passthru", 1, this._rigCameras[0]), this._rigCameras[1]._rigPostProcess = new e.AnaglyphPostProcess(this.name + "_anaglyph", 1, this._rigCameras);
					break;
				case i.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case i.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
				case i.RIG_MODE_STEREOSCOPIC_OVERUNDER:
					var n = this.cameraRigMode === i.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || this.cameraRigMode === i.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;
					this._rigCameras[0]._rigPostProcess = new e.PassPostProcess(this.name + "_passthru", 1, this._rigCameras[0]), this._rigCameras[1]._rigPostProcess = new e.StereoscopicInterlacePostProcess(this.name + "_stereoInterlace", this._rigCameras, n);
					break;
				case i.RIG_MODE_VR:
					var o = r.vrCameraMetrics || e.VRCameraMetrics.GetDefault();
					this._rigCameras[0]._cameraRigParams.vrMetrics = o, this._rigCameras[0].viewport = new e.Viewport(0, 0, .5, 1), this._rigCameras[0]._cameraRigParams.vrWorkMatrix = new e.Matrix, this._rigCameras[0]._cameraRigParams.vrHMatrix = o.leftHMatrix, this._rigCameras[0]._cameraRigParams.vrPreViewMatrix = o.leftPreViewMatrix, this._rigCameras[0].getProjectionMatrix = this._rigCameras[0]._getVRProjectionMatrix, this._rigCameras[1]._cameraRigParams.vrMetrics = o, this._rigCameras[1].viewport = new e.Viewport(.5, 0, .5, 1), this._rigCameras[1]._cameraRigParams.vrWorkMatrix = new e.Matrix, this._rigCameras[1]._cameraRigParams.vrHMatrix = o.rightHMatrix, this._rigCameras[1]._cameraRigParams.vrPreViewMatrix = o.rightPreViewMatrix, this._rigCameras[1].getProjectionMatrix = this._rigCameras[1]._getVRProjectionMatrix, o.compensateDistortion && (this._rigCameras[0]._rigPostProcess = new e.VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Left", this._rigCameras[0], (!1), o), this._rigCameras[1]._rigPostProcess = new e.VRDistortionCorrectionPostProcess("VR_Distort_Compensation_Right", this._rigCameras[1], (!0), o));
					break;
				case i.RIG_MODE_WEBVR:
					r.vrDisplay && (this._rigCameras[0].viewport = new e.Viewport(0, 0, .5, 1), this._rigCameras[0].setCameraRigParameter("left", !0), this._rigCameras[0].setCameraRigParameter("frameData", r.frameData), this._rigCameras[0]._cameraRigParams.vrWorkMatrix = new e.Matrix, this._rigCameras[0].getProjectionMatrix = this._getWebVRProjectionMatrix, this._rigCameras[1].viewport = new e.Viewport(.5, 0, .5, 1), this._rigCameras[1].setCameraRigParameter("frameData", r.frameData), this._rigCameras[1]._cameraRigParams.vrWorkMatrix = new e.Matrix, this._rigCameras[1].getProjectionMatrix = this._getWebVRProjectionMatrix)
			}
			this._cascadePostProcessesToRigCams(), this.update()
		}, i.prototype._getVRProjectionMatrix = function() {
			return e.Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix
		}, i.prototype._getWebVRProjectionMatrix = function() {
			var t = this._cameraRigParams.left ? this._cameraRigParams.frameData.leftProjectionMatrix : this._cameraRigParams.frameData.rightProjectionMatrix;
			return [8, 9, 10, 11].forEach((function(e) {
				t[e] *= -1
			})), e.Matrix.FromArrayToRef(t, 0, this._projectionMatrix), this._projectionMatrix
		}, i.prototype._getWebVRViewMatrix = function() {
			var t = this._cameraRigParams.left ? this._cameraRigParams.frameData.leftViewMatrix : this._cameraRigParams.frameData.rightViewMatrix;
			return [8, 9, 10, 11].forEach((function(e) {
				t[e] *= -1
			})), e.Matrix.FromArrayToRef(t, 0, this._webvrViewMatrix), this._webvrViewMatrix
		}, i.prototype.setCameraRigParameter = function(t, i) {
			this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[t] = i, "interaxialDistance" === t && (this._cameraRigParams.stereoHalfAngle = e.Tools.ToRadians(i / .0637))
		}, i.prototype.createRigCamera = function(e, t) {
			return null
		}, i.prototype._updateRigCameras = function() {
			for (var e = 0; e < this._rigCameras.length; e++) this._rigCameras[e].minZ = this.minZ, this._rigCameras[e].maxZ = this.maxZ, this._rigCameras[e].fov = this.fov;
			this.cameraRigMode === i.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport)
		}, i.prototype._setupInputs = function() {}, i.prototype.serialize = function() {
			var t = e.SerializationHelper.Serialize(this);
			return t.type = this.getTypeName(), this.parent && (t.parentId = this.parent.id), this.inputs && this.inputs.serialize(t), e.Animation.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t
		}, i.prototype.getTypeName = function() {
			return "Camera"
		}, i.prototype.clone = function(t) {
			return e.SerializationHelper.Clone(i.GetConstructorFromName(this.getTypeName(), t, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this)
		}, i.prototype.getDirection = function(t) {
			var i = e.Vector3.Zero();
			return this.getDirectionToRef(t, i), i
		}, i.prototype.getDirectionToRef = function(t, i) {
			e.Vector3.TransformNormalToRef(t, this.getWorldMatrix(), i)
		}, i.GetConstructorFromName = function(t, i, r, n, o) {
			switch (void 0 === n && (n = 0), void 0 === o && (o = !0), t) {
				case "ArcRotateCamera":
					return function() {
						return new e.ArcRotateCamera(i, 0, 0, 1, e.Vector3.Zero(), r)
					};
				case "DeviceOrientationCamera":
					return function() {
						return new e.DeviceOrientationCamera(i, e.Vector3.Zero(), r)
					};
				case "FollowCamera":
					return function() {
						return new e.FollowCamera(i, e.Vector3.Zero(), r)
					};
				case "ArcFollowCamera":
					return function() {
						return new e.ArcFollowCamera(i, 0, 0, 1, null, r)
					};
				case "GamepadCamera":
					return function() {
						return new e.GamepadCamera(i, e.Vector3.Zero(), r)
					};
				case "TouchCamera":
					return function() {
						return new e.TouchCamera(i, e.Vector3.Zero(), r)
					};
				case "VirtualJoysticksCamera":
					return function() {
						return new e.VirtualJoysticksCamera(i, e.Vector3.Zero(), r)
					};
				case "WebVRFreeCamera":
					return function() {
						return new e.WebVRFreeCamera(i, e.Vector3.Zero(), r)
					};
				case "VRDeviceOrientationFreeCamera":
					return function() {
						return new e.VRDeviceOrientationFreeCamera(i, e.Vector3.Zero(), r)
					};
				case "AnaglyphArcRotateCamera":
					return function() {
						return new e.AnaglyphArcRotateCamera(i, 0, 0, 1, e.Vector3.Zero(), n, r)
					};
				case "AnaglyphFreeCamera":
					return function() {
						return new e.AnaglyphFreeCamera(i, e.Vector3.Zero(), n, r)
					};
				case "AnaglyphGamepadCamera":
					return function() {
						return new e.AnaglyphGamepadCamera(i, e.Vector3.Zero(), n, r)
					};
				case "AnaglyphUniversalCamera":
					return function() {
						return new e.AnaglyphUniversalCamera(i, e.Vector3.Zero(), n, r)
					};
				case "StereoscopicArcRotateCamera":
					return function() {
						return new e.StereoscopicArcRotateCamera(i, 0, 0, 1, e.Vector3.Zero(), n, o, r)
					};
				case "StereoscopicFreeCamera":
					return function() {
						return new e.StereoscopicFreeCamera(i, e.Vector3.Zero(), n, o, r)
					};
				case "StereoscopicGamepadCamera":
					return function() {
						return new e.StereoscopicGamepadCamera(i, e.Vector3.Zero(), n, o, r)
					};
				case "StereoscopicUniversalCamera":
					return function() {
						return new e.StereoscopicUniversalCamera(i, e.Vector3.Zero(), n, o, r)
					};
				case "FreeCamera":
					return function() {
						return new e.UniversalCamera(i, e.Vector3.Zero(), r)
					};
				default:
					return function() {
						return new e.UniversalCamera(i, e.Vector3.Zero(), r)
					}
			}
		}, i.Parse = function(t, r) {
			var n = t.type,
				o = i.GetConstructorFromName(n, t.name, r, t.interaxial_distance, t.isStereoscopicSideBySide),
				s = e.SerializationHelper.Parse(o, t, r);
			if (t.parentId && (s._waitingParentId = t.parentId), s.inputs && (s.inputs.parse(t), s._setupInputs()), t.target && s.setTarget && s.setTarget(e.Vector3.FromArray(t.target)), t.cameraRigMode) {
				var a = t.interaxial_distance ? {
					interaxialDistance: t.interaxial_distance
				} : {};
				s.setCameraRigMode(t.cameraRigMode, a)
			}
			if (t.animations) {
				for (var h = 0; h < t.animations.length; h++) {
					var c = t.animations[h];
					s.animations.push(e.Animation.Parse(c))
				}
				e.Node.ParseAnimationRanges(s, t, r)
			}
			return t.autoAnimate && r.beginAnimation(s, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), s
		}, i._PERSPECTIVE_CAMERA = 0, i._ORTHOGRAPHIC_CAMERA = 1, i._FOVMODE_VERTICAL_FIXED = 0, i._FOVMODE_HORIZONTAL_FIXED = 1, i._RIG_MODE_NONE = 0, i._RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10, i._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11, i._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12, i._RIG_MODE_STEREOSCOPIC_OVERUNDER = 13, i._RIG_MODE_VR = 20, i._RIG_MODE_WEBVR = 21, i.ForceAttachControlToAlwaysPreventDefault = !1, __decorate([e.serializeAsVector3()], i.prototype, "position", void 0), __decorate([e.serializeAsVector3()], i.prototype, "upVector", void 0), __decorate([e.serialize()], i.prototype, "orthoLeft", void 0), __decorate([e.serialize()], i.prototype, "orthoRight", void 0), __decorate([e.serialize()], i.prototype, "orthoBottom", void 0), __decorate([e.serialize()], i.prototype, "orthoTop", void 0), __decorate([e.serialize()], i.prototype, "fov", void 0), __decorate([e.serialize()], i.prototype, "minZ", void 0), __decorate([e.serialize()], i.prototype, "maxZ", void 0), __decorate([e.serialize()], i.prototype, "inertia", void 0), __decorate([e.serialize()], i.prototype, "mode", void 0), __decorate([e.serialize()], i.prototype, "layerMask", void 0), __decorate([e.serialize()], i.prototype, "fovMode", void 0), __decorate([e.serialize()], i.prototype, "cameraRigMode", void 0), __decorate([e.serialize()], i.prototype, "interaxialDistance", void 0), __decorate([e.serialize()], i.prototype, "isStereoscopicSideBySide", void 0), i
	})(e.Node);
	e.Camera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	e.CameraInputTypes = {};
	var t = (function() {
		function t(e) {
			this.attached = {}, this.camera = e, this.checkInputs = function() {}
		}
		return t.prototype.add = function(t) {
			var i = t.getSimpleName();
			return this.attached[i] ? void e.Tools.Warn("camera input of type " + i + " already exists on camera") : (this.attached[i] = t, t.camera = this.camera, t.checkInputs && (this.checkInputs = this._addCheckInputs(t.checkInputs.bind(t))), void(this.attachedElement && t.attachControl(this.attachedElement)))
		}, t.prototype.remove = function(e) {
			for (var t in this.attached) {
				var i = this.attached[t];
				i === e && (i.detachControl(this.attachedElement), delete this.attached[t], this.rebuildInputCheck())
			}
		}, t.prototype.removeByType = function(e) {
			for (var t in this.attached) {
				var i = this.attached[t];
				i.getTypeName() === e && (i.detachControl(this.attachedElement), delete this.attached[t], this.rebuildInputCheck())
			}
		}, t.prototype._addCheckInputs = function(e) {
			var t = this.checkInputs;
			return function() {
				t(), e()
			}
		}, t.prototype.attachInput = function(e) {
			e.attachControl(this.attachedElement, this.noPreventDefault)
		}, t.prototype.attachElement = function(t, i) {
			if (!this.attachedElement) {
				i = !e.Camera.ForceAttachControlToAlwaysPreventDefault && i, this.attachedElement = t, this.noPreventDefault = i;
				for (var r in this.attached) {
					this.attached[r];
					this.attached[r].attachControl(t, i)
				}
			}
		}, t.prototype.detachElement = function(e) {
			if (this.attachedElement === e) {
				for (var t in this.attached) {
					this.attached[t];
					this.attached[t].detachControl(e)
				}
				this.attachedElement = null
			}
		}, t.prototype.rebuildInputCheck = function() {
			this.checkInputs = function() {};
			for (var e in this.attached) {
				var t = this.attached[e];
				t.checkInputs && (this.checkInputs = this._addCheckInputs(t.checkInputs.bind(t)))
			}
		}, t.prototype.clear = function() {
			this.attachedElement && this.detachElement(this.attachedElement), this.attached = {}, this.attachedElement = null, this.checkInputs = function() {}
		}, t.prototype.serialize = function(t) {
			var i = {};
			for (var r in this.attached) {
				var n = this.attached[r],
					o = e.SerializationHelper.Serialize(n);
				i[n.getTypeName()] = o
			}
			t.inputsmgr = i
		}, t.prototype.parse = function(t) {
			var i = t.inputsmgr;
			if (i) {
				this.clear();
				for (var r in i) {
					var n = e.CameraInputTypes[r];
					if (n) {
						var o = i[r],
							s = e.SerializationHelper.Parse((function() {
								return new n
							}), o, null);
						this.add(s)
					}
				}
			} else
				for (var r in this.attached) {
					var n = e.CameraInputTypes[this.attached[r].getTypeName()];
					if (n) {
						var s = e.SerializationHelper.Parse((function() {
							return new n
						}), t, null);
						this.remove(this.attached[r]), this.add(s)
					}
				}
		}, t
	})();
	e.CameraInputsManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e) {
			void 0 === e && (e = !0), this.touchEnabled = e, this.buttons = [0, 1, 2], this.angularSensibility = 2e3
		}
		return t.prototype.attachControl = function(t, i) {
			var r = this,
				n = this.camera.getEngine();
			this._pointerInput || (this._pointerInput = function(o, s) {
				var a = o.event;
				if ((r.touchEnabled || "touch" !== a.pointerType) && (o.type === e.PointerEventTypes.POINTERMOVE || r.buttons.indexOf(a.button) !== -1))
					if (o.type === e.PointerEventTypes.POINTERDOWN) {
						try {
							a.srcElement.setPointerCapture(a.pointerId)
						} catch (h) {}
						r.previousPosition = {
							x: a.clientX,
							y: a.clientY
						}, i || (a.preventDefault(), t.focus())
					} else if (o.type === e.PointerEventTypes.POINTERUP) {
					try {
						a.srcElement.releasePointerCapture(a.pointerId)
					} catch (h) {}
					r.previousPosition = null, i || a.preventDefault()
				} else if (o.type === e.PointerEventTypes.POINTERMOVE) {
					if (!r.previousPosition || n.isPointerLock) return;
					var c = a.clientX - r.previousPosition.x,
						l = a.clientY - r.previousPosition.y;
					r.camera.getScene().useRightHandedSystem ? r.camera.cameraRotation.y -= c / r.angularSensibility : r.camera.cameraRotation.y += c / r.angularSensibility, r.camera.cameraRotation.x += l / r.angularSensibility, r.previousPosition = {
						x: a.clientX,
						y: a.clientY
					}, i || a.preventDefault()
				}
			}), this._onMouseMove = function(e) {
				if (n.isPointerLock) {
					var t = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0,
						o = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;
					r.camera.getScene().useRightHandedSystem ? r.camera.cameraRotation.y -= t / r.angularSensibility : r.camera.cameraRotation.y += t / r.angularSensibility, r.camera.cameraRotation.x += o / r.angularSensibility, r.previousPosition = null, i || e.preventDefault()
				}
			}, this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, e.PointerEventTypes.POINTERDOWN | e.PointerEventTypes.POINTERUP | e.PointerEventTypes.POINTERMOVE), t.addEventListener("mousemove", this._onMouseMove, !1)
		}, t.prototype.detachControl = function(e) {
			this._observer && e && (this.camera.getScene().onPointerObservable.remove(this._observer), e.removeEventListener("mousemove", this._onMouseMove), this._observer = null, this._onMouseMove = null, this.previousPosition = null)
		}, t.prototype.getTypeName = function() {
			return "FreeCameraMouseInput"
		}, t.prototype.getSimpleName = function() {
			return "mouse"
		}, __decorate([e.serialize()], t.prototype, "buttons", void 0), __decorate([e.serialize()], t.prototype, "angularSensibility", void 0), t
	})();
	e.FreeCameraMouseInput = t, e.CameraInputTypes.FreeCameraMouseInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this._keys = [], this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39]
		}
		return t.prototype.attachControl = function(t, i) {
			var r = this;
			this._onKeyDown || (t.tabIndex = 1, this._onKeyDown = function(e) {
				if (r.keysUp.indexOf(e.keyCode) !== -1 || r.keysDown.indexOf(e.keyCode) !== -1 || r.keysLeft.indexOf(e.keyCode) !== -1 || r.keysRight.indexOf(e.keyCode) !== -1) {
					var t = r._keys.indexOf(e.keyCode);
					t === -1 && r._keys.push(e.keyCode), i || e.preventDefault()
				}
			}, this._onKeyUp = function(e) {
				if (r.keysUp.indexOf(e.keyCode) !== -1 || r.keysDown.indexOf(e.keyCode) !== -1 || r.keysLeft.indexOf(e.keyCode) !== -1 || r.keysRight.indexOf(e.keyCode) !== -1) {
					var t = r._keys.indexOf(e.keyCode);
					t >= 0 && r._keys.splice(t, 1), i || e.preventDefault()
				}
			}, t.addEventListener("keydown", this._onKeyDown, !1), t.addEventListener("keyup", this._onKeyUp, !1), e.Tools.RegisterTopRootEvents([{
				name: "blur",
				handler: this._onLostFocus
			}]))
		}, t.prototype.detachControl = function(t) {
			this._onKeyDown && (t.removeEventListener("keydown", this._onKeyDown), t.removeEventListener("keyup", this._onKeyUp), e.Tools.UnregisterTopRootEvents([{
				name: "blur",
				handler: this._onLostFocus
			}]), this._keys = [], this._onKeyDown = null, this._onKeyUp = null)
		}, t.prototype.checkInputs = function() {
			if (this._onKeyDown)
				for (var t = this.camera, i = 0; i < this._keys.length; i++) {
					var r = this._keys[i],
						n = t._computeLocalCameraSpeed();
					this.keysLeft.indexOf(r) !== -1 ? t._localDirection.copyFromFloats(-n, 0, 0) : this.keysUp.indexOf(r) !== -1 ? t._localDirection.copyFromFloats(0, 0, n) : this.keysRight.indexOf(r) !== -1 ? t._localDirection.copyFromFloats(n, 0, 0) : this.keysDown.indexOf(r) !== -1 && t._localDirection.copyFromFloats(0, 0, -n), t.getScene().useRightHandedSystem && (t._localDirection.z *= -1), t.getViewMatrix().invertToRef(t._cameraTransformMatrix), e.Vector3.TransformNormalToRef(t._localDirection, t._cameraTransformMatrix, t._transformedDirection), t.cameraDirection.addInPlace(t._transformedDirection)
				}
		}, t.prototype.getTypeName = function() {
			return "FreeCameraKeyboardMoveInput"
		}, t.prototype._onLostFocus = function(e) {
			this._keys = []
		}, t.prototype.getSimpleName = function() {
			return "keyboard"
		}, __decorate([e.serialize()], t.prototype, "keysUp", void 0), __decorate([e.serialize()], t.prototype, "keysDown", void 0), __decorate([e.serialize()], t.prototype, "keysLeft", void 0), __decorate([e.serialize()], t.prototype, "keysRight", void 0), t
	})();
	e.FreeCameraKeyboardMoveInput = t, e.CameraInputTypes.FreeCameraKeyboardMoveInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this._offsetX = null, this._offsetY = null, this._pointerCount = 0, this._pointerPressed = [], this.touchAngularSensibility = 2e5, this.touchMoveSensibility = 250
		}
		return t.prototype.attachControl = function(t, i) {
			var r, n = this;
			void 0 === this._pointerInput && (this._onLostFocus = function(e) {
				n._offsetX = null, n._offsetY = null
			}, this._pointerInput = function(t, o) {
				var s = t.event;
				if ("mouse" !== s.pointerType)
					if (t.type === e.PointerEventTypes.POINTERDOWN) {
						if (i || s.preventDefault(), n._pointerPressed.push(s.pointerId), 1 !== n._pointerPressed.length) return;
						r = {
							x: s.clientX,
							y: s.clientY
						}
					} else if (t.type === e.PointerEventTypes.POINTERUP) {
					i || s.preventDefault();
					var a = n._pointerPressed.indexOf(s.pointerId);
					if (a === -1) return;
					if (n._pointerPressed.splice(a, 1), 0 != a) return;
					r = null, n._offsetX = null, n._offsetY = null
				} else if (t.type === e.PointerEventTypes.POINTERMOVE) {
					if (i || s.preventDefault(), !r) return;
					var a = n._pointerPressed.indexOf(s.pointerId);
					if (0 != a) return;
					n._offsetX = s.clientX - r.x, n._offsetY = -(s.clientY - r.y)
				}
			}), this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, e.PointerEventTypes.POINTERDOWN | e.PointerEventTypes.POINTERUP | e.PointerEventTypes.POINTERMOVE), t.addEventListener("blur", this._onLostFocus)
		}, t.prototype.detachControl = function(e) {
			this._pointerInput && e && (this.camera.getScene().onPointerObservable.remove(this._observer), this._observer = null, e.removeEventListener("blur", this._onLostFocus), this._onLostFocus = null, this._pointerPressed = [], this._offsetX = null, this._offsetY = null, this._pointerCount = 0)
		}, t.prototype.checkInputs = function() {
			if (this._offsetX) {
				var t = this.camera;
				if (t.cameraRotation.y += this._offsetX / this.touchAngularSensibility, this._pointerPressed.length > 1) t.cameraRotation.x += -this._offsetY / this.touchAngularSensibility;
				else {
					var i = t._computeLocalCameraSpeed(),
						r = new e.Vector3(0, 0, i * this._offsetY / this.touchMoveSensibility);
					e.Matrix.RotationYawPitchRollToRef(t.rotation.y, t.rotation.x, 0, t._cameraRotationMatrix), t.cameraDirection.addInPlace(e.Vector3.TransformCoordinates(r, t._cameraRotationMatrix))
				}
			}
		}, t.prototype.getTypeName = function() {
			return "FreeCameraTouchInput"
		}, t.prototype.getSimpleName = function() {
			return "touch"
		}, __decorate([e.serialize()], t.prototype, "touchAngularSensibility", void 0), __decorate([e.serialize()], t.prototype, "touchMoveSensibility", void 0), t
	})();
	e.FreeCameraTouchInput = t, e.CameraInputTypes.FreeCameraTouchInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			var t = this;
			this._screenOrientationAngle = 0, this._screenQuaternion = new e.Quaternion, this._alpha = 0, this._beta = 0, this._gamma = 0, this._orientationChanged = function() {
				t._screenOrientationAngle = void 0 !== window.orientation ? +window.orientation : window.screen.orientation && window.screen.orientation.angle ? window.screen.orientation.angle : 0, t._screenOrientationAngle = -e.Tools.ToRadians(t._screenOrientationAngle / 2), t._screenQuaternion.copyFromFloats(0, Math.sin(t._screenOrientationAngle), 0, Math.cos(t._screenOrientationAngle))
			}, this._deviceOrientation = function(e) {
				t._alpha = e.alpha, t._beta = e.beta, t._gamma = e.gamma
			}, this._constantTranform = new e.Quaternion((-Math.sqrt(.5)), 0, 0, Math.sqrt(.5)), this._orientationChanged()
		}
		return Object.defineProperty(t.prototype, "camera", {
			get: function() {
				return this._camera
			},
			set: function(t) {
				this._camera = t, this._camera.rotationQuaternion || (this._camera.rotationQuaternion = new e.Quaternion)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.attachControl = function(e, t) {
			window.addEventListener("orientationchange", this._orientationChanged), window.addEventListener("deviceorientation", this._deviceOrientation), this._orientationChanged()
		}, t.prototype.detachControl = function(e) {
			window.removeEventListener("orientationchange", this._orientationChanged), window.removeEventListener("deviceorientation", this._deviceOrientation)
		}, t.prototype.checkInputs = function() {
			this._alpha && (e.Quaternion.RotationYawPitchRollToRef(e.Tools.ToRadians(this._alpha), e.Tools.ToRadians(this._beta), -e.Tools.ToRadians(this._gamma), this.camera.rotationQuaternion), this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion), this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform), this._camera.rotationQuaternion.z *= -1, this._camera.rotationQuaternion.w *= -1)
		}, t.prototype.getTypeName = function() {
			return "FreeCameraDeviceOrientationInput"
		}, t.prototype.getSimpleName = function() {
			return "deviceOrientation"
		}, t
	})();
	e.FreeCameraDeviceOrientationInput = t, e.CameraInputTypes.FreeCameraDeviceOrientationInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this.gamepadAngularSensibility = 200, this.gamepadMoveSensibility = 40
		}
		return t.prototype.attachControl = function(t, i) {
			var r = this;
			this._gamepads = new e.Gamepads(function(e) {
				r._onNewGameConnected(e)
			})
		}, t.prototype.detachControl = function(e) {
			this._gamepads && this._gamepads.dispose(), this.gamepad = null
		}, t.prototype.checkInputs = function() {
			if (this.gamepad) {
				var t = this.camera,
					i = this.gamepad.leftStick,
					r = i.x / this.gamepadMoveSensibility,
					n = i.y / this.gamepadMoveSensibility;
				i.x = Math.abs(r) > .005 ? 0 + r : 0, i.y = Math.abs(n) > .005 ? 0 + n : 0;
				var o = this.gamepad.rightStick,
					s = o.x / this.gamepadAngularSensibility,
					a = o.y / this.gamepadAngularSensibility;
				o.x = Math.abs(s) > .001 ? 0 + s : 0, o.y = Math.abs(a) > .001 ? 0 + a : 0;
				var h = e.Matrix.RotationYawPitchRoll(t.rotation.y, t.rotation.x, 0),
					c = 50 * t._computeLocalCameraSpeed(),
					l = e.Vector3.TransformCoordinates(new e.Vector3(i.x * c, 0, -i.y * c), h);
				t.cameraDirection = t.cameraDirection.add(l), t.cameraRotation = t.cameraRotation.add(new e.Vector2(o.y, o.x))
			}
		}, t.prototype._onNewGameConnected = function(e) {
			0 === e.index && (this.gamepad = e)
		}, t.prototype.getTypeName = function() {
			return "FreeCameraGamepadInput"
		}, t.prototype.getSimpleName = function() {
			return "gamepad"
		}, __decorate([e.serialize()], t.prototype, "gamepadAngularSensibility", void 0), __decorate([e.serialize()], t.prototype, "gamepadMoveSensibility", void 0), t
	})();
	e.FreeCameraGamepadInput = t, e.CameraInputTypes.FreeCameraGamepadInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this._keys = [], this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39]
		}
		return t.prototype.attachControl = function(t, i) {
			var r = this;
			t.tabIndex = 1, this._onKeyDown = function(e) {
				if (r.keysUp.indexOf(e.keyCode) !== -1 || r.keysDown.indexOf(e.keyCode) !== -1 || r.keysLeft.indexOf(e.keyCode) !== -1 || r.keysRight.indexOf(e.keyCode) !== -1) {
					var t = r._keys.indexOf(e.keyCode);
					t === -1 && r._keys.push(e.keyCode), e.preventDefault && (i || e.preventDefault())
				}
			}, this._onKeyUp = function(e) {
				if (r.keysUp.indexOf(e.keyCode) !== -1 || r.keysDown.indexOf(e.keyCode) !== -1 || r.keysLeft.indexOf(e.keyCode) !== -1 || r.keysRight.indexOf(e.keyCode) !== -1) {
					var t = r._keys.indexOf(e.keyCode);
					t >= 0 && r._keys.splice(t, 1), e.preventDefault && (i || e.preventDefault())
				}
			}, this._onLostFocus = function() {
				r._keys = []
			}, t.addEventListener("keydown", this._onKeyDown, !1), t.addEventListener("keyup", this._onKeyUp, !1), e.Tools.RegisterTopRootEvents([{
				name: "blur",
				handler: this._onLostFocus
			}])
		}, t.prototype.detachControl = function(t) {
			t && (t.removeEventListener("keydown", this._onKeyDown), t.removeEventListener("keyup", this._onKeyUp)), e.Tools.UnregisterTopRootEvents([{
				name: "blur",
				handler: this._onLostFocus
			}]), this._keys = [], this._onKeyDown = null, this._onKeyUp = null, this._onLostFocus = null
		}, t.prototype.checkInputs = function() {
			if (this._onKeyDown)
				for (var e = this.camera, t = 0; t < this._keys.length; t++) {
					var i = this._keys[t];
					this.keysLeft.indexOf(i) !== -1 ? e.inertialAlphaOffset -= .01 : this.keysUp.indexOf(i) !== -1 ? e.inertialBetaOffset -= .01 : this.keysRight.indexOf(i) !== -1 ? e.inertialAlphaOffset += .01 : this.keysDown.indexOf(i) !== -1 && (e.inertialBetaOffset += .01)
				}
		}, t.prototype.getTypeName = function() {
			return "ArcRotateCameraKeyboardMoveInput"
		}, t.prototype.getSimpleName = function() {
			return "keyboard"
		}, __decorate([e.serialize()], t.prototype, "keysUp", void 0), __decorate([e.serialize()], t.prototype, "keysDown", void 0), __decorate([e.serialize()], t.prototype, "keysLeft", void 0), __decorate([e.serialize()], t.prototype, "keysRight", void 0), t
	})();
	e.ArcRotateCameraKeyboardMoveInput = t, e.CameraInputTypes.ArcRotateCameraKeyboardMoveInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this.wheelPrecision = 3
		}
		return t.prototype.attachControl = function(t, i) {
			var r = this;
			this._wheel = function(t, n) {
				if (t.type === e.PointerEventTypes.POINTERWHEEL) {
					var o = t.event,
						s = 0;
					o.wheelDelta ? s = o.wheelDelta / (40 * r.wheelPrecision) : o.detail && (s = -o.detail / r.wheelPrecision), s && (r.camera.inertialRadiusOffset += s), o.preventDefault && (i || o.preventDefault())
				}
			}, this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, e.PointerEventTypes.POINTERWHEEL)
		}, t.prototype.detachControl = function(e) {
			this._observer && e && (this.camera.getScene().onPointerObservable.remove(this._observer), this._observer = null, this._wheel = null)
		}, t.prototype.getTypeName = function() {
			return "ArcRotateCameraMouseWheelInput"
		}, t.prototype.getSimpleName = function() {
			return "mousewheel"
		}, __decorate([e.serialize()], t.prototype, "wheelPrecision", void 0), t
	})();
	e.ArcRotateCameraMouseWheelInput = t, e.CameraInputTypes.ArcRotateCameraMouseWheelInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (e.Tools.GetPointerPrefix(), (function() {
		function t() {
			this.buttons = [0, 1, 2], this.angularSensibilityX = 1e3, this.angularSensibilityY = 1e3, this.pinchPrecision = 6, this.panningSensibility = 50, this._isPanClick = !1, this.pinchInwards = !0
		}
		return t.prototype.attachControl = function(t, i) {
			var r, n, o, s = this,
				a = this.camera.getEngine(),
				h = 0;
			this._pointerInput = function(a, c) {
				var l = a.event;
				if (a.type === e.PointerEventTypes.POINTERMOVE || s.buttons.indexOf(l.button) !== -1)
					if (a.type === e.PointerEventTypes.POINTERDOWN) {
						try {
							l.srcElement.setPointerCapture(l.pointerId)
						} catch (u) {}
						s._isPanClick = l.button === s.camera._panningMouseButton, r = {
							x: l.clientX,
							y: l.clientY,
							pointerId: l.pointerId,
							type: l.pointerType
						}, void 0 === n ? n = r : void 0 === o && (o = r), i || (l.preventDefault(), t.focus())
					} else if (a.type === e.PointerEventTypes.POINTERUP) {
					try {
						l.srcElement.releasePointerCapture(l.pointerId)
					} catch (u) {}
					r = null, h = 0, n = o = void 0, i || l.preventDefault()
				} else if (a.type === e.PointerEventTypes.POINTERMOVE)
					if (i || l.preventDefault(), n && void 0 === o) {
						if (0 !== s.panningSensibility && (l.ctrlKey && s.camera._useCtrlForPanning || !s.camera._useCtrlForPanning && s._isPanClick)) s.camera.inertialPanningX += -(l.clientX - r.x) / s.panningSensibility, s.camera.inertialPanningY += (l.clientY - r.y) / s.panningSensibility;
						else {
							var d = l.clientX - r.x,
								f = l.clientY - r.y;
							s.camera.inertialAlphaOffset -= d / s.angularSensibilityX, s.camera.inertialBetaOffset -= f / s.angularSensibilityY
						}
						r.x = l.clientX, r.y = l.clientY
					} else if (n && o) {
					var p = n.pointerId === l.pointerId ? n : o;
					p.x = l.clientX, p.y = l.clientY;
					var m = s.pinchInwards ? 1 : -1,
						_ = n.x - o.x,
						g = n.y - o.y,
						v = _ * _ + g * g;
					if (0 === h) return void(h = v);
					v !== h && (s.camera.inertialRadiusOffset += (v - h) / (s.pinchPrecision * ((s.angularSensibilityX + s.angularSensibilityY) / 2) * m), h = v)
				}
			}, this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, e.PointerEventTypes.POINTERDOWN | e.PointerEventTypes.POINTERUP | e.PointerEventTypes.POINTERMOVE), this._onContextMenu = function(e) {
				e.preventDefault()
			}, this.camera._useCtrlForPanning || t.addEventListener("contextmenu", this._onContextMenu, !1), this._onLostFocus = function() {
				n = o = void 0, h = 0, r = null
			}, this._onMouseMove = function(e) {
				if (a.isPointerLock) {
					var t = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0,
						r = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;
					s.camera.inertialAlphaOffset -= t / s.angularSensibilityX, s.camera.inertialBetaOffset -= r / s.angularSensibilityY, i || e.preventDefault()
				}
			}, this._onGestureStart = function(e) {
				void 0 !== window.MSGesture && (s._MSGestureHandler || (s._MSGestureHandler = new MSGesture, s._MSGestureHandler.target = t), s._MSGestureHandler.addPointer(e.pointerId))
			}, this._onGesture = function(e) {
				s.camera.radius *= e.scale, e.preventDefault && (i || (e.stopPropagation(), e.preventDefault()))
			}, t.addEventListener("mousemove", this._onMouseMove, !1), t.addEventListener("MSPointerDown", this._onGestureStart, !1), t.addEventListener("MSGestureChange", this._onGesture, !1), t.addEventListener("keydown", this._onKeyDown, !1), t.addEventListener("keyup", this._onKeyUp, !1), e.Tools.RegisterTopRootEvents([{
				name: "blur",
				handler: this._onLostFocus
			}])
		}, t.prototype.detachControl = function(t) {
			t && this._observer && (this.camera.getScene().onPointerObservable.remove(this._observer), this._observer = null, t.removeEventListener("contextmenu", this._onContextMenu), t.removeEventListener("mousemove", this._onMouseMove), t.removeEventListener("MSPointerDown", this._onGestureStart), t.removeEventListener("MSGestureChange", this._onGesture), t.removeEventListener("keydown", this._onKeyDown), t.removeEventListener("keyup", this._onKeyUp), this._isPanClick = !1, this.pinchInwards = !0, this._onKeyDown = null, this._onKeyUp = null, this._onMouseMove = null, this._onGestureStart = null, this._onGesture = null, this._MSGestureHandler = null, this._onLostFocus = null, this._onContextMenu = null), e.Tools.UnregisterTopRootEvents([{
				name: "blur",
				handler: this._onLostFocus
			}])
		}, t.prototype.getTypeName = function() {
			return "ArcRotateCameraPointersInput"
		}, t.prototype.getSimpleName = function() {
			return "pointers"
		}, __decorate([e.serialize()], t.prototype, "buttons", void 0), __decorate([e.serialize()], t.prototype, "angularSensibilityX", void 0), __decorate([e.serialize()], t.prototype, "angularSensibilityY", void 0), __decorate([e.serialize()], t.prototype, "pinchPrecision", void 0), __decorate([e.serialize()], t.prototype, "panningSensibility", void 0), t
	})());
	e.ArcRotateCameraPointersInput = t, e.CameraInputTypes.ArcRotateCameraPointersInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this.gamepadRotationSensibility = 80, this.gamepadMoveSensibility = 40
		}
		return t.prototype.attachControl = function(t, i) {
			var r = this;
			this._gamepads = new e.Gamepads(function(e) {
				r._onNewGameConnected(e)
			})
		}, t.prototype.detachControl = function(e) {
			this._gamepads && this._gamepads.dispose(), this.gamepad = null
		}, t.prototype.checkInputs = function() {
			if (this.gamepad) {
				var e = this.camera,
					t = this.gamepad.rightStick;
				if (0 != t.x) {
					var i = t.x / this.gamepadRotationSensibility;
					0 != i && Math.abs(i) > .005 && (e.inertialAlphaOffset += i)
				}
				if (0 != t.y) {
					var r = t.y / this.gamepadRotationSensibility;
					0 != r && Math.abs(r) > .005 && (e.inertialBetaOffset += r)
				}
				var n = this.gamepad.leftStick;
				if (0 != n.y) {
					var o = n.y / this.gamepadMoveSensibility;
					0 != o && Math.abs(o) > .005 && (this.camera.inertialRadiusOffset -= o)
				}
			}
		}, t.prototype._onNewGameConnected = function(e) {
			0 === e.index && (this.gamepad = e)
		}, t.prototype.getTypeName = function() {
			return "ArcRotateCameraGamepadInput"
		}, t.prototype.getSimpleName = function() {
			return "gamepad"
		}, __decorate([e.serialize()], t.prototype, "gamepadRotationSensibility", void 0), __decorate([e.serialize()], t.prototype, "gamepadMoveSensibility", void 0), t
	})();
	e.ArcRotateCameraGamepadInput = t, e.CameraInputTypes.ArcRotateCameraGamepadInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {
			this.alphaCorrection = 1, this.betaCorrection = 1, this.gammaCorrection = 1, this._alpha = 0, this._beta = 0, this._gamma = 0, this._dirty = !1, this._deviceOrientationHandler = this._onOrientationEvent.bind(this)
		}
		return e.prototype.attachControl = function(e, t) {
			this.camera.attachControl(e, t), window.addEventListener("deviceorientation", this._deviceOrientationHandler);
		}, e.prototype._onOrientationEvent = function(e) {
			this.camera;
			this._alpha = 0 | +e.alpha, this._beta = 0 | +e.beta, this._gamma = 0 | +e.gamma, this._dirty = !0
		}, e.prototype.checkInputs = function() {
			this._dirty && (this._dirty = !1, this._gamma < 0 && (this._gamma = 180 + this._gamma), this.camera.alpha = -this._alpha / 180 * Math.PI % Math.PI * 2, this.camera.beta = this._gamma / 180 * Math.PI)
		}, e.prototype.detachControl = function(e) {
			window.removeEventListener("deviceorientation", this._deviceOrientationHandler)
		}, e.prototype.getTypeName = function() {
			return "ArcRotateCameraVRDeviceOrientationInput"
		}, e.prototype.getSimpleName = function() {
			return "VRDeviceOrientation"
		}, e
	})();
	e.ArcRotateCameraVRDeviceOrientationInput = t, e.CameraInputTypes.ArcRotateCameraVRDeviceOrientationInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n) {
			t.call(this, i, r, n), this.cameraDirection = new e.Vector3(0, 0, 0), this.cameraRotation = new e.Vector2(0, 0), this.rotation = new e.Vector3(0, 0, 0), this.speed = 2, this.noRotationConstraint = !1, this.lockedTarget = null, this._currentTarget = e.Vector3.Zero(), this._viewMatrix = e.Matrix.Zero(), this._camMatrix = e.Matrix.Zero(), this._cameraTransformMatrix = e.Matrix.Zero(), this._cameraRotationMatrix = e.Matrix.Zero(), this._referencePoint = new e.Vector3(0, 0, 1), this._defaultUpVector = new e.Vector3(0, 1, 0), this._transformedReferencePoint = e.Vector3.Zero(), this._lookAtTemp = e.Matrix.Zero(), this._tempMatrix = e.Matrix.Zero()
		}
		return __extends(i, t), i.prototype.getFrontPosition = function(e) {
			var t = this.getTarget().subtract(this.position);
			return t.normalize(), t.scaleInPlace(e), this.globalPosition.add(t)
		}, i.prototype._getLockedTargetPosition = function() {
			return this.lockedTarget ? (this.lockedTarget.absolutePosition && this.lockedTarget.computeWorldMatrix(), this.lockedTarget.absolutePosition || this.lockedTarget) : null
		}, i.prototype._initCache = function() {
			t.prototype._initCache.call(this), this._cache.lockedTarget = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotationQuaternion = new e.Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
		}, i.prototype._updateCache = function(e) {
			e || t.prototype._updateCache.call(this);
			var i = this._getLockedTargetPosition();
			i ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(i) : this._cache.lockedTarget = i.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation), this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)
		}, i.prototype._isSynchronizedViewMatrix = function() {
			if (!t.prototype._isSynchronizedViewMatrix.call(this)) return !1;
			var e = this._getLockedTargetPosition();
			return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(e) : !e) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))
		}, i.prototype._computeLocalCameraSpeed = function() {
			var e = this.getEngine();
			return this.speed * Math.sqrt(e.getDeltaTime() / (100 * e.getFps()))
		}, i.prototype.setTarget = function(t) {
			this.upVector.normalize(), e.Matrix.LookAtLHToRef(this.position, t, this._defaultUpVector, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
			var i = t.subtract(this.position);
			i.x >= 0 ? this.rotation.y = -Math.atan(i.z / i.x) + Math.PI / 2 : this.rotation.y = -Math.atan(i.z / i.x) - Math.PI / 2, this.rotation.z = 0, isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0), this.rotationQuaternion && e.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion)
		}, i.prototype.getTarget = function() {
			return this._currentTarget
		}, i.prototype._decideIfNeedsToMove = function() {
			return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0
		}, i.prototype._updatePosition = function() {
			this.position.addInPlace(this.cameraDirection)
		}, i.prototype._checkInputs = function() {
			var i = this._decideIfNeedsToMove(),
				r = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
			if (i && this._updatePosition(), r && (this.rotation.x += this.cameraRotation.x, this.rotation.y += this.cameraRotation.y, !this.noRotationConstraint)) {
				var n = Math.PI / 2 * .95;
				this.rotation.x > n && (this.rotation.x = n), this.rotation.x < -n && (this.rotation.x = -n)
			}
			i && (Math.abs(this.cameraDirection.x) < e.Epsilon && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < e.Epsilon && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < e.Epsilon && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), r && (Math.abs(this.cameraRotation.x) < e.Epsilon && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < e.Epsilon && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)), t.prototype._checkInputs.call(this)
		}, i.prototype._updateCameraRotationMatrix = function() {
			this.rotationQuaternion ? (this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix), e.Vector3.TransformNormalToRef(this._defaultUpVector, this._cameraRotationMatrix, this.upVector)) : e.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix)
		}, i.prototype._getViewMatrix = function() {
			return this.lockedTarget ? this._currentTarget.copyFrom(this._getLockedTargetPosition()) : (this._updateCameraRotationMatrix(), e.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget)), this.getScene().useRightHandedSystem ? e.Matrix.LookAtRHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix) : e.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix), this._viewMatrix
		}, i.prototype.createRigCamera = function(t, r) {
			if (this.cameraRigMode !== e.Camera.RIG_MODE_NONE) {
				var n = new i(t, this.position.clone(), this.getScene());
				return this.cameraRigMode !== e.Camera.RIG_MODE_VR && this.cameraRigMode !== e.Camera.RIG_MODE_WEBVR || (this.rotationQuaternion || (this.rotationQuaternion = new e.Quaternion), n._cameraRigParams = {}, n.rotationQuaternion = new e.Quaternion), n
			}
			return null
		}, i.prototype._updateRigCameras = function() {
			var i = this._rigCameras[0],
				r = this._rigCameras[1];
			switch (this.cameraRigMode) {
				case e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
				case e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
				case e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
					var n = this.cameraRigMode === e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1,
						o = this.cameraRigMode === e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
					this._getRigCamPosition(this._cameraRigParams.stereoHalfAngle * n, i.position), this._getRigCamPosition(this._cameraRigParams.stereoHalfAngle * o, r.position), i.setTarget(this.getTarget()), r.setTarget(this.getTarget());
					break;
				case e.Camera.RIG_MODE_VR:
				case e.Camera.RIG_MODE_WEBVR:
					i.rotationQuaternion ? (i.rotationQuaternion.copyFrom(this.rotationQuaternion), r.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (i.rotation.copyFrom(this.rotation), r.rotation.copyFrom(this.rotation)), i.position.copyFrom(this.position), r.position.copyFrom(this.position)
			}
			t.prototype._updateRigCameras.call(this)
		}, i.prototype._getRigCamPosition = function(t, i) {
			this._rigCamTransformMatrix || (this._rigCamTransformMatrix = new e.Matrix);
			var r = this.getTarget();
			e.Matrix.Translation(-r.x, -r.y, -r.z).multiplyToRef(e.Matrix.RotationY(t), this._rigCamTransformMatrix), this._rigCamTransformMatrix = this._rigCamTransformMatrix.multiply(e.Matrix.Translation(r.x, r.y, r.z)), e.Vector3.TransformCoordinatesToRef(this.position, this._rigCamTransformMatrix, i)
		}, i.prototype.getTypeName = function() {
			return "TargetCamera"
		}, __decorate([e.serializeAsVector3()], i.prototype, "rotation", void 0), __decorate([e.serialize()], i.prototype, "speed", void 0), __decorate([e.serializeAsMeshReference("lockedTargetId")], i.prototype, "lockedTarget", void 0), i
	})(e.Camera);
	e.TargetCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n) {
			var o = this;
			t.call(this, i, r, n), this.ellipsoid = new e.Vector3(.5, 1, .5), this.checkCollisions = !1, this.applyGravity = !1, this._collider = new e.Collider, this._needMoveForGravity = !1, this._oldPosition = e.Vector3.Zero(), this._diffPosition = e.Vector3.Zero(), this._newPosition = e.Vector3.Zero(), this._onCollisionPositionChange = function(t, i, r) {
				void 0 === r && (r = null), o.getScene().workerCollisions && i.multiplyInPlace(o._collider.radius);
				var n = function(t) {
					o._newPosition.copyFrom(t), o._newPosition.subtractToRef(o._oldPosition, o._diffPosition);
					o.position.clone();
					o._diffPosition.length() > e.Engine.CollisionsEpsilon && (o.position.addInPlace(o._diffPosition), o.onCollide && r && o.onCollide(r))
				};
				n(i)
			}, this.inputs = new e.FreeCameraInputsManager(this), this.inputs.addKeyboard().addMouse()
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "angularSensibility", {
			get: function() {
				var e = this.inputs.attached.mouse;
				if (e) return e.angularSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.mouse;
				t && (t.angularSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysUp", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysUp
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysUp = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysDown", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysDown
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysDown = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysLeft", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysLeft
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysLeft = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysRight", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysRight
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysRight = e)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.attachControl = function(e, t) {
			this.inputs.attachElement(e, t)
		}, i.prototype.detachControl = function(t) {
			this.inputs.detachElement(t), this.cameraDirection = new e.Vector3(0, 0, 0), this.cameraRotation = new e.Vector2(0, 0)
		}, i.prototype._collideWithWorld = function(t) {
			var i;
			i = this.parent ? e.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix()) : this.position, i.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition), this._collider.radius = this.ellipsoid;
			var r = t;
			this.applyGravity && (r = t.add(this.getScene().gravity)), this.getScene().collisionCoordinator.getNewPosition(this._oldPosition, r, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId)
		}, i.prototype._checkInputs = function() {
			this._localDirection || (this._localDirection = e.Vector3.Zero(), this._transformedDirection = e.Vector3.Zero()), this.inputs.checkInputs(), t.prototype._checkInputs.call(this)
		}, i.prototype._decideIfNeedsToMove = function() {
			return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0
		}, i.prototype._updatePosition = function() {
			this.checkCollisions && this.getScene().collisionsEnabled ? this._collideWithWorld(this.cameraDirection) : this.position.addInPlace(this.cameraDirection)
		}, i.prototype.dispose = function() {
			this.inputs.clear(), t.prototype.dispose.call(this)
		}, i.prototype.getTypeName = function() {
			return "FreeCamera"
		}, __decorate([e.serializeAsVector3()], i.prototype, "ellipsoid", void 0), __decorate([e.serialize()], i.prototype, "checkCollisions", void 0), __decorate([e.serialize()], i.prototype, "applyGravity", void 0), i
	})(e.TargetCamera);
	e.FreeCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e) {
			t.call(this, e)
		}
		return __extends(i, t), i.prototype.addKeyboard = function() {
			return this.add(new e.FreeCameraKeyboardMoveInput), this
		}, i.prototype.addMouse = function(t) {
			return void 0 === t && (t = !0), this.add(new e.FreeCameraMouseInput(t)), this
		}, i.prototype.addGamepad = function() {
			return this.add(new e.FreeCameraGamepadInput), this
		}, i.prototype.addDeviceOrientation = function() {
			return this.add(new e.FreeCameraDeviceOrientationInput), this
		}, i.prototype.addTouch = function() {
			return this.add(new e.FreeCameraTouchInput), this
		}, i.prototype.addVirtualJoystick = function() {
			return this.add(new e.FreeCameraVirtualJoystickInput), this
		}, i
	})(e.CameraInputsManager);
	e.FreeCameraInputsManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r, n) {
			t.call(this, e, i, r), this.radius = 12, this.rotationOffset = 0, this.heightOffset = 4, this.cameraAcceleration = .05, this.maxCameraSpeed = 20, this.lockedTarget = n
		}
		return __extends(i, t), i.prototype.getRadians = function(e) {
			return e * Math.PI / 180
		}, i.prototype.follow = function(t) {
			if (t) {
				var i;
				if (t.rotationQuaternion) {
					var r = new e.Matrix;
					t.rotationQuaternion.toRotationMatrix(r), i = Math.atan2(r.m[8], r.m[10])
				} else i = t.rotation.y;
				var n = this.getRadians(this.rotationOffset) + i,
					o = t.position.x + Math.sin(n) * this.radius,
					s = t.position.z + Math.cos(n) * this.radius,
					a = o - this.position.x,
					h = t.position.y + this.heightOffset - this.position.y,
					c = s - this.position.z,
					l = a * this.cameraAcceleration * 2,
					u = h * this.cameraAcceleration,
					d = c * this.cameraAcceleration * 2;
				(l > this.maxCameraSpeed || l < -this.maxCameraSpeed) && (l = l < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed), (u > this.maxCameraSpeed || u < -this.maxCameraSpeed) && (u = u < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed), (d > this.maxCameraSpeed || d < -this.maxCameraSpeed) && (d = d < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed), this.position = new e.Vector3(this.position.x + l, this.position.y + u, this.position.z + d), this.setTarget(t.position)
			}
		}, i.prototype._checkInputs = function() {
			t.prototype._checkInputs.call(this), this.follow(this.lockedTarget)
		}, i.prototype.getTypeName = function() {
			return "FollowCamera"
		}, __decorate([e.serialize()], i.prototype, "radius", void 0), __decorate([e.serialize()], i.prototype, "rotationOffset", void 0), __decorate([e.serialize()], i.prototype, "heightOffset", void 0), __decorate([e.serialize()], i.prototype, "cameraAcceleration", void 0), __decorate([e.serialize()], i.prototype, "maxCameraSpeed", void 0), __decorate([e.serializeAsMeshReference("lockedTargetId")], i.prototype, "lockedTarget", void 0), i
	})(e.TargetCamera);
	e.FollowCamera = t;
	var i = (function(t) {
		function i(i, r, n, o, s, a) {
			t.call(this, i, e.Vector3.Zero(), a), this.alpha = r, this.beta = n, this.radius = o, this.target = s, this._cartesianCoordinates = e.Vector3.Zero(), this.follow()
		}
		return __extends(i, t), i.prototype.follow = function() {
			this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta), this._cartesianCoordinates.y = this.radius * Math.sin(this.beta), this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta), this.position = this.target.position.add(this._cartesianCoordinates), this.setTarget(this.target.position)
		}, i.prototype._checkInputs = function() {
			t.prototype._checkInputs.call(this), this.follow()
		}, i.prototype.getTypeName = function() {
			return "ArcFollowCamera"
		}, i
	})(e.TargetCamera);
	e.ArcFollowCamera = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r) {
			e.call(this, t, i, r), this.inputs.addTouch(), this._setupInputs()
		}
		return __extends(t, e), Object.defineProperty(t.prototype, "touchAngularSensibility", {
			get: function() {
				var e = this.inputs.attached.touch;
				if (e) return e.touchAngularSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.touch;
				t && (t.touchAngularSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "touchMoveSensibility", {
			get: function() {
				var e = this.inputs.attached.touch;
				if (e) return e.touchMoveSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.touch;
				t && (t.touchMoveSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getTypeName = function() {
			return "TouchCamera"
		}, t.prototype._setupInputs = function() {
			var e = this.inputs.attached.mouse;
			e && (e.touchEnabled = !1)
		}, t
	})(e.FreeCamera);
	e.TouchCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a) {
			var h = this;
			t.call(this, i, e.Vector3.Zero(), a), this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.lowerAlphaLimit = null, this.upperAlphaLimit = null, this.lowerBetaLimit = .01, this.upperBetaLimit = Math.PI, this.lowerRadiusLimit = null, this.upperRadiusLimit = null, this.inertialPanningX = 0, this.inertialPanningY = 0, this.zoomOnFactor = 1, this.targetScreenOffset = e.Vector2.Zero(), this.allowUpsideDown = !0, this._viewMatrix = new e.Matrix, this.panningAxis = new e.Vector3(1, 1, 0), this.checkCollisions = !1, this.collisionRadius = new e.Vector3(.5, .5, .5), this._collider = new e.Collider, this._previousPosition = e.Vector3.Zero(), this._collisionVelocity = e.Vector3.Zero(), this._newPosition = e.Vector3.Zero(), this._onCollisionPositionChange = function(t, i, r) {
				void 0 === r && (r = null), h.getScene().workerCollisions && h.checkCollisions && i.multiplyInPlace(h._collider.radius), r ? (h.setPosition(i), h.onCollide && h.onCollide(r)) : h._previousPosition.copyFrom(h.position);
				var n = Math.cos(h.alpha),
					o = Math.sin(h.alpha),
					s = Math.cos(h.beta),
					a = Math.sin(h.beta);
				0 === a && (a = 1e-4);
				var c = h._getTargetPosition();
				c.addToRef(new e.Vector3(h.radius * n * a, h.radius * s, h.radius * o * a), h._newPosition), h.position.copyFrom(h._newPosition);
				var l = h.upVector;
				h.allowUpsideDown && h.beta < 0 && (l = l.clone(), l = l.negate()), e.Matrix.LookAtLHToRef(h.position, c, l, h._viewMatrix), h._viewMatrix.m[12] += h.targetScreenOffset.x, h._viewMatrix.m[13] += h.targetScreenOffset.y, h._collisionTriggered = !1
			}, s ? this.target = s : this.target = e.Vector3.Zero(), this.alpha = r, this.beta = n, this.radius = o, this.getViewMatrix(), this.inputs = new e.ArcRotateCameraInputsManager(this), this.inputs.addKeyboard().addMouseWheel().addPointers().addGamepad()
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "angularSensibilityX", {
			get: function() {
				var e = this.inputs.attached.pointers;
				if (e) return e.angularSensibilityX
			},
			set: function(e) {
				var t = this.inputs.attached.pointers;
				t && (t.angularSensibilityX = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "angularSensibilityY", {
			get: function() {
				var e = this.inputs.attached.pointers;
				if (e) return e.angularSensibilityY
			},
			set: function(e) {
				var t = this.inputs.attached.pointers;
				t && (t.angularSensibilityY = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "pinchPrecision", {
			get: function() {
				var e = this.inputs.attached.pointers;
				if (e) return e.pinchPrecision
			},
			set: function(e) {
				var t = this.inputs.attached.pointers;
				t && (t.pinchPrecision = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "panningSensibility", {
			get: function() {
				var e = this.inputs.attached.pointers;
				if (e) return e.panningSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.pointers;
				t && (t.panningSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysUp", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysUp
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysUp = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysDown", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysDown
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysDown = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysLeft", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysLeft
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysLeft = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "keysRight", {
			get: function() {
				var e = this.inputs.attached.keyboard;
				if (e) return e.keysRight
			},
			set: function(e) {
				var t = this.inputs.attached.keyboard;
				t && (t.keysRight = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "wheelPrecision", {
			get: function() {
				var e = this.inputs.attached.mousewheel;
				if (e) return e.wheelPrecision
			},
			set: function(e) {
				var t = this.inputs.attached.mousewheel;
				t && (t.wheelPrecision = e)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._initCache = function() {
			t.prototype._initCache.call(this), this._cache.target = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.alpha = void 0, this._cache.beta = void 0, this._cache.radius = void 0, this._cache.targetScreenOffset = e.Vector2.Zero()
		}, i.prototype._updateCache = function(e) {
			e || t.prototype._updateCache.call(this), this._cache.target.copyFrom(this._getTargetPosition()), this._cache.alpha = this.alpha, this._cache.beta = this.beta, this._cache.radius = this.radius, this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset)
		}, i.prototype._getTargetPosition = function() {
			if (this.target.getAbsolutePosition) {
				var e = this.target.getAbsolutePosition();
				return this._targetBoundingCenter ? e.add(this._targetBoundingCenter) : e
			}
			return this.target
		}, i.prototype._isSynchronizedViewMatrix = function() {
			return !!t.prototype._isSynchronizedViewMatrix.call(this) && (this._cache.target.equals(this.target) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset))
		}, i.prototype.attachControl = function(e, t, i, r) {
			var n = this;
			void 0 === i && (i = !0), void 0 === r && (r = 2), this._useCtrlForPanning = i, this._panningMouseButton = r, this.inputs.attachElement(e, t), this._reset = function() {
				n.inertialAlphaOffset = 0, n.inertialBetaOffset = 0, n.inertialRadiusOffset = 0
			}
		}, i.prototype.detachControl = function(e) {
			this.inputs.detachElement(e), this._reset && this._reset()
		}, i.prototype._checkInputs = function() {
			this._collisionTriggered || (this.inputs.checkInputs(), 0 === this.inertialAlphaOffset && 0 === this.inertialBetaOffset && 0 === this.inertialRadiusOffset || (this.getScene().useRightHandedSystem ? this.alpha -= this.beta <= 0 ? -this.inertialAlphaOffset : this.inertialAlphaOffset : this.alpha += this.beta <= 0 ? -this.inertialAlphaOffset : this.inertialAlphaOffset, this.beta += this.inertialBetaOffset, this.radius -= this.inertialRadiusOffset, this.inertialAlphaOffset *= this.inertia, this.inertialBetaOffset *= this.inertia, this.inertialRadiusOffset *= this.inertia, Math.abs(this.inertialAlphaOffset) < e.Epsilon && (this.inertialAlphaOffset = 0), Math.abs(this.inertialBetaOffset) < e.Epsilon && (this.inertialBetaOffset = 0), Math.abs(this.inertialRadiusOffset) < e.Epsilon && (this.inertialRadiusOffset = 0)), 0 === this.inertialPanningX && 0 === this.inertialPanningY || (this._localDirection || (this._localDirection = e.Vector3.Zero(), this._transformedDirection = e.Vector3.Zero()), this.inertialPanningX *= this.inertia, this.inertialPanningY *= this.inertia, Math.abs(this.inertialPanningX) < e.Epsilon && (this.inertialPanningX = 0), Math.abs(this.inertialPanningY) < e.Epsilon && (this.inertialPanningY = 0), this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY), this._localDirection.multiplyInPlace(this.panningAxis), this._viewMatrix.invertToRef(this._cameraTransformMatrix), e.Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection), this.panningAxis.y || (this._transformedDirection.y = 0), this.target.getAbsolutePosition || this.target.addInPlace(this._transformedDirection)), this._checkLimits(), t.prototype._checkInputs.call(this))
		}, i.prototype._checkLimits = function() {
			null === this.lowerBetaLimit || void 0 === this.lowerBetaLimit ? this.allowUpsideDown && this.beta > Math.PI && (this.beta = this.beta - 2 * Math.PI) : this.beta < this.lowerBetaLimit && (this.beta = this.lowerBetaLimit), null === this.upperBetaLimit || void 0 === this.upperBetaLimit ? this.allowUpsideDown && this.beta < -Math.PI && (this.beta = this.beta + 2 * Math.PI) : this.beta > this.upperBetaLimit && (this.beta = this.upperBetaLimit), this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit && (this.alpha = this.lowerAlphaLimit), this.upperAlphaLimit && this.alpha > this.upperAlphaLimit && (this.alpha = this.upperAlphaLimit), this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit && (this.radius = this.lowerRadiusLimit), this.upperRadiusLimit && this.radius > this.upperRadiusLimit && (this.radius = this.upperRadiusLimit)
		}, i.prototype.rebuildAnglesAndRadius = function() {
			var e = this.position.subtract(this._getTargetPosition());
			this.radius = e.length(), this.alpha = Math.acos(e.x / Math.sqrt(Math.pow(e.x, 2) + Math.pow(e.z, 2))), e.z < 0 && (this.alpha = 2 * Math.PI - this.alpha), this.beta = Math.acos(e.y / this.radius), this._checkLimits()
		}, i.prototype.setPosition = function(e) {
			this.position.equals(e) || (this.position.copyFrom(e), this.rebuildAnglesAndRadius())
		}, i.prototype.setTarget = function(e, t) {
			void 0 === t && (t = !1), this._getTargetPosition().equals(e) || (t && e.getBoundingInfo ? this._targetBoundingCenter = e.getBoundingInfo().boundingBox.center.clone() : this._targetBoundingCenter = null, this.target = e, this.rebuildAnglesAndRadius())
		}, i.prototype._getViewMatrix = function() {
			var t = Math.cos(this.alpha),
				i = Math.sin(this.alpha),
				r = Math.cos(this.beta),
				n = Math.sin(this.beta);
			0 === n && (n = 1e-4);
			var o = this._getTargetPosition();
			if (o.addToRef(new e.Vector3(this.radius * t * n, this.radius * r, this.radius * i * n), this._newPosition), this.getScene().collisionsEnabled && this.checkCollisions) this._collider.radius = this.collisionRadius, this._newPosition.subtractToRef(this.position, this._collisionVelocity), this._collisionTriggered = !0, this.getScene().collisionCoordinator.getNewPosition(this.position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
			else {
				this.position.copyFrom(this._newPosition);
				var s = this.upVector;
				this.allowUpsideDown && this.beta < 0 && (s = s.clone(), s = s.negate()), this.getScene().useRightHandedSystem ? e.Matrix.LookAtRHToRef(this.position, o, s, this._viewMatrix) : e.Matrix.LookAtLHToRef(this.position, o, s, this._viewMatrix), this._viewMatrix.m[12] += this.targetScreenOffset.x, this._viewMatrix.m[13] += this.targetScreenOffset.y
			}
			return this._currentTarget = o, this._viewMatrix
		}, i.prototype.zoomOn = function(t, i) {
			void 0 === i && (i = !1), t = t || this.getScene().meshes;
			var r = e.Mesh.MinMax(t),
				n = e.Vector3.Distance(r.min, r.max);
			this.radius = n * this.zoomOnFactor, this.focusOn({
				min: r.min,
				max: r.max,
				distance: n
			}, i)
		}, i.prototype.focusOn = function(t, i) {
			void 0 === i && (i = !1);
			var r, n;
			void 0 === t.min ? (r = t || this.getScene().meshes, r = e.Mesh.MinMax(r), n = e.Vector3.Distance(r.min, r.max)) : (r = t, n = t.distance), this.target = e.Mesh.Center(r), i || (this.maxZ = 2 * n)
		}, i.prototype.createRigCamera = function(t, r) {
			var n;
			switch (this.cameraRigMode) {
				case e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
				case e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
				case e.Camera.RIG_MODE_VR:
					n = this._cameraRigParams.stereoHalfAngle * (0 === r ? 1 : -1);
					break;
				case e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
					n = this._cameraRigParams.stereoHalfAngle * (0 === r ? -1 : 1)
			}
			var o = new i(t, this.alpha + n, this.beta, this.radius, this.target, this.getScene());
			return o._cameraRigParams = {}, o
		}, i.prototype._updateRigCameras = function() {
			var i = this._rigCameras[0],
				r = this._rigCameras[1];
			switch (i.beta = r.beta = this.beta, i.radius = r.radius = this.radius, this.cameraRigMode) {
				case e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
				case e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
				case e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
				case e.Camera.RIG_MODE_VR:
					i.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle, r.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
					break;
				case e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
					i.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle, r.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle
			}
			t.prototype._updateRigCameras.call(this)
		}, i.prototype.dispose = function() {
			this.inputs.clear(), t.prototype.dispose.call(this)
		}, i.prototype.getTypeName = function() {
			return "ArcRotateCamera"
		}, __decorate([e.serialize()], i.prototype, "alpha", void 0), __decorate([e.serialize()], i.prototype, "beta", void 0), __decorate([e.serialize()], i.prototype, "radius", void 0), __decorate([e.serializeAsVector3()], i.prototype, "target", void 0), __decorate([e.serialize()], i.prototype, "inertialAlphaOffset", void 0), __decorate([e.serialize()], i.prototype, "inertialBetaOffset", void 0), __decorate([e.serialize()], i.prototype, "inertialRadiusOffset", void 0), __decorate([e.serialize()], i.prototype, "lowerAlphaLimit", void 0), __decorate([e.serialize()], i.prototype, "upperAlphaLimit", void 0), __decorate([e.serialize()], i.prototype, "lowerBetaLimit", void 0), __decorate([e.serialize()], i.prototype, "upperBetaLimit", void 0), __decorate([e.serialize()], i.prototype, "lowerRadiusLimit", void 0), __decorate([e.serialize()], i.prototype, "upperRadiusLimit", void 0), __decorate([e.serialize()], i.prototype, "inertialPanningX", void 0), __decorate([e.serialize()], i.prototype, "inertialPanningY", void 0), __decorate([e.serialize()], i.prototype, "zoomOnFactor", void 0), __decorate([e.serialize()], i.prototype, "allowUpsideDown", void 0), i
	})(e.TargetCamera);
	e.ArcRotateCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e) {
			t.call(this, e)
		}
		return __extends(i, t), i.prototype.addMouseWheel = function() {
			return this.add(new e.ArcRotateCameraMouseWheelInput), this
		}, i.prototype.addPointers = function() {
			return this.add(new e.ArcRotateCameraPointersInput), this
		}, i.prototype.addKeyboard = function() {
			return this.add(new e.ArcRotateCameraKeyboardMoveInput), this
		}, i.prototype.addGamepad = function() {
			return this.add(new e.ArcRotateCameraGamepadInput), this
		}, i.prototype.addVRDeviceOrientation = function() {
			return this.add(new e.ArcRotateCameraVRDeviceOrientationInput), this
		}, i
	})(e.CameraInputsManager);
	e.ArcRotateCameraInputsManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e) {
			this._renderingGroups = new Array, this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderinGroupInfo = null, this._scene = e;
			for (var i = t.MIN_RENDERINGGROUPS; i < t.MAX_RENDERINGGROUPS; i++) this._autoClearDepthStencil[i] = !0
		}
		return t.prototype._renderParticles = function(e, t) {
			if (0 !== this._scene._activeParticleSystems.length) {
				var i = this._scene.activeCamera;
				this._scene._particlesDuration.beginMonitoring();
				for (var r = 0; r < this._scene._activeParticleSystems.length; r++) {
					var n = this._scene._activeParticleSystems.data[r];
					n.renderingGroupId === e && 0 !== (i.layerMask & n.layerMask) && (this._clearDepthStencilBuffer(), n.emitter.position && t && t.indexOf(n.emitter) === -1 || this._scene._activeParticles.addCount(n.render(), !1))
				}
				this._scene._particlesDuration.endMonitoring(!1)
			}
		}, t.prototype._renderSprites = function(e) {
			if (this._scene.spritesEnabled && 0 !== this._scene.spriteManagers.length) {
				var t = this._scene.activeCamera;
				this._scene._spritesDuration.beginMonitoring();
				for (var i = 0; i < this._scene.spriteManagers.length; i++) {
					var r = this._scene.spriteManagers[i];
					r.renderingGroupId === e && 0 !== (t.layerMask & r.layerMask) && (this._clearDepthStencilBuffer(), r.render())
				}
				this._scene._spritesDuration.endMonitoring(!1)
			}
		}, t.prototype._clearDepthStencilBuffer = function() {
			this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(0, !1, !0, !0), this._depthStencilBufferAlreadyCleaned = !0)
		}, t.prototype._renderSpritesAndParticles = function() {
			this._currentRenderSprites && this._renderSprites(this._currentIndex), this._currentRenderParticles && this._renderParticles(this._currentIndex, this._currentActiveMeshes)
		}, t.prototype.render = function(i, r, n, o) {
			var s = this._scene.onRenderingGroupObservable.hasObservers() ? this._scene.onRenderingGroupObservable : null,
				a = null;
			s && (this._renderinGroupInfo || (this._renderinGroupInfo = new e.RenderingGroupInfo), a = this._renderinGroupInfo, a.scene = this._scene, a.camera = this._scene.activeCamera), this._currentActiveMeshes = r, this._currentRenderParticles = n, this._currentRenderSprites = o;
			for (var h = t.MIN_RENDERINGGROUPS; h < t.MAX_RENDERINGGROUPS; h++) {
				this._depthStencilBufferAlreadyCleaned = h === t.MIN_RENDERINGGROUPS;
				var c = this._renderingGroups[h],
					l = !1;
				if (this._currentIndex = h, c) {
					var u = 0;
					s && (u = Math.pow(2, h), a.renderStage = e.RenderingGroupInfo.STAGE_PRECLEAR, a.renderingGroupId = h, s.notifyObservers(a, u)), this._autoClearDepthStencil[h] && this._clearDepthStencilBuffer(), s && (a.renderStage = e.RenderingGroupInfo.STAGE_PREOPAQUE, s.notifyObservers(a, u)), c.onBeforeTransparentRendering || (c.onBeforeTransparentRendering = this._renderSpritesAndParticles.bind(this)), s && (a.renderStage = e.RenderingGroupInfo.STAGE_PRETRANSPARENT, s.notifyObservers(a, u)), c.render(i) || (this._renderingGroups.splice(h, 1), l = !0, this._renderSpritesAndParticles()), s && (a.renderStage = e.RenderingGroupInfo.STAGE_POSTTRANSPARENT, s.notifyObservers(a, u))
				} else if (this._renderSpritesAndParticles(), s) {
					var u = Math.pow(2, h);
					a.renderStage = e.RenderingGroupInfo.STAGE_PRECLEAR,
						a.renderingGroupId = h, s.notifyObservers(a, u), a.renderStage = e.RenderingGroupInfo.STAGE_POSTTRANSPARENT, s.notifyObservers(a, u)
				}
				l && h--
			}
		}, t.prototype.reset = function() {
			for (var e = t.MIN_RENDERINGGROUPS; e < t.MAX_RENDERINGGROUPS; e++) {
				var i = this._renderingGroups[e];
				i && i.prepare()
			}
		}, t.prototype.dispatch = function(t) {
			var i = t.getMesh(),
				r = i.renderingGroupId || 0;
			this._renderingGroups[r] || (this._renderingGroups[r] = new e.RenderingGroup(r, this._scene, this._customOpaqueSortCompareFn[r], this._customAlphaTestSortCompareFn[r], this._customTransparentSortCompareFn[r])), this._renderingGroups[r].dispatch(t)
		}, t.prototype.setRenderingOrder = function(e, t, i, r) {
			if (void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = i, this._customTransparentSortCompareFn[e] = r, this._renderingGroups[e]) {
				var n = this._renderingGroups[e];
				n.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], n.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], n.transparentSortCompareFn = this._customTransparentSortCompareFn[e]
			}
		}, t.prototype.setRenderingAutoClearDepthStencil = function(e, t) {
			this._autoClearDepthStencil[e] = t
		}, t.MAX_RENDERINGGROUPS = 4, t.MIN_RENDERINGGROUPS = 0, t
	})();
	e.RenderingManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o) {
			void 0 === r && (r = null), void 0 === n && (n = null), void 0 === o && (o = null), this.index = t, this._opaqueSubMeshes = new e.SmartArray(256), this._transparentSubMeshes = new e.SmartArray(256), this._alphaTestSubMeshes = new e.SmartArray(256), this._scene = i, this.opaqueSortCompareFn = r, this.alphaTestSortCompareFn = n, this.transparentSortCompareFn = o
		}
		return Object.defineProperty(t.prototype, "opaqueSortCompareFn", {
			set: function(e) {
				this._opaqueSortCompareFn = e, e ? this._renderOpaque = this.renderOpaqueSorted : this._renderOpaque = t.renderUnsorted
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "alphaTestSortCompareFn", {
			set: function(e) {
				this._alphaTestSortCompareFn = e, e ? this._renderAlphaTest = this.renderAlphaTestSorted : this._renderAlphaTest = t.renderUnsorted
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "transparentSortCompareFn", {
			set: function(e) {
				e ? this._transparentSortCompareFn = e : this._transparentSortCompareFn = t.defaultTransparentSortCompare, this._renderTransparent = this.renderTransparentSorted
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.render = function(t) {
			if (t) return t(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes), !0;
			if (0 === this._opaqueSubMeshes.length && 0 === this._alphaTestSubMeshes.length && 0 === this._transparentSubMeshes.length) return this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), !1;
			var i = this._scene.getEngine();
			return this._renderOpaque(this._opaqueSubMeshes), i.setAlphaTesting(!0), this._renderAlphaTest(this._alphaTestSubMeshes), i.setAlphaTesting(!1), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), this._renderTransparent(this._transparentSubMeshes), i.setAlphaMode(e.Engine.ALPHA_DISABLE), !0
		}, t.prototype.renderOpaqueSorted = function(e) {
			return t.renderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera.globalPosition, !1)
		}, t.prototype.renderAlphaTestSorted = function(e) {
			return t.renderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera.globalPosition, !1)
		}, t.prototype.renderTransparentSorted = function(e) {
			return t.renderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera.globalPosition, !0)
		}, t.renderSorted = function(e, t, i, r) {
			for (var n, o = 0; o < e.length; o++) n = e.data[o], n._alphaIndex = n.getMesh().alphaIndex, n._distanceToCamera = n.getBoundingInfo().boundingSphere.centerWorld.subtract(i).length();
			var s = e.data.slice(0, e.length);
			for (s.sort(t), o = 0; o < s.length; o++) n = s[o], n.render(r)
		}, t.renderUnsorted = function(e) {
			for (var t = 0; t < e.length; t++) {
				var i = e.data[t];
				i.render(!1)
			}
		}, t.defaultTransparentSortCompare = function(e, i) {
			return e._alphaIndex > i._alphaIndex ? 1 : e._alphaIndex < i._alphaIndex ? -1 : t.backToFrontSortCompare(e, i)
		}, t.backToFrontSortCompare = function(e, t) {
			return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0
		}, t.frontToBackSortCompare = function(e, t) {
			return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0
		}, t.prototype.prepare = function() {
			this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset()
		}, t.prototype.dispatch = function(e) {
			var t = e.getMaterial(),
				i = e.getMesh();
			t.needAlphaBlending() || i.visibility < 1 || i.hasVertexAlpha ? this._transparentSubMeshes.push(e) : t.needAlphaTesting() ? this._alphaTestSubMeshes.push(e) : this._opaqueSubMeshes.push(e)
		}, t
	})();
	e.RenderingGroup = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {}
		return Object.defineProperty(e, "POINTERDOWN", {
			get: function() {
				return e._POINTERDOWN
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e, "POINTERUP", {
			get: function() {
				return e._POINTERUP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e, "POINTERMOVE", {
			get: function() {
				return e._POINTERMOVE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e, "POINTERWHEEL", {
			get: function() {
				return e._POINTERWHEEL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e, "POINTERPICK", {
			get: function() {
				return e._POINTERPICK
			},
			enumerable: !0,
			configurable: !0
		}), e._POINTERDOWN = 1, e._POINTERUP = 2, e._POINTERMOVE = 4, e._POINTERWHEEL = 8, e._POINTERPICK = 16, e
	})();
	e.PointerEventTypes = t;
	var i = (function() {
		function e(e, t) {
			this.type = e, this.event = t
		}
		return e
	})();
	e.PointerInfoBase = i;
	var r = (function(t) {
		function i(i, r, n, o) {
			t.call(this, i, r), this.skipOnPointerObservable = !1, this.localPosition = new e.Vector2(n, o)
		}
		return __extends(i, t), i
	})(i);
	e.PointerInfoPre = r;
	var n = (function(e) {
		function t(t, i, r) {
			e.call(this, t, i), this.pickInfo = r
		}
		return __extends(t, e), t
	})(i);
	e.PointerInfo = n;
	var o = (function() {
		function e() {}
		return e.STAGE_PRECLEAR = 1, e.STAGE_PREOPAQUE = 2, e.STAGE_PRETRANSPARENT = 3, e.STAGE_POSTTRANSPARENT = 4, e
	})();
	e.RenderingGroupInfo = o;
	var s = (function() {
		function i(t) {
			this.autoClear = !0, this.clearColor = new e.Color3(.2, .2, .3), this.ambientColor = new e.Color3(0, 0, 0), this.forceWireframe = !1, this.forcePointsCloud = !1, this.forceShowBoundingBoxes = !1, this.animationsEnabled = !0, this.constantlyUpdateMeshUnderPointer = !1, this.useRightHandedSystem = !1, this.hoverCursor = "pointer", this.metadata = null, this.onDisposeObservable = new e.Observable, this.onBeforeRenderObservable = new e.Observable, this.onAfterRenderObservable = new e.Observable, this.onReadyObservable = new e.Observable, this.onBeforeCameraRenderObservable = new e.Observable, this.onAfterCameraRenderObservable = new e.Observable, this.onNewCameraAddedObservable = new e.Observable, this.onCameraRemovedObservable = new e.Observable, this.onNewLightAddedObservable = new e.Observable, this.onLightRemovedObservable = new e.Observable, this.onNewGeometryAddedObservable = new e.Observable, this.onGeometryRemovedObservable = new e.Observable, this.onNewMeshAddedObservable = new e.Observable, this.onMeshRemovedObservable = new e.Observable, this.onRenderingGroupObservable = new e.Observable, this.animations = [], this.onPrePointerObservable = new e.Observable, this.onPointerObservable = new e.Observable, this.cameraToUseForPointers = null, this._startingPointerPosition = new e.Vector2(0, 0), this._startingPointerTime = 0, this.fogEnabled = !0, this.fogMode = i.FOGMODE_NONE, this.fogColor = new e.Color3(.2, .2, .3), this.fogDensity = .1, this.fogStart = 0, this.fogEnd = 1e3, this.shadowsEnabled = !0, this.lightsEnabled = !0, this.lights = new Array, this.cameras = new Array, this.activeCameras = new Array, this.meshes = new Array, this._geometries = new Array, this.materials = new Array, this.multiMaterials = new Array, this.texturesEnabled = !0, this.textures = new Array, this.particlesEnabled = !0, this.particleSystems = new Array, this.spritesEnabled = !0, this.spriteManagers = new Array, this.layers = new Array, this.highlightLayers = new Array, this.skeletonsEnabled = !0, this.skeletons = new Array, this.lensFlaresEnabled = !0, this.lensFlareSystems = new Array, this.collisionsEnabled = !0, this.gravity = new e.Vector3(0, (-9.807), 0), this.postProcessesEnabled = !0, this.renderTargetsEnabled = !0, this.dumpNextRenderTargets = !1, this.customRenderTargets = new Array, this.importedMeshesFiles = new Array, this.probesEnabled = !0, this.reflectionProbes = new Array, this._actionManagers = new Array, this._meshesForIntersections = new e.SmartArray(256), this.proceduralTexturesEnabled = !0, this._proceduralTextures = new Array, this.soundTracks = new Array, this._audioEnabled = !0, this._headphone = !1, this._totalMeshesCounter = new e.PerfCounter, this._totalLightsCounter = new e.PerfCounter, this._totalMaterialsCounter = new e.PerfCounter, this._totalTexturesCounter = new e.PerfCounter, this._totalVertices = new e.PerfCounter, this._activeIndices = new e.PerfCounter, this._activeParticles = new e.PerfCounter, this._lastFrameDuration = new e.PerfCounter, this._evaluateActiveMeshesDuration = new e.PerfCounter, this._renderTargetsDuration = new e.PerfCounter, this._particlesDuration = new e.PerfCounter, this._renderDuration = new e.PerfCounter, this._spritesDuration = new e.PerfCounter, this._activeBones = new e.PerfCounter, this._renderId = 0, this._executeWhenReadyTimeoutId = -1, this._intermediateRendering = !1, this._toBeDisposed = new e.SmartArray(256), this._pendingData = [], this._activeMeshes = new e.SmartArray(256), this._processedMaterials = new e.SmartArray(256), this._renderTargets = new e.SmartArray(256), this._activeParticleSystems = new e.SmartArray(256), this._activeSkeletons = new e.SmartArray(32), this._softwareSkinnedMeshes = new e.SmartArray(32), this._activeAnimatables = new Array, this._transformMatrix = e.Matrix.Zero(), this._edgesRenderers = new e.SmartArray(16), this._uniqueIdCounter = 0, this._engine = t, t.scenes.push(this), this._externalData = new e.StringDictionary, this._uid = null, this._renderingManager = new e.RenderingManager(this), this.postProcessManager = new e.PostProcessManager(this), this.postProcessRenderPipelineManager = new e.PostProcessRenderPipelineManager, this._boundingBoxRenderer = new e.BoundingBoxRenderer(this), e.OutlineRenderer && (this._outlineRenderer = new e.OutlineRenderer(this)), this.attachControl(), e.SoundTrack && (this.mainSoundTrack = new e.SoundTrack(this, {
				mainTrack: !0
			})), e.SimplificationQueue && (this.simplificationQueue = new e.SimplificationQueue), this.workerCollisions = !1
		}
		return Object.defineProperty(i, "FOGMODE_NONE", {
			get: function() {
				return i._FOGMODE_NONE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "FOGMODE_EXP", {
			get: function() {
				return i._FOGMODE_EXP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "FOGMODE_EXP2", {
			get: function() {
				return i._FOGMODE_EXP2
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "FOGMODE_LINEAR", {
			get: function() {
				return i._FOGMODE_LINEAR
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onDispose", {
			set: function(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "beforeRender", {
			set: function(e) {
				this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "afterRender", {
			set: function(e) {
				this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "beforeCameraRender", {
			set: function(e) {
				this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "afterCameraRender", {
			set: function(e) {
				this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "unTranslatedPointer", {
			get: function() {
				return new e.Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "defaultMaterial", {
			get: function() {
				return this._defaultMaterial || (this._defaultMaterial = new e.StandardMaterial("default material", this)), this._defaultMaterial
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "debugLayer", {
			get: function() {
				return this._debugLayer || (this._debugLayer = new e.DebugLayer(this)), this._debugLayer
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "workerCollisions", {
			get: function() {
				return this._workerCollisions
			},
			set: function(t) {
				t = t && !!Worker, this._workerCollisions = t, this.collisionCoordinator && this.collisionCoordinator.destroy(), this.collisionCoordinator = t ? new e.CollisionCoordinatorWorker : new e.CollisionCoordinatorLegacy, this.collisionCoordinator.init(this)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "SelectionOctree", {
			get: function() {
				return this._selectionOctree
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "meshUnderPointer", {
			get: function() {
				return this._pointerOverMesh
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "pointerX", {
			get: function() {
				return this._pointerX
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "pointerY", {
			get: function() {
				return this._pointerY
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getCachedMaterial = function() {
			return this._cachedMaterial
		}, i.prototype.getBoundingBoxRenderer = function() {
			return this._boundingBoxRenderer
		}, i.prototype.getOutlineRenderer = function() {
			return this._outlineRenderer
		}, i.prototype.getEngine = function() {
			return this._engine
		}, i.prototype.getTotalVertices = function() {
			return this._totalVertices.current
		}, Object.defineProperty(i.prototype, "totalVerticesPerfCounter", {
			get: function() {
				return this._totalVertices
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getActiveIndices = function() {
			return this._activeIndices.current
		}, Object.defineProperty(i.prototype, "totalActiveIndicesPerfCounter", {
			get: function() {
				return this._activeIndices
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getActiveParticles = function() {
			return this._activeParticles.current
		}, Object.defineProperty(i.prototype, "activeParticlesPerfCounter", {
			get: function() {
				return this._activeParticles
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getActiveBones = function() {
			return this._activeBones.current
		}, Object.defineProperty(i.prototype, "activeBonesPerfCounter", {
			get: function() {
				return this._activeBones
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getLastFrameDuration = function() {
			return this._lastFrameDuration.current
		}, Object.defineProperty(i.prototype, "lastFramePerfCounter", {
			get: function() {
				return this._lastFrameDuration
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getEvaluateActiveMeshesDuration = function() {
			return this._evaluateActiveMeshesDuration.current
		}, Object.defineProperty(i.prototype, "evaluateActiveMeshesDurationPerfCounter", {
			get: function() {
				return this._evaluateActiveMeshesDuration
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getActiveMeshes = function() {
			return this._activeMeshes
		}, i.prototype.getRenderTargetsDuration = function() {
			return this._renderTargetsDuration.current
		}, i.prototype.getRenderDuration = function() {
			return this._renderDuration.current
		}, Object.defineProperty(i.prototype, "renderDurationPerfCounter", {
			get: function() {
				return this._renderDuration
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getParticlesDuration = function() {
			return this._particlesDuration.current
		}, Object.defineProperty(i.prototype, "particlesDurationPerfCounter", {
			get: function() {
				return this._particlesDuration
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getSpritesDuration = function() {
			return this._spritesDuration.current
		}, Object.defineProperty(i.prototype, "spriteDuractionPerfCounter", {
			get: function() {
				return this._spritesDuration
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getAnimationRatio = function() {
			return this._animationRatio
		}, i.prototype.getRenderId = function() {
			return this._renderId
		}, i.prototype.incrementRenderId = function() {
			this._renderId++
		}, i.prototype._updatePointerPosition = function(e) {
			var t = this._engine.getRenderingCanvasClientRect();
			this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY, this.cameraToUseForPointers && (this._pointerX = this._pointerX - this.cameraToUseForPointers.viewport.x * this._engine.getRenderWidth(), this._pointerY = this._pointerY - this.cameraToUseForPointers.viewport.y * this._engine.getRenderHeight())
		}, i.prototype.attachControl = function(i, o, s) {
			var a = this;
			void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === s && (s = !0);
			var h = function(e) {
				return e.isPickable && e.actionManager && e.actionManager.hasPointerTriggers
			};
			this._onPointerMove = function(e) {
				if (a._updatePointerPosition(e), a.onPrePointerObservable.hasObservers()) {
					var i = "mousewheel" === e.type || "DOMMouseScroll" === e.type ? t.POINTERWHEEL : t.POINTERMOVE,
						o = new r(i, e, a._unTranslatedPointerX, a._unTranslatedPointerY);
					if (a.onPrePointerObservable.notifyObservers(o, i), o.skipOnPointerObservable) return
				}
				if (a.cameraToUseForPointers || a.activeCamera) {
					var s = a._engine.getRenderingCanvas();
					a.pointerMovePredicate || (a.pointerMovePredicate = function(e) {
						return e.isPickable && e.isVisible && e.isReady() && (a.constantlyUpdateMeshUnderPointer || null !== e.actionManager && void 0 !== e.actionManager)
					});
					var c = a.pick(a._unTranslatedPointerX, a._unTranslatedPointerY, a.pointerMovePredicate, !1, a.cameraToUseForPointers);
					if (c.hit && c.pickedMesh ? (a.setPointerOverSprite(null), a.setPointerOverMesh(c.pickedMesh), a._pointerOverMesh.actionManager && a._pointerOverMesh.actionManager.hasPointerTriggers ? a._pointerOverMesh.actionManager.hoverCursor ? s.style.cursor = a._pointerOverMesh.actionManager.hoverCursor : s.style.cursor = a.hoverCursor : s.style.cursor = "") : (a.setPointerOverMesh(null), c = a.pickSprite(a._unTranslatedPointerX, a._unTranslatedPointerY, h, !1, a.cameraToUseForPointers), c.hit && c.pickedSprite ? (a.setPointerOverSprite(c.pickedSprite), a._pointerOverSprite.actionManager && a._pointerOverSprite.actionManager.hoverCursor ? s.style.cursor = a._pointerOverSprite.actionManager.hoverCursor : s.style.cursor = a.hoverCursor) : (a.setPointerOverSprite(null), s.style.cursor = "")), a.onPointerMove && a.onPointerMove(e, c), a.onPointerObservable.hasObservers()) {
						var i = "mousewheel" === e.type || "DOMMouseScroll" === e.type ? t.POINTERWHEEL : t.POINTERMOVE,
							o = new n(i, e, c);
						a.onPointerObservable.notifyObservers(o, i)
					}
				}
			}, this._onPointerDown = function(i) {
				if (a._updatePointerPosition(i), a.onPrePointerObservable.hasObservers()) {
					var o = t.POINTERDOWN,
						s = new r(o, i, a._unTranslatedPointerX, a._unTranslatedPointerY);
					if (a.onPrePointerObservable.notifyObservers(s, o), s.skipOnPointerObservable) return
				}
				if (a.cameraToUseForPointers || a.activeCamera) {
					a._startingPointerPosition.x = a._pointerX, a._startingPointerPosition.y = a._pointerY, a._startingPointerTime = (new Date).getTime(), a.pointerDownPredicate || (a.pointerDownPredicate = function(e) {
						return e.isPickable && e.isVisible && e.isReady()
					}), a._pickedDownMesh = null;
					var c = a.pick(a._unTranslatedPointerX, a._unTranslatedPointerY, a.pointerDownPredicate, !1, a.cameraToUseForPointers);
					if (c.hit && c.pickedMesh && c.pickedMesh.actionManager) {
						if (a._pickedDownMesh = c.pickedMesh, c.pickedMesh.actionManager.hasPickTriggers) {
							switch (i.button) {
								case 0:
									c.pickedMesh.actionManager.processTrigger(e.ActionManager.OnLeftPickTrigger, e.ActionEvent.CreateNew(c.pickedMesh, i));
									break;
								case 1:
									c.pickedMesh.actionManager.processTrigger(e.ActionManager.OnCenterPickTrigger, e.ActionEvent.CreateNew(c.pickedMesh, i));
									break;
								case 2:
									c.pickedMesh.actionManager.processTrigger(e.ActionManager.OnRightPickTrigger, e.ActionEvent.CreateNew(c.pickedMesh, i))
							}
							c.pickedMesh.actionManager && c.pickedMesh.actionManager.processTrigger(e.ActionManager.OnPickDownTrigger, e.ActionEvent.CreateNew(c.pickedMesh, i))
						}
						if (c.pickedMesh.actionManager && c.pickedMesh.actionManager.hasSpecificTrigger(e.ActionManager.OnLongPressTrigger)) {
							var l = a;
							window.setTimeout((function() {
								var t = l.pick(l._unTranslatedPointerX, l._unTranslatedPointerY, (function(t) {
									return t.isPickable && t.isVisible && t.isReady() && t.actionManager && t.actionManager.hasSpecificTrigger(e.ActionManager.OnLongPressTrigger)
								}), !1, l.cameraToUseForPointers);
								t.hit && t.pickedMesh && t.pickedMesh.actionManager && 0 !== l._startingPointerTime && (new Date).getTime() - l._startingPointerTime > e.ActionManager.LongPressDelay && Math.abs(l._startingPointerPosition.x - l._pointerX) < e.ActionManager.DragMovementThreshold && Math.abs(l._startingPointerPosition.y - l._pointerY) < e.ActionManager.DragMovementThreshold && (l._startingPointerTime = 0, t.pickedMesh.actionManager.processTrigger(e.ActionManager.OnLongPressTrigger, e.ActionEvent.CreateNew(t.pickedMesh, i)))
							}), e.ActionManager.LongPressDelay)
						}
					}
					if (a.onPointerDown && a.onPointerDown(i, c), a.onPointerObservable.hasObservers()) {
						var o = t.POINTERDOWN,
							s = new n(o, i, c);
						a.onPointerObservable.notifyObservers(s, o)
					}
					if (a._pickedDownSprite = null, a.spriteManagers.length > 0 && (c = a.pickSprite(a._unTranslatedPointerX, a._unTranslatedPointerY, h, !1, a.cameraToUseForPointers), c.hit && c.pickedSprite && c.pickedSprite.actionManager)) {
						switch (a._pickedDownSprite = c.pickedSprite, i.button) {
							case 0:
								c.pickedSprite.actionManager.processTrigger(e.ActionManager.OnLeftPickTrigger, e.ActionEvent.CreateNewFromSprite(c.pickedSprite, a, i));
								break;
							case 1:
								c.pickedSprite.actionManager.processTrigger(e.ActionManager.OnCenterPickTrigger, e.ActionEvent.CreateNewFromSprite(c.pickedSprite, a, i));
								break;
							case 2:
								c.pickedSprite.actionManager.processTrigger(e.ActionManager.OnRightPickTrigger, e.ActionEvent.CreateNewFromSprite(c.pickedSprite, a, i))
						}
						c.pickedSprite.actionManager && c.pickedSprite.actionManager.processTrigger(e.ActionManager.OnPickDownTrigger, e.ActionEvent.CreateNewFromSprite(c.pickedSprite, a, i))
					}
				}
			}, this._onPointerUp = function(i) {
				if (a._updatePointerPosition(i), a.onPrePointerObservable.hasObservers()) {
					var o = t.POINTERUP,
						s = new r(o, i, a._unTranslatedPointerX, a._unTranslatedPointerY);
					if (a.onPrePointerObservable.notifyObservers(s, o), s.skipOnPointerObservable) return
				}
				if (a.cameraToUseForPointers || a.activeCamera) {
					a.pointerUpPredicate || (a.pointerUpPredicate = function(e) {
						return e.isPickable && e.isVisible && e.isReady()
					});
					var c = a.pick(a._unTranslatedPointerX, a._unTranslatedPointerY, a.pointerUpPredicate, !1, a.cameraToUseForPointers);
					if (c.hit && c.pickedMesh) {
						if (null != a._pickedDownMesh && c.pickedMesh == a._pickedDownMesh && (a.onPointerPick && a.onPointerPick(i, c), a.onPointerObservable.hasObservers())) {
							var o = t.POINTERPICK,
								s = new n(o, i, c);
							a.onPointerObservable.notifyObservers(s, o)
						}
						c.pickedMesh.actionManager && (c.pickedMesh.actionManager.processTrigger(e.ActionManager.OnPickUpTrigger, e.ActionEvent.CreateNew(c.pickedMesh, i)), c.pickedMesh.actionManager && Math.abs(a._startingPointerPosition.x - a._pointerX) < e.ActionManager.DragMovementThreshold && Math.abs(a._startingPointerPosition.y - a._pointerY) < e.ActionManager.DragMovementThreshold && c.pickedMesh.actionManager.processTrigger(e.ActionManager.OnPickTrigger, e.ActionEvent.CreateNew(c.pickedMesh, i)))
					}
					if (a._pickedDownMesh && a._pickedDownMesh.actionManager && a._pickedDownMesh !== c.pickedMesh && a._pickedDownMesh.actionManager.processTrigger(e.ActionManager.OnPickOutTrigger, e.ActionEvent.CreateNew(a._pickedDownMesh, i)), a.onPointerUp && a.onPointerUp(i, c), a.onPointerObservable.hasObservers()) {
						var o = t.POINTERUP,
							s = new n(o, i, c);
						a.onPointerObservable.notifyObservers(s, o)
					}
					a._startingPointerTime = 0, a.spriteManagers.length > 0 && (c = a.pickSprite(a._unTranslatedPointerX, a._unTranslatedPointerY, h, !1, a.cameraToUseForPointers), c.hit && c.pickedSprite && c.pickedSprite.actionManager && (c.pickedSprite.actionManager.processTrigger(e.ActionManager.OnPickUpTrigger, e.ActionEvent.CreateNewFromSprite(c.pickedSprite, a, i)), c.pickedSprite.actionManager && Math.abs(a._startingPointerPosition.x - a._pointerX) < e.ActionManager.DragMovementThreshold && Math.abs(a._startingPointerPosition.y - a._pointerY) < e.ActionManager.DragMovementThreshold && c.pickedSprite.actionManager.processTrigger(e.ActionManager.OnPickTrigger, e.ActionEvent.CreateNewFromSprite(c.pickedSprite, a, i))), a._pickedDownSprite && a._pickedDownSprite.actionManager && a._pickedDownSprite !== c.pickedSprite && a._pickedDownSprite.actionManager.processTrigger(e.ActionManager.OnPickOutTrigger, e.ActionEvent.CreateNewFromSprite(a._pickedDownSprite, a, i)))
				}
			}, this._onKeyDown = function(t) {
				a.actionManager && a.actionManager.processTrigger(e.ActionManager.OnKeyDownTrigger, e.ActionEvent.CreateNewFromScene(a, t))
			}, this._onKeyUp = function(t) {
				a.actionManager && a.actionManager.processTrigger(e.ActionManager.OnKeyUpTrigger, e.ActionEvent.CreateNewFromScene(a, t))
			};
			var c = e.Tools.GetPointerPrefix(),
				l = this._engine.getRenderingCanvas();
			s && (l.addEventListener(c + "move", this._onPointerMove, !1), l.addEventListener("mousewheel", this._onPointerMove, !1), l.addEventListener("DOMMouseScroll", this._onPointerMove, !1)), o && l.addEventListener(c + "down", this._onPointerDown, !1), i && l.addEventListener(c + "up", this._onPointerUp, !1), l.tabIndex = 1, l.addEventListener("keydown", this._onKeyDown, !1), l.addEventListener("keyup", this._onKeyUp, !1)
		}, i.prototype.detachControl = function() {
			var t = e.Tools.GetPointerPrefix(),
				i = this._engine.getRenderingCanvas();
			i.removeEventListener(t + "move", this._onPointerMove), i.removeEventListener(t + "down", this._onPointerDown), i.removeEventListener(t + "up", this._onPointerUp), i.removeEventListener("mousewheel", this._onPointerMove), i.removeEventListener("DOMMouseScroll", this._onPointerMove), i.removeEventListener("keydown", this._onKeyDown), i.removeEventListener("keyup", this._onKeyUp)
		}, i.prototype.isReady = function() {
			if (this._pendingData.length > 0) return !1;
			var t;
			for (t = 0; t < this._geometries.length; t++) {
				var i = this._geometries[t];
				if (i.delayLoadState === e.Engine.DELAYLOADSTATE_LOADING) return !1
			}
			for (t = 0; t < this.meshes.length; t++) {
				var r = this.meshes[t];
				if (!r.isReady()) return !1;
				var n = r.material;
				if (n && !n.isReady(r)) return !1
			}
			return !0
		}, i.prototype.resetCachedMaterial = function() {
			this._cachedMaterial = null
		}, i.prototype.registerBeforeRender = function(e) {
			this.onBeforeRenderObservable.add(e)
		}, i.prototype.unregisterBeforeRender = function(e) {
			this.onBeforeRenderObservable.removeCallback(e)
		}, i.prototype.registerAfterRender = function(e) {
			this.onAfterRenderObservable.add(e)
		}, i.prototype.unregisterAfterRender = function(e) {
			this.onAfterRenderObservable.removeCallback(e)
		}, i.prototype._addPendingData = function(e) {
			this._pendingData.push(e)
		}, i.prototype._removePendingData = function(e) {
			var t = this._pendingData.indexOf(e);
			t !== -1 && this._pendingData.splice(t, 1)
		}, i.prototype.getWaitingItemsCount = function() {
			return this._pendingData.length
		}, i.prototype.executeWhenReady = function(e) {
			var t = this;
			this.onReadyObservable.add(e), this._executeWhenReadyTimeoutId === -1 && (this._executeWhenReadyTimeoutId = setTimeout((function() {
				t._checkIsReady()
			}), 150))
		}, i.prototype._checkIsReady = function() {
			var e = this;
			return this.isReady() ? (this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), void(this._executeWhenReadyTimeoutId = -1)) : void(this._executeWhenReadyTimeoutId = setTimeout((function() {
				e._checkIsReady()
			}), 150))
		}, i.prototype.beginAnimation = function(t, i, r, n, o, s, a) {
			if (void 0 === o && (o = 1), this.stopAnimation(t), a || (a = new e.Animatable(this, t, i, r, n, o, s)), t.animations && a.appendAnimations(t, t.animations), t.getAnimatables)
				for (var h = t.getAnimatables(), c = 0; c < h.length; c++) this.beginAnimation(h[c], i, r, n, o, s, a);
			return a.reset(), a
		}, i.prototype.beginDirectAnimation = function(t, i, r, n, o, s, a) {
			void 0 === s && (s = 1);
			var h = new e.Animatable(this, t, r, n, o, s, a, i);
			return h
		}, i.prototype.getAnimatableByTarget = function(e) {
			for (var t = 0; t < this._activeAnimatables.length; t++)
				if (this._activeAnimatables[t].target === e) return this._activeAnimatables[t];
			return null
		}, Object.defineProperty(i.prototype, "Animatables", {
			get: function() {
				return this._activeAnimatables
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.stopAnimation = function(e, t) {
			var i = this.getAnimatableByTarget(e);
			i && i.stop(t)
		}, i.prototype._animate = function() {
			if (this.animationsEnabled && 0 !== this._activeAnimatables.length) {
				if (!this._animationStartDate) {
					if (this._pendingData.length > 0) return;
					this._animationStartDate = e.Tools.Now
				}
				for (var t = e.Tools.Now, i = t - this._animationStartDate, r = 0; r < this._activeAnimatables.length; r++) this._activeAnimatables[r]._animate(i)
			}
		}, i.prototype.getViewMatrix = function() {
			return this._viewMatrix
		}, i.prototype.getProjectionMatrix = function() {
			return this._projectionMatrix
		}, i.prototype.getTransformMatrix = function() {
			return this._transformMatrix
		}, i.prototype.setTransformMatrix = function(t, i) {
			this._viewMatrix = t, this._projectionMatrix = i, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? e.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = e.Frustum.GetPlanes(this._transformMatrix)
		}, i.prototype.addMesh = function(e) {
			e.uniqueId = this._uniqueIdCounter++;
			this.meshes.push(e);
			this.collisionCoordinator.onMeshAdded(e), this.onNewMeshAddedObservable.notifyObservers(e)
		}, i.prototype.removeMesh = function(e) {
			var t = this.meshes.indexOf(e);
			return t !== -1 && this.meshes.splice(t, 1), this.collisionCoordinator.onMeshRemoved(e), this.onMeshRemovedObservable.notifyObservers(e), t
		}, i.prototype.removeSkeleton = function(e) {
			var t = this.skeletons.indexOf(e);
			return t !== -1 && this.skeletons.splice(t, 1), t
		}, i.prototype.removeLight = function(e) {
			var t = this.lights.indexOf(e);
			return t !== -1 && this.lights.splice(t, 1), this.onLightRemovedObservable.notifyObservers(e), t
		}, i.prototype.removeCamera = function(e) {
			var t = this.cameras.indexOf(e);
			t !== -1 && this.cameras.splice(t, 1);
			var i = this.activeCameras.indexOf(e);
			return i !== -1 && this.activeCameras.splice(i, 1), this.activeCamera === e && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(e), t
		}, i.prototype.addLight = function(e) {
			e.uniqueId = this._uniqueIdCounter++;
			this.lights.push(e);
			this.onNewLightAddedObservable.notifyObservers(e)
		}, i.prototype.addCamera = function(e) {
			e.uniqueId = this._uniqueIdCounter++;
			this.cameras.push(e);
			this.onNewCameraAddedObservable.notifyObservers(e)
		}, i.prototype.switchActiveCamera = function(e, t) {
			void 0 === t && (t = !0);
			var i = this._engine.getRenderingCanvas();
			this.activeCamera.detachControl(i), this.activeCamera = e, t && e.attachControl(i)
		}, i.prototype.setActiveCameraByID = function(e) {
			var t = this.getCameraByID(e);
			return t ? (this.activeCamera = t, t) : null
		}, i.prototype.setActiveCameraByName = function(e) {
			var t = this.getCameraByName(e);
			return t ? (this.activeCamera = t, t) : null
		}, i.prototype.getMaterialByID = function(e) {
			for (var t = 0; t < this.materials.length; t++)
				if (this.materials[t].id === e) return this.materials[t];
			return null
		}, i.prototype.getMaterialByName = function(e) {
			for (var t = 0; t < this.materials.length; t++)
				if (this.materials[t].name === e) return this.materials[t];
			return null
		}, i.prototype.getLensFlareSystemByName = function(e) {
			for (var t = 0; t < this.lensFlareSystems.length; t++)
				if (this.lensFlareSystems[t].name === e) return this.lensFlareSystems[t];
			return null
		}, i.prototype.getLensFlareSystemByID = function(e) {
			for (var t = 0; t < this.lensFlareSystems.length; t++)
				if (this.lensFlareSystems[t].id === e) return this.lensFlareSystems[t];
			return null
		}, i.prototype.getCameraByID = function(e) {
			for (var t = 0; t < this.cameras.length; t++)
				if (this.cameras[t].id === e) return this.cameras[t];
			return null
		}, i.prototype.getCameraByUniqueID = function(e) {
			for (var t = 0; t < this.cameras.length; t++)
				if (this.cameras[t].uniqueId === e) return this.cameras[t];
			return null
		}, i.prototype.getCameraByName = function(e) {
			for (var t = 0; t < this.cameras.length; t++)
				if (this.cameras[t].name === e) return this.cameras[t];
			return null
		}, i.prototype.getBoneByID = function(e) {
			for (var t = 0; t < this.skeletons.length; t++)
				for (var i = this.skeletons[t], r = 0; r < i.bones.length; r++)
					if (i.bones[r].id === e) return i.bones[r];
			return null
		}, i.prototype.getBoneByName = function(e) {
			for (var t = 0; t < this.skeletons.length; t++)
				for (var i = this.skeletons[t], r = 0; r < i.bones.length; r++)
					if (i.bones[r].name === e) return i.bones[r];
			return null
		}, i.prototype.getLightByName = function(e) {
			for (var t = 0; t < this.lights.length; t++)
				if (this.lights[t].name === e) return this.lights[t];
			return null
		}, i.prototype.getLightByID = function(e) {
			for (var t = 0; t < this.lights.length; t++)
				if (this.lights[t].id === e) return this.lights[t];
			return null
		}, i.prototype.getLightByUniqueID = function(e) {
			for (var t = 0; t < this.lights.length; t++)
				if (this.lights[t].uniqueId === e) return this.lights[t];
			return null
		}, i.prototype.getParticleSystemByID = function(e) {
			for (var t = 0; t < this.particleSystems.length; t++)
				if (this.particleSystems[t].id === e) return this.particleSystems[t];
			return null
		}, i.prototype.getGeometryByID = function(e) {
			for (var t = 0; t < this._geometries.length; t++)
				if (this._geometries[t].id === e) return this._geometries[t];
			return null
		}, i.prototype.pushGeometry = function(e, t) {
			return !(!t && this.getGeometryByID(e.id)) && (this._geometries.push(e), this.collisionCoordinator.onGeometryAdded(e), this.onNewGeometryAddedObservable.notifyObservers(e), !0)
		}, i.prototype.removeGeometry = function(e) {
			var t = this._geometries.indexOf(e);
			return t > -1 && (this._geometries.splice(t, 1), this.collisionCoordinator.onGeometryDeleted(e), this.onGeometryRemovedObservable.notifyObservers(e), !0)
		}, i.prototype.getGeometries = function() {
			return this._geometries
		}, i.prototype.getMeshByID = function(e) {
			for (var t = 0; t < this.meshes.length; t++)
				if (this.meshes[t].id === e) return this.meshes[t];
			return null
		}, i.prototype.getMeshesByID = function(e) {
			return this.meshes.filter((function(t) {
				return t.id === e
			}))
		}, i.prototype.getMeshByUniqueID = function(e) {
			for (var t = 0; t < this.meshes.length; t++)
				if (this.meshes[t].uniqueId === e) return this.meshes[t];
			return null
		}, i.prototype.getLastMeshByID = function(e) {
			for (var t = this.meshes.length - 1; t >= 0; t--)
				if (this.meshes[t].id === e) return this.meshes[t];
			return null
		}, i.prototype.getLastEntryByID = function(e) {
			var t;
			for (t = this.meshes.length - 1; t >= 0; t--)
				if (this.meshes[t].id === e) return this.meshes[t];
			for (t = this.cameras.length - 1; t >= 0; t--)
				if (this.cameras[t].id === e) return this.cameras[t];
			for (t = this.lights.length - 1; t >= 0; t--)
				if (this.lights[t].id === e) return this.lights[t];
			return null
		}, i.prototype.getNodeByID = function(e) {
			var t = this.getMeshByID(e);
			if (t) return t;
			var i = this.getLightByID(e);
			if (i) return i;
			var r = this.getCameraByID(e);
			if (r) return r;
			var n = this.getBoneByID(e);
			return n
		}, i.prototype.getNodeByName = function(e) {
			var t = this.getMeshByName(e);
			if (t) return t;
			var i = this.getLightByName(e);
			if (i) return i;
			var r = this.getCameraByName(e);
			if (r) return r;
			var n = this.getBoneByName(e);
			return n
		}, i.prototype.getMeshByName = function(e) {
			for (var t = 0; t < this.meshes.length; t++)
				if (this.meshes[t].name === e) return this.meshes[t];
			return null
		}, i.prototype.getSoundByName = function(t) {
			var i;
			if (e.AudioEngine) {
				for (i = 0; i < this.mainSoundTrack.soundCollection.length; i++)
					if (this.mainSoundTrack.soundCollection[i].name === t) return this.mainSoundTrack.soundCollection[i];
				for (var r = 0; r < this.soundTracks.length; r++)
					for (i = 0; i < this.soundTracks[r].soundCollection.length; i++)
						if (this.soundTracks[r].soundCollection[i].name === t) return this.soundTracks[r].soundCollection[i]
			}
			return null
		}, i.prototype.getLastSkeletonByID = function(e) {
			for (var t = this.skeletons.length - 1; t >= 0; t--)
				if (this.skeletons[t].id === e) return this.skeletons[t];
			return null
		}, i.prototype.getSkeletonById = function(e) {
			for (var t = 0; t < this.skeletons.length; t++)
				if (this.skeletons[t].id === e) return this.skeletons[t];
			return null
		}, i.prototype.getSkeletonByName = function(e) {
			for (var t = 0; t < this.skeletons.length; t++)
				if (this.skeletons[t].name === e) return this.skeletons[t];
			return null
		}, i.prototype.isActiveMesh = function(e) {
			return this._activeMeshes.indexOf(e) !== -1
		}, Object.defineProperty(i.prototype, "uid", {
			get: function() {
				return this._uid || (this._uid = e.Tools.RandomId()), this._uid
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.addExternalData = function(e, t) {
			return this._externalData.add(e, t)
		}, i.prototype.getExternalData = function(e) {
			return this._externalData.get(e)
		}, i.prototype.getOrAddExternalDataWithFactory = function(e, t) {
			return this._externalData.getOrAddWithFactory(e, t)
		}, i.prototype.removeExternalData = function(e) {
			return this._externalData.remove(e)
		}, i.prototype._evaluateSubMesh = function(e, t) {
			if (t.alwaysSelectAsActiveMesh || 1 === t.subMeshes.length || e.isInFrustum(this._frustumPlanes)) {
				var i = e.getMaterial();
				t.showSubMeshesBoundingBox && this._boundingBoxRenderer.renderList.push(e.getBoundingInfo().boundingBox), i && (i.getRenderTargetTextures && this._processedMaterials.indexOf(i) === -1 && (this._processedMaterials.push(i), this._renderTargets.concatWithNoDuplicate(i.getRenderTargetTextures())), this._activeIndices.addCount(e.indexCount, !1), this._renderingManager.dispatch(e))
			}
		}, i.prototype._isInIntermediateRendering = function() {
			return this._intermediateRendering
		}, i.prototype._evaluateActiveMeshes = function() {
			this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset(), this._boundingBoxRenderer.reset(), this._edgesRenderers.reset();
			var t, i;
			if (this._selectionOctree) {
				var r = this._selectionOctree.select(this._frustumPlanes);
				t = r.data, i = r.length
			} else i = this.meshes.length, t = this.meshes;
			for (var n = 0; n < i; n++) {
				var o = t[n];
				if (!o.isBlocked && (this._totalVertices.addCount(o.getTotalVertices(), !1), o.isReady() && o.isEnabled())) {
					o.computeWorldMatrix(), o.actionManager && o.actionManager.hasSpecificTriggers([e.ActionManager.OnIntersectionEnterTrigger, e.ActionManager.OnIntersectionExitTrigger]) && this._meshesForIntersections.pushNoDuplicate(o);
					var s = o.getLOD(this.activeCamera);
					s && (o._preActivate(), (o.alwaysSelectAsActiveMesh || o.isVisible && o.visibility > 0 && 0 !== (o.layerMask & this.activeCamera.layerMask) && o.isInFrustum(this._frustumPlanes)) && (this._activeMeshes.push(o), this.activeCamera._activeMeshes.push(o), o._activate(this._renderId), this._activeMesh(o, s)))
				}
			}
			this._particlesDuration.beginMonitoring();
			e.Tools.Now;
			if (this.particlesEnabled) {
				e.Tools.StartPerformanceCounter("Particles", this.particleSystems.length > 0);
				for (var a = 0; a < this.particleSystems.length; a++) {
					var h = this.particleSystems[a];
					h.isStarted() && (!h.emitter.position || h.emitter && h.emitter.isEnabled()) && (this._activeParticleSystems.push(h), h.animate())
				}
				e.Tools.EndPerformanceCounter("Particles", this.particleSystems.length > 0)
			}
			this._particlesDuration.endMonitoring(!1)
		}, i.prototype._activeMesh = function(e, t) {
			if (t.skeleton && this.skeletonsEnabled && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && t.skeleton.prepare(), t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t)), (e.showBoundingBox || this.forceShowBoundingBoxes) && this._boundingBoxRenderer.renderList.push(e.getBoundingInfo().boundingBox), e._edgesRenderer && this._edgesRenderers.push(e._edgesRenderer), t && t.subMeshes) {
				var i, r;
				if (t._submeshesOctree && t.useOctreeForRenderingSelection) {
					var n = t._submeshesOctree.select(this._frustumPlanes);
					i = n.length, r = n.data
				} else r = t.subMeshes, i = r.length;
				for (var o = 0; o < i; o++) {
					var s = r[o];
					this._evaluateSubMesh(s, t)
				}
			}
		}, i.prototype.updateTransformMatrix = function(e) {
			this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(e))
		}, i.prototype._renderForCamera = function(t) {
			var i = this._engine;
			e.Tools.Now;
			if (this.activeCamera = t, !this.activeCamera) throw new Error("Active camera not set");
			e.Tools.StartPerformanceCounter("Rendering camera " + this.activeCamera.name), i.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, this.updateTransformMatrix(), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshesDuration.beginMonitoring(), e.Tools.StartPerformanceCounter("Active meshes evaluation"), this._evaluateActiveMeshes(), this._evaluateActiveMeshesDuration.endMonitoring(!1), e.Tools.EndPerformanceCounter("Active meshes evaluation");
			for (var r = 0; r < this._softwareSkinnedMeshes.length; r++) {
				var n = this._softwareSkinnedMeshes.data[r];
				n.applySkeleton(n.skeleton)
			}
			this._renderTargetsDuration.beginMonitoring();
			var o = !1;
			e.Tools.Now;
			if (this.renderTargetsEnabled && this._renderTargets.length > 0) {
				this._intermediateRendering = !0, e.Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
				for (var s = 0; s < this._renderTargets.length; s++) {
					var a = this._renderTargets.data[s];
					if (a._shouldRender()) {
						this._renderId++;
						var h = a.activeCamera && a.activeCamera !== this.activeCamera;
						a.render(h, this.dumpNextRenderTargets)
					}
				}
				e.Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0), this._intermediateRendering = !1, this._renderId++, o = !0
			}
			var c = this._engine.getStencilBuffer(),
				l = !1;
			if (this.renderTargetsEnabled && this.highlightLayers && this.highlightLayers.length > 0) {
				this._intermediateRendering = !0;
				for (var u = 0; u < this.highlightLayers.length; u++) {
					var d = this.highlightLayers[u];
					if (d.shouldRender() && (!d.camera || d.camera.cameraRigMode === e.Camera.RIG_MODE_NONE && t === d.camera || d.camera.cameraRigMode !== e.Camera.RIG_MODE_NONE && d.camera._rigCameras.indexOf(t) > -1)) {
						l = !0;
						var a = d._mainTexture;
						a._shouldRender() && (this._renderId++, a.render(!1, !1), o = !0)
					}
				}
				this._intermediateRendering = !1, this._renderId++
			}
			o && i.restoreDefaultFramebuffer(), this._renderTargetsDuration.endMonitoring(!1), this.postProcessManager._prepareFrame(), this._renderDuration.beginMonitoring();
			var f, p;
			if (this.layers.length) {
				for (i.setDepthBuffer(!1), f = 0; f < this.layers.length; f++) p = this.layers[f], p.isBackground && p.render();
				i.setDepthBuffer(!0)
			}
			e.Tools.StartPerformanceCounter("Main render"), l && this._engine.setStencilBuffer(!0), this._renderingManager.render(null, null, !0, !0), l && this._engine.setStencilBuffer(c), e.Tools.EndPerformanceCounter("Main render"), this._boundingBoxRenderer.render();
			for (var m = 0; m < this._edgesRenderers.length; m++) this._edgesRenderers.data[m].render();
			if (this.lensFlaresEnabled) {
				e.Tools.StartPerformanceCounter("Lens flares", this.lensFlareSystems.length > 0);
				for (var _ = 0; _ < this.lensFlareSystems.length; _++) {
					var g = this.lensFlareSystems[_];
					0 !== (t.layerMask & g.layerMask) && g.render()
				}
				e.Tools.EndPerformanceCounter("Lens flares", this.lensFlareSystems.length > 0)
			}
			if (this.layers.length) {
				for (i.setDepthBuffer(!1), f = 0; f < this.layers.length; f++) p = this.layers[f], p.isBackground || p.render();
				i.setDepthBuffer(!0)
			}
			if (l) {
				i.setDepthBuffer(!1);
				for (var u = 0; u < this.highlightLayers.length; u++) this.highlightLayers[u].shouldRender() && this.highlightLayers[u].render();
				i.setDepthBuffer(!0)
			}
			this._renderDuration.endMonitoring(!1), this.postProcessManager._finalizeFrame(t.isIntermediate), this.activeCamera._updateFromScene(), this._renderTargets.reset(), this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera), e.Tools.EndPerformanceCounter("Rendering camera " + this.activeCamera.name)
		}, i.prototype._processSubCameras = function(t) {
			if (t.cameraRigMode === e.Camera.RIG_MODE_NONE) return void this._renderForCamera(t);
			for (var i = 0; i < t._rigCameras.length; i++) this._renderForCamera(t._rigCameras[i]);
			this.activeCamera = t, this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix()), this.activeCamera._updateFromScene()
		}, i.prototype._checkIntersections = function() {
			for (var t = 0; t < this._meshesForIntersections.length; t++)
				for (var i = this._meshesForIntersections.data[t], r = 0; r < i.actionManager.actions.length; r++) {
					var n = i.actionManager.actions[r];
					if (n.trigger === e.ActionManager.OnIntersectionEnterTrigger || n.trigger === e.ActionManager.OnIntersectionExitTrigger) {
						var o = n.getTriggerParameter(),
							s = o instanceof e.AbstractMesh ? o : o.mesh,
							a = s.intersectsMesh(i, o.usePreciseIntersection),
							h = i._intersectionsInProgress.indexOf(s);
						a && h === -1 ? n.trigger === e.ActionManager.OnIntersectionEnterTrigger ? (n._executeCurrent(e.ActionEvent.CreateNew(i, null, s)), i._intersectionsInProgress.push(s)) : n.trigger === e.ActionManager.OnIntersectionExitTrigger && i._intersectionsInProgress.push(s) : !a && h > -1 && (n.trigger === e.ActionManager.OnIntersectionExitTrigger && n._executeCurrent(e.ActionEvent.CreateNew(i, null, s)), i.actionManager.hasSpecificTrigger(e.ActionManager.OnIntersectionExitTrigger) && n.trigger !== e.ActionManager.OnIntersectionExitTrigger || i._intersectionsInProgress.splice(h, 1))
					}
				}
		}, i.prototype.render = function() {
			this._lastFrameDuration.beginMonitoring(), this._particlesDuration.fetchNewFrame(), this._spritesDuration.fetchNewFrame(), this._activeParticles.fetchNewFrame(), this._renderDuration.fetchNewFrame(), this._renderTargetsDuration.fetchNewFrame(), this._evaluateActiveMeshesDuration.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this.getEngine().drawCallsPerfCounter.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), e.Tools.StartPerformanceCounter("Scene rendering"), this.actionManager && this.actionManager.processTrigger(e.ActionManager.OnEveryFrameTrigger, null), this.simplificationQueue && !this.simplificationQueue.running && this.simplificationQueue.executeNext();
			var t = Math.max(i.MinDeltaTime, Math.min(this._engine.getDeltaTime(), i.MaxDeltaTime));
			this._animationRatio = .06 * t, this._animate(), this._physicsEngine && (e.Tools.StartPerformanceCounter("Physics"), this._physicsEngine._step(t / 1e3), e.Tools.EndPerformanceCounter("Physics")), this.onBeforeRenderObservable.notifyObservers(this), this._renderTargetsDuration.beginMonitoring();
			var r = (e.Tools.Now, this.getEngine()),
				n = this.activeCamera;
			if (this.renderTargetsEnabled) {
				e.Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
				for (var o = 0; o < this.customRenderTargets.length; o++) {
					var s = this.customRenderTargets[o];
					if (s._shouldRender()) {
						if (this._renderId++, this.activeCamera = s.activeCamera || this.activeCamera, !this.activeCamera) throw new Error("Active camera not set");
						r.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), s.render(n !== this.activeCamera, this.dumpNextRenderTargets)
					}
				}
				e.Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._renderId++
			}
			if (this.customRenderTargets.length > 0 && r.restoreDefaultFramebuffer(), this._renderTargetsDuration.endMonitoring(), this.activeCamera = n, this.proceduralTexturesEnabled) {
				e.Tools.StartPerformanceCounter("Procedural textures", this._proceduralTextures.length > 0);
				for (var a = 0; a < this._proceduralTextures.length; a++) {
					var h = this._proceduralTextures[a];
					h._shouldRender() && h.render()
				}
				e.Tools.EndPerformanceCounter("Procedural textures", this._proceduralTextures.length > 0)
			}
			if (this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, !0, !0), this.shadowsEnabled)
				for (var c = 0; c < this.lights.length; c++) {
					var l = this.lights[c],
						u = l.getShadowGenerator();
					l.isEnabled() && u && u.getShadowMap().getScene().textures.indexOf(u.getShadowMap()) !== -1 && this._renderTargets.push(u.getShadowMap())
				}
			if (this._depthRenderer && this._renderTargets.push(this._depthRenderer.getDepthMap()), this.postProcessRenderPipelineManager.update(), this.activeCameras.length > 0)
				for (var d = 0; d < this.activeCameras.length; d++) d > 0 && this._engine.clear(0, !1, !0, !0), this._processSubCameras(this.activeCameras[d]);
			else {
				if (!this.activeCamera) throw new Error("No camera defined");
				this._processSubCameras(this.activeCamera)
			}
			this._checkIntersections(), e.AudioEngine && this._updateAudioParameters(), this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this);
			for (var f = 0; f < this._toBeDisposed.length; f++) this._toBeDisposed.data[f].dispose(), this._toBeDisposed[f] = null;
			this._toBeDisposed.reset(), this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), e.Tools.EndPerformanceCounter("Scene rendering"), this._lastFrameDuration.endMonitoring(), this._totalMeshesCounter.addCount(this.meshes.length, !0), this._totalLightsCounter.addCount(this.lights.length, !0), this._totalMaterialsCounter.addCount(this.materials.length, !0), this._totalTexturesCounter.addCount(this.textures.length, !0), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0)
		}, i.prototype._updateAudioParameters = function() {
			if (this.audioEnabled && (0 !== this.mainSoundTrack.soundCollection.length || 1 !== this.soundTracks.length)) {
				var t, i = e.Engine.audioEngine;
				if (t = this.activeCameras.length > 0 ? this.activeCameras[0] : this.activeCamera, t && i.canUseWebAudio) {
					i.audioContext.listener.setPosition(t.position.x, t.position.y, t.position.z);
					var r = e.Matrix.Invert(t.getViewMatrix()),
						n = e.Vector3.TransformNormal(new e.Vector3(0, 0, (-1)), r);
					n.normalize(), i.audioContext.listener.setOrientation(n.x, n.y, n.z, 0, 1, 0);
					var o;
					for (o = 0; o < this.mainSoundTrack.soundCollection.length; o++) {
						var s = this.mainSoundTrack.soundCollection[o];
						s.useCustomAttenuation && s.updateDistanceFromListener()
					}
					for (o = 0; o < this.soundTracks.length; o++)
						for (var a = 0; a < this.soundTracks[o].soundCollection.length; a++) s = this.soundTracks[o].soundCollection[a], s.useCustomAttenuation && s.updateDistanceFromListener()
				}
			}
		}, Object.defineProperty(i.prototype, "audioEnabled", {
			get: function() {
				return this._audioEnabled
			},
			set: function(t) {
				this._audioEnabled = t, e.AudioEngine && (this._audioEnabled ? this._enableAudio() : this._disableAudio())
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._disableAudio = function() {
			var e;
			for (e = 0; e < this.mainSoundTrack.soundCollection.length; e++) this.mainSoundTrack.soundCollection[e].pause();
			for (e = 0; e < this.soundTracks.length; e++)
				for (var t = 0; t < this.soundTracks[e].soundCollection.length; t++) this.soundTracks[e].soundCollection[t].pause()
		}, i.prototype._enableAudio = function() {
			var e;
			for (e = 0; e < this.mainSoundTrack.soundCollection.length; e++) this.mainSoundTrack.soundCollection[e].isPaused && this.mainSoundTrack.soundCollection[e].play();
			for (e = 0; e < this.soundTracks.length; e++)
				for (var t = 0; t < this.soundTracks[e].soundCollection.length; t++) this.soundTracks[e].soundCollection[t].isPaused && this.soundTracks[e].soundCollection[t].play()
		}, Object.defineProperty(i.prototype, "headphone", {
			get: function() {
				return this._headphone
			},
			set: function(t) {
				this._headphone = t, e.AudioEngine && (this._headphone ? this._switchAudioModeForHeadphones() : this._switchAudioModeForNormalSpeakers())
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._switchAudioModeForHeadphones = function() {
			this.mainSoundTrack.switchPanningModelToHRTF();
			for (var e = 0; e < this.soundTracks.length; e++) this.soundTracks[e].switchPanningModelToHRTF()
		}, i.prototype._switchAudioModeForNormalSpeakers = function() {
			this.mainSoundTrack.switchPanningModelToEqualPower();
			for (var e = 0; e < this.soundTracks.length; e++) this.soundTracks[e].switchPanningModelToEqualPower()
		}, i.prototype.enableDepthRenderer = function() {
			return this._depthRenderer ? this._depthRenderer : (this._depthRenderer = new e.DepthRenderer(this), this._depthRenderer)
		}, i.prototype.disableDepthRenderer = function() {
			this._depthRenderer && (this._depthRenderer.dispose(), this._depthRenderer = null)
		}, i.prototype.freezeMaterials = function() {
			for (var e = 0; e < this.materials.length; e++) this.materials[e].freeze()
		}, i.prototype.unfreezeMaterials = function() {
			for (var e = 0; e < this.materials.length; e++) this.materials[e].unfreeze()
		}, i.prototype.dispose = function() {
			this.beforeRender = null, this.afterRender = null, this.skeletons = [], this._boundingBoxRenderer.dispose(), this._depthRenderer && this._depthRenderer.dispose(), this._debugLayer && this._debugLayer.hide(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.detachControl(), e.AudioEngine && this.disposeSounds();
			var t, i = this._engine.getRenderingCanvas();
			for (t = 0; t < this.cameras.length; t++) this.cameras[t].detachControl(i);
			for (; this.lights.length;) this.lights[0].dispose();
			for (; this.meshes.length;) this.meshes[0].dispose(!0);
			for (; this.cameras.length;) this.cameras[0].dispose();
			for (; this.materials.length;) this.materials[0].dispose();
			for (; this.particleSystems.length;) this.particleSystems[0].dispose();
			for (; this.spriteManagers.length;) this.spriteManagers[0].dispose();
			for (; this.layers.length;) this.layers[0].dispose();
			for (; this.highlightLayers.length;) this.highlightLayers[0].dispose();
			for (; this.textures.length;) this.textures[0].dispose();
			this.postProcessManager.dispose(), this._physicsEngine && this.disablePhysicsEngine(), t = this._engine.scenes.indexOf(this), t > -1 && this._engine.scenes.splice(t, 1), this._engine.wipeCaches()
		}, i.prototype.disposeSounds = function() {
			this.mainSoundTrack.dispose();
			for (var e = 0; e < this.soundTracks.length; e++) this.soundTracks[e].dispose()
		}, i.prototype.getWorldExtends = function() {
			for (var t = new e.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), i = new e.Vector3((-Number.MAX_VALUE), (-Number.MAX_VALUE), (-Number.MAX_VALUE)), r = 0; r < this.meshes.length; r++) {
				var n = this.meshes[r];
				n.computeWorldMatrix(!0);
				var o = n.getBoundingInfo().boundingBox.minimumWorld,
					s = n.getBoundingInfo().boundingBox.maximumWorld;
				e.Tools.CheckExtends(o, t, i), e.Tools.CheckExtends(s, t, i)
			}
			return {
				min: t,
				max: i
			}
		}, i.prototype.createOrUpdateSelectionOctree = function(t, i) {
			void 0 === t && (t = 64), void 0 === i && (i = 2), this._selectionOctree || (this._selectionOctree = new e.Octree(e.Octree.CreationFuncForMeshes, t, i));
			var r = this.getWorldExtends();
			return this._selectionOctree.update(r.min, r.max, this.meshes), this._selectionOctree
		}, i.prototype.createPickingRay = function(t, i, r, n, o) {
			void 0 === o && (o = !1);
			var s = this._engine;
			if (!n) {
				if (!this.activeCamera) throw new Error("Active camera not set");
				n = this.activeCamera
			}
			var a = n.viewport,
				h = a.toGlobal(s.getRenderWidth(), s.getRenderHeight());
			return t = t / this._engine.getHardwareScalingLevel() - h.x, i = i / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - h.y - h.height), e.Ray.CreateNew(t, i, h.width, h.height, r ? r : e.Matrix.Identity(), o ? e.Matrix.Identity() : n.getViewMatrix(), n.getProjectionMatrix())
		}, i.prototype.createPickingRayInCameraSpace = function(t, i, r) {
			var n = this._engine;
			if (!r) {
				if (!this.activeCamera) throw new Error("Active camera not set");
				r = this.activeCamera
			}
			var o = r.viewport,
				s = o.toGlobal(n.getRenderWidth(), n.getRenderHeight()),
				a = e.Matrix.Identity();
			return t = t / this._engine.getHardwareScalingLevel() - s.x, i = i / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - s.y - s.height), e.Ray.CreateNew(t, i, s.width, s.height, a, a, r.getProjectionMatrix())
		}, i.prototype._internalPick = function(t, i, r) {
			for (var n = null, o = 0; o < this.meshes.length; o++) {
				var s = this.meshes[o];
				if (i) {
					if (!i(s)) continue
				} else if (!s.isEnabled() || !s.isVisible || !s.isPickable) continue;
				var a = s.getWorldMatrix(),
					h = t(a),
					c = s.intersects(h, r);
				if (c && c.hit && (r || null == n || !(c.distance >= n.distance)) && (n = c, r)) break
			}
			return n || new e.PickingInfo
		}, i.prototype._internalMultiPick = function(e, t) {
			for (var i = new Array, r = 0; r < this.meshes.length; r++) {
				var n = this.meshes[r];
				if (t) {
					if (!t(n)) continue
				} else if (!n.isEnabled() || !n.isVisible || !n.isPickable) continue;
				var o = n.getWorldMatrix(),
					s = e(o),
					a = n.intersects(s, !1);
				a && a.hit && i.push(a)
			}
			return i
		}, i.prototype._internalPickSprites = function(t, i, r, n) {
			var o = null;
			if (n = n || this.activeCamera, this.spriteManagers.length > 0)
				for (var s = 0; s < this.spriteManagers.length; s++) {
					var a = this.spriteManagers[s];
					if (a.isPickable) {
						var h = a.intersects(t, n, i, r);
						if (h && h.hit && (r || null == o || !(h.distance >= o.distance)) && (o = h, r)) break
					}
				}
			return o || new e.PickingInfo
		}, i.prototype.pick = function(e, t, i, r, n) {
			var o = this;
			return this._internalPick((function(i) {
				return o.createPickingRay(e, t, i, n)
			}), i, r)
		}, i.prototype.pickSprite = function(e, t, i, r, n) {
			return this._internalPickSprites(this.createPickingRayInCameraSpace(e, t, n), i, r, n)
		}, i.prototype.pickWithRay = function(t, i, r) {
			var n = this;
			return this._internalPick((function(i) {
				return n._pickWithRayInverseMatrix || (n._pickWithRayInverseMatrix = e.Matrix.Identity()), i.invertToRef(n._pickWithRayInverseMatrix), e.Ray.Transform(t, n._pickWithRayInverseMatrix)
			}), i, r)
		}, i.prototype.multiPick = function(e, t, i, r) {
			var n = this;
			return this._internalMultiPick((function(i) {
				return n.createPickingRay(e, t, i, r)
			}), i)
		}, i.prototype.multiPickWithRay = function(t, i) {
			var r = this;
			return this._internalMultiPick((function(i) {
				return r._pickWithRayInverseMatrix || (r._pickWithRayInverseMatrix = e.Matrix.Identity()), i.invertToRef(r._pickWithRayInverseMatrix), e.Ray.Transform(t, r._pickWithRayInverseMatrix)
			}), i)
		}, i.prototype.setPointerOverMesh = function(t) {
			this._pointerOverMesh !== t && (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.processTrigger(e.ActionManager.OnPointerOutTrigger, e.ActionEvent.CreateNew(this._pointerOverMesh)), this._pointerOverMesh = t, this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.processTrigger(e.ActionManager.OnPointerOverTrigger, e.ActionEvent.CreateNew(this._pointerOverMesh)))
		}, i.prototype.getPointerOverMesh = function() {
			return this._pointerOverMesh
		}, i.prototype.setPointerOverSprite = function(t) {
			this._pointerOverSprite !== t && (this._pointerOverSprite && this._pointerOverSprite.actionManager && this._pointerOverSprite.actionManager.processTrigger(e.ActionManager.OnPointerOutTrigger, e.ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this)), this._pointerOverSprite = t, this._pointerOverSprite && this._pointerOverSprite.actionManager && this._pointerOverSprite.actionManager.processTrigger(e.ActionManager.OnPointerOverTrigger, e.ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this)))
		}, i.prototype.getPointerOverSprite = function() {
			return this._pointerOverSprite
		}, i.prototype.getPhysicsEngine = function() {
			return this._physicsEngine
		}, i.prototype.enablePhysics = function(t, i) {
			if (this._physicsEngine) return !0;
			try {
				return this._physicsEngine = new e.PhysicsEngine(t, i), !0
			} catch (r) {
				return e.Tools.Error(r.message), !1
			}
		}, i.prototype.disablePhysicsEngine = function() {
			this._physicsEngine && (this._physicsEngine.dispose(), this._physicsEngine = void 0)
		}, i.prototype.isPhysicsEnabled = function() {
			return void 0 !== this._physicsEngine
		}, i.prototype.setGravity = function(t) {
			e.Tools.Warn("Deprecated, please use 'scene.getPhysicsEngine().setGravity()'"), this._physicsEngine && this._physicsEngine.setGravity(t)
		}, i.prototype.createCompoundImpostor = function(t, i) {
			e.Tools.Warn("Scene.createCompoundImpostor is deprecated. Please use PhysicsImpostor parent/child"), t.parts && (i = t, t = t.parts);
			var r = t[0].mesh;
			r.physicsImpostor = new e.PhysicsImpostor(r, t[0].impostor, i, this);
			for (var n = 1; n < t.length; n++) {
				var o = t[n].mesh;
				o.parent !== r && (o.position = o.position.subtract(r.position), o.parent = r), o.physicsImpostor = new e.PhysicsImpostor(o, t[n].impostor, i, this)
			}
			r.physicsImpostor.forceUpdate()
		}, i.prototype.deleteCompoundImpostor = function(e) {
			var t = e.parts[0].mesh;
			t.physicsImpostor.dispose(), t.physicsImpostor = null
		}, i.prototype.createDefaultCameraOrLight = function() {
			if (0 === this.lights.length && new e.HemisphericLight("default light", e.Vector3.Up(), this), !this.activeCamera) {
				var t = new e.FreeCamera("default camera", e.Vector3.Zero(), this),
					i = this.getWorldExtends(),
					r = i.min.add(i.max.subtract(i.min).scale(.5));
				t.position = new e.Vector3(r.x, r.y, i.min.z - (i.max.z - i.min.z)), t.setTarget(r), this.activeCamera = t
			}
		}, i.prototype._getByTags = function(t, i, r) {
			if (void 0 === i) return t;
			var n = [];
			r = r || function(e) {};
			for (var o in t) {
				var s = t[o];
				e.Tags.MatchesQuery(s, i) && (n.push(s), r(s))
			}
			return n
		}, i.prototype.getMeshesByTags = function(e, t) {
			return this._getByTags(this.meshes, e, t)
		}, i.prototype.getCamerasByTags = function(e, t) {
			return this._getByTags(this.cameras, e, t)
		}, i.prototype.getLightsByTags = function(e, t) {
			return this._getByTags(this.lights, e, t)
		}, i.prototype.getMaterialByTags = function(e, t) {
			return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t))
		}, i.prototype.setRenderingOrder = function(e, t, i, r) {
			void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), this._renderingManager.setRenderingOrder(e, t, i, r)
		}, i.prototype.setRenderingAutoClearDepthStencil = function(e, t) {
			this._renderingManager.setRenderingAutoClearDepthStencil(e, t)
		}, i._FOGMODE_NONE = 0, i._FOGMODE_EXP = 1, i._FOGMODE_EXP2 = 2, i._FOGMODE_LINEAR = 3, i.MinDeltaTime = 1, i.MaxDeltaTime = 1e3, i
	})();
	e.Scene = s
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o, s) {
			t instanceof e.Mesh ? this._engine = t.getScene().getEngine() : this._engine = t, this._updatable = r, this._data = i, this._strideSize = n, o || this.create(), this._instanced = s
		}
		return t.prototype.createVertexBuffer = function(t, i, r, n) {
			return new e.VertexBuffer(this._engine, this, t, this._updatable, (!0), n ? n : this._strideSize, this._instanced, i, r)
		}, t.prototype.isUpdatable = function() {
			return this._updatable
		}, t.prototype.getData = function() {
			return this._data
		}, t.prototype.getBuffer = function() {
			return this._buffer
		}, t.prototype.getStrideSize = function() {
			return this._strideSize
		}, t.prototype.getIsInstanced = function() {
			return this._instanced
		}, t.prototype.create = function(e) {
			!e && this._buffer || (e = e || this._data, this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e), this._data = e) : this._buffer = this._engine.createVertexBuffer(e))
		}, t.prototype.update = function(e) {
			this.create(e)
		}, t.prototype.updateDirectly = function(e, t, i) {
			this._buffer && this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, t, i ? i * this.getStrideSize() : void 0), this._data = null)
		}, t.prototype.dispose = function() {
			this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null)
		}, t
	})();
	e.Buffer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(i, r, n, o, s, a, h, c, l) {
			if (!a) switch (n) {
				case t.PositionKind:
					a = 3;
					break;
				case t.NormalKind:
					a = 3;
					break;
				case t.UVKind:
				case t.UV2Kind:
				case t.UV3Kind:
				case t.UV4Kind:
				case t.UV5Kind:
				case t.UV6Kind:
					a = 2;
					break;
				case t.ColorKind:
					a = 4;
					break;
				case t.MatricesIndicesKind:
				case t.MatricesIndicesExtraKind:
					a = 4;
					break;
				case t.MatricesWeightsKind:
				case t.MatricesWeightsExtraKind:
					a = 4
			}
			r instanceof e.Buffer ? (a || (a = r.getStrideSize()), this._buffer = r, this._ownsBuffer = !1) : (this._buffer = new e.Buffer(i, r, o, a, s, h), this._ownsBuffer = !0), this._stride = a, this._offset = c ? c : 0, this._size = l ? l : a, this._kind = n
		}
		return t.prototype.getKind = function() {
			return this._kind
		}, t.prototype.isUpdatable = function() {
			return this._buffer.isUpdatable()
		}, t.prototype.getData = function() {
			return this._buffer.getData()
		}, t.prototype.getBuffer = function() {
			return this._buffer.getBuffer()
		}, t.prototype.getStrideSize = function() {
			return this._stride
		}, t.prototype.getOffset = function() {
			return this._offset
		}, t.prototype.getSize = function() {
			return this._size
		}, t.prototype.getIsInstanced = function() {
			return this._buffer.getIsInstanced()
		}, t.prototype.create = function(e) {
			return this._buffer.create(e)
		}, t.prototype.update = function(e) {
			return this._buffer.update(e)
		}, t.prototype.updateDirectly = function(e, t) {
			return this._buffer.updateDirectly(e, t)
		}, t.prototype.dispose = function() {
			this._ownsBuffer && this._buffer.dispose()
		}, Object.defineProperty(t, "PositionKind", {
			get: function() {
				return t._PositionKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "NormalKind", {
			get: function() {
				return t._NormalKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "UVKind", {
			get: function() {
				return t._UVKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "UV2Kind", {
			get: function() {
				return t._UV2Kind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "UV3Kind", {
			get: function() {
				return t._UV3Kind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "UV4Kind", {
			get: function() {
				return t._UV4Kind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "UV5Kind", {
			get: function() {
				return t._UV5Kind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "UV6Kind", {
			get: function() {
				return t._UV6Kind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "ColorKind", {
			get: function() {
				return t._ColorKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "MatricesIndicesKind", {
			get: function() {
				return t._MatricesIndicesKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "MatricesWeightsKind", {
			get: function() {
				return t._MatricesWeightsKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "MatricesIndicesExtraKind", {
			get: function() {
				return t._MatricesIndicesExtraKind
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "MatricesWeightsExtraKind", {
			get: function() {
				return t._MatricesWeightsExtraKind
			},
			enumerable: !0,
			configurable: !0
		}), t._PositionKind = "position", t._NormalKind = "normal", t._UVKind = "uv", t._UV2Kind = "uv2", t._UV3Kind = "uv3", t._UV4Kind = "uv4", t._UV5Kind = "uv5", t._UV6Kind = "uv6", t._ColorKind = "color", t._MatricesIndicesKind = "matricesIndices", t._MatricesWeightsKind = "matricesWeights", t._MatricesIndicesExtraKind = "matricesIndicesExtra", t._MatricesWeightsExtraKind = "matricesWeightsExtra", t
	})();
	e.VertexBuffer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i) {
			t.call(this, e, i.getScene()), i.instances.push(this), this._sourceMesh = i, this.position.copyFrom(i.position), this.rotation.copyFrom(i.rotation), this.scaling.copyFrom(i.scaling), i.rotationQuaternion && (this.rotationQuaternion = i.rotationQuaternion.clone()), this.infiniteDistance = i.infiniteDistance, this.setPivotMatrix(i.getPivotMatrix()),
				this.refreshBoundingInfo(), this._syncSubMeshes()
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "receiveShadows", {
			get: function() {
				return this._sourceMesh.receiveShadows
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "material", {
			get: function() {
				return this._sourceMesh.material
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "visibility", {
			get: function() {
				return this._sourceMesh.visibility
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "skeleton", {
			get: function() {
				return this._sourceMesh.skeleton
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "renderingGroupId", {
			get: function() {
				return this._sourceMesh.renderingGroupId
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getTotalVertices = function() {
			return this._sourceMesh.getTotalVertices()
		}, Object.defineProperty(i.prototype, "sourceMesh", {
			get: function() {
				return this._sourceMesh
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getVerticesData = function(e, t) {
			return this._sourceMesh.getVerticesData(e, t)
		}, i.prototype.isVerticesDataPresent = function(e) {
			return this._sourceMesh.isVerticesDataPresent(e)
		}, i.prototype.getIndices = function() {
			return this._sourceMesh.getIndices()
		}, Object.defineProperty(i.prototype, "_positions", {
			get: function() {
				return this._sourceMesh._positions
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.refreshBoundingInfo = function() {
			var t = this._sourceMesh.getBoundingInfo();
			this._boundingInfo = new e.BoundingInfo(t.minimum.clone(), t.maximum.clone()), this._updateBoundingInfo()
		}, i.prototype._preActivate = function() {
			this._currentLOD && this._currentLOD._preActivate()
		}, i.prototype._activate = function(e) {
			this._currentLOD && this._currentLOD._registerInstanceForRenderId(this, e)
		}, i.prototype.getLOD = function(e) {
			return this._currentLOD = this.sourceMesh.getLOD(this.getScene().activeCamera, this.getBoundingInfo().boundingSphere), this._currentLOD === this.sourceMesh ? this : this._currentLOD
		}, i.prototype._syncSubMeshes = function() {
			if (this.releaseSubMeshes(), this._sourceMesh.subMeshes)
				for (var e = 0; e < this._sourceMesh.subMeshes.length; e++) this._sourceMesh.subMeshes[e].clone(this, this._sourceMesh)
		}, i.prototype._generatePointsArray = function() {
			return this._sourceMesh._generatePointsArray()
		}, i.prototype.clone = function(t, i, r) {
			var n = this._sourceMesh.createInstance(t);
			if (e.Tools.DeepCopy(this, n, ["name", "subMeshes"], []), this.refreshBoundingInfo(), i && (n.parent = i), !r)
				for (var o = 0; o < this.getScene().meshes.length; o++) {
					var s = this.getScene().meshes[o];
					s.parent === this && s.clone(s.name, n)
				}
			return n.computeWorldMatrix(!0), n
		}, i.prototype.dispose = function(e) {
			var i = this._sourceMesh.instances.indexOf(this);
			this._sourceMesh.instances.splice(i, 1), t.prototype.dispose.call(this, e)
		}, i
	})(e.AbstractMesh);
	e.InstancedMesh = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {
			this.mustReturn = !1, this.visibleInstances = new Array, this.renderSelf = new Array
		}
		return e
	})();
	e._InstancesBatch = t;
	var i = (function(i) {
		function r(n, o, s, a, h, c) {
			if (void 0 === s && (s = null), void 0 === c && (c = !0), i.call(this, n, o), this.onBeforeRenderObservable = new e.Observable, this.onAfterRenderObservable = new e.Observable, this.onBeforeDrawObservable = new e.Observable, this.delayLoadState = e.Engine.DELAYLOADSTATE_NONE, this.instances = new Array, this._LODLevels = new Array, this._visibleInstances = {}, this._renderIdForInstances = new Array, this._batchCache = new t, this._instancesBufferSize = 2048, this._sideOrientation = r._DEFAULTSIDE, this._areNormalsFrozen = !1, a) {
				a._geometry && a._geometry.applyToMesh(this), e.Tools.DeepCopy(a, this, ["name", "material", "skeleton", "instances", "parent"], ["_poseMatrix"]), this.parent = a.parent, this.setPivotMatrix(a.getPivotMatrix()), this.id = n + "." + a.id, this.material = a.material;
				var l;
				if (!h)
					for (l = 0; l < o.meshes.length; l++) {
						var u = o.meshes[l];
						if (u.parent === a) {
							u.clone(n + "." + u.name, this, h)
						}
					}
				var d = this.getScene().getPhysicsEngine();
				if (c && d) {
					var f = d.getImpostorForPhysicsObject(a);
					f && (this.physicsImpostor = f.clone(this))
				}
				for (l = 0; l < o.particleSystems.length; l++) {
					var p = o.particleSystems[l];
					p.emitter === a && p.clone(p.name, this)
				}
				this.computeWorldMatrix(!0)
			}
			null !== s && (this.parent = s)
		}
		return __extends(r, i), Object.defineProperty(r, "FRONTSIDE", {
			get: function() {
				return r._FRONTSIDE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "BACKSIDE", {
			get: function() {
				return r._BACKSIDE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "DOUBLESIDE", {
			get: function() {
				return r._DOUBLESIDE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "DEFAULTSIDE", {
			get: function() {
				return r._DEFAULTSIDE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "NO_CAP", {
			get: function() {
				return r._NO_CAP
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "CAP_START", {
			get: function() {
				return r._CAP_START
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "CAP_END", {
			get: function() {
				return r._CAP_END
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r, "CAP_ALL", {
			get: function() {
				return r._CAP_ALL
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r.prototype, "onBeforeDraw", {
			set: function(e) {
				this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype.toString = function(t) {
			var r = i.prototype.toString.call(this, t);
			if (r += ", n vertices: " + this.getTotalVertices(), r += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"), this.animations)
				for (var n = 0; n < this.animations.length; n++) r += ", animation[0]: " + this.animations[n].toString(t);
			return t && (r += ", flat shading: " + (this._geometry ? this.getVerticesData(e.VertexBuffer.PositionKind).length / 3 === this.getIndices().length ? "YES" : "NO" : "UNKNOWN")), r
		}, Object.defineProperty(r.prototype, "hasLODLevels", {
			get: function() {
				return this._LODLevels.length > 0
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype._sortLODLevels = function() {
			this._LODLevels.sort((function(e, t) {
				return e.distance < t.distance ? 1 : e.distance > t.distance ? -1 : 0
			}))
		}, r.prototype.addLODLevel = function(t, i) {
			if (i && i._masterMesh) return e.Tools.Warn("You cannot use a mesh as LOD level twice"), this;
			var r = new e.Internals.MeshLODLevel(t, i);
			return this._LODLevels.push(r), i && (i._masterMesh = this), this._sortLODLevels(), this
		}, r.prototype.getLODLevelAtDistance = function(e) {
			for (var t = 0; t < this._LODLevels.length; t++) {
				var i = this._LODLevels[t];
				if (i.distance === e) return i.mesh
			}
			return null
		}, r.prototype.removeLODLevel = function(e) {
			for (var t = 0; t < this._LODLevels.length; t++) this._LODLevels[t].mesh === e && (this._LODLevels.splice(t, 1), e && (e._masterMesh = null));
			return this._sortLODLevels(), this
		}, r.prototype.getLOD = function(e, t) {
			if (!this._LODLevels || 0 === this._LODLevels.length) return this;
			var i = (t ? t : this.getBoundingInfo().boundingSphere).centerWorld.subtract(e.globalPosition).length();
			if (this._LODLevels[this._LODLevels.length - 1].distance > i) return this.onLODLevelSelection && this.onLODLevelSelection(i, this, this._LODLevels[this._LODLevels.length - 1].mesh), this;
			for (var r = 0; r < this._LODLevels.length; r++) {
				var n = this._LODLevels[r];
				if (n.distance < i) return n.mesh && (n.mesh._preActivate(), n.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)), this.onLODLevelSelection && this.onLODLevelSelection(i, this, n.mesh), n.mesh
			}
			return this.onLODLevelSelection && this.onLODLevelSelection(i, this, this), this
		}, Object.defineProperty(r.prototype, "geometry", {
			get: function() {
				return this._geometry
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype.getTotalVertices = function() {
			return this._geometry ? this._geometry.getTotalVertices() : 0
		}, r.prototype.getVerticesData = function(e, t) {
			return this._geometry ? this._geometry.getVerticesData(e, t) : null
		}, r.prototype.getVertexBuffer = function(e) {
			if (this._geometry) return this._geometry.getVertexBuffer(e)
		}, r.prototype.isVerticesDataPresent = function(e) {
			return this._geometry ? this._geometry.isVerticesDataPresent(e) : !!this._delayInfo && this._delayInfo.indexOf(e) !== -1
		}, r.prototype.getVerticesDataKinds = function() {
			if (!this._geometry) {
				var e = [];
				return this._delayInfo && this._delayInfo.forEach((function(t, i, r) {
					e.push(t)
				})), e
			}
			return this._geometry.getVerticesDataKinds()
		}, r.prototype.getTotalIndices = function() {
			return this._geometry ? this._geometry.getTotalIndices() : 0
		}, r.prototype.getIndices = function(e) {
			return this._geometry ? this._geometry.getIndices(e) : []
		}, Object.defineProperty(r.prototype, "isBlocked", {
			get: function() {
				return null !== this._masterMesh && void 0 !== this._masterMesh
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype.isReady = function() {
			return this.delayLoadState !== e.Engine.DELAYLOADSTATE_LOADING && i.prototype.isReady.call(this)
		}, r.prototype.isDisposed = function() {
			return this._isDisposed
		}, Object.defineProperty(r.prototype, "sideOrientation", {
			get: function() {
				return this._sideOrientation
			},
			set: function(e) {
				this._sideOrientation = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r.prototype, "areNormalsFrozen", {
			get: function() {
				return this._areNormalsFrozen
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype.freezeNormals = function() {
			this._areNormalsFrozen = !0
		}, r.prototype.unfreezeNormals = function() {
			this._areNormalsFrozen = !1
		}, Object.defineProperty(r.prototype, "overridenInstanceCount", {
			set: function(e) {
				this._overridenInstanceCount = e
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype._preActivate = function() {
			var e = this.getScene().getRenderId();
			this._preActivateId !== e && (this._preActivateId = e, this._visibleInstances = null)
		}, r.prototype._preActivateForIntermediateRendering = function(e) {
			this._visibleInstances && (this._visibleInstances.intermediateDefaultRenderId = e)
		}, r.prototype._registerInstanceForRenderId = function(e, t) {
			this._visibleInstances || (this._visibleInstances = {}, this._visibleInstances.defaultRenderId = t, this._visibleInstances.selfDefaultRenderId = this._renderId), this._visibleInstances[t] || (this._visibleInstances[t] = new Array), this._visibleInstances[t].push(e)
		}, r.prototype.refreshBoundingInfo = function() {
			if (!this._boundingInfo.isLocked) {
				var t = this.getVerticesData(e.VertexBuffer.PositionKind);
				if (t) {
					var i = e.Tools.ExtractMinAndMax(t, 0, this.getTotalVertices());
					this._boundingInfo = new e.BoundingInfo(i.minimum, i.maximum)
				}
				if (this.subMeshes)
					for (var r = 0; r < this.subMeshes.length; r++) this.subMeshes[r].refreshBoundingInfo();
				this._updateBoundingInfo()
			}
		}, r.prototype._createGlobalSubMesh = function() {
			var t = this.getTotalVertices();
			return t && this.getIndices() ? (this.releaseSubMeshes(), new e.SubMesh(0, 0, t, 0, this.getTotalIndices(), this)) : null
		}, r.prototype.subdivide = function(t) {
			if (!(t < 1)) {
				for (var i = this.getTotalIndices(), r = i / t | 0, n = 0; r % 3 !== 0;) r++;
				this.releaseSubMeshes();
				for (var o = 0; o < t && !(n >= i); o++) e.SubMesh.CreateFromIndices(0, n, Math.min(r, i - n), this), n += r;
				this.synchronizeInstances()
			}
		}, r.prototype.setVerticesData = function(t, i, r, n) {
			if (this._geometry) this._geometry.setVerticesData(t, i, r, n);
			else {
				var o = new e.VertexData;
				o.set(i, t);
				var s = this.getScene();
				new e.Geometry(e.Geometry.RandomId(), s, o, r, this)
			}
		}, r.prototype.setVerticesBuffer = function(t) {
			if (!this._geometry) {
				var i = this.getScene();
				new e.Geometry(e.Geometry.RandomId(), i).applyToMesh(this)
			}
			this._geometry.setVerticesBuffer(t)
		}, r.prototype.updateVerticesData = function(e, t, i, r) {
			this._geometry && (r ? (this.makeGeometryUnique(), this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i))
		}, r.prototype.updateVerticesDataDirectly = function(t, i, r, n) {
			e.Tools.Warn("Mesh.updateVerticesDataDirectly deprecated since 2.3."), this._geometry && (n ? (this.makeGeometryUnique(), this.updateVerticesDataDirectly(t, i, r, !1)) : this._geometry.updateVerticesDataDirectly(t, i, r))
		}, r.prototype.updateMeshPositions = function(t, i) {
			void 0 === i && (i = !0);
			var r = this.getVerticesData(e.VertexBuffer.PositionKind);
			if (t(r), this.updateVerticesData(e.VertexBuffer.PositionKind, r, !1, !1), i) {
				var n = this.getIndices(),
					o = this.getVerticesData(e.VertexBuffer.NormalKind);
				e.VertexData.ComputeNormals(r, n, o), this.updateVerticesData(e.VertexBuffer.NormalKind, o, !1, !1)
			}
		}, r.prototype.makeGeometryUnique = function() {
			if (this._geometry) {
				var t = this._geometry,
					i = this._geometry.copy(e.Geometry.RandomId());
				t.releaseForMesh(this, !0), i.applyToMesh(this)
			}
		}, r.prototype.setIndices = function(t, i) {
			if (this._geometry) this._geometry.setIndices(t, i);
			else {
				var r = new e.VertexData;
				r.indices = t;
				var n = this.getScene();
				new e.Geometry(e.Geometry.RandomId(), n, r, (!1), this)
			}
		}, r.prototype.toLeftHanded = function() {
			this._geometry && this._geometry.toLeftHanded()
		}, r.prototype._bind = function(t, i, r) {
			var n, o = this.getScene().getEngine();
			if (this._unIndexed) n = null;
			else switch (r) {
				case e.Material.PointFillMode:
					n = null;
					break;
				case e.Material.WireFrameFillMode:
					n = t.getLinesIndexBuffer(this.getIndices(), o);
					break;
				default:
				case e.Material.TriangleFillMode:
					n = this._unIndexed ? null : this._geometry.getIndexBuffer()
			}
			o.bindBuffers(this._geometry.getVertexBuffers(), n, i)
		}, r.prototype._draw = function(t, i, r) {
			if (this._geometry && this._geometry.getVertexBuffers() && this._geometry.getIndexBuffer()) {
				this.onBeforeDrawObservable.notifyObservers(this);
				var n = this.getScene().getEngine();
				switch (i) {
					case e.Material.PointFillMode:
						n.drawPointClouds(t.verticesStart, t.verticesCount, r);
						break;
					case e.Material.WireFrameFillMode:
						this._unIndexed ? n.drawUnIndexed(!1, t.verticesStart, t.verticesCount, r) : n.draw(!1, 0, r > 0 ? t.linesIndexCount / 2 : t.linesIndexCount, r);
						break;
					default:
						this._unIndexed ? n.drawUnIndexed(!0, t.verticesStart, t.verticesCount, r) : n.draw(!0, t.indexStart, t.indexCount, r)
				}
			}
		}, r.prototype.registerBeforeRender = function(e) {
			this.onBeforeRenderObservable.add(e)
		}, r.prototype.unregisterBeforeRender = function(e) {
			this.onBeforeRenderObservable.removeCallback(e)
		}, r.prototype.registerAfterRender = function(e) {
			this.onAfterRenderObservable.add(e)
		}, r.prototype.unregisterAfterRender = function(e) {
			this.onAfterRenderObservable.removeCallback(e)
		}, r.prototype._getInstancesRenderList = function(e) {
			var t = this.getScene();
			if (this._batchCache.mustReturn = !1, this._batchCache.renderSelf[e] = this.isEnabled() && this.isVisible, this._batchCache.visibleInstances[e] = null, this._visibleInstances) {
				var i = t.getRenderId(),
					r = t._isInIntermediateRendering() ? this._visibleInstances.intermediateDefaultRenderId : this._visibleInstances.defaultRenderId;
				this._batchCache.visibleInstances[e] = this._visibleInstances[i];
				var n = this._renderId;
				if (!this._batchCache.visibleInstances[e] && r && (this._batchCache.visibleInstances[e] = this._visibleInstances[r], i = Math.max(r, i), n = Math.max(this._visibleInstances.selfDefaultRenderId, i)), this._batchCache.visibleInstances[e] && this._batchCache.visibleInstances[e].length) {
					if (this._renderIdForInstances[e] === i) return this._batchCache.mustReturn = !0, this._batchCache;
					i !== n && (this._batchCache.renderSelf[e] = !1)
				}
				this._renderIdForInstances[e] = i
			}
			return this._batchCache
		}, r.prototype._renderWithInstances = function(t, i, r, n, o) {
			for (var s = r.visibleInstances[t._id], a = s.length + 1, h = 16 * a * 4, c = this._instancesBufferSize, l = this._instancesBuffer; this._instancesBufferSize < h;) this._instancesBufferSize *= 2;
			this._instancesData && c == this._instancesBufferSize || (this._instancesData = new Float32Array(this._instancesBufferSize / 4));
			var u = 0,
				d = 0,
				f = this.getWorldMatrix();
			if (r.renderSelf[t._id] && (f.copyToArray(this._instancesData, u), u += 16, d++), s)
				for (var p = 0; p < s.length; p++) {
					var m = s[p];
					m.getWorldMatrix().copyToArray(this._instancesData, u), u += 16, d++
				}
			l && c == this._instancesBufferSize ? l.updateDirectly(this._instancesData, 0, d) : (l && l.dispose(), l = new e.Buffer(o, this._instancesData, (!0), 16, (!1), (!0)), this._instancesBuffer = l, this.setVerticesBuffer(l.createVertexBuffer("world0", 0, 4)), this.setVerticesBuffer(l.createVertexBuffer("world1", 4, 4)), this.setVerticesBuffer(l.createVertexBuffer("world2", 8, 4)), this.setVerticesBuffer(l.createVertexBuffer("world3", 12, 4))), o.bindBuffers(this.geometry.getVertexBuffers(), this.geometry.getIndexBuffer(), n), this._draw(t, i, d), o.unbindInstanceAttributes()
		}, r.prototype._processRendering = function(e, t, i, r, n, o, s) {
			var a = this.getScene(),
				h = a.getEngine();
			if (n) this._renderWithInstances(e, i, r, t, h);
			else if (r.renderSelf[e._id] && (o && o(!1, this.getWorldMatrix(), s), this._draw(e, i, this._overridenInstanceCount)), r.visibleInstances[e._id])
				for (var c = 0; c < r.visibleInstances[e._id].length; c++) {
					var l = r.visibleInstances[e._id][c],
						u = l.getWorldMatrix();
					o && o(!0, u, s), this._draw(e, i)
				}
		}, r.prototype.render = function(t, i) {
			var r = this.getScene(),
				n = this._getInstancesRenderList(t._id);
			if (!n.mustReturn && this._geometry && this._geometry.getVertexBuffers() && this._geometry.getIndexBuffer()) {
				this.onBeforeRenderObservable.notifyObservers(this);
				var o = r.getEngine(),
					s = null !== o.getCaps().instancedArrays && null !== n.visibleInstances[t._id] && void 0 !== n.visibleInstances[t._id],
					a = t.getMaterial();
				if (a && a.isReady(this, s)) {
					var h = o.getDepthWrite();
					this.renderOutline && (o.setDepthWrite(!1), r.getOutlineRenderer().render(t, n), o.setDepthWrite(h)), a._preBind();
					var c = a.getEffect(),
						l = r.forcePointsCloud ? e.Material.PointFillMode : r.forceWireframe ? e.Material.WireFrameFillMode : a.fillMode;
					this._bind(t, c, l);
					var u = this.getWorldMatrix();
					if (a.bind(u, this), i && o.setAlphaMode(a.alphaMode), this._processRendering(t, c, l, n, s, this._onBeforeDraw, a), a.unbind(), this.renderOutline && h && (o.setDepthWrite(!0), o.setColorWrite(!1), r.getOutlineRenderer().render(t, n), o.setColorWrite(!0)), this.renderOverlay) {
						var d = o.getAlphaMode();
						o.setAlphaMode(e.Engine.ALPHA_COMBINE), r.getOutlineRenderer().render(t, n, !0), o.setAlphaMode(d)
					}
					this.onAfterRenderObservable.notifyObservers(this)
				}
			}
		}, r.prototype._onBeforeDraw = function(e, t, i) {
			e && i.bindOnlyWorldMatrix(t)
		}, r.prototype.getEmittedParticleSystems = function() {
			for (var e = new Array, t = 0; t < this.getScene().particleSystems.length; t++) {
				var i = this.getScene().particleSystems[t];
				i.emitter === this && e.push(i)
			}
			return e
		}, r.prototype.getHierarchyEmittedParticleSystems = function() {
			var e = new Array,
				t = this.getDescendants();
			t.push(this);
			for (var i = 0; i < this.getScene().particleSystems.length; i++) {
				var r = this.getScene().particleSystems[i];
				t.indexOf(r.emitter) !== -1 && e.push(r)
			}
			return e
		}, r.prototype._checkDelayState = function() {
			var t = this.getScene();
			this._geometry ? this._geometry.load(t) : this.delayLoadState === e.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = e.Engine.DELAYLOADSTATE_LOADING, this._queueLoad(this, t))
		}, r.prototype._queueLoad = function(t, i) {
			var r = this;
			i._addPendingData(t);
			var n = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
			e.Tools.LoadFile(this.delayLoadingFile, (function(t) {
				t instanceof ArrayBuffer ? r._delayLoadingFunction(t, r) : r._delayLoadingFunction(JSON.parse(t), r), r.delayLoadState = e.Engine.DELAYLOADSTATE_LOADED, i._removePendingData(r)
			}), (function() {}), i.database, n)
		}, r.prototype.isInFrustum = function(t) {
			return this.delayLoadState !== e.Engine.DELAYLOADSTATE_LOADING && (!!i.prototype.isInFrustum.call(this, t) && (this._checkDelayState(), !0))
		}, r.prototype.setMaterialByID = function(e) {
			var t, i = this.getScene().materials;
			for (t = 0; t < i.length; t++)
				if (i[t].id === e) return void(this.material = i[t]);
			var r = this.getScene().multiMaterials;
			for (t = 0; t < r.length; t++)
				if (r[t].id === e) return void(this.material = r[t])
		}, r.prototype.getAnimatables = function() {
			var e = [];
			return this.material && e.push(this.material), this.skeleton && e.push(this.skeleton), e
		}, r.prototype.bakeTransformIntoVertices = function(t) {
			if (this.isVerticesDataPresent(e.VertexBuffer.PositionKind)) {
				var i = this.subMeshes.splice(0);
				this._resetPointsArrayCache();
				var r, n = this.getVerticesData(e.VertexBuffer.PositionKind),
					o = [];
				for (r = 0; r < n.length; r += 3) e.Vector3.TransformCoordinates(e.Vector3.FromArray(n, r), t).toArray(o, r);
				if (this.setVerticesData(e.VertexBuffer.PositionKind, o, this.getVertexBuffer(e.VertexBuffer.PositionKind).isUpdatable()), this.isVerticesDataPresent(e.VertexBuffer.NormalKind)) {
					for (n = this.getVerticesData(e.VertexBuffer.NormalKind), o = [], r = 0; r < n.length; r += 3) e.Vector3.TransformNormal(e.Vector3.FromArray(n, r), t).normalize().toArray(o, r);
					this.setVerticesData(e.VertexBuffer.NormalKind, o, this.getVertexBuffer(e.VertexBuffer.NormalKind).isUpdatable()), t.m[0] * t.m[5] * t.m[10] < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = i
				}
			}
		}, r.prototype.bakeCurrentTransformIntoVertices = function() {
			this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = e.Quaternion.Identity()), this._worldMatrix = e.Matrix.Identity()
		}, r.prototype._resetPointsArrayCache = function() {
			this._positions = null
		}, r.prototype._generatePointsArray = function() {
			if (this._positions) return !0;
			this._positions = [];
			var t = this.getVerticesData(e.VertexBuffer.PositionKind);
			if (!t) return !1;
			for (var i = 0; i < t.length; i += 3) this._positions.push(e.Vector3.FromArray(t, i));
			return !0
		}, r.prototype.clone = function(e, t, i, n) {
			return void 0 === n && (n = !0), new r(e, this.getScene(), t, this, i, n)
		}, r.prototype.dispose = function(e) {
			for (this._geometry && this._geometry.releaseForMesh(this, !0), this._instancesBuffer && (this._instancesBuffer.dispose(), this._instancesBuffer = null); this.instances.length;) this.instances[0].dispose();
			for (var t = this.getScene().highlightLayers, r = 0; r < t.length; r++) {
				var n = t[r];
				n && (n.removeMesh(this), n.removeExcludedMesh(this))
			}
			i.prototype.dispose.call(this, e)
		}, r.prototype.applyDisplacementMap = function(t, i, r, n) {
			var o = this,
				s = this.getScene(),
				a = function(e) {
					var t = document.createElement("canvas"),
						s = t.getContext("2d"),
						a = e.width,
						h = e.height;
					t.width = a, t.height = h, s.drawImage(e, 0, 0);
					var c = s.getImageData(0, 0, a, h).data;
					o.applyDisplacementMapFromBuffer(c, a, h, i, r), n && n(o)
				};
			e.Tools.LoadImage(t, a, (function() {}), s.database)
		}, r.prototype.applyDisplacementMapFromBuffer = function(t, i, r, n, o) {
			if (!this.isVerticesDataPresent(e.VertexBuffer.PositionKind) || !this.isVerticesDataPresent(e.VertexBuffer.NormalKind) || !this.isVerticesDataPresent(e.VertexBuffer.UVKind)) return void e.Tools.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
			for (var s = this.getVerticesData(e.VertexBuffer.PositionKind), a = this.getVerticesData(e.VertexBuffer.NormalKind), h = this.getVerticesData(e.VertexBuffer.UVKind), c = e.Vector3.Zero(), l = e.Vector3.Zero(), u = e.Vector2.Zero(), d = 0; d < s.length; d += 3) {
				e.Vector3.FromArrayToRef(s, d, c), e.Vector3.FromArrayToRef(a, d, l), e.Vector2.FromArrayToRef(h, d / 3 * 2, u);
				var f = Math.abs(u.x) * i % i | 0,
					p = Math.abs(u.y) * r % r | 0,
					m = 4 * (f + p * i),
					_ = t[m] / 255,
					g = t[m + 1] / 255,
					v = t[m + 2] / 255,
					y = .3 * _ + .59 * g + .11 * v;
				l.normalize(), l.scaleInPlace(n + (o - n) * y), c = c.add(l), c.toArray(s, d)
			}
			e.VertexData.ComputeNormals(s, this.getIndices(), a), this.updateVerticesData(e.VertexBuffer.PositionKind, s), this.updateVerticesData(e.VertexBuffer.NormalKind, a)
		}, r.prototype.convertToFlatShadedMesh = function() {
			var t, i, r = this.getVerticesDataKinds(),
				n = [],
				o = [],
				s = [],
				a = !1;
			for (t = 0; t < r.length; t++) {
				i = r[t];
				var h = this.getVertexBuffer(i);
				i !== e.VertexBuffer.NormalKind ? (n[i] = h, o[i] = n[i].getData(), s[i] = []) : (a = h.isUpdatable(), r.splice(t, 1), t--)
			}
			var c, l = this.subMeshes.slice(0),
				u = this.getIndices(),
				d = this.getTotalIndices();
			for (c = 0; c < d; c++) {
				var f = u[c];
				for (t = 0; t < r.length; t++) {
					i = r[t];
					for (var p = n[i].getStrideSize(), m = 0; m < p; m++) s[i].push(o[i][f * p + m])
				}
			}
			var _ = [],
				g = s[e.VertexBuffer.PositionKind];
			for (c = 0; c < d; c += 3) {
				u[c] = c, u[c + 1] = c + 1, u[c + 2] = c + 2;
				for (var v = e.Vector3.FromArray(g, 3 * c), y = e.Vector3.FromArray(g, 3 * (c + 1)), x = e.Vector3.FromArray(g, 3 * (c + 2)), b = v.subtract(y), T = x.subtract(y), A = e.Vector3.Normalize(e.Vector3.Cross(b, T)), E = 0; E < 3; E++) _.push(A.x), _.push(A.y), _.push(A.z)
			}
			for (this.setIndices(u), this.setVerticesData(e.VertexBuffer.NormalKind, _, a), t = 0; t < r.length; t++) i = r[t], this.setVerticesData(i, s[i], n[i].isUpdatable());
			this.releaseSubMeshes();
			for (var P = 0; P < l.length; P++) {
				var M = l[P];
				new e.SubMesh(M.materialIndex, M.indexStart, M.indexCount, M.indexStart, M.indexCount, this)
			}
			this.synchronizeInstances()
		}, r.prototype.convertToUnIndexedMesh = function() {
			var t, i, r = this.getVerticesDataKinds(),
				n = [],
				o = [],
				s = [];
			for (t = 0; t < r.length; t++) {
				i = r[t];
				var a = this.getVertexBuffer(i);
				n[i] = a, o[i] = n[i].getData(), s[i] = []
			}
			var h, c = this.subMeshes.slice(0),
				l = this.getIndices(),
				u = this.getTotalIndices();
			for (h = 0; h < u; h++) {
				var d = l[h];
				for (t = 0; t < r.length; t++) {
					i = r[t];
					for (var f = n[i].getStrideSize(), p = 0; p < f; p++) s[i].push(o[i][d * f + p])
				}
			}
			for (h = 0; h < u; h += 3) l[h] = h, l[h + 1] = h + 1, l[h + 2] = h + 2;
			for (this.setIndices(l), t = 0; t < r.length; t++) i = r[t], this.setVerticesData(i, s[i], n[i].isUpdatable());
			this.releaseSubMeshes();
			for (var m = 0; m < c.length; m++) {
				var _ = c[m];
				new e.SubMesh(_.materialIndex, _.indexStart, _.indexCount, _.indexStart, _.indexCount, this)
			}
			this._unIndexed = !0, this.synchronizeInstances()
		}, r.prototype.flipFaces = function(t) {
			void 0 === t && (t = !1);
			var i, r = e.VertexData.ExtractFromMesh(this);
			if (t && this.isVerticesDataPresent(e.VertexBuffer.NormalKind))
				for (i = 0; i < r.normals.length; i++) r.normals[i] *= -1;
			var n;
			for (i = 0; i < r.indices.length; i += 3) n = r.indices[i + 1], r.indices[i + 1] = r.indices[i + 2], r.indices[i + 2] = n;
			r.applyToMesh(this)
		}, r.prototype.createInstance = function(t) {
			return new e.InstancedMesh(t, this)
		}, r.prototype.synchronizeInstances = function() {
			for (var e = 0; e < this.instances.length; e++) {
				var t = this.instances[e];
				t._syncSubMeshes()
			}
		}, r.prototype.simplify = function(t, i, r, n) {
			void 0 === i && (i = !0), void 0 === r && (r = e.SimplificationType.QUADRATIC), this.getScene().simplificationQueue.addTask({
				settings: t,
				parallelProcessing: i,
				mesh: this,
				simplificationType: r,
				successCallback: n
			})
		}, r.prototype.optimizeIndices = function(t) {
			for (var i = this, r = this.getIndices(), n = this.getVerticesData(e.VertexBuffer.PositionKind), o = [], s = 0; s < n.length; s += 3) o.push(e.Vector3.FromArray(n, s));
			var a = [];
			e.AsyncLoop.SyncAsyncForLoop(o.length, 40, (function(e) {
				for (var t = o.length - 1 - e, i = o[t], r = 0; r < t; ++r) {
					var n = o[r];
					if (i.equals(n)) {
						a[t] = r;
						break
					}
				}
			}), (function() {
				for (var e = 0; e < r.length; ++e) r[e] = a[r[e]] || r[e];
				var n = i.subMeshes.slice(0);
				i.setIndices(r), i.subMeshes = n, t && t(i)
			}))
		}, r.Parse = function(t, i, n) {
			var o = new r(t.name, i);
			if (o.id = t.id, e.Tags.AddTagsTo(o, t.tags), o.position = e.Vector3.FromArray(t.position), void 0 !== t.metadata && (o.metadata = t.metadata), t.rotationQuaternion ? o.rotationQuaternion = e.Quaternion.FromArray(t.rotationQuaternion) : t.rotation && (o.rotation = e.Vector3.FromArray(t.rotation)), o.scaling = e.Vector3.FromArray(t.scaling), t.localMatrix ? o.setPivotMatrix(e.Matrix.FromArray(t.localMatrix)) : t.pivotMatrix && o.setPivotMatrix(e.Matrix.FromArray(t.pivotMatrix)), o.setEnabled(t.isEnabled), o.isVisible = t.isVisible, o.infiniteDistance = t.infiniteDistance, o.showBoundingBox = t.showBoundingBox, o.showSubMeshesBoundingBox = t.showSubMeshesBoundingBox, void 0 !== t.applyFog && (o.applyFog = t.applyFog), void 0 !== t.pickable && (o.isPickable = t.pickable), void 0 !== t.alphaIndex && (o.alphaIndex = t.alphaIndex), o.receiveShadows = t.receiveShadows, o.billboardMode = t.billboardMode, void 0 !== t.visibility && (o.visibility = t.visibility), o.checkCollisions = t.checkCollisions, void 0 !== t.isBlocker && (o.isBlocker = t.isBlocker), o._shouldGenerateFlatShading = t.useFlatShading, t.freezeWorldMatrix && (o._waitingFreezeWorldMatrix = t.freezeWorldMatrix), t.parentId && (o._waitingParentId = t.parentId), void 0 !== t.actions && (o._waitingActions = t.actions), void 0 !== t.overlayAlpha && (o.overlayAlpha = t.overlayAlpha), void 0 !== t.overlayColor && (o.overlayColor = e.Color3.FromArray(t.overlayColor)), void 0 !== t.renderOverlay && (o.renderOverlay = t.renderOverlay), o.hasVertexAlpha = t.hasVertexAlpha, t.delayLoadingFile ? (o.delayLoadState = e.Engine.DELAYLOADSTATE_NOTLOADED, o.delayLoadingFile = n + t.delayLoadingFile, o._boundingInfo = new e.BoundingInfo(e.Vector3.FromArray(t.boundingBoxMinimum), e.Vector3.FromArray(t.boundingBoxMaximum)), t._binaryInfo && (o._binaryInfo = t._binaryInfo), o._delayInfo = [], t.hasUVs && o._delayInfo.push(e.VertexBuffer.UVKind), t.hasUVs2 && o._delayInfo.push(e.VertexBuffer.UV2Kind), t.hasUVs3 && o._delayInfo.push(e.VertexBuffer.UV3Kind), t.hasUVs4 && o._delayInfo.push(e.VertexBuffer.UV4Kind), t.hasUVs5 && o._delayInfo.push(e.VertexBuffer.UV5Kind), t.hasUVs6 && o._delayInfo.push(e.VertexBuffer.UV6Kind), t.hasColors && o._delayInfo.push(e.VertexBuffer.ColorKind), t.hasMatricesIndices && o._delayInfo.push(e.VertexBuffer.MatricesIndicesKind), t.hasMatricesWeights && o._delayInfo.push(e.VertexBuffer.MatricesWeightsKind), o._delayLoadingFunction = e.Geometry.ImportGeometry, e.SceneLoader.ForceFullSceneLoadingForIncremental && o._checkDelayState()) : e.Geometry.ImportGeometry(t, o), t.materialId ? o.setMaterialByID(t.materialId) : o.material = null, t.skeletonId > -1 && (o.skeleton = i.getLastSkeletonByID(t.skeletonId), t.numBoneInfluencers && (o.numBoneInfluencers = t.numBoneInfluencers)), t.animations) {
				for (var s = 0; s < t.animations.length; s++) {
					var a = t.animations[s];
					o.animations.push(e.Animation.Parse(a))
				}
				e.Node.ParseAnimationRanges(o, t, i)
			}
			if (t.autoAnimate && i.beginAnimation(o, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), t.layerMask && !isNaN(t.layerMask) ? o.layerMask = Math.abs(parseInt(t.layerMask)) : o.layerMask = 268435455, t.physicsImpostor && (o.physicsImpostor = new e.PhysicsImpostor(o, t.physicsImpostor, {
					mass: t.physicsMass,
					friction: t.physicsFriction,
					restitution: t.physicsRestitution
				}, i)), t.instances)
				for (var h = 0; h < t.instances.length; h++) {
					var c = t.instances[h],
						l = o.createInstance(c.name);
					if (e.Tags.AddTagsTo(l, c.tags), l.position = e.Vector3.FromArray(c.position), c.parentId && (l._waitingParentId = c.parentId), c.rotationQuaternion ? l.rotationQuaternion = e.Quaternion.FromArray(c.rotationQuaternion) : c.rotation && (l.rotation = e.Vector3.FromArray(c.rotation)), l.scaling = e.Vector3.FromArray(c.scaling), l.checkCollisions = o.checkCollisions, t.animations) {
						for (s = 0; s < t.animations.length; s++) a = t.animations[s], l.animations.push(e.Animation.Parse(a));
						e.Node.ParseAnimationRanges(l, t, i)
					}
				}
			return o
		}, r.CreateRibbon = function(t, i, r, n, o, s, a, h, c) {
			return e.MeshBuilder.CreateRibbon(t, {
				pathArray: i,
				closeArray: r,
				closePath: n,
				offset: o,
				updatable: a,
				sideOrientation: h,
				instance: c
			}, s)
		}, r.CreateDisc = function(t, i, r, n, o, s) {
			var a = {
				radius: i,
				tessellation: r,
				sideOrientation: s,
				updatable: o
			};
			return e.MeshBuilder.CreateDisc(t, a, n)
		}, r.CreateBox = function(t, i, r, n, o) {
			var s = {
				size: i,
				sideOrientation: o,
				updatable: n
			};
			return e.MeshBuilder.CreateBox(t, s, r)
		}, r.CreateSphere = function(t, i, r, n, o, s) {
			var a = {
				segments: i,
				diameterX: r,
				diameterY: r,
				diameterZ: r,
				sideOrientation: s,
				updatable: o
			};
			return e.MeshBuilder.CreateSphere(t, a, n)
		}, r.CreateCylinder = function(t, i, n, o, s, a, h, c, l) {
			void 0 !== h && h instanceof e.Scene || (void 0 !== h && (l = c || r.DEFAULTSIDE, c = h), h = a, a = 1);
			var u = {
				height: i,
				diameterTop: n,
				diameterBottom: o,
				tessellation: s,
				subdivisions: a,
				sideOrientation: l,
				updatable: c
			};
			return e.MeshBuilder.CreateCylinder(t, u, h)
		}, r.CreateTorus = function(t, i, r, n, o, s, a) {
			var h = {
				diameter: i,
				thickness: r,
				tessellation: n,
				sideOrientation: a,
				updatable: s
			};
			return e.MeshBuilder.CreateTorus(t, h, o)
		}, r.CreateTorusKnot = function(t, i, r, n, o, s, a, h, c, l) {
			var u = {
				radius: i,
				tube: r,
				radialSegments: n,
				tubularSegments: o,
				p: s,
				q: a,
				sideOrientation: l,
				updatable: c
			};
			return e.MeshBuilder.CreateTorusKnot(t, u, h)
		}, r.CreateLines = function(t, i, r, n, o) {
			var s = {
				points: i,
				updatable: n,
				instance: o
			};
			return e.MeshBuilder.CreateLines(t, s, r)
		}, r.CreateDashedLines = function(t, i, r, n, o, s, a, h) {
			var c = {
				points: i,
				dashSize: r,
				gapSize: n,
				dashNb: o,
				updatable: a,
				instance: h
			};
			return e.MeshBuilder.CreateDashedLines(t, c, s)
		}, r.ExtrudeShape = function(t, i, n, o, s, a, h, c, l, u) {
			var d = {
				shape: i,
				path: n,
				scale: o,
				rotation: s,
				cap: 0 === a ? 0 : a || r.NO_CAP,
				sideOrientation: l,
				instance: u,
				updatable: c
			};
			return e.MeshBuilder.ExtrudeShape(t, d, h)
		}, r.ExtrudeShapeCustom = function(t, i, n, o, s, a, h, c, l, u, d, f) {
			var p = {
				shape: i,
				path: n,
				scaleFunction: o,
				rotationFunction: s,
				ribbonCloseArray: a,
				ribbonClosePath: h,
				cap: 0 === c ? 0 : c || r.NO_CAP,
				sideOrientation: d,
				instance: f,
				updatable: u
			};
			return e.MeshBuilder.ExtrudeShapeCustom(t, p, l)
		}, r.CreateLathe = function(t, i, r, n, o, s, a) {
			var h = {
				shape: i,
				radius: r,
				tessellation: n,
				sideOrientation: a,
				updatable: s
			};
			return e.MeshBuilder.CreateLathe(t, h, o)
		}, r.CreatePlane = function(t, i, r, n, o) {
			var s = {
				size: i,
				width: i,
				height: i,
				sideOrientation: o,
				updatable: n
			};
			return e.MeshBuilder.CreatePlane(t, s, r)
		}, r.CreateGround = function(t, i, r, n, o, s) {
			var a = {
				width: i,
				height: r,
				subdivisions: n,
				updatable: s
			};
			return e.MeshBuilder.CreateGround(t, a, o)
		}, r.CreateTiledGround = function(t, i, r, n, o, s, a, h, c) {
			var l = {
				xmin: i,
				zmin: r,
				xmax: n,
				zmax: o,
				subdivisions: s,
				precision: a,
				updatable: c
			};
			return e.MeshBuilder.CreateTiledGround(t, l, h)
		}, r.CreateGroundFromHeightMap = function(t, i, r, n, o, s, a, h, c, l) {
			var u = {
				width: r,
				height: n,
				subdivisions: o,
				minHeight: s,
				maxHeight: a,
				updatable: c,
				onReady: l
			};
			return e.MeshBuilder.CreateGroundFromHeightMap(t, i, u, h)
		}, r.CreateTube = function(t, i, r, n, o, s, a, h, c, l) {
			var u = {
				path: i,
				radius: r,
				tessellation: n,
				radiusFunction: o,
				arc: 1,
				cap: s,
				updatable: h,
				sideOrientation: c,
				instance: l
			};
			return e.MeshBuilder.CreateTube(t, u, a)
		}, r.CreatePolyhedron = function(t, i, r) {
			return e.MeshBuilder.CreatePolyhedron(t, i, r)
		}, r.CreateIcoSphere = function(t, i, r) {
			return e.MeshBuilder.CreateIcoSphere(t, i, r)
		}, r.CreateDecal = function(t, i, r, n, o, s) {
			var a = {
				position: r,
				normal: n,
				size: o,
				angle: s
			};
			return e.MeshBuilder.CreateDecal(t, i, a)
		}, r.prototype.setPositionsForCPUSkinning = function() {
			var t;
			return this._sourcePositions || (t = this.getVerticesData(e.VertexBuffer.PositionKind), this._sourcePositions = new Float32Array(t), this.getVertexBuffer(e.VertexBuffer.PositionKind).isUpdatable() || this.setVerticesData(e.VertexBuffer.PositionKind, t, !0)), this._sourcePositions
		}, r.prototype.setNormalsForCPUSkinning = function() {
			var t;
			return this._sourceNormals || (t = this.getVerticesData(e.VertexBuffer.NormalKind), this._sourceNormals = new Float32Array(t), this.getVertexBuffer(e.VertexBuffer.NormalKind).isUpdatable() || this.setVerticesData(e.VertexBuffer.NormalKind, t, !0)), this._sourceNormals
		}, r.prototype.applySkeleton = function(t) {
			if (this.geometry && this.geometry._softwareSkinningRenderId != this.getScene().getRenderId()) {
				if (this.geometry._softwareSkinningRenderId = this.getScene().getRenderId(), !this.isVerticesDataPresent(e.VertexBuffer.PositionKind)) return this;
				if (!this.isVerticesDataPresent(e.VertexBuffer.NormalKind)) return this;
				if (!this.isVerticesDataPresent(e.VertexBuffer.MatricesIndicesKind)) return this;
				if (!this.isVerticesDataPresent(e.VertexBuffer.MatricesWeightsKind)) return this;
				if (!this._sourcePositions) {
					var i = this.subMeshes.slice();
					this.setPositionsForCPUSkinning(), this.subMeshes = i
				}
				this._sourceNormals || this.setNormalsForCPUSkinning();
				var r = this.getVerticesData(e.VertexBuffer.PositionKind);
				r instanceof Float32Array || (r = new Float32Array(r));
				var n = this.getVerticesData(e.VertexBuffer.NormalKind);
				n instanceof Float32Array || (n = new Float32Array(n));
				for (var o, s = this.getVerticesData(e.VertexBuffer.MatricesIndicesKind), a = this.getVerticesData(e.VertexBuffer.MatricesWeightsKind), h = this.numBoneInfluencers > 4, c = h ? this.getVerticesData(e.VertexBuffer.MatricesIndicesExtraKind) : null, l = h ? this.getVerticesData(e.VertexBuffer.MatricesWeightsExtraKind) : null, u = t.getTransformMatrices(this), d = e.Vector3.Zero(), f = new e.Matrix, p = new e.Matrix, m = 0, _ = 0; _ < r.length; _ += 3, m += 4) {
					var g;
					for (o = 0; o < 4 && (g = a[m + o], g > 0); o++) e.Matrix.FromFloat32ArrayToRefScaled(u, 16 * s[m + o], g, p), f.addToSelf(p);
					if (h)
						for (o = 0; o < 4 && (g = l[m + o], g > 0); o++) e.Matrix.FromFloat32ArrayToRefScaled(u, 16 * c[m + o], g, p), f.addToSelf(p);
					e.Vector3.TransformCoordinatesFromFloatsToRef(this._sourcePositions[_], this._sourcePositions[_ + 1], this._sourcePositions[_ + 2], f, d), d.toArray(r, _), e.Vector3.TransformNormalFromFloatsToRef(this._sourceNormals[_], this._sourceNormals[_ + 1], this._sourceNormals[_ + 2], f, d), d.toArray(n, _), f.reset()
				}
				return this.updateVerticesData(e.VertexBuffer.PositionKind, r), this.updateVerticesData(e.VertexBuffer.NormalKind, n), this
			}
		}, r.MinMax = function(e) {
			var t = null,
				i = null;
			return e.forEach((function(e, r, n) {
				var o = e.getBoundingInfo().boundingBox;
				t ? (t.MinimizeInPlace(o.minimumWorld), i.MaximizeInPlace(o.maximumWorld)) : (t = o.minimumWorld, i = o.maximumWorld)
			})), {
				min: t,
				max: i
			}
		}, r.Center = function(t) {
			var i = t instanceof Array ? e.Mesh.MinMax(t) : t;
			return e.Vector3.Center(i.min, i.max)
		}, r.MergeMeshes = function(t, i, n, o) {
			void 0 === i && (i = !0);
			var s;
			if (!n) {
				var a = 0;
				for (s = 0; s < t.length; s++)
					if (t[s] && (a += t[s].getTotalVertices(), a > 65536)) return e.Tools.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"), null
			}
			var h, c, l;
			for (s = 0; s < t.length; s++) t[s] && (t[s].computeWorldMatrix(!0), c = e.VertexData.ExtractFromMesh(t[s], !0), c.transform(t[s].getWorldMatrix()), h ? h.merge(c) : (h = c, l = t[s]));
			if (o || (o = new r(l.name + "_merged", l.getScene())), h.applyToMesh(o), o.material = l.material, o.checkCollisions = l.checkCollisions, i)
				for (s = 0; s < t.length; s++) t[s] && t[s].dispose();
			return o
		}, r._FRONTSIDE = 0, r._BACKSIDE = 1, r._DOUBLESIDE = 2, r._DEFAULTSIDE = 0, r._NO_CAP = 0, r._CAP_START = 1, r._CAP_END = 2, r._CAP_ALL = 3, r
	})(e.AbstractMesh);
	e.Mesh = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i, r, n, o, s, a) {
			void 0 === a && (a = !0), this.materialIndex = e, this.verticesStart = t, this.verticesCount = i, this.indexStart = r, this.indexCount = n, this._renderId = 0, this._mesh = o, this._renderingMesh = s || o, o.subMeshes.push(this), this._trianglePlanes = [], this._id = o.subMeshes.length - 1, a && (this.refreshBoundingInfo(), o.computeWorldMatrix(!0))
		}
		return Object.defineProperty(t.prototype, "IsGlobal", {
			get: function() {
				return 0 === this.verticesStart && this.verticesCount == this._mesh.getTotalVertices()
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getBoundingInfo = function() {
			return this.IsGlobal ? this._mesh.getBoundingInfo() : this._boundingInfo
		}, t.prototype.getMesh = function() {
			return this._mesh
		}, t.prototype.getRenderingMesh = function() {
			return this._renderingMesh
		}, t.prototype.getMaterial = function() {
			var t = this._renderingMesh.material;
			if (t && t instanceof e.MultiMaterial) {
				var i = t;
				return i.getSubMaterial(this.materialIndex)
			}
			return t ? t : this._mesh.getScene().defaultMaterial
		}, t.prototype.refreshBoundingInfo = function() {
			if (this._lastColliderWorldVertices = null, !this.IsGlobal) {
				var t = this._renderingMesh.getVerticesData(e.VertexBuffer.PositionKind);
				if (!t) return void(this._boundingInfo = this._mesh._boundingInfo);
				var i, r = this._renderingMesh.getIndices();
				i = 0 === this.indexStart && this.indexCount === r.length ? {
					minimum: this._renderingMesh.getBoundingInfo().minimum.clone(),
					maximum: this._renderingMesh.getBoundingInfo().maximum.clone()
				} : e.Tools.ExtractMinAndMaxIndexed(t, r, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias), this._boundingInfo = new e.BoundingInfo(i.minimum, i.maximum)
			}
		}, t.prototype._checkCollision = function(e) {
			return this.getBoundingInfo()._checkCollision(e)
		}, t.prototype.updateBoundingInfo = function(e) {
			this.getBoundingInfo() || this.refreshBoundingInfo(), this.getBoundingInfo().update(e)
		}, t.prototype.isInFrustum = function(e) {
			return this.getBoundingInfo().isInFrustum(e)
		}, t.prototype.isCompletelyInFrustum = function(e) {
			return this.getBoundingInfo().isCompletelyInFrustum(e)
		}, t.prototype.render = function(e) {
			this._renderingMesh.render(this, e)
		}, t.prototype.getLinesIndexBuffer = function(e, t) {
			if (!this._linesIndexBuffer) {
				for (var i = [], r = this.indexStart; r < this.indexStart + this.indexCount; r += 3) i.push(e[r], e[r + 1], e[r + 1], e[r + 2], e[r + 2], e[r]);
				this._linesIndexBuffer = t.createIndexBuffer(i), this.linesIndexCount = i.length
			}
			return this._linesIndexBuffer
		}, t.prototype.canIntersects = function(e) {
			return e.intersectsBox(this.getBoundingInfo().boundingBox)
		}, t.prototype.intersects = function(t, i, r, n) {
			var o = null;
			if (this._mesh instanceof e.LinesMesh)
				for (var s = this._mesh, a = this.indexStart; a < this.indexStart + this.indexCount; a += 2) {
					var h = i[r[a]],
						c = i[r[a + 1]],
						l = t.intersectionSegment(h, c, s.intersectionThreshold);
					if (!(l < 0) && (n || !o || l < o.distance) && (o = new e.IntersectionInfo(null, null, l), n)) break
				} else
					for (var a = this.indexStart; a < this.indexStart + this.indexCount; a += 3) {
						var h = i[r[a]],
							c = i[r[a + 1]],
							u = i[r[a + 2]],
							d = t.intersectsTriangle(h, c, u);
						if (d) {
							if (d.distance < 0) continue;
							if ((n || !o || d.distance < o.distance) && (o = d, o.faceId = a / 3, n)) break
						}
					}
			return o
		}, t.prototype.clone = function(i, r) {
			var n = new t(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, i, r, (!1));
			return this.IsGlobal || (n._boundingInfo = new e.BoundingInfo(this.getBoundingInfo().minimum, this.getBoundingInfo().maximum)), n
		}, t.prototype.dispose = function() {
			this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null);
			var e = this._mesh.subMeshes.indexOf(this);
			this._mesh.subMeshes.splice(e, 1)
		}, t.CreateFromIndices = function(e, i, r, n, o) {
			var s = Number.MAX_VALUE,
				a = -Number.MAX_VALUE;
			o = o || n;
			for (var h = o.getIndices(), c = i; c < i + r; c++) {
				var l = h[c];
				l < s && (s = l), l > a && (a = l)
			}
			return new t(e, s, a - s + 1, i, r, n, o)
		}, t
	})();
	e.SubMesh = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {}
		return t.updateSideOrientation = function(t, i) {
			return t == e.Mesh.DOUBLESIDE ? e.Mesh.DOUBLESIDE : void 0 === t || null === t ? e.Mesh.FRONTSIDE : t
		}, t.CreateBox = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateBox(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateSphere = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateSphere(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateDisc = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateDisc(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateIcoSphere = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateIcoSphere(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateRibbon = function(t, i, r) {
			var n = i.pathArray,
				o = i.closeArray,
				s = i.closePath,
				a = (i.offset, this.updateSideOrientation(i.sideOrientation, r)),
				h = i.instance,
				c = i.updatable;
			if (h) {
				e.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, e.Tmp.Vector3[0]), e.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, e.Tmp.Vector3[1]);
				var l = function(t) {
						for (var i = n[0].length, r = 0, o = h.sideOrientation === e.Mesh.DOUBLESIDE ? 2 : 1, s = 1; s <= o; s++)
							for (var a = 0; a < n.length; a++) {
								var c = n[a],
									l = c.length;
								i = i < l ? i : l;
								for (var u = 0; u < i;) t[r] = c[u].x, t[r + 1] = c[u].y, t[r + 2] = c[u].z, c[u].x < e.Tmp.Vector3[0].x && (e.Tmp.Vector3[0].x = c[u].x), c[u].x > e.Tmp.Vector3[1].x && (e.Tmp.Vector3[1].x = c[u].x), c[u].y < e.Tmp.Vector3[0].y && (e.Tmp.Vector3[0].y = c[u].y), c[u].y > e.Tmp.Vector3[1].y && (e.Tmp.Vector3[1].y = c[u].y), c[u].z < e.Tmp.Vector3[0].z && (e.Tmp.Vector3[0].z = c[u].z), c[u].z > e.Tmp.Vector3[1].z && (e.Tmp.Vector3[1].z = c[u].z), u++, r += 3;
								h._closePath && (t[r] = c[0].x, t[r + 1] = c[0].y, t[r + 2] = c[0].z, r += 3)
							}
					},
					u = h.getVerticesData(e.VertexBuffer.PositionKind);
				if (l(u), h._boundingInfo = new e.BoundingInfo(e.Tmp.Vector3[0], e.Tmp.Vector3[1]), h._boundingInfo.update(h._worldMatrix), h.updateVerticesData(e.VertexBuffer.PositionKind, u, !1, !1), !h.areNormalsFrozen) {
					var d = h.getIndices(),
						f = h.getVerticesData(e.VertexBuffer.NormalKind);
					if (e.VertexData.ComputeNormals(u, d, f), h._closePath)
						for (var p = 0, m = 0, _ = 0; _ < n.length; _++) p = 3 * h._idx[_], m = _ + 1 < n.length ? 3 * (h._idx[_ + 1] - 1) : f.length - 3, f[p] = .5 * (f[p] + f[m]), f[p + 1] = .5 * (f[p + 1] + f[m + 1]), f[p + 2] = .5 * (f[p + 2] + f[m + 2]), f[m] = f[p], f[m + 1] = f[p + 1], f[m + 2] = f[p + 2];
					h.updateVerticesData(e.VertexBuffer.NormalKind, f, !1, !1)
				}
				return h
			}
			var g = new e.Mesh(t, r);
			g.sideOrientation = a;
			var v = e.VertexData.CreateRibbon(i);
			return s && (g._idx = v._idx), g._closePath = s, g._closeArray = o, v.applyToMesh(g, c), g
		}, t.CreateCylinder = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateCylinder(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateTorus = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateTorus(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateTorusKnot = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreateTorusKnot(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateLineSystem = function(t, i, r) {
			var n = i.instance,
				o = i.lines;
			if (n) {
				var s = function(e) {
					for (var t = 0, i = 0; i < o.length; i++)
						for (var r = o[i], n = 0; n < r.length; n++) e[t] = r[n].x, e[t + 1] = r[n].y, e[t + 2] = r[n].z, t += 3
				};
				return n.updateMeshPositions(s, !1), n
			}
			var a = new e.LinesMesh(t, r),
				h = e.VertexData.CreateLineSystem(i);
			return h.applyToMesh(a, i.updatable), a
		}, t.CreateLines = function(e, i, r) {
			var n = t.CreateLineSystem(e, {
				lines: [i.points],
				updatable: i.updatable,
				instance: i.instance
			}, r);
			return n
		}, t.CreateDashedLines = function(t, i, r) {
			var n = i.points,
				o = i.instance,
				s = i.gapSize,
				a = (i.dashNb, i.dashSize);
			if (o) {
				var h = function(t) {
					var i = e.Vector3.Zero(),
						r = t.length / 6,
						s = 0,
						a = 0,
						h = 0,
						c = 0,
						l = 0,
						u = 0,
						d = 0,
						f = 0;
					for (d = 0; d < n.length - 1; d++) n[d + 1].subtractToRef(n[d], i), s += i.length();
					for (h = s / r, c = o.dashSize * h / (o.dashSize + o.gapSize), d = 0; d < n.length - 1; d++)
						for (n[d + 1].subtractToRef(n[d], i), a = Math.floor(i.length() / h), i.normalize(), f = 0; f < a && u < t.length;) l = h * f, t[u] = n[d].x + l * i.x, t[u + 1] = n[d].y + l * i.y, t[u + 2] = n[d].z + l * i.z, t[u + 3] = n[d].x + (l + c) * i.x, t[u + 4] = n[d].y + (l + c) * i.y, t[u + 5] = n[d].z + (l + c) * i.z, u += 6, f++;
					for (; u < t.length;) t[u] = n[d].x, t[u + 1] = n[d].y, t[u + 2] = n[d].z, u += 3
				};
				return o.updateMeshPositions(h, !1), o
			}
			var c = new e.LinesMesh(t, r),
				l = e.VertexData.CreateDashedLines(i);
			return l.applyToMesh(c, i.updatable), c.dashSize = a, c.gapSize = s, c
		}, t.ExtrudeShape = function(i, r, n) {
			var o = r.path,
				s = r.shape,
				a = r.scale || 1,
				h = r.rotation || 0,
				c = 0 === r.cap ? 0 : r.cap || e.Mesh.NO_CAP,
				l = r.updatable,
				u = this.updateSideOrientation(r.sideOrientation, n),
				d = r.instance,
				f = r.invertUV || !1;
			return t._ExtrudeShapeGeneric(i, s, o, a, h, null, null, !1, !1, c, !1, n, l, u, d, f)
		}, t.ExtrudeShapeCustom = function(i, r, n) {
			var o = r.path,
				s = r.shape,
				a = r.scaleFunction || function() {
					return 1
				},
				h = r.rotationFunction || function() {
					return 0
				},
				c = r.ribbonCloseArray || !1,
				l = r.ribbonClosePath || !1,
				u = 0 === r.cap ? 0 : r.cap || e.Mesh.NO_CAP,
				d = r.updatable,
				f = this.updateSideOrientation(r.sideOrientation, n),
				p = r.instance,
				m = r.invertUV || !1;
			return t._ExtrudeShapeGeneric(i, s, o, null, null, a, h, c, l, u, !0, n, d, f, p, m)
		}, t.CreateLathe = function(i, r, n) {
			var o, s = r.arc <= 0 || r.arc > 1 ? 1 : r.arc || 1,
				a = void 0 === r.closed || r.closed,
				h = r.shape,
				c = r.radius || 1,
				l = r.tessellation || 64,
				u = r.updatable,
				d = this.updateSideOrientation(r.sideOrientation, n),
				f = r.cap || e.Mesh.NO_CAP,
				p = 2 * Math.PI,
				m = new Array,
				_ = r.invertUV || !1,
				g = 0,
				v = 0,
				y = p / l * s,
				x = new Array;
			for (g = 0; g <= l; g++) {
				var x = [];
				for (f != e.Mesh.CAP_START && f != e.Mesh.CAP_ALL || (x.push(new e.Vector3(0, h[0].y, 0)), x.push(new e.Vector3(Math.cos(g * y) * h[0].x * c, h[0].y, Math.sin(g * y) * h[0].x * c))), v = 0; v < h.length; v++) o = new e.Vector3(Math.cos(g * y) * h[v].x * c, h[v].y, Math.sin(g * y) * h[v].x * c), x.push(o);
				f != e.Mesh.CAP_END && f != e.Mesh.CAP_ALL || (x.push(new e.Vector3(Math.cos(g * y) * h[h.length - 1].x * c, h[h.length - 1].y, Math.sin(g * y) * h[h.length - 1].x * c)), x.push(new e.Vector3(0, h[h.length - 1].y, 0))), m.push(x)
			}
			var b = t.CreateRibbon(i, {
				pathArray: m,
				closeArray: a,
				sideOrientation: d,
				updatable: u,
				invertUV: _
			}, n);
			return b
		}, t.CreatePlane = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreatePlane(i);
			if (o.applyToMesh(n, i.updatable), i.sourcePlane) {
				n.translate(i.sourcePlane.normal, i.sourcePlane.d);
				var s = Math.acos(e.Vector3.Dot(i.sourcePlane.normal, e.Axis.Z)),
					a = e.Vector3.Cross(e.Axis.Z, i.sourcePlane.normal);
				n.rotate(a, s)
			}
			return n
		}, t.CreateGround = function(t, i, r) {
			var n = new e.GroundMesh(t, r);
			n._setReady(!1), n._subdivisionsX = i.subdivisionsX || i.subdivisions || 1, n._subdivisionsY = i.subdivisionsY || i.subdivisions || 1, n._width = i.width || 1, n._height = i.height || 1, n._maxX = n._width / 2, n._maxZ = n._height / 2, n._minX = -n._maxX, n._minZ = -n._maxZ;
			var o = e.VertexData.CreateGround(i);
			return o.applyToMesh(n, i.updatable), n._setReady(!0), n
		}, t.CreateTiledGround = function(t, i, r) {
			var n = new e.Mesh(t, r),
				o = e.VertexData.CreateTiledGround(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateGroundFromHeightMap = function(t, i, r, n) {
			var o = r.width || 10,
				s = r.height || 10,
				a = r.subdivisions || 1,
				h = r.minHeight || 0,
				c = r.maxHeight || 10,
				l = r.updatable,
				u = r.onReady,
				d = new e.GroundMesh(t, n);
			d._subdivisionsX = a, d._subdivisionsY = a, d._width = o, d._height = s, d._maxX = d._width / 2, d._maxZ = d._height / 2, d._minX = -d._maxX, d._minZ = -d._maxZ, d._setReady(!1);
			var f = function(t) {
				var i = document.createElement("canvas"),
					r = i.getContext("2d"),
					n = t.width,
					f = t.height;
				i.width = n, i.height = f, r.drawImage(t, 0, 0);
				var p = r.getImageData(0, 0, n, f).data,
					m = e.VertexData.CreateGroundFromHeightMap({
						width: o,
						height: s,
						subdivisions: a,
						minHeight: h,
						maxHeight: c,
						buffer: p,
						bufferWidth: n,
						bufferHeight: f
					});
				m.applyToMesh(d, l), d._setReady(!0), u && u(d)
			};
			return e.Tools.LoadImage(i, f, (function() {}), n.database), d
		}, t.CreateTube = function(i, r, n) {
			var o = r.path,
				s = r.radius || 1,
				a = r.tessellation || 64,
				h = r.radiusFunction,
				c = r.cap || e.Mesh.NO_CAP,
				l = r.invertUV || !1,
				u = r.updatable,
				d = this.updateSideOrientation(r.sideOrientation, n),
				f = r.instance;
			r.arc = r.arc <= 0 || r.arc > 1 ? 1 : r.arc || 1;
			var p, m, _ = function(t, i, r, n, o, s, a, h) {
				for (var c, l, u, d, f = i.getTangents(), p = i.getNormals(), m = i.getDistances(), _ = 2 * Math.PI, g = _ / o * h, v = function() {
						return n
					}, y = s || v, x = e.Tmp.Matrix[0], b = a === e.Mesh._NO_CAP || a === e.Mesh.CAP_END ? 0 : 2, T = 0; T < t.length; T++) {
					l = y(T, m[T]), c = Array(), u = p[T];
					for (var A = 0; A < o; A++) e.Matrix.RotationAxisToRef(f[T], g * A, x), d = c[A] ? c[A] : e.Vector3.Zero(), e.Vector3.TransformCoordinatesToRef(u, x, d), d.scaleInPlace(l).addInPlace(t[T]), c[A] = d;
					r[b] = c, b++
				}
				var E = function(e, i) {
					for (var r = Array(), n = 0; n < e; n++) r.push(t[i]);
					return r
				};
				switch (a) {
					case e.Mesh.NO_CAP:
						break;
					case e.Mesh.CAP_START:
						r[0] = E(o, 0), r[1] = r[2].slice(0);
						break;
					case e.Mesh.CAP_END:
						r[b] = r[b - 1].slice(0), r[b + 1] = E(o, t.length - 1);
						break;
					case e.Mesh.CAP_ALL:
						r[0] = E(o, 0), r[1] = r[2].slice(0), r[b] = r[b - 1].slice(0), r[b + 1] = E(o, t.length - 1)
				}
				return r
			};
			if (f) {
				var g = r.arc || f.arc;
				return p = f.path3D.update(o), m = _(o, p, f.pathArray, s, f.tessellation, h, f.cap, g), f = t.CreateRibbon(null, {
					pathArray: m,
					instance: f
				}), f.path3D = p, f.pathArray = m, f.arc = g, f
			}
			p = new e.Path3D(o);
			var v = new Array;
			c = c < 0 || c > 3 ? 0 : c, m = _(o, p, v, s, a, h, c, r.arc);
			var y = t.CreateRibbon(i, {
				pathArray: m,
				closePath: !0,
				closeArray: !1,
				updatable: u,
				sideOrientation: d,
				invertUV: l
			}, n);
			return y.pathArray = m, y.path3D = p, y.tessellation = a, y.cap = c, y.arc = r.arc, y
		}, t.CreatePolyhedron = function(t, i, r) {
			var n = new e.Mesh(t, r);
			i.sideOrientation = this.updateSideOrientation(i.sideOrientation, r);
			var o = e.VertexData.CreatePolyhedron(i);
			return o.applyToMesh(n, i.updatable), n
		}, t.CreateDecal = function(t, i, r) {
			var n = i.getIndices(),
				o = i.getVerticesData(e.VertexBuffer.PositionKind),
				s = i.getVerticesData(e.VertexBuffer.NormalKind),
				a = r.position || e.Vector3.Zero(),
				h = r.normal || e.Vector3.Up(),
				c = r.size || new e.Vector3(1, 1, 1),
				l = r.angle || 0;
			if (!h) {
				var u = new e.Vector3(0, 0, 1),
					d = i.getScene().activeCamera,
					f = e.Vector3.TransformCoordinates(u, d.getWorldMatrix());
				h = d.globalPosition.subtract(f)
			}
			var p = -Math.atan2(h.z, h.x) - Math.PI / 2,
				m = Math.sqrt(h.x * h.x + h.z * h.z),
				_ = Math.atan2(h.y, m),
				g = e.Matrix.RotationYawPitchRoll(p, _, l).multiply(e.Matrix.Translation(a.x, a.y, a.z)),
				v = e.Matrix.Invert(g),
				y = i.getWorldMatrix(),
				x = y.multiply(v),
				b = new e.VertexData;
			b.indices = [], b.positions = [], b.normals = [], b.uvs = [];
			for (var T = 0, A = function(t) {
					var i = n[t],
						r = new e.PositionNormalVertex;
					return r.position = new e.Vector3(o[3 * i], o[3 * i + 1], o[3 * i + 2]), r.position = e.Vector3.TransformCoordinates(r.position, x), r.normal = new e.Vector3(s[3 * i], s[3 * i + 1], s[3 * i + 2]), r
				}, E = function(t, i) {
					if (0 === t.length) return t;
					for (var r = .5 * Math.abs(e.Vector3.Dot(c, i)), n = function(t, n) {
							var o = e.Vector3.GetClipFactor(t.position, n.position, i, r);
							return new e.PositionNormalVertex(e.Vector3.Lerp(t.position, n.position, o), e.Vector3.Lerp(t.normal, n.normal, o))
						}, o = new Array, s = 0; s < t.length; s += 3) {
						var a, h, l, u, d, f, p, m = 0,
							_ = e.Vector3.Dot(t[s].position, i) - r,
							g = e.Vector3.Dot(t[s + 1].position, i) - r,
							v = e.Vector3.Dot(t[s + 2].position, i) - r;
						switch (a = _ > 0, h = g > 0, l = v > 0, m = (a ? 1 : 0) + (h ? 1 : 0) + (l ? 1 : 0)) {
							case 0:
								o.push(t[s]), o.push(t[s + 1]), o.push(t[s + 2]);
								break;
							case 1:
								if (a && (u = t[s + 1], d = t[s + 2], f = n(t[s], u), p = n(t[s], d)), h) {
									u = t[s], d = t[s + 2], f = n(t[s + 1], u), p = n(t[s + 1], d), o.push(f), o.push(d.clone()), o.push(u.clone()), o.push(d.clone()), o.push(f.clone()), o.push(p);
									break
								}
								l && (u = t[s], d = t[s + 1], f = n(t[s + 2], u), p = n(t[s + 2], d)), o.push(u.clone()), o.push(d.clone()), o.push(f), o.push(p), o.push(f.clone()), o.push(d.clone());
								break;
							case 2:
								a || (u = t[s].clone(), d = n(u, t[s + 1]), f = n(u, t[s + 2]), o.push(u), o.push(d), o.push(f)), h || (u = t[s + 1].clone(), d = n(u, t[s + 2]), f = n(u, t[s]), o.push(u), o.push(d), o.push(f)), l || (u = t[s + 2].clone(), d = n(u, t[s]), f = n(u, t[s + 1]), o.push(u), o.push(d), o.push(f));
								break;
							case 3:
						}
					}
					return o
				}, P = 0; P < n.length; P += 3) {
				var M = new Array;
				if (M.push(A(P)), M.push(A(P + 1)), M.push(A(P + 2)), M = E(M, new e.Vector3(1, 0, 0)), M = E(M, new e.Vector3((-1), 0, 0)), M = E(M, new e.Vector3(0, 1, 0)), M = E(M, new e.Vector3(0, (-1), 0)), M = E(M, new e.Vector3(0, 0, 1)), M = E(M, new e.Vector3(0, 0, (-1))), 0 !== M.length)
					for (var S = 0; S < M.length; S++) {
						var C = M[S];
						b.indices.push(T), C.position.toArray(b.positions, 3 * T), C.normal.toArray(b.normals, 3 * T), b.uvs.push(.5 + C.position.x / c.x), b.uvs.push(.5 + C.position.y / c.y), T++
					}
			}
			var R = new e.Mesh(t, i.getScene());
			return b.applyToMesh(R), R.position = a.clone(), R.rotation = new e.Vector3(_, p, l), R
		}, t._ExtrudeShapeGeneric = function(i, r, n, o, s, a, h, c, l, u, d, f, p, m, _, g) {
			var v, y, x = function(t, i, r, n, o, s, a, h, c, l) {
				for (var u = r.getTangents(), d = r.getNormals(), f = r.getBinormals(), p = r.getDistances(), m = 0, _ = function() {
						return o
					}, g = function() {
						return s
					}, v = l ? h : g, y = l ? a : _, x = c === e.Mesh.NO_CAP || c === e.Mesh.CAP_END ? 0 : 2, b = e.Tmp.Matrix[0], T = 0; T < i.length; T++) {
					for (var A = new Array, E = v(T, p[T]), P = y(T, p[T]), M = 0; M < t.length; M++) {
						e.Matrix.RotationAxisToRef(u[T], m, b);
						var S = u[T].scale(t[M].z).add(d[T].scale(t[M].x)).add(f[T].scale(t[M].y)),
							C = A[M] ? A[M] : e.Vector3.Zero();
						e.Vector3.TransformCoordinatesToRef(S, b, C), C.scaleInPlace(P).addInPlace(i[T]), A[M] = C
					}
					n[x] = A, m += E, x++
				}
				var R = function(t) {
					var i, r = Array(),
						n = e.Vector3.Zero();
					for (i = 0; i < t.length; i++) n.addInPlace(t[i]);
					for (n.scaleInPlace(1 / t.length), i = 0; i < t.length; i++) r.push(n);
					return r
				};
				switch (c) {
					case e.Mesh.NO_CAP:
						break;
					case e.Mesh.CAP_START:
						n[0] = R(n[2]), n[1] = n[2].slice(0);
						break;
					case e.Mesh.CAP_END:
						n[x] = n[x - 1], n[x + 1] = R(n[x - 1]);
						break;
					case e.Mesh.CAP_ALL:
						n[0] = R(n[2]), n[1] = n[2].slice(0), n[x] = n[x - 1], n[x + 1] = R(n[x - 1])
				}
				return n
			};
			if (_) return v = _.path3D.update(n), y = x(r, n, _.path3D, _.pathArray, o, s, a, h, _.cap, d), _ = e.Mesh.CreateRibbon(null, y, null, null, null, f, null, null, _);
			v = new e.Path3D(n);
			var b = new Array;
			u = u < 0 || u > 3 ? 0 : u, y = x(r, n, v, b, o, s, a, h, u, d);
			var T = t.CreateRibbon(i, {
				pathArray: y,
				closeArray: c,
				closePath: l,
				updatable: p,
				sideOrientation: m,
				invertUV: g
			}, f);
			return T.pathArray = y, T.path3D = v, T.cap = u, T
		}, t
	})();
	e.MeshBuilder = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t) {
			this.hasAlpha = !1, this.getAlphaFromRGB = !1, this.level = 1, this.coordinatesIndex = 0, this.coordinatesMode = e.Texture.EXPLICIT_MODE, this.wrapU = e.Texture.WRAP_ADDRESSMODE, this.wrapV = e.Texture.WRAP_ADDRESSMODE, this.anisotropicFilteringLevel = 4, this.isCube = !1, this.isRenderTarget = !1, this.animations = new Array, this.onDisposeObservable = new e.Observable, this.delayLoadState = e.Engine.DELAYLOADSTATE_NONE, this._scene = t, this._scene.textures.push(this), this._uid = null
		}
		return Object.defineProperty(t.prototype, "uid", {
			get: function() {
				return this._uid || (this._uid = e.Tools.RandomId()), this._uid
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.toString = function() {
			return this.name
		}, Object.defineProperty(t.prototype, "onDispose", {
			set: function(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.getTextureMatrix = function() {
			return null
		}, t.prototype.getReflectionTextureMatrix = function() {
			return null
		}, t.prototype.getInternalTexture = function() {
			return this._texture
		}, t.prototype.isReady = function() {
			return this.delayLoadState === e.Engine.DELAYLOADSTATE_NOTLOADED || !!this._texture && this._texture.isReady
		}, t.prototype.getSize = function() {
			return this._texture._width ? new e.Size(this._texture._width, this._texture._height) : this._texture._size ? new e.Size(this._texture._size, this._texture._size) : e.Size.Zero()
		}, t.prototype.getBaseSize = function() {
			return this.isReady() && this._texture ? this._texture._size ? new e.Size(this._texture._size, this._texture._size) : new e.Size(this._texture._baseWidth, this._texture._baseHeight) : e.Size.Zero()
		}, t.prototype.scale = function(e) {}, Object.defineProperty(t.prototype, "canRescale", {
			get: function() {
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype._removeFromCache = function(e, t) {
			for (var i = this._scene.getEngine().getLoadedTexturesCache(), r = 0; r < i.length; r++) {
				var n = i[r];
				if (n.url === e && n.noMipmap === t) return void i.splice(r, 1)
			}
		}, t.prototype._getFromCache = function(e, t, i) {
			for (var r = this._scene.getEngine().getLoadedTexturesCache(), n = 0; n < r.length; n++) {
				var o = r[n];
				if (o.url === e && o.noMipmap === t && (!i || i === o.samplingMode)) return o.references++, o
			}
			return null
		}, t.prototype.delayLoad = function() {}, t.prototype.clone = function() {
			return null
		}, t.prototype.releaseInternalTexture = function() {
			this._texture && (this._scene.getEngine().releaseInternalTexture(this._texture), delete this._texture)
		}, t.prototype.dispose = function() {
			this.getScene().stopAnimation(this);
			var e = this._scene.textures.indexOf(this);
			e >= 0 && this._scene.textures.splice(e, 1), void 0 !== this._texture && (this.releaseInternalTexture(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear())
		}, t.prototype.serialize = function() {
			if (!this.name) return null;
			var t = e.SerializationHelper.Serialize(this);
			return e.Animation.AppendSerializedAnimations(this, t), t
		}, __decorate([e.serialize()], t.prototype, "name", void 0), __decorate([e.serialize()], t.prototype, "hasAlpha", void 0), __decorate([e.serialize()], t.prototype, "getAlphaFromRGB", void 0), __decorate([e.serialize()], t.prototype, "level", void 0), __decorate([e.serialize()], t.prototype, "coordinatesIndex", void 0), __decorate([e.serialize()], t.prototype, "coordinatesMode", void 0), __decorate([e.serialize()], t.prototype, "wrapU", void 0), __decorate([e.serialize()], t.prototype, "wrapV", void 0), __decorate([e.serialize()], t.prototype, "anisotropicFilteringLevel", void 0), __decorate([e.serialize()], t.prototype, "isCube", void 0), __decorate([e.serialize()], t.prototype, "isRenderTarget", void 0), t
	})();
	e.BaseTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(r, n, o, s, a, h, c, l, u) {
			var d = this;
			if (void 0 === o && (o = !1), void 0 === s && (s = !0), void 0 === a && (a = i.TRILINEAR_SAMPLINGMODE), void 0 === h && (h = null), void 0 === c && (c = null), void 0 === l && (l = null), void 0 === u && (u = !1), t.call(this, n), this.uOffset = 0, this.vOffset = 0, this.uScale = 1, this.vScale = 1, this.uAng = 0, this.vAng = 0, this.wAng = 0, this.name = r, this.url = r, this._noMipmap = o, this._invertY = s, this._samplingMode = a, this._buffer = l, this._deleteBuffer = u, r) {
				this._texture = this._getFromCache(r, o, a);
				var f = function() {
					d._onLoadObservarble && d._onLoadObservarble.hasObservers() && d.onLoadObservable.notifyObservers(!0), h && h()
				};
				this._texture ? this._texture.isReady ? e.Tools.SetImmediate((function() {
					return f()
				})) : this._texture.onLoadedCallbacks.push(f) : n.useDelayedTextureLoading ? (this.delayLoadState = e.Engine.DELAYLOADSTATE_NOTLOADED, this._delayedOnLoad = f, this._delayedOnError = c) : (this._texture = n.getEngine().createTexture(r, o, s, n, this._samplingMode, f, c, this._buffer), u && delete this._buffer)
			}
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "noMipmap", {
			get: function() {
				return this._noMipmap
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.delayLoad = function() {
			this.delayLoadState === e.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = e.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap, this._samplingMode), this._texture || (this._texture = this.getScene().getEngine().createTexture(this.url, this._noMipmap, this._invertY, this.getScene(), this._samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer), this._deleteBuffer && delete this._buffer))
		}, i.prototype.updateSamplingMode = function(e) {
			this._texture && (this._samplingMode = e, this.getScene().getEngine().updateTextureSamplingMode(e, this._texture))
		}, i.prototype._prepareRowForTextureGeneration = function(t, i, r, n) {
			t *= this.uScale, i *= this.vScale, t -= .5 * this.uScale, i -= .5 * this.vScale, r -= .5, e.Vector3.TransformCoordinatesFromFloatsToRef(t, i, r, this._rowGenerationMatrix, n), n.x += .5 * this.uScale + this.uOffset, n.y += .5 * this.vScale + this.vOffset, n.z += .5
		}, i.prototype.getTextureMatrix = function() {
			return this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng ? this._cachedTextureMatrix : (this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedTextureMatrix || (this._cachedTextureMatrix = e.Matrix.Zero(), this._rowGenerationMatrix = new e.Matrix, this._t0 = e.Vector3.Zero(), this._t1 = e.Vector3.Zero(), this._t2 = e.Vector3.Zero()), e.Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), e.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix.m[0] = this._t1.x, this._cachedTextureMatrix.m[1] = this._t1.y, this._cachedTextureMatrix.m[2] = this._t1.z, this._cachedTextureMatrix.m[4] = this._t2.x, this._cachedTextureMatrix.m[5] = this._t2.y, this._cachedTextureMatrix.m[6] = this._t2.z, this._cachedTextureMatrix.m[8] = this._t0.x, this._cachedTextureMatrix.m[9] = this._t0.y, this._cachedTextureMatrix.m[10] = this._t0.z, this._cachedTextureMatrix)
		}, i.prototype.getReflectionTextureMatrix = function() {
			if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) return this._cachedTextureMatrix;
			switch (this._cachedTextureMatrix || (this._cachedTextureMatrix = e.Matrix.Zero(), this._projectionModeMatrix = e.Matrix.Zero()), this._cachedCoordinatesMode = this.coordinatesMode, this.coordinatesMode) {
				case i.PLANAR_MODE:
					e.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix[0] = this.uScale, this._cachedTextureMatrix[5] = this.vScale, this._cachedTextureMatrix[12] = this.uOffset, this._cachedTextureMatrix[13] = this.vOffset;
					break;
				case i.PROJECTION_MODE:
					e.Matrix.IdentityToRef(this._projectionModeMatrix), this._projectionModeMatrix.m[0] = .5, this._projectionModeMatrix.m[5] = -.5, this._projectionModeMatrix.m[10] = 0, this._projectionModeMatrix.m[12] = .5, this._projectionModeMatrix.m[13] = .5, this._projectionModeMatrix.m[14] = 1, this._projectionModeMatrix.m[15] = 1, this.getScene().getProjectionMatrix().multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
					break;
				default:
					e.Matrix.IdentityToRef(this._cachedTextureMatrix)
			}
			return this._cachedTextureMatrix
		}, i.prototype.clone = function() {
			var t = this;
			return e.SerializationHelper.Clone((function() {
				return new i(t._texture.url, t.getScene(), t._noMipmap, t._invertY, t._samplingMode)
			}), this)
		}, Object.defineProperty(i.prototype, "onLoadObservable", {
			get: function() {
				return this._onLoadObservarble || (this._onLoadObservarble = new e.Observable), this._onLoadObservarble
			},
			enumerable: !0,
			configurable: !0
		}), i.CreateFromBase64String = function(e, t, r, n, o, s, a, h) {
			return void 0 === s && (s = i.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = null), void 0 === h && (h = null), new i("data:" + t, r, n, o, s, a, h, e)
		}, i.Parse = function(t, r, n) {
			if (t.customType) {
				var o = e.Tools.Instantiate(t.customType);
				return o.Parse(t, r, n)
			}
			if (t.isCube) return e.CubeTexture.Parse(t, r, n);
			if (!t.name && !t.isRenderTarget) return null;
			var s = e.SerializationHelper.Parse((function() {
				if (t.mirrorPlane) {
					var o = new e.MirrorTexture(t.name, t.renderTargetSize, r);
					return o._waitingRenderList = t.renderList, o.mirrorPlane = e.Plane.FromArray(t.mirrorPlane), o
				}
				if (t.isRenderTarget) {
					var s = new e.RenderTargetTexture(t.name, t.renderTargetSize, r);
					return s._waitingRenderList = t.renderList, s
				}
				var a;
				return a = t.base64String ? i.CreateFromBase64String(t.base64String, t.name, r) : new i(n + t.name, r)
			}), t, r);
			if (t.animations)
				for (var a = 0; a < t.animations.length; a++) {
					var h = t.animations[a];
					s.animations.push(e.Animation.Parse(h))
				}
			return s
		}, i.LoadFromDataString = function(e, t, r, n, o, s, a, h, c) {
			return void 0 === n && (n = !1), void 0 === o && (o = !1), void 0 === s && (s = !0), void 0 === a && (a = i.TRILINEAR_SAMPLINGMODE), void 0 === h && (h = null), void 0 === c && (c = null), "data:" !== e.substr(0, 5) && (e = "data:" + e), new i(e, r, o, s, a, h, c, t, n)
		}, i.NEAREST_SAMPLINGMODE = 1, i.BILINEAR_SAMPLINGMODE = 2, i.TRILINEAR_SAMPLINGMODE = 3, i.EXPLICIT_MODE = 0, i.SPHERICAL_MODE = 1, i.PLANAR_MODE = 2, i.CUBIC_MODE = 3, i.PROJECTION_MODE = 4, i.SKYBOX_MODE = 5, i.INVCUBIC_MODE = 6, i.EQUIRECTANGULAR_MODE = 7, i.FIXED_EQUIRECTANGULAR_MODE = 8, i.CLAMP_ADDRESSMODE = 0, i.WRAP_ADDRESSMODE = 1, i.MIRROR_ADDRESSMODE = 2, __decorate([e.serialize()], i.prototype, "url", void 0), __decorate([e.serialize()], i.prototype, "uOffset", void 0), __decorate([e.serialize()], i.prototype, "vOffset", void 0), __decorate([e.serialize()], i.prototype, "uScale", void 0), __decorate([e.serialize()], i.prototype, "vScale", void 0), __decorate([e.serialize()], i.prototype, "uAng", void 0), __decorate([e.serialize()], i.prototype, "vAng", void 0), __decorate([e.serialize()], i.prototype, "wAng", void 0), i
	})(e.BaseTexture);
	e.Texture = t;
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h) {
			if (void 0 === a && (a = null), void 0 === h && (h = null), t.call(this, r), this.coordinatesMode = e.Texture.CUBIC_MODE, this.name = i, this.url = i, this._noMipmap = o, this.hasAlpha = !1, i || s) {
				if (this._texture = this._getFromCache(i, o), !s) {
					n || (n = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"]), s = [];
					for (var c = 0; c < n.length; c++) s.push(i + n[c]);
					this._extensions = n
				}
				this._files = s, this._texture ? a && (this._texture.isReady ? e.Tools.SetImmediate((function() {
					return a()
				})) : this._texture.onLoadedCallbacks.push(a)) : r.useDelayedTextureLoading ? this.delayLoadState = e.Engine.DELAYLOADSTATE_NOTLOADED : this._texture = r.getEngine().createCubeTexture(i, r, s, o, a, h), this.isCube = !0, this._textureMatrix = e.Matrix.Identity()
			}
		}
		return __extends(i, t), i.CreateFromImages = function(e, t, r) {
			return new i("", t, null, r, e)
		}, i.prototype.delayLoad = function() {
			this.delayLoadState === e.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = e.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap), this._texture || (this._texture = this.getScene().getEngine().createCubeTexture(this.url, this.getScene(), this._files, this._noMipmap)))
		}, i.prototype.getReflectionTextureMatrix = function() {
			return this._textureMatrix
		}, i.Parse = function(t, i, r) {
			var n = e.SerializationHelper.Parse((function() {
				return new e.CubeTexture(r + t.name, i, t.extensions)
			}), t, i);
			if (t.animations)
				for (var o = 0; o < t.animations.length; o++) {
					var s = t.animations[o];
					n.animations.push(e.Animation.Parse(s))
				}
			return n
		}, i.prototype.clone = function() {
			var t = this;
			return e.SerializationHelper.Clone((function() {
				return new i(t.url, t.getScene(), t._extensions, t._noMipmap, t._files)
			}), this)
		}, i
	})(e.BaseTexture);
	e.CubeTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h, c, l, u) {
			void 0 === s && (s = !0), void 0 === a && (a = e.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === h && (h = !1), void 0 === c && (c = e.Texture.TRILINEAR_SAMPLINGMODE), void 0 === l && (l = !0), void 0 === u && (u = !1), t.call(this, null, n, !o), this.isCube = h, this.renderList = new Array, this.renderParticles = !0, this.renderSprites = !1, this.coordinatesMode = e.Texture.PROJECTION_MODE, this.onAfterUnbindObservable = new e.Observable, this.onBeforeRenderObservable = new e.Observable, this.onAfterRenderObservable = new e.Observable, this.onClearObservable = new e.Observable, this._currentRefreshId = -1, this._refreshRate = 1, this.name = i, this.isRenderTarget = !0, this._size = r, this._generateMipMaps = o, this._doNotChangeAspectRatio = s, c === e.Texture.NEAREST_SAMPLINGMODE && (this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE), h ? (this._texture = n.getEngine().createRenderTargetCubeTexture(r, {
				generateMipMaps: o,
				samplingMode: c,
				generateDepthBuffer: l,
				generateStencilBuffer: u
			}), this.coordinatesMode = e.Texture.INVCUBIC_MODE, this._textureMatrix = e.Matrix.Identity()) : this._texture = n.getEngine().createRenderTargetTexture(r, {
				generateMipMaps: o,
				type: a,
				samplingMode: c,
				generateDepthBuffer: l,
				generateStencilBuffer: u
			}), this._renderingManager = new e.RenderingManager(n)
		}
		return __extends(i, t), Object.defineProperty(i, "REFRESHRATE_RENDER_ONCE", {
			get: function() {
				return i._REFRESHRATE_RENDER_ONCE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "REFRESHRATE_RENDER_ONEVERYFRAME", {
			get: function() {
				return i._REFRESHRATE_RENDER_ONEVERYFRAME
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "REFRESHRATE_RENDER_ONEVERYTWOFRAMES", {
			get: function() {
				return i._REFRESHRATE_RENDER_ONEVERYTWOFRAMES
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onAfterUnbind", {
			set: function(e) {
				this._onAfterUnbindObserver && this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onBeforeRender", {
			set: function(e) {
				this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onAfterRender", {
			set: function(e) {
				this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "onClear", {
			set: function(e) {
				this._onClearObserver && this.onClearObservable.remove(this._onClearObserver), this._onClearObserver = this.onClearObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.resetRefreshCounter = function() {
			this._currentRefreshId = -1
		}, Object.defineProperty(i.prototype, "refreshRate", {
			get: function() {
				return this._refreshRate
			},
			set: function(e) {
				this._refreshRate = e, this.resetRefreshCounter()
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._shouldRender = function() {
			return this._currentRefreshId === -1 ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1)
		}, i.prototype.isReady = function() {
			return !!this.getScene().renderTargetsEnabled && t.prototype.isReady.call(this)
		}, i.prototype.getRenderSize = function() {
			return this._size
		}, Object.defineProperty(i.prototype, "canRescale", {
			get: function() {
				return !0
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.scale = function(e) {
			var t = this._size * e;
			this.resize(t, this._generateMipMaps)
		}, i.prototype.getReflectionTextureMatrix = function() {
			return this.isCube ? this._textureMatrix : t.prototype.getReflectionTextureMatrix.call(this)
		}, i.prototype.resize = function(e, t) {
			this.releaseInternalTexture(), this.isCube ? this._texture = this.getScene().getEngine().createRenderTargetCubeTexture(e) : this._texture = this.getScene().getEngine().createRenderTargetTexture(e, t)
		}, i.prototype.render = function(e, t) {
			var i = this.getScene();
			if (void 0 !== this.useCameraPostProcesses && (e = this.useCameraPostProcesses), this.activeCamera && this.activeCamera !== i.activeCamera && i.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(!0)), this._waitingRenderList) {
				this.renderList = [];
				for (var r = 0; r < this._waitingRenderList.length; r++) {
					var n = this._waitingRenderList[r];
					this.renderList.push(i.getMeshByID(n))
				}
				delete this._waitingRenderList
			}
			if (this.renderListPredicate) {
				this.renderList.splice(0);
				for (var o = this.getScene().meshes, r = 0; r < o.length; r++) {
					var s = o[r];
					this.renderListPredicate(s) && this.renderList.push(s)
				}
			}
			if (!this.renderList || 0 !== this.renderList.length) {
				this._renderingManager.reset();
				for (var a = this.renderList ? this.renderList : i.getActiveMeshes().data, h = this.renderList ? this.renderList.length : i.getActiveMeshes().length, c = i.getRenderId(), l = 0; l < h; l++) {
					var s = a[l];
					if (s) {
						if (!s.isReady()) {
							this.resetRefreshCounter();
							continue
						}
						if (s._preActivateForIntermediateRendering(c), s.isEnabled() && s.isVisible && s.subMeshes && 0 !== (s.layerMask & i.activeCamera.layerMask)) {
							s._activate(c);
							for (var u = 0; u < s.subMeshes.length; u++) {
								var d = s.subMeshes[u];
								i._activeIndices.addCount(d.indexCount, !1), this._renderingManager.dispatch(d)
							}
						}
					}
				}
				if (this.isCube)
					for (var f = 0; f < 6; f++) this.renderToTarget(f, a, h, e, t), i.incrementRenderId(), i.resetCachedMaterial();
				else this.renderToTarget(0, a, h, e, t);
				this.onAfterUnbindObservable.notifyObservers(this), this.activeCamera && this.activeCamera !== i.activeCamera && i.setTransformMatrix(i.activeCamera.getViewMatrix(), i.activeCamera.getProjectionMatrix(!0)), i.resetCachedMaterial()
			}
		}, i.prototype.renderToTarget = function(t, i, r, n, o) {
			var s = this.getScene(),
				a = s.getEngine();
			n && s.postProcessManager._prepareFrame(this._texture) || (this.isCube ? a.bindFramebuffer(this._texture, t) : a.bindFramebuffer(this._texture)), this.onBeforeRenderObservable.notifyObservers(t), this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(a) : a.clear(s.clearColor, !0, !0, !0), this._doNotChangeAspectRatio || s.updateTransformMatrix(!0), this._renderingManager.render(this.customRenderFunction, i, this.renderParticles, this.renderSprites), n && s.postProcessManager._finalizeFrame(!1, this._texture, t), this._doNotChangeAspectRatio || s.updateTransformMatrix(!0), this.onAfterRenderObservable.notifyObservers(t), o && e.Tools.DumpFramebuffer(this._size, this._size, a), this.isCube && 5 !== t || (this.isCube && 5 === t && a.generateMipMapsForCubemap(this._texture), a.unBindFramebuffer(this._texture, this.isCube))
		}, i.prototype.setRenderingOrder = function(e, t, i, r) {
			void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), this._renderingManager.setRenderingOrder(e, t, i, r)
		}, i.prototype.setRenderingAutoClearDepthStencil = function(e, t) {
			this._renderingManager.setRenderingAutoClearDepthStencil(e, t)
		}, i.prototype.clone = function() {
			var e = this.getSize(),
				t = new i(this.name, e.width, this.getScene(), this._generateMipMaps);
			return t.hasAlpha = this.hasAlpha, t.level = this.level, t.coordinatesMode = this.coordinatesMode, t.renderList = this.renderList.slice(0), t
		}, i.prototype.serialize = function() {
			if (!this.name) return null;
			var e = t.prototype.serialize.call(this);
			e.renderTargetSize = this.getRenderSize(), e.renderList = [];
			for (var i = 0; i < this.renderList.length; i++) e.renderList.push(this.renderList[i].id);
			return e
		}, i._REFRESHRATE_RENDER_ONCE = 0, i._REFRESHRATE_RENDER_ONEVERYFRAME = 1, i._REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2, i
	})(e.Texture);
	e.RenderTargetTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h) {
			void 0 === a && (a = !0), void 0 === h && (h = !1), t.call(this, null, o, !a), this.isCube = h, this.isEnabled = !0, this._currentRefreshId = -1, this._refreshRate = 1, this._vertexBuffers = {}, this._uniforms = new Array, this._samplers = new Array, this._textures = new Array, this._floats = new Array, this._floatsArrays = {}, this._colors3 = new Array, this._colors4 = new Array, this._vectors2 = new Array, this._vectors3 = new Array, this._matrices = new Array, this._fallbackTextureUsed = !1, o._proceduralTextures.push(this), this.name = i, this.isRenderTarget = !0, this._size = r, this._generateMipMaps = a, this.setFragment(n), this._fallbackTexture = s;
			var c = o.getEngine();
			h ? (this._texture = c.createRenderTargetCubeTexture(r, {
				generateMipMaps: a
			}), this.setFloat("face", 0)) : this._texture = c.createRenderTargetTexture(r, a);
			var l = [];
			l.push(1, 1), l.push(-1, 1), l.push(-1, -1), l.push(1, -1), this._vertexBuffers[e.VertexBuffer.PositionKind] = new e.VertexBuffer(c, l, e.VertexBuffer.PositionKind, (!1), (!1), 2);
			var u = [];
			u.push(0), u.push(1), u.push(2), u.push(0), u.push(2), u.push(3), this._indexBuffer = c.createIndexBuffer(u)
		}
		return __extends(i, t), i.prototype.reset = function() {
			if (void 0 !== this._effect) {
				var e = this.getScene().getEngine();
				e._releaseEffect(this._effect)
			}
		}, i.prototype.isReady = function() {
			var t, i = this,
				r = this.getScene().getEngine();
			return !!this._fragment && (!!this._fallbackTextureUsed || (t = void 0 !== this._fragment.fragmentElement ? {
				vertex: "procedural",
				fragmentElement: this._fragment.fragmentElement
			} : {
				vertex: "procedural",
				fragment: this._fragment
			}, this._effect = r.createEffect(t, [e.VertexBuffer.PositionKind], this._uniforms, this._samplers, "", null, null, (function() {
				i.releaseInternalTexture(), i._fallbackTexture && (i._texture = i._fallbackTexture._texture, i._texture.references++), i._fallbackTextureUsed = !0
			})), this._effect.isReady()))
		}, i.prototype.resetRefreshCounter = function() {
			this._currentRefreshId = -1
		}, i.prototype.setFragment = function(e) {
			this._fragment = e
		}, Object.defineProperty(i.prototype, "refreshRate", {
			get: function() {
				return this._refreshRate
			},
			set: function(e) {
				this._refreshRate = e, this.resetRefreshCounter()
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._shouldRender = function() {
			return !!(this.isEnabled && this.isReady() && this._texture) && (!this._fallbackTextureUsed && (this._currentRefreshId === -1 ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1)))
		}, i.prototype.getRenderSize = function() {
			return this._size
		}, i.prototype.resize = function(e, t) {
			this._fallbackTextureUsed || (this.releaseInternalTexture(), this._texture = this.getScene().getEngine().createRenderTargetTexture(e, t))
		}, i.prototype._checkUniform = function(e) {
			this._uniforms.indexOf(e) === -1 && this._uniforms.push(e)
		}, i.prototype.setTexture = function(e, t) {
			return this._samplers.indexOf(e) === -1 && this._samplers.push(e), this._textures[e] = t, this
		}, i.prototype.setFloat = function(e, t) {
			return this._checkUniform(e), this._floats[e] = t, this
		}, i.prototype.setFloats = function(e, t) {
			return this._checkUniform(e), this._floatsArrays[e] = t, this
		}, i.prototype.setColor3 = function(e, t) {
			return this._checkUniform(e), this._colors3[e] = t, this
		}, i.prototype.setColor4 = function(e, t) {
			return this._checkUniform(e), this._colors4[e] = t, this
		}, i.prototype.setVector2 = function(e, t) {
			return this._checkUniform(e), this._vectors2[e] = t, this
		}, i.prototype.setVector3 = function(e, t) {
			return this._checkUniform(e), this._vectors3[e] = t, this
		}, i.prototype.setMatrix = function(e, t) {
			return this._checkUniform(e), this._matrices[e] = t, this
		}, i.prototype.render = function(e) {
			var t = this.getScene(),
				i = t.getEngine();
			i.enableEffect(this._effect), i.setState(!1);
			for (var r in this._textures) this._effect.setTexture(r, this._textures[r]);
			for (r in this._floats) this._effect.setFloat(r, this._floats[r]);
			for (r in this._floatsArrays) this._effect.setArray(r, this._floatsArrays[r]);
			for (r in this._colors3) this._effect.setColor3(r, this._colors3[r]);
			for (r in this._colors4) {
				var n = this._colors4[r];
				this._effect.setFloat4(r, n.r, n.g, n.b, n.a)
			}
			for (r in this._vectors2) this._effect.setVector2(r, this._vectors2[r]);
			for (r in this._vectors3) this._effect.setVector3(r, this._vectors3[r]);
			for (r in this._matrices) this._effect.setMatrix(r, this._matrices[r]);
			if (i.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect), this.isCube)
				for (var o = 0; o < 6; o++) i.bindFramebuffer(this._texture, o), this._effect.setFloat("face", o), i.clear(t.clearColor, !0, !0, !0), i.draw(!0, 0, 6), 5 === o && i.generateMipMapsForCubemap(this._texture);
			else i.bindFramebuffer(this._texture), i.clear(t.clearColor, !0, !0, !0), i.draw(!0, 0, 6);
			i.unBindFramebuffer(this._texture, this.isCube), this.onGenerated && this.onGenerated()
		}, i.prototype.clone = function() {
			var e = this.getSize(),
				t = new i(this.name, e.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
			return t.hasAlpha = this.hasAlpha, t.level = this.level, t.coordinatesMode = this.coordinatesMode, t
		}, i.prototype.dispose = function() {
			var i = this.getScene()._proceduralTextures.indexOf(this);
			i >= 0 && this.getScene()._proceduralTextures.splice(i, 1);
			var r = this._vertexBuffers[e.VertexBuffer.PositionKind];
			r && (r.dispose(), this._vertexBuffers[e.VertexBuffer.PositionKind] = null), this._indexBuffer && this.getScene().getEngine()._releaseBuffer(this._indexBuffer) && (this._indexBuffer = null), t.prototype.dispose.call(this)
		}, i
	})(e.Texture);
	e.ProceduralTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o) {
			var s = this;
			t.call(this, i, r, n, o, !0), this.mirrorPlane = new e.Plane(0, 1, 0, 1), this._transformMatrix = e.Matrix.Zero(), this._mirrorMatrix = e.Matrix.Zero(), this.onBeforeRenderObservable.add((function() {
				e.Matrix.ReflectionToRef(s.mirrorPlane, s._mirrorMatrix), s._savedViewMatrix = n.getViewMatrix(), s._mirrorMatrix.multiplyToRef(s._savedViewMatrix, s._transformMatrix), n.setTransformMatrix(s._transformMatrix, n.getProjectionMatrix()), n.clipPlane = s.mirrorPlane, n.getEngine().cullBackFaces = !1, n._mirroredCameraPosition = e.Vector3.TransformCoordinates(n.activeCamera.position, s._mirrorMatrix)
			})), this.onAfterRenderObservable.add((function() {
				n.setTransformMatrix(s._savedViewMatrix, n.getProjectionMatrix()), n.getEngine().cullBackFaces = !0, n._mirroredCameraPosition = null, delete n.clipPlane
			}))
		}
		return __extends(i, t), i.prototype.clone = function() {
			var e = this.getSize(),
				t = new i(this.name, e.width, this.getScene(), this._generateMipMaps);
			return t.hasAlpha = this.hasAlpha, t.level = this.level, t.mirrorPlane = this.mirrorPlane.clone(), t.renderList = this.renderList.slice(0), t
		}, i.prototype.serialize = function() {
			if (!this.name) return null;
			var e = t.prototype.serialize.call(this);
			return e.mirrorPlane = this.mirrorPlane.asArray(), e
		}, i
	})(e.RenderTargetTexture);
	e.MirrorTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o) {
			var s = this;
			t.call(this, i, r, n, o, !0), this.refractionPlane = new e.Plane(0, 1, 0, 1), this.depth = 2, this.onBeforeRenderObservable.add((function() {
				n.clipPlane = s.refractionPlane
			})), this.onAfterRenderObservable.add((function() {
				delete n.clipPlane
			}))
		}
		return __extends(i, t), i.prototype.clone = function() {
			var e = this.getSize(),
				t = new i(this.name, e.width, this.getScene(), this._generateMipMaps);
			return t.hasAlpha = this.hasAlpha, t.level = this.level, t.refractionPlane = this.refractionPlane.clone(), t.renderList = this.renderList.slice(0), t.depth = this.depth, t
		}, i.prototype.serialize = function() {
			if (!this.name) return null;
			var e = t.prototype.serialize.call(this);
			return e.mirrorPlane = this.refractionPlane.asArray(), e.depth = this.depth, e
		}, i
	})(e.RenderTargetTexture);
	e.RefractionTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			void 0 === s && (s = e.Texture.TRILINEAR_SAMPLINGMODE), t.call(this, null, n, !o), this.name = i, this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._generateMipMaps = o, r.getContext ? (this._canvas = r, this._texture = n.getEngine().createDynamicTexture(r.width, r.height, o, s)) : (this._canvas = document.createElement("canvas"), r.width ? this._texture = n.getEngine().createDynamicTexture(r.width, r.height, o, s) : this._texture = n.getEngine().createDynamicTexture(r, r, o, s));
			var a = this.getSize();
			this._canvas.width = a.width, this._canvas.height = a.height, this._context = this._canvas.getContext("2d")
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "canRescale", {
			get: function() {
				return !0
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.scale = function(e) {
			var t = this.getSize();
			t.width *= e, t.height *= e, this._canvas.width = t.width, this._canvas.height = t.height, this.releaseInternalTexture(), this._texture = this.getScene().getEngine().createDynamicTexture(t.width, t.height, this._generateMipMaps, this._samplingMode)
		}, i.prototype.getContext = function() {
			return this._context
		}, i.prototype.clear = function() {
			var e = this.getSize();
			this._context.fillRect(0, 0, e.width, e.height)
		}, i.prototype.update = function(e) {
			this.getScene().getEngine().updateDynamicTexture(this._texture, this._canvas, void 0 === e || e)
		}, i.prototype.drawText = function(e, t, i, r, n, o, s, a) {
			void 0 === a && (a = !0);
			var h = this.getSize();
			if (o && (this._context.fillStyle = o, this._context.fillRect(0, 0, h.width, h.height)), this._context.font = r, null === t) {
				var c = this._context.measureText(e);
				t = (h.width - c.width) / 2
			}
			this._context.fillStyle = n, this._context.fillText(e, t, i), a && this.update(s)
		}, i.prototype.clone = function() {
			var e = this.getSize(),
				t = new i(this.name, e, this.getScene(), this._generateMipMaps);
			return t.hasAlpha = this.hasAlpha, t.level = this.level, t.wrapU = this.wrapU, t.wrapV = this.wrapV, t
		}, i
	})(e.Texture);
	e.DynamicTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a) {
			var h = this;
			void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === a && (a = e.Texture.TRILINEAR_SAMPLINGMODE), t.call(this, null, n, !o, s), this._autoLaunch = !0;
			var c;
			this.name = i, r instanceof HTMLVideoElement ? this.video = r : (c = r, this.video = document.createElement("video"), this.video.autoplay = !1, this.video.loop = !0), this._generateMipMaps = o, this._samplingMode = a, e.Tools.IsExponentOfTwo(this.video.videoWidth) && e.Tools.IsExponentOfTwo(this.video.videoHeight) ? (this.wrapU = e.Texture.WRAP_ADDRESSMODE, this.wrapV = e.Texture.WRAP_ADDRESSMODE) : (this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._generateMipMaps = !1), c ? (this.video.addEventListener("canplaythrough", (function() {
				h._createTexture()
			})), c.forEach((function(e) {
				var t = document.createElement("source");
				t.src = e, h.video.appendChild(t)
			}))) : this._createTexture(), this._lastUpdate = e.Tools.Now
		}
		return __extends(i, t), i.prototype._createTexture = function() {
			this._texture = this.getScene().getEngine().createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this._samplingMode), this._texture.isReady = !0
		}, i.prototype.update = function() {
			this._autoLaunch && (this._autoLaunch = !1, this.video.play());
			var t = e.Tools.Now;
			return !(t - this._lastUpdate < 15 || this.video.readyState !== this.video.HAVE_ENOUGH_DATA) && (this._lastUpdate = t, this.getScene().getEngine().updateVideoTexture(this._texture, this.video, this._invertY), !0)
		}, i
	})(e.Texture);
	e.VideoTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r, n, o, s) {
			t.call(this, e, r, null, n, o, s), this._animate = !0, this._time = 0, this._texturePath = i, this.loadJson(i), this.refreshRate = 1
		}
		return __extends(i, t), i.prototype.loadJson = function(t) {
			function i() {
				e.Tools.Log("No config file found in " + t + " trying to use ShadersStore or DOM element");
				try {
					n.setFragment(n._texturePath)
				} catch (i) {
					e.Tools.Error("No json or ShaderStore or DOM element found for CustomProceduralTexture")
				}
			}
			var r = this,
				n = this,
				o = t + "/config.json",
				s = new XMLHttpRequest;
			s.open("GET", o, !0), s.addEventListener("load", (function() {
				if (200 === s.status || e.Tools.ValidateXHRData(s, 1)) try {
					r._config = JSON.parse(s.response), r.updateShaderUniforms(), r.updateTextures(), r.setFragment(r._texturePath + "/custom"), r._animate = r._config.animate, r.refreshRate = r._config.refreshrate
				} catch (t) {
					i()
				} else i()
			}), !1), s.addEventListener("error", (function() {
				i()
			}), !1);
			try {
				s.send()
			} catch (a) {
				e.Tools.Error("CustomProceduralTexture: Error on XHR send request.")
			}
		}, i.prototype.isReady = function() {
			if (!t.prototype.isReady.call(this)) return !1;
			for (var e in this._textures) {
				var i = this._textures[e];
				if (!i.isReady()) return !1
			}
			return !0
		}, i.prototype.render = function(e) {
			this._animate && (this._time += .03 * this.getScene().getAnimationRatio(), this.updateShaderUniforms()), t.prototype.render.call(this, e)
		}, i.prototype.updateTextures = function() {
			for (var t = 0; t < this._config.sampler2Ds.length; t++) this.setTexture(this._config.sampler2Ds[t].sample2Dname, new e.Texture(this._texturePath + "/" + this._config.sampler2Ds[t].textureRelativeUrl, this.getScene()))
		}, i.prototype.updateShaderUniforms = function() {
			if (this._config)
				for (var t = 0; t < this._config.uniforms.length; t++) {
					var i = this._config.uniforms[t];
					switch (i.type) {
						case "float":
							this.setFloat(i.name, i.value);
							break;
						case "color3":
							this.setColor3(i.name, new e.Color3(i.r, i.g, i.b));
							break;
						case "color4":
							this.setColor4(i.name, new e.Color4(i.r, i.g, i.b, i.a));
							break;
						case "vector2":
							this.setVector2(i.name, new e.Vector2(i.x, i.y));
							break;
						case "vector3":
							this.setVector3(i.name, new e.Vector3(i.x, i.y, i.z))
					}
				}
			this.setFloat("time", this._time)
		}, Object.defineProperty(i.prototype, "animate", {
			get: function() {
				return this._animate
			},
			set: function(e) {
				this._animate = e
			},
			enumerable: !0,
			configurable: !0
		}), i
	})(e.ProceduralTexture);
	e.CustomProceduralTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this._defines = {}, this._currentRank = 32, this._maxRank = -1
		}
		return t.prototype.addFallback = function(e, t) {
			this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array), this._defines[e].push(t)
		}, t.prototype.addCPUSkinningFallback = function(e, t) {
			this._meshRank = e, this._mesh = t, e > this._maxRank && (this._maxRank = e)
		}, Object.defineProperty(t.prototype, "isMoreFallbacks", {
			get: function() {
				return this._currentRank <= this._maxRank
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.reduce = function(t) {
			for (var i = this._defines[this._currentRank], r = 0; r < i.length; r++) t = t.replace("#define " + i[r], "");
			return this._mesh && this._currentRank === this._meshRank && (this._mesh.computeBonesUsingShaders = !1, t = t.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"), e.Tools.Log("Falling back to CPU skinning for " + this._mesh.name)), this._currentRank++, t
		}, t
	})();
	e.EffectFallbacks = t;
	var i = (function() {
		function t(e, t, i, r, n, o, s, a, h, c) {
			var l = this;
			this._isReady = !1, this._compilationError = "", this._valueCache = {}, this._engine = n, this.name = e, this.defines = o, this._uniformsNames = i.concat(r), this._samplers = r, this._attributesNames = t, this.onError = h, this.onCompiled = a, this._indexParameters = c;
			var u, d;
			e.vertexElement ? (u = document.getElementById(e.vertexElement), u || (u = e.vertexElement)) : u = e.vertex || e, e.fragmentElement ? (d = document.getElementById(e.fragmentElement), d || (d = e.fragmentElement)) : d = e.fragment || e, this._loadVertexShader(u, (function(e) {
				l._processIncludes(e, (function(e) {
					l._loadFragmentShader(d, (function(i) {
						l._processIncludes(i, (function(i) {
							l._prepareEffect(e, i, t, o, s)
						}))
					}))
				}))
			}))
		}
		return t.prototype.isReady = function() {
			return this._isReady
		}, t.prototype.getProgram = function() {
			return this._program
		}, t.prototype.getAttributesNames = function() {
			return this._attributesNames
		}, t.prototype.getAttributeLocation = function(e) {
			return this._attributes[e]
		}, t.prototype.getAttributeLocationByName = function(e) {
			var t = this._attributesNames.indexOf(e);
			return this._attributes[t]
		}, t.prototype.getAttributesCount = function() {
			return this._attributes.length
		}, t.prototype.getUniformIndex = function(e) {
			return this._uniformsNames.indexOf(e)
		}, t.prototype.getUniform = function(e) {
			return this._uniforms[this._uniformsNames.indexOf(e)]
		}, t.prototype.getSamplers = function() {
			return this._samplers
		}, t.prototype.getCompilationError = function() {
			return this._compilationError
		}, t.prototype.getVertexShaderSource = function() {
			return this._engine.getVertexShaderSource(this._program)
		}, t.prototype.getFragmentShaderSource = function() {
			return this._engine.getFragmentShaderSource(this._program)
		}, t.prototype._loadVertexShader = function(i, r) {
			if (i instanceof HTMLElement) {
				var n = e.Tools.GetDOMTextContent(i);
				return void r(n)
			}
			if ("base64:" === i.substr(0, 7)) {
				var o = window.atob(i.substr(7));
				return void r(o)
			}
			if (t.ShadersStore[i + "VertexShader"]) return void r(t.ShadersStore[i + "VertexShader"]);
			var s;
			s = "." === i[0] || "/" === i[0] || i.indexOf("http") > -1 ? i : e.Engine.ShadersRepository + i, e.Tools.LoadFile(s + ".vertex.fx", r)
		}, t.prototype._loadFragmentShader = function(i, r) {
			if (i instanceof HTMLElement) {
				var n = e.Tools.GetDOMTextContent(i);
				return void r(n)
			}
			if ("base64:" === i.substr(0, 7)) {
				var o = window.atob(i.substr(7));
				return void r(o)
			}
			if (t.ShadersStore[i + "PixelShader"]) return void r(t.ShadersStore[i + "PixelShader"]);
			if (t.ShadersStore[i + "FragmentShader"]) return void r(t.ShadersStore[i + "FragmentShader"]);
			var s;
			s = "." === i[0] || "/" === i[0] || i.indexOf("http") > -1 ? i : e.Engine.ShadersRepository + i, e.Tools.LoadFile(s + ".fragment.fx", r)
		}, t.prototype._dumpShadersName = function() {
			this.name.vertexElement ? (e.Tools.Error("Vertex shader:" + this.name.vertexElement), e.Tools.Error("Fragment shader:" + this.name.fragmentElement)) : this.name.vertex ? (e.Tools.Error("Vertex shader:" + this.name.vertex), e.Tools.Error("Fragment shader:" + this.name.fragment)) : (e.Tools.Error("Vertex shader:" + this.name), e.Tools.Error("Fragment shader:" + this.name))
		}, t.prototype._processIncludes = function(i, r) {
			for (var n = this, o = /#include<(.+)>(\((.*)\))*(\[(.*)\])*/g, s = o.exec(i), a = new String(i); null != s;) {
				var h = s[1];
				if (!t.IncludesShadersStore[h]) {
					var c = e.Engine.ShadersRepository + "ShadersInclude/" + h + ".fx";
					return void e.Tools.LoadFile(c, (function(e) {
						t.IncludesShadersStore[h] = e, n._processIncludes(a, r)
					}))
				}
				var l = t.IncludesShadersStore[h];
				if (s[2])
					for (var u = s[3].split(","), d = 0; d < u.length; d += 2) {
						var f = new RegExp(u[d], "g"),
							p = u[d + 1];
						l = l.replace(f, p)
					}
				if (s[4]) {
					var m = s[5];
					if (m.indexOf("..") !== -1) {
						var _ = m.split(".."),
							g = parseInt(_[0]),
							v = parseInt(_[1]),
							y = l.slice(0);
						l = "", isNaN(v) && (v = this._indexParameters[_[1]]);
						for (var x = g; x <= v; x++) l += y.replace(/\{X\}/g, x) + "\n"
					} else l = l.replace(/\{X\}/g, m)
				}
				a = a.replace(s[0], l), s = o.exec(i)
			}
			r(a)
		}, t.prototype._processPrecision = function(e) {
			return e.indexOf("precision highp float") === -1 ? e = this._engine.getCaps().highPrecisionShaderSupported ? "precision highp float;\n" + e : "precision mediump float;\n" + e : this._engine.getCaps().highPrecisionShaderSupported || (e = e.replace("precision highp float", "precision mediump float")), e
		}, t.prototype._prepareEffect = function(t, i, r, n, o) {
			try {
				var s = this._engine;
				t = this._processPrecision(t), i = this._processPrecision(i), this._program = s.createShaderProgram(t, i, n), this._uniforms = s.getUniforms(this._program, this._uniformsNames), this._attributes = s.getAttributes(this._program, r);
				var a;
				for (a = 0; a < this._samplers.length; a++) {
					var h = this.getUniform(this._samplers[a]);
					null == h && (this._samplers.splice(a, 1), a--)
				}
				s.bindSamplers(this), this._compilationError = "", this._isReady = !0, this.onCompiled && this.onCompiled(this)
			} catch (c) {
				this._compilationError = c.message, e.Tools.Error("Unable to compile effect: "), e.Tools.Error("Defines: " + n), e.Tools.Error("Error: " + this._compilationError), this._dumpShadersName(), o && o.isMoreFallbacks ? (e.Tools.Error("Trying next fallback."), n = o.reduce(n), this._prepareEffect(t, i, r, n, o)) : this.onError && this.onError(this, this._compilationError)
			}
		}, Object.defineProperty(t.prototype, "isSupported", {
			get: function() {
				return "" === this._compilationError
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype._bindTexture = function(e, t) {
			this._engine._bindTexture(this._samplers.indexOf(e), t)
		}, t.prototype.setTexture = function(e, t) {
			this._engine.setTexture(this._samplers.indexOf(e), this.getUniform(e), t)
		}, t.prototype.setTextureArray = function(e, t) {
			if (this._samplers.indexOf(e + "Ex") === -1)
				for (var i = this._samplers.indexOf(e), r = 1; r < t.length; r++) this._samplers.splice(i + r, 0, e + "Ex");
			this._engine.setTextureArray(this._samplers.indexOf(e), this.getUniform(e), t)
		}, t.prototype.setTextureFromPostProcess = function(e, t) {
			this._engine.setTextureFromPostProcess(this._samplers.indexOf(e), t)
		}, t.prototype._cacheMatrix = function(t, i) {
			var r = !1,
				n = this._valueCache[t];
			n && n instanceof e.Matrix || (r = !0, n = new e.Matrix);
			for (var o = n.m, s = i.m, a = 0; a < 16; a++) o[a] !== s[a] && (o[a] = s[a], r = !0);
			return this._valueCache[t] = n, r
		}, t.prototype._cacheFloat2 = function(e, t, i) {
			var r = this._valueCache[e];
			if (!r) return r = [t, i], this._valueCache[e] = r, !0;
			var n = !1;
			return r[0] !== t && (r[0] = t, n = !0), r[1] !== i && (r[1] = i, n = !0), n
		}, t.prototype._cacheFloat3 = function(e, t, i, r) {
			var n = this._valueCache[e];
			if (!n) return n = [t, i, r], this._valueCache[e] = n, !0;
			var o = !1;
			return n[0] !== t && (n[0] = t, o = !0), n[1] !== i && (n[1] = i, o = !0), n[2] !== r && (n[2] = r, o = !0), o
		}, t.prototype._cacheFloat4 = function(e, t, i, r, n) {
			var o = this._valueCache[e];
			if (!o) return o = [t, i, r, n], this._valueCache[e] = o, !0;
			var s = !1;
			return o[0] !== t && (o[0] = t, s = !0), o[1] !== i && (o[1] = i, s = !0), o[2] !== r && (o[2] = r, s = !0), o[3] !== n && (o[3] = n, s = !0), s
		}, t.prototype.setIntArray = function(e, t) {
			return this._valueCache[e] = null, this._engine.setIntArray(this.getUniform(e), t), this
		}, t.prototype.setIntArray2 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setIntArray2(this.getUniform(e), t), this
		}, t.prototype.setIntArray3 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setIntArray3(this.getUniform(e), t), this
		}, t.prototype.setIntArray4 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setIntArray4(this.getUniform(e), t), this
		}, t.prototype.setFloatArray = function(e, t) {
			return this._valueCache[e] = null, this._engine.setFloatArray(this.getUniform(e), t), this
		}, t.prototype.setFloatArray2 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setFloatArray2(this.getUniform(e), t), this
		}, t.prototype.setFloatArray3 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setFloatArray3(this.getUniform(e), t), this
		}, t.prototype.setFloatArray4 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setFloatArray4(this.getUniform(e), t), this
		}, t.prototype.setArray = function(e, t) {
			return this._valueCache[e] = null, this._engine.setArray(this.getUniform(e), t), this
		}, t.prototype.setArray2 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setArray2(this.getUniform(e), t), this
		}, t.prototype.setArray3 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setArray3(this.getUniform(e), t), this
		}, t.prototype.setArray4 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setArray4(this.getUniform(e), t), this
		}, t.prototype.setMatrices = function(e, t) {
			return this._valueCache[e] = null, this._engine.setMatrices(this.getUniform(e), t), this
		}, t.prototype.setMatrix = function(e, t) {
			return this._cacheMatrix(e, t) && this._engine.setMatrix(this.getUniform(e), t), this
		}, t.prototype.setMatrix3x3 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setMatrix3x3(this.getUniform(e), t), this
		}, t.prototype.setMatrix2x2 = function(e, t) {
			return this._valueCache[e] = null, this._engine.setMatrix2x2(this.getUniform(e), t), this
		}, t.prototype.setFloat = function(e, t) {
			var i = this._valueCache[e];
			return void 0 !== i && i === t ? this : (this._valueCache[e] = t, this._engine.setFloat(this.getUniform(e), t), this)
		}, t.prototype.setBool = function(e, t) {
			var i = this._valueCache[e];
			return void 0 !== i && i === t ? this : (this._valueCache[e] = t, this._engine.setBool(this.getUniform(e), t ? 1 : 0),
				this)
		}, t.prototype.setVector2 = function(e, t) {
			return this._cacheFloat2(e, t.x, t.y) && this._engine.setFloat2(this.getUniform(e), t.x, t.y), this
		}, t.prototype.setFloat2 = function(e, t, i) {
			return this._cacheFloat2(e, t, i) && this._engine.setFloat2(this.getUniform(e), t, i), this
		}, t.prototype.setVector3 = function(e, t) {
			return this._cacheFloat3(e, t.x, t.y, t.z) && this._engine.setFloat3(this.getUniform(e), t.x, t.y, t.z), this
		}, t.prototype.setFloat3 = function(e, t, i, r) {
			return this._cacheFloat3(e, t, i, r) && this._engine.setFloat3(this.getUniform(e), t, i, r), this
		}, t.prototype.setVector4 = function(e, t) {
			return this._cacheFloat4(e, t.x, t.y, t.z, t.w) && this._engine.setFloat4(this.getUniform(e), t.x, t.y, t.z, t.w), this
		}, t.prototype.setFloat4 = function(e, t, i, r, n) {
			return this._cacheFloat4(e, t, i, r, n) && this._engine.setFloat4(this.getUniform(e), t, i, r, n), this
		}, t.prototype.setColor3 = function(e, t) {
			return this._cacheFloat3(e, t.r, t.g, t.b) && this._engine.setColor3(this.getUniform(e), t), this
		}, t.prototype.setColor4 = function(e, t, i) {
			return this._cacheFloat4(e, t.r, t.g, t.b, i) && this._engine.setColor4(this.getUniform(e), t, i), this
		}, t.ShadersStore = {}, t.IncludesShadersStore = {}, t
	})();
	e.Effect = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {}
		return t.PrepareDefinesForLights = function(t, i, r, n) {
			void 0 === n && (n = 4);
			for (var o = 0, s = !1, a = !1, h = !1, c = !1, l = 0; l < t.lights.length; l++) {
				var u = t.lights[l];
				if (u.isEnabled()) {
					if (u._excludedMeshesIds.length > 0) {
						for (var d = 0; d < u._excludedMeshesIds.length; d++) {
							var f = t.getMeshByID(u._excludedMeshesIds[d]);
							f && u.excludedMeshes.push(f)
						}
						u._excludedMeshesIds = []
					}
					if (u._includedOnlyMeshesIds.length > 0) {
						for (var p = 0; p < u._includedOnlyMeshesIds.length; p++) {
							var m = t.getMeshByID(u._includedOnlyMeshesIds[p]);
							m && u.includedOnlyMeshes.push(m)
						}
						u._includedOnlyMeshesIds = []
					}
					if (u.canAffectMesh(i)) {
						s = !0, void 0 === r["LIGHT" + o] && (a = !0), r["LIGHT" + o] = !0;
						var _;
						if (_ = u instanceof e.SpotLight ? "SPOTLIGHT" + o : u instanceof e.HemisphericLight ? "HEMILIGHT" + o : u instanceof e.PointLight ? "POINTLIGHT" + o : "DIRLIGHT" + o, void 0 === r[_] && (a = !0), r[_] = !0, u.specular.equalsFloats(0, 0, 0) || void 0 === r.SPECULARTERM || (r.SPECULARTERM = !0), t.shadowsEnabled) {
							var g = u.getShadowGenerator();
							i && i.receiveShadows && g && (void 0 === r["SHADOW" + o] && (a = !0), r["SHADOW" + o] = !0, r.SHADOWS = !0, (g.useVarianceShadowMap || g.useBlurVarianceShadowMap) && (void 0 === r["SHADOWVSM" + o] && (a = !0), r["SHADOWVSM" + o] = !0), g.usePoissonSampling && (void 0 === r["SHADOWPCF" + o] && (a = !0), r["SHADOWPCF" + o] = !0), h = !0)
						}
						if (u.lightmapMode != e.Light.LIGHTMAP_DEFAULT && (c = !0, void 0 === r["LIGHTMAPEXCLUDED" + o] && (a = !0), void 0 === r["LIGHTMAPNOSPECULAR" + o] && (a = !0), r["LIGHTMAPEXCLUDED" + o] = !0, u.lightmapMode == e.Light.LIGHTMAP_SHADOWSONLY && (r["LIGHTMAPNOSPECULAR" + o] = !0)), o++, o === n) break
					}
				}
			}
			var v = t.getEngine().getCaps();
			return h && v.textureFloat && v.textureFloatLinearFiltering && v.textureFloatRender && (void 0 === r.SHADOWFULLFLOAT && (a = !0), r.SHADOWFULLFLOAT = !0), void 0 === r.LIGHTMAPEXCLUDED && (a = !0), c && (r.LIGHTMAPEXCLUDED = !0), a && r.rebuild(), s
		}, t.PrepareUniformsAndSamplersList = function(e, t, i, r) {
			void 0 === r && (r = 4);
			for (var n = 0; n < r && i["LIGHT" + n]; n++) e.push("vLightData" + n, "vLightDiffuse" + n, "vLightSpecular" + n, "vLightDirection" + n, "vLightGround" + n, "lightMatrix" + n, "shadowsInfo" + n), t.push("shadowSampler" + n)
		}, t.HandleFallbacksForShadows = function(e, t, i) {
			void 0 === i && (i = 4);
			for (var r = 0; r < i && e["LIGHT" + r]; r++) r > 0 && t.addFallback(r, "LIGHT" + r), e["SHADOW" + r] && t.addFallback(0, "SHADOW" + r), e["SHADOWPCF" + r] && t.addFallback(0, "SHADOWPCF" + r), e["SHADOWVSM" + r] && t.addFallback(0, "SHADOWVSM" + r)
		}, t.PrepareAttributesForBones = function(t, i, r, n) {
			r.NUM_BONE_INFLUENCERS > 0 && (n.addCPUSkinningFallback(0, i), t.push(e.VertexBuffer.MatricesIndicesKind), t.push(e.VertexBuffer.MatricesWeightsKind), r.NUM_BONE_INFLUENCERS > 4 && (t.push(e.VertexBuffer.MatricesIndicesExtraKind), t.push(e.VertexBuffer.MatricesWeightsExtraKind)))
		}, t.PrepareAttributesForInstances = function(e, t) {
			t.INSTANCES && (e.push("world0"), e.push("world1"), e.push("world2"), e.push("world3"))
		}, t.BindLightShadow = function(e, t, i, r, n, o) {
			var s = e.getShadowGenerator();
			return i.receiveShadows && s && (e.needCube() ? o || (o = !0, n.setFloat2("depthValues", t.activeCamera.minZ, t.activeCamera.maxZ)) : n.setMatrix("lightMatrix" + r, s.getTransformMatrix()), n.setTexture("shadowSampler" + r, s.getShadowMapForRendering()), n.setFloat3("shadowsInfo" + r, s.getDarkness(), s.blurScale / s.getShadowMap().getSize().width, s.bias)), o
		}, t.BindLightProperties = function(t, i, r) {
			t instanceof e.PointLight ? t.transferToEffect(i, "vLightData" + r) : t instanceof e.DirectionalLight ? t.transferToEffect(i, "vLightData" + r) : t instanceof e.SpotLight ? t.transferToEffect(i, "vLightData" + r, "vLightDirection" + r) : t instanceof e.HemisphericLight && t.transferToEffect(i, "vLightData" + r, "vLightGround" + r)
		}, t.BindLights = function(i, r, n, o, s) {
			void 0 === s && (s = 4);
			for (var a = 0, h = !1, c = 0; c < i.lights.length; c++) {
				var l = i.lights[c];
				if (l.isEnabled() && l.canAffectMesh(r) && (t.BindLightProperties(l, n, a), l.diffuse.scaleToRef(l.intensity, e.Tmp.Color3[0]), n.setColor4("vLightDiffuse" + a, e.Tmp.Color3[0], l.range), o.SPECULARTERM && (l.specular.scaleToRef(l.intensity, e.Tmp.Color3[1]), n.setColor3("vLightSpecular" + a, e.Tmp.Color3[1])), i.shadowsEnabled && (h = this.BindLightShadow(l, i, r, a, n, h)), a++, a === s)) break
			}
		}, t.BindFogParameters = function(t, i, r) {
			t.fogEnabled && i.applyFog && t.fogMode !== e.Scene.FOGMODE_NONE && (r.setFloat4("vFogInfos", t.fogMode, t.fogStart, t.fogEnd, t.fogDensity), r.setColor3("vFogColor", t.fogColor))
		}, t.BindBonesParameters = function(e, t) {
			if (e && e.useBones && e.computeBonesUsingShaders) {
				var i = e.skeleton.getTransformMatrices(e);
				i && t.setMatrices("mBones", i)
			}
		}, t.BindLogDepth = function(e, t, i) {
			e.LOGARITHMICDEPTH && t.setFloat("logarithmicDepthConstant", 2 / (Math.log(i.activeCamera.maxZ + 1) / Math.LN2))
		}, t.BindClipPlane = function(e, t) {
			if (t.clipPlane) {
				var i = t.clipPlane;
				e.setFloat4("vClipPlane", i.normal.x, i.normal.y, i.normal.z, i.d)
			}
		}, t
	})();
	e.MaterialHelper = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this.isEnabled = !0, this.leftColor = e.Color3.White(), this.rightColor = e.Color3.Black(), this.bias = 0, this.power = 1
		}
		return t.prototype.clone = function() {
			var i = new t;
			return e.Tools.DeepCopy(this, i), i
		}, t.prototype.serialize = function() {
			var e = {};
			return e.isEnabled = this.isEnabled, e.leftColor = this.leftColor, e.rightColor = this.rightColor, e.bias = this.bias, e.power = this.power, e
		}, t.Parse = function(i) {
			var r = new t;
			return r.isEnabled = i.isEnabled, r.leftColor = e.Color3.FromArray(i.leftColor), r.rightColor = e.Color3.FromArray(i.rightColor), r.bias = i.bias, r.power = i.power || 1, r
		}, t
	})();
	e.FresnelParameters = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {}
		return e.prototype.rebuild = function() {
			this._keys && delete this._keys, this._keys = Object.keys(this)
		}, e.prototype.isEqual = function(e) {
			if (this._keys.length !== e._keys.length) return !1;
			for (var t = 0; t < this._keys.length; t++) {
				var i = this._keys[t];
				if (this[i] !== e[i]) return !1
			}
			return !0
		}, e.prototype.cloneTo = function(e) {
			this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));
			for (var t = 0; t < this._keys.length; t++) {
				var i = this._keys[t];
				e[i] = this[i]
			}
		}, e.prototype.reset = function() {
			for (var e = 0; e < this._keys.length; e++) {
				var t = this._keys[e];
				"number" == typeof this[t] ? this[t] = 0 : this[t] = !1
			}
		}, e.prototype.toString = function() {
			for (var e = "", t = 0; t < this._keys.length; t++) {
				var i = this._keys[t];
				"number" == typeof this[i] ? e += "#define " + i + " " + this[i] + "\n" : this[i] && (e += "#define " + i + "\n")
			}
			return e
		}, e
	})();
	e.MaterialDefines = t;
	var i = (function() {
		function t(i, r, n) {
			this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = "", this.alpha = 1, this.backFaceCulling = !0, this.doNotSerialize = !1, this.onDisposeObservable = new e.Observable, this.onBindObservable = new e.Observable, this.onUnBindObservable = new e.Observable, this.alphaMode = e.Engine.ALPHA_COMBINE, this.disableDepthWrite = !1, this.fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this._wasPreviouslyReady = !1, this._fillMode = t.TriangleFillMode, this.name = i, this.id = i, this._scene = r, r.useRightHandedSystem ? this.sideOrientation = t.ClockWiseSideOrientation : this.sideOrientation = t.CounterClockWiseSideOrientation, n || r.materials.push(this)
		}
		return Object.defineProperty(t, "TriangleFillMode", {
			get: function() {
				return t._TriangleFillMode
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "WireFrameFillMode", {
			get: function() {
				return t._WireFrameFillMode
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "PointFillMode", {
			get: function() {
				return t._PointFillMode
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "ClockWiseSideOrientation", {
			get: function() {
				return t._ClockWiseSideOrientation
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "CounterClockWiseSideOrientation", {
			get: function() {
				return t._CounterClockWiseSideOrientation
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onDispose", {
			set: function(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onBind", {
			set: function(e) {
				this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "wireframe", {
			get: function() {
				return this._fillMode === t.WireFrameFillMode
			},
			set: function(e) {
				this._fillMode = e ? t.WireFrameFillMode : t.TriangleFillMode
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "pointsCloud", {
			get: function() {
				return this._fillMode === t.PointFillMode
			},
			set: function(e) {
				this._fillMode = e ? t.PointFillMode : t.TriangleFillMode
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "fillMode", {
			get: function() {
				return this._fillMode
			},
			set: function(e) {
				this._fillMode = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.toString = function(e) {
			var t = "Name: " + this.name;
			return t
		}, Object.defineProperty(t.prototype, "isFrozen", {
			get: function() {
				return this.checkReadyOnlyOnce
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.freeze = function() {
			this.checkReadyOnlyOnce = !0
		}, t.prototype.unfreeze = function() {
			this.checkReadyOnlyOnce = !1
		}, t.prototype.isReady = function(e, t) {
			return !0
		}, t.prototype.getEffect = function() {
			return this._effect
		}, t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.needAlphaBlending = function() {
			return this.alpha < 1
		}, t.prototype.needAlphaTesting = function() {
			return !1
		}, t.prototype.getAlphaTestTexture = function() {
			return null
		}, t.prototype.markDirty = function() {
			this._wasPreviouslyReady = !1
		}, t.prototype._preBind = function() {
			var e = this._scene.getEngine(),
				i = this.sideOrientation === t.ClockWiseSideOrientation;
			e.enableEffect(this._effect), e.setState(this.backFaceCulling, this.zOffset, !1, i)
		}, t.prototype.bind = function(e, t) {
			if (this._scene._cachedMaterial = this, this.onBindObservable.notifyObservers(t), this.disableDepthWrite) {
				var i = this._scene.getEngine();
				this._cachedDepthWriteState = i.getDepthWrite(), i.setDepthWrite(!1)
			}
		}, t.prototype.bindOnlyWorldMatrix = function(e) {}, t.prototype.unbind = function() {
			if (this.onUnBindObservable.notifyObservers(this), this.disableDepthWrite) {
				var e = this._scene.getEngine();
				e.setDepthWrite(this._cachedDepthWriteState)
			}
		}, t.prototype.clone = function(e) {
			return null
		}, t.prototype.getBindedMeshes = function() {
			for (var e = new Array, t = 0; t < this._scene.meshes.length; t++) {
				var i = this._scene.meshes[t];
				i.material === this && e.push(i)
			}
			return e
		}, t.prototype.dispose = function(e, t) {
			this.getScene().stopAnimation(this);
			var i = this._scene.materials.indexOf(this);
			for (i >= 0 && this._scene.materials.splice(i, 1), e && this._effect && (this._scene.getEngine()._releaseEffect(this._effect), this._effect = null), i = 0; i < this._scene.meshes.length; i++) {
				var r = this._scene.meshes[i];
				r.material === this && (r.material = null)
			}
			this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBindObservable.clear(), this.onUnBindObservable.clear()
		}, t.prototype.serialize = function() {
			return e.SerializationHelper.Serialize(this)
		}, t.ParseMultiMaterial = function(t, i) {
			var r = new e.MultiMaterial(t.name, i);
			r.id = t.id, e.Tags.AddTagsTo(r, t.tags);
			for (var n = 0; n < t.materials.length; n++) {
				var o = t.materials[n];
				o ? r.subMaterials.push(i.getMaterialByID(o)) : r.subMaterials.push(null)
			}
			return r
		}, t.Parse = function(t, i, r) {
			if (!t.customType) return e.StandardMaterial.Parse(t, i, r);
			var n = e.Tools.Instantiate(t.customType);
			return n.Parse(t, i, r)
		}, t._TriangleFillMode = 0, t._WireFrameFillMode = 1, t._PointFillMode = 2, t._ClockWiseSideOrientation = 0, t._CounterClockWiseSideOrientation = 1, __decorate([e.serialize()], t.prototype, "id", void 0), __decorate([e.serialize()], t.prototype, "name", void 0), __decorate([e.serialize()], t.prototype, "checkReadyOnEveryCall", void 0), __decorate([e.serialize()], t.prototype, "checkReadyOnlyOnce", void 0), __decorate([e.serialize()], t.prototype, "state", void 0), __decorate([e.serialize()], t.prototype, "alpha", void 0), __decorate([e.serialize()], t.prototype, "backFaceCulling", void 0), __decorate([e.serialize()], t.prototype, "sideOrientation", void 0), __decorate([e.serialize()], t.prototype, "alphaMode", void 0), __decorate([e.serialize()], t.prototype, "disableDepthWrite", void 0), __decorate([e.serialize()], t.prototype, "fogEnabled", void 0), __decorate([e.serialize()], t.prototype, "pointSize", void 0), __decorate([e.serialize()], t.prototype, "zOffset", void 0), __decorate([e.serialize()], t.prototype, "wireframe", null), __decorate([e.serialize()], t.prototype, "pointsCloud", null), __decorate([e.serialize()], t.prototype, "fillMode", null), t
	})();
	e.Material = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
			function t() {
				e.call(this), this.DIFFUSE = !1, this.AMBIENT = !1, this.OPACITY = !1, this.OPACITYRGB = !1, this.REFLECTION = !1, this.EMISSIVE = !1, this.SPECULAR = !1, this.BUMP = !1, this.PARALLAX = !1, this.PARALLAXOCCLUSION = !1, this.SPECULAROVERALPHA = !1, this.CLIPPLANE = !1, this.ALPHATEST = !1, this.ALPHAFROMDIFFUSE = !1, this.POINTSIZE = !1, this.FOG = !1, this.SPECULARTERM = !1, this.DIFFUSEFRESNEL = !1, this.OPACITYFRESNEL = !1, this.REFLECTIONFRESNEL = !1, this.REFRACTIONFRESNEL = !1, this.EMISSIVEFRESNEL = !1, this.FRESNEL = !1, this.NORMAL = !1, this.UV1 = !1, this.UV2 = !1, this.VERTEXCOLOR = !1, this.VERTEXALPHA = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.INSTANCES = !1, this.GLOSSINESS = !1, this.ROUGHNESS = !1, this.EMISSIVEASILLUMINATION = !1, this.LINKEMISSIVEWITHDIFFUSE = !1, this.REFLECTIONFRESNELFROMSPECULAR = !1, this.LIGHTMAP = !1, this.USELIGHTMAPASSHADOWMAP = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, this.INVERTCUBICMAP = !1, this.LOGARITHMICDEPTH = !1, this.REFRACTION = !1, this.REFRACTIONMAP_3D = !1, this.REFLECTIONOVERALPHA = !1, this.INVERTNORMALMAPX = !1, this.INVERTNORMALMAPY = !1, this.SHADOWFULLFLOAT = !1, this.CAMERACOLORGRADING = !1, this.CAMERACOLORCURVES = !1, this.rebuild()
			}
			return __extends(t, e), t
		})(e.MaterialDefines),
		i = (function(i) {
			function r(r, n) {
				var o = this;
				i.call(this, r, n), this.ambientColor = new e.Color3(0, 0, 0), this.diffuseColor = new e.Color3(1, 1, 1), this.specularColor = new e.Color3(1, 1, 1), this.emissiveColor = new e.Color3(0, 0, 0), this.specularPower = 64, this.useAlphaFromDiffuseTexture = !1, this.useEmissiveAsIllumination = !1, this.linkEmissiveWithDiffuse = !1, this.useReflectionFresnelFromSpecular = !1, this.useSpecularOverAlpha = !1, this.useReflectionOverAlpha = !1, this.disableLighting = !1, this.useParallax = !1, this.useParallaxOcclusion = !1, this.parallaxScaleBias = .05, this.roughness = 0, this.indexOfRefraction = .98, this.invertRefractionY = !0, this.useLightmapAsShadowmap = !1, this.useGlossinessFromSpecularMapAlpha = !1, this.maxSimultaneousLights = 4, this.invertNormalMapX = !1, this.invertNormalMapY = !1, this.cameraColorGradingTexture = null, this.cameraColorCurves = null, this._renderTargets = new e.SmartArray(16), this._worldViewProjectionMatrix = e.Matrix.Zero(), this._globalAmbientColor = new e.Color3(0, 0, 0), this._defines = new t, this._cachedDefines = new t, this._cachedDefines.BonesPerMesh = -1, this.getRenderTargetTextures = function() {
					return o._renderTargets.reset(), o.reflectionTexture && o.reflectionTexture.isRenderTarget && o._renderTargets.push(o.reflectionTexture), o.refractionTexture && o.refractionTexture.isRenderTarget && o._renderTargets.push(o.refractionTexture), o._renderTargets
				}
			}
			return __extends(r, i), Object.defineProperty(r.prototype, "useLogarithmicDepth", {
				get: function() {
					return this._useLogarithmicDepth
				},
				set: function(e) {
					this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported
				},
				enumerable: !0,
				configurable: !0
			}), r.prototype.needAlphaBlending = function() {
				return this.alpha < 1 || null != this.opacityTexture || this._shouldUseAlphaFromDiffuseTexture() || this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled
			}, r.prototype.needAlphaTesting = function() {
				return null != this.diffuseTexture && this.diffuseTexture.hasAlpha
			}, r.prototype._shouldUseAlphaFromDiffuseTexture = function() {
				return null != this.diffuseTexture && this.diffuseTexture.hasAlpha && this.useAlphaFromDiffuseTexture
			}, r.prototype.getAlphaTestTexture = function() {
				return this.diffuseTexture
			}, r.prototype._checkCache = function(e, t, i) {
				return !t || this._defines.INSTANCES === i && !(!t._materialDefines || !t._materialDefines.isEqual(this._defines))
			}, r.prototype.isReady = function(i, n) {
				if (this.isFrozen && this._wasPreviouslyReady) return !0;
				var o = this.getScene(),
					s = o.getEngine(),
					a = !1,
					h = !1;
				if (this._defines.reset(), o.lightsEnabled && !this.disableLighting && (h = e.MaterialHelper.PrepareDefinesForLights(o, i, this._defines, this.maxSimultaneousLights)), !this.checkReadyOnEveryCall && this._renderId === o.getRenderId() && this._checkCache(o, i, n)) return !0;
				if (o.texturesEnabled) {
					if (this.diffuseTexture && r.DiffuseTextureEnabled) {
						if (!this.diffuseTexture.isReady()) return !1;
						a = !0, this._defines.DIFFUSE = !0
					}
					if (this.ambientTexture && r.AmbientTextureEnabled) {
						if (!this.ambientTexture.isReady()) return !1;
						a = !0, this._defines.AMBIENT = !0
					}
					if (this.opacityTexture && r.OpacityTextureEnabled) {
						if (!this.opacityTexture.isReady()) return !1;
						a = !0, this._defines.OPACITY = !0, this.opacityTexture.getAlphaFromRGB && (this._defines.OPACITYRGB = !0)
					}
					if (this.reflectionTexture && r.ReflectionTextureEnabled) {
						if (!this.reflectionTexture.isReady()) return !1;
						switch (h = !0, this._defines.REFLECTION = !0, this.roughness > 0 && (this._defines.ROUGHNESS = !0), this.useReflectionOverAlpha && (this._defines.REFLECTIONOVERALPHA = !0), this.reflectionTexture.coordinatesMode === e.Texture.INVCUBIC_MODE && (this._defines.INVERTCUBICMAP = !0), this._defines.REFLECTIONMAP_3D = this.reflectionTexture.isCube, this.reflectionTexture.coordinatesMode) {
							case e.Texture.CUBIC_MODE:
							case e.Texture.INVCUBIC_MODE:
								this._defines.REFLECTIONMAP_CUBIC = !0;
								break;
							case e.Texture.EXPLICIT_MODE:
								this._defines.REFLECTIONMAP_EXPLICIT = !0;
								break;
							case e.Texture.PLANAR_MODE:
								this._defines.REFLECTIONMAP_PLANAR = !0;
								break;
							case e.Texture.PROJECTION_MODE:
								this._defines.REFLECTIONMAP_PROJECTION = !0;
								break;
							case e.Texture.SKYBOX_MODE:
								this._defines.REFLECTIONMAP_SKYBOX = !0;
								break;
							case e.Texture.SPHERICAL_MODE:
								this._defines.REFLECTIONMAP_SPHERICAL = !0;
								break;
							case e.Texture.EQUIRECTANGULAR_MODE:
								this._defines.REFLECTIONMAP_EQUIRECTANGULAR = !0;
								break;
							case e.Texture.FIXED_EQUIRECTANGULAR_MODE:
								this._defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !0
						}
					}
					if (this.emissiveTexture && r.EmissiveTextureEnabled) {
						if (!this.emissiveTexture.isReady()) return !1;
						a = !0, this._defines.EMISSIVE = !0
					}
					if (this.lightmapTexture && r.LightmapTextureEnabled) {
						if (!this.lightmapTexture.isReady()) return !1;
						a = !0, this._defines.LIGHTMAP = !0, this._defines.USELIGHTMAPASSHADOWMAP = this.useLightmapAsShadowmap
					}
					if (this.specularTexture && r.SpecularTextureEnabled) {
						if (!this.specularTexture.isReady()) return !1;
						a = !0, this._defines.SPECULAR = !0, this._defines.GLOSSINESS = this.useGlossinessFromSpecularMapAlpha
					}
					if (o.getEngine().getCaps().standardDerivatives && this.bumpTexture && r.BumpTextureEnabled) {
						if (!this.bumpTexture.isReady()) return !1;
						a = !0, this._defines.BUMP = !0, this.useParallax && (this._defines.PARALLAX = !0, this.useParallaxOcclusion && (this._defines.PARALLAXOCCLUSION = !0)), this.invertNormalMapX && (this._defines.INVERTNORMALMAPX = !0), this.invertNormalMapY && (this._defines.INVERTNORMALMAPY = !0)
					}
					if (this.refractionTexture && r.RefractionTextureEnabled) {
						if (!this.refractionTexture.isReady()) return !1;
						a = !0, this._defines.REFRACTION = !0, this._defines.REFRACTIONMAP_3D = this.refractionTexture.isCube
					}
					if (this.cameraColorGradingTexture && r.ColorGradingTextureEnabled) {
						if (!this.cameraColorGradingTexture.isReady()) return !1;
						this._defines.CAMERACOLORGRADING = !0
					}
				}
				if (o.clipPlane && (this._defines.CLIPPLANE = !0), s.getAlphaTesting() && (this._defines.ALPHATEST = !0), this._shouldUseAlphaFromDiffuseTexture() && (this._defines.ALPHAFROMDIFFUSE = !0), this.useEmissiveAsIllumination && (this._defines.EMISSIVEASILLUMINATION = !0), this.linkEmissiveWithDiffuse && (this._defines.LINKEMISSIVEWITHDIFFUSE = !0), this.useLogarithmicDepth && (this._defines.LOGARITHMICDEPTH = !0), this.cameraColorCurves && (this._defines.CAMERACOLORCURVES = !0), (this.pointsCloud || o.forcePointsCloud) && (this._defines.POINTSIZE = !0), o.fogEnabled && i && i.applyFog && o.fogMode !== e.Scene.FOGMODE_NONE && this.fogEnabled && (this._defines.FOG = !0), r.FresnelEnabled && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled || this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled || this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled || this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled || this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (this._defines.DIFFUSEFRESNEL = !0), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && (this._defines.OPACITYFRESNEL = !0), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (this._defines.REFLECTIONFRESNEL = !0, this.useReflectionFresnelFromSpecular && (this._defines.REFLECTIONFRESNELFROMSPECULAR = !0)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (this._defines.REFRACTIONFRESNEL = !0), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (this._defines.EMISSIVEFRESNEL = !0), h = !0, this._defines.FRESNEL = !0), this._defines.SPECULARTERM && this.useSpecularOverAlpha && (this._defines.SPECULAROVERALPHA = !0), i && (h && i.isVerticesDataPresent(e.VertexBuffer.NormalKind) && (this._defines.NORMAL = !0), a && (i.isVerticesDataPresent(e.VertexBuffer.UVKind) && (this._defines.UV1 = !0), i.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (this._defines.UV2 = !0)), i.useVertexColors && i.isVerticesDataPresent(e.VertexBuffer.ColorKind) && (this._defines.VERTEXCOLOR = !0, i.hasVertexAlpha && (this._defines.VERTEXALPHA = !0)), i.useBones && i.computeBonesUsingShaders && (this._defines.NUM_BONE_INFLUENCERS = i.numBoneInfluencers, this._defines.BonesPerMesh = i.skeleton.bones.length + 1), n && (this._defines.INSTANCES = !0)), !this._defines.isEqual(this._cachedDefines)) {
					this._defines.cloneTo(this._cachedDefines), o.resetCachedMaterial();
					var c = new e.EffectFallbacks;
					this._defines.REFLECTION && c.addFallback(0, "REFLECTION"), this._defines.SPECULAR && c.addFallback(0, "SPECULAR"), this._defines.BUMP && c.addFallback(0, "BUMP"), this._defines.PARALLAX && c.addFallback(1, "PARALLAX"), this._defines.PARALLAXOCCLUSION && c.addFallback(0, "PARALLAXOCCLUSION"), this._defines.SPECULAROVERALPHA && c.addFallback(0, "SPECULAROVERALPHA"), this._defines.FOG && c.addFallback(1, "FOG"), this._defines.POINTSIZE && c.addFallback(0, "POINTSIZE"), this._defines.LOGARITHMICDEPTH && c.addFallback(0, "LOGARITHMICDEPTH"), e.MaterialHelper.HandleFallbacksForShadows(this._defines, c, this.maxSimultaneousLights), this._defines.SPECULARTERM && c.addFallback(0, "SPECULARTERM"), this._defines.DIFFUSEFRESNEL && c.addFallback(1, "DIFFUSEFRESNEL"), this._defines.OPACITYFRESNEL && c.addFallback(2, "OPACITYFRESNEL"), this._defines.REFLECTIONFRESNEL && c.addFallback(3, "REFLECTIONFRESNEL"), this._defines.EMISSIVEFRESNEL && c.addFallback(4, "EMISSIVEFRESNEL"), this._defines.FRESNEL && c.addFallback(4, "FRESNEL");
					var l = [e.VertexBuffer.PositionKind];
					this._defines.NORMAL && l.push(e.VertexBuffer.NormalKind), this._defines.UV1 && l.push(e.VertexBuffer.UVKind), this._defines.UV2 && l.push(e.VertexBuffer.UV2Kind), this._defines.VERTEXCOLOR && l.push(e.VertexBuffer.ColorKind), e.MaterialHelper.PrepareAttributesForBones(l, i, this._defines, c), e.MaterialHelper.PrepareAttributesForInstances(l, this._defines);
					var u = "default",
						d = this._defines.toString(),
						f = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vDiffuseColor", "vSpecularColor", "vEmissiveColor", "vFogInfos", "vFogColor", "pointSize", "vDiffuseInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vEmissiveInfos", "vSpecularInfos", "vBumpInfos", "vLightmapInfos", "vRefractionInfos", "mBones", "vClipPlane", "diffuseMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "specularMatrix", "bumpMatrix", "lightmapMatrix", "refractionMatrix", "depthValues", "diffuseLeftColor", "diffuseRightColor", "opacityParts", "reflectionLeftColor", "reflectionRightColor", "emissiveLeftColor", "emissiveRightColor", "refractionLeftColor", "refractionRightColor", "logarithmicDepthConstant"],
						p = ["diffuseSampler", "ambientSampler", "opacitySampler", "reflectionCubeSampler", "reflection2DSampler", "emissiveSampler", "specularSampler", "bumpSampler", "lightmapSampler", "refractionCubeSampler", "refraction2DSampler"];
					this._defines.CAMERACOLORCURVES && e.ColorCurves.PrepareUniforms(f), this._defines.CAMERACOLORGRADING && e.ColorGradingTexture.PrepareUniformsAndSamplers(f, p), e.MaterialHelper.PrepareUniformsAndSamplersList(f, p, this._defines, this.maxSimultaneousLights), this._effect = o.getEngine().createEffect(u, l, f, p, d, c, this.onCompiled, this.onError, {
						maxSimultaneousLights: this.maxSimultaneousLights - 1
					})
				}
				return !!this._effect.isReady() && (this._renderId = o.getRenderId(), this._wasPreviouslyReady = !0, i && (i._materialDefines || (i._materialDefines = new t), this._defines.cloneTo(i._materialDefines)), !0)
			}, r.prototype.unbind = function() {
				this.reflectionTexture && this.reflectionTexture.isRenderTarget && this._effect.setTexture("reflection2DSampler", null), this.refractionTexture && this.refractionTexture.isRenderTarget && this._effect.setTexture("refraction2DSampler", null), i.prototype.unbind.call(this)
			}, r.prototype.bindOnlyWorldMatrix = function(e) {
				this._effect.setMatrix("world", e)
			}, r.prototype.bind = function(t, n) {
				var o = this.getScene();
				if (this.bindOnlyWorldMatrix(t), e.MaterialHelper.BindBonesParameters(n, this._effect), o.getCachedMaterial() !== this) {
					if (this._effect.setMatrix("viewProjection", o.getTransformMatrix()), r.FresnelEnabled && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (this._effect.setColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), this._effect.setColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && this._effect.setColor4("opacityParts", new e.Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (this._effect.setColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), this._effect.setColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (this._effect.setColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), this._effect.setColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (this._effect.setColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), this._effect.setColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), o.texturesEnabled) {
						if (this.diffuseTexture && r.DiffuseTextureEnabled && (this._effect.setTexture("diffuseSampler", this.diffuseTexture), this._effect.setFloat2("vDiffuseInfos", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level), this._effect.setMatrix("diffuseMatrix", this.diffuseTexture.getTextureMatrix())), this.ambientTexture && r.AmbientTextureEnabled && (this._effect.setTexture("ambientSampler", this.ambientTexture), this._effect.setFloat2("vAmbientInfos", this.ambientTexture.coordinatesIndex, this.ambientTexture.level), this._effect.setMatrix("ambientMatrix", this.ambientTexture.getTextureMatrix())), this.opacityTexture && r.OpacityTextureEnabled && (this._effect.setTexture("opacitySampler", this.opacityTexture), this._effect.setFloat2("vOpacityInfos", this.opacityTexture.coordinatesIndex, this.opacityTexture.level), this._effect.setMatrix("opacityMatrix", this.opacityTexture.getTextureMatrix())), this.reflectionTexture && r.ReflectionTextureEnabled && (this.reflectionTexture.isCube ? this._effect.setTexture("reflectionCubeSampler", this.reflectionTexture) : this._effect.setTexture("reflection2DSampler", this.reflectionTexture), this._effect.setMatrix("reflectionMatrix", this.reflectionTexture.getReflectionTextureMatrix()), this._effect.setFloat2("vReflectionInfos", this.reflectionTexture.level, this.roughness)), this.emissiveTexture && r.EmissiveTextureEnabled && (this._effect.setTexture("emissiveSampler", this.emissiveTexture), this._effect.setFloat2("vEmissiveInfos", this.emissiveTexture.coordinatesIndex, this.emissiveTexture.level), this._effect.setMatrix("emissiveMatrix", this.emissiveTexture.getTextureMatrix())), this.lightmapTexture && r.LightmapTextureEnabled && (this._effect.setTexture("lightmapSampler", this.lightmapTexture), this._effect.setFloat2("vLightmapInfos", this.lightmapTexture.coordinatesIndex, this.lightmapTexture.level), this._effect.setMatrix("lightmapMatrix", this.lightmapTexture.getTextureMatrix())), this.specularTexture && r.SpecularTextureEnabled && (this._effect.setTexture("specularSampler", this.specularTexture), this._effect.setFloat2("vSpecularInfos", this.specularTexture.coordinatesIndex, this.specularTexture.level), this._effect.setMatrix("specularMatrix", this.specularTexture.getTextureMatrix())), this.bumpTexture && o.getEngine().getCaps().standardDerivatives && r.BumpTextureEnabled && (this._effect.setTexture("bumpSampler", this.bumpTexture), this._effect.setFloat3("vBumpInfos", this.bumpTexture.coordinatesIndex, 1 / this.bumpTexture.level, this.parallaxScaleBias), this._effect.setMatrix("bumpMatrix", this.bumpTexture.getTextureMatrix())), this.refractionTexture && r.RefractionTextureEnabled) {
							var s = 1;
							this.refractionTexture.isCube ? this._effect.setTexture("refractionCubeSampler", this.refractionTexture) : (this._effect.setTexture("refraction2DSampler", this.refractionTexture), this._effect.setMatrix("refractionMatrix", this.refractionTexture.getReflectionTextureMatrix()), this.refractionTexture.depth && (s = this.refractionTexture.depth)), this._effect.setFloat4("vRefractionInfos", this.refractionTexture.level, this.indexOfRefraction, s, this.invertRefractionY ? -1 : 1)
						}
						this.cameraColorGradingTexture && r.ColorGradingTextureEnabled && e.ColorGradingTexture.Bind(this.cameraColorGradingTexture, this._effect)
					}
					e.MaterialHelper.BindClipPlane(this._effect, o), this.pointsCloud && this._effect.setFloat("pointSize", this.pointSize), o.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), this._effect.setVector3("vEyePosition", o._mirroredCameraPosition ? o._mirroredCameraPosition : o.activeCamera.position), this._effect.setColor3("vAmbientColor", this._globalAmbientColor), this._defines.SPECULARTERM && this._effect.setColor4("vSpecularColor", this.specularColor, this.specularPower), this._effect.setColor3("vEmissiveColor", this.emissiveColor)
				}
				o.getCachedMaterial() === this && this.isFrozen || (this._effect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * n.visibility), o.lightsEnabled && !this.disableLighting && e.MaterialHelper.BindLights(o, n, this._effect, this._defines, this.maxSimultaneousLights), (o.fogEnabled && n.applyFog && o.fogMode !== e.Scene.FOGMODE_NONE || this.reflectionTexture || this.refractionTexture) && this._effect.setMatrix("view", o.getViewMatrix()), e.MaterialHelper.BindFogParameters(o, n, this._effect), e.MaterialHelper.BindLogDepth(this._defines, this._effect, o),
					this.cameraColorCurves && e.ColorCurves.Bind(this.cameraColorCurves, this._effect)), i.prototype.bind.call(this, t, n)
			}, r.prototype.getAnimatables = function() {
				var e = [];
				return this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0 && e.push(this.diffuseTexture), this.ambientTexture && this.ambientTexture.animations && this.ambientTexture.animations.length > 0 && e.push(this.ambientTexture), this.opacityTexture && this.opacityTexture.animations && this.opacityTexture.animations.length > 0 && e.push(this.opacityTexture), this.reflectionTexture && this.reflectionTexture.animations && this.reflectionTexture.animations.length > 0 && e.push(this.reflectionTexture), this.emissiveTexture && this.emissiveTexture.animations && this.emissiveTexture.animations.length > 0 && e.push(this.emissiveTexture), this.specularTexture && this.specularTexture.animations && this.specularTexture.animations.length > 0 && e.push(this.specularTexture), this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0 && e.push(this.bumpTexture), this.lightmapTexture && this.lightmapTexture.animations && this.lightmapTexture.animations.length > 0 && e.push(this.lightmapTexture), this.refractionTexture && this.refractionTexture.animations && this.refractionTexture.animations.length > 0 && e.push(this.refractionTexture), this.cameraColorGradingTexture && this.cameraColorGradingTexture.animations && this.cameraColorGradingTexture.animations.length > 0 && e.push(this.cameraColorGradingTexture), e
			}, r.prototype.dispose = function(e, t) {
				t && (this.diffuseTexture && this.diffuseTexture.dispose(), this.ambientTexture && this.ambientTexture.dispose(), this.opacityTexture && this.opacityTexture.dispose(), this.reflectionTexture && this.reflectionTexture.dispose(), this.emissiveTexture && this.emissiveTexture.dispose(), this.specularTexture && this.specularTexture.dispose(), this.bumpTexture && this.bumpTexture.dispose(), this.lightmapTexture && this.lightmapTexture.dispose(), this.refractionTexture && this.refractionTexture.dispose(), this.cameraColorGradingTexture && this.cameraColorGradingTexture.dispose()), i.prototype.dispose.call(this, e, t)
			}, r.prototype.clone = function(t) {
				var i = this;
				return e.SerializationHelper.Clone((function() {
					return new r(t, i.getScene())
				}), this)
			}, r.prototype.serialize = function() {
				return e.SerializationHelper.Serialize(this)
			}, r.Parse = function(t, i, n) {
				return e.SerializationHelper.Parse((function() {
					return new r(t.name, i)
				}), t, i, n)
			}, r.DiffuseTextureEnabled = !0, r.AmbientTextureEnabled = !0, r.OpacityTextureEnabled = !0, r.ReflectionTextureEnabled = !0, r.EmissiveTextureEnabled = !0, r.SpecularTextureEnabled = !0, r.BumpTextureEnabled = !0, r.FresnelEnabled = !0, r.LightmapTextureEnabled = !0, r.RefractionTextureEnabled = !0, r.ColorGradingTextureEnabled = !0, __decorate([e.serializeAsTexture()], r.prototype, "diffuseTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "ambientTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "opacityTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "reflectionTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "emissiveTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "specularTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "bumpTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "lightmapTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "refractionTexture", void 0), __decorate([e.serializeAsColor3("ambient")], r.prototype, "ambientColor", void 0), __decorate([e.serializeAsColor3("diffuse")], r.prototype, "diffuseColor", void 0), __decorate([e.serializeAsColor3("specular")], r.prototype, "specularColor", void 0), __decorate([e.serializeAsColor3("emissive")], r.prototype, "emissiveColor", void 0), __decorate([e.serialize()], r.prototype, "specularPower", void 0), __decorate([e.serialize()], r.prototype, "useAlphaFromDiffuseTexture", void 0), __decorate([e.serialize()], r.prototype, "useEmissiveAsIllumination", void 0), __decorate([e.serialize()], r.prototype, "linkEmissiveWithDiffuse", void 0), __decorate([e.serialize()], r.prototype, "useReflectionFresnelFromSpecular", void 0), __decorate([e.serialize()], r.prototype, "useSpecularOverAlpha", void 0), __decorate([e.serialize()], r.prototype, "useReflectionOverAlpha", void 0), __decorate([e.serialize()], r.prototype, "disableLighting", void 0), __decorate([e.serialize()], r.prototype, "useParallax", void 0), __decorate([e.serialize()], r.prototype, "useParallaxOcclusion", void 0), __decorate([e.serialize()], r.prototype, "parallaxScaleBias", void 0), __decorate([e.serialize()], r.prototype, "roughness", void 0), __decorate([e.serialize()], r.prototype, "indexOfRefraction", void 0), __decorate([e.serialize()], r.prototype, "invertRefractionY", void 0), __decorate([e.serialize()], r.prototype, "useLightmapAsShadowmap", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "diffuseFresnelParameters", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "opacityFresnelParameters", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "reflectionFresnelParameters", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "refractionFresnelParameters", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "emissiveFresnelParameters", void 0), __decorate([e.serialize()], r.prototype, "useGlossinessFromSpecularMapAlpha", void 0), __decorate([e.serialize()], r.prototype, "maxSimultaneousLights", void 0), __decorate([e.serialize()], r.prototype, "invertNormalMapX", void 0), __decorate([e.serialize()], r.prototype, "invertNormalMapY", void 0), __decorate([e.serializeAsTexture()], r.prototype, "cameraColorGradingTexture", void 0), __decorate([e.serializeAsColorCurves()], r.prototype, "cameraColorCurves", void 0), __decorate([e.serialize()], r.prototype, "useLogarithmicDepth", null), r
		})(e.Material);
	e.StandardMaterial = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i) {
			t.call(this, e, i, !0), this.subMaterials = new Array, i.multiMaterials.push(this)
		}
		return __extends(i, t), i.prototype.getSubMaterial = function(e) {
			return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e]
		}, i.prototype.isReady = function(e) {
			for (var t = 0; t < this.subMaterials.length; t++) {
				var i = this.subMaterials[t];
				if (i && !this.subMaterials[t].isReady(e)) return !1
			}
			return !0
		}, i.prototype.clone = function(e, t) {
			for (var r = new i(e, this.getScene()), n = 0; n < this.subMaterials.length; n++) {
				var o = null;
				o = t ? this.subMaterials[n].clone(e + "-" + this.subMaterials[n].name) : this.subMaterials[n], r.subMaterials.push(o)
			}
			return r
		}, i.prototype.serialize = function() {
			var t = {};
			t.name = this.name, t.id = this.id, t.tags = e.Tags.GetTags(this), t.materials = [];
			for (var i = 0; i < this.subMaterials.length; i++) {
				var r = this.subMaterials[i];
				r ? t.materials.push(r.id) : t.materials.push(null)
			}
			return t
		}, i
	})(e.Material);
	e.MultiMaterial = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {}
		return Object.defineProperty(t, "NO_LOGGING", {
			get: function() {
				return 0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "MINIMAL_LOGGING", {
			get: function() {
				return 1
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "SUMMARY_LOGGING", {
			get: function() {
				return 2
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "DETAILED_LOGGING", {
			get: function() {
				return 3
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "ForceFullSceneLoadingForIncremental", {
			get: function() {
				return t._ForceFullSceneLoadingForIncremental
			},
			set: function(e) {
				t._ForceFullSceneLoadingForIncremental = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "ShowLoadingScreen", {
			get: function() {
				return t._ShowLoadingScreen
			},
			set: function(e) {
				t._ShowLoadingScreen = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "loggingLevel", {
			get: function() {
				return t._loggingLevel
			},
			set: function(e) {
				t._loggingLevel = e
			},
			enumerable: !0,
			configurable: !0
		}), t._getDefaultPlugin = function() {
			return t._registeredPlugins[".babylon"]
		}, t._getPluginForExtension = function(e) {
			var i = t._registeredPlugins[e];
			return i ? i : t._getDefaultPlugin()
		}, t._getPluginForFilename = function(e) {
			e.name && (e = e.name);
			var i = e.lastIndexOf("."),
				r = e.indexOf("?");
			r === -1 && (r = e.length);
			var n = e.substring(i, r).toLowerCase();
			return t._getPluginForExtension(n)
		}, t._getDirectLoad = function(e) {
			return e.substr && "data:" === e.substr(0, 5) ? e.substr(5) : null
		}, t.GetPluginForExtension = function(e) {
			return t._getPluginForExtension(e).plugin
		}, t.RegisterPlugin = function(e) {
			if ("string" == typeof e.extensions) {
				var i = e.extensions;
				t._registeredPlugins[i.toLowerCase()] = {
					plugin: e,
					isBinary: !1
				}
			} else {
				var r = e.extensions;
				Object.keys(r).forEach((function(i) {
					t._registeredPlugins[i.toLowerCase()] = {
						plugin: e,
						isBinary: r[i].isBinary
					}
				}))
			}
		}, t.ImportMesh = function(i, r, n, o, s, a, h) {
			if (n.substr && "/" === n.substr(0, 1)) return void e.Tools.Error("Wrong sceneFilename parameter");
			if (n.substr && "/" === n.substr(0, 1)) return void e.Tools.Error("Wrong sceneFilename parameter");
			var c = t._getDirectLoad(n),
				l = {};
			o._addPendingData(l);
			var u = function(u) {
				o.database = d;
				var f = c ? t._getDefaultPlugin() : t._getPluginForFilename(n),
					p = f.plugin,
					m = f.isBinary,
					_ = function(e) {
						var t = [],
							a = [],
							c = [];
						try {
							if (p.importMesh) {
								var u = p;
								if (!u.importMesh(i, o, e, r, t, a, c)) return h && h(o, "Unable to import meshes from " + r + n), void o._removePendingData(l);
								s && (o.importedMeshesFiles.push(r + n), s(t, a, c), o._removePendingData(l))
							} else {
								var d = p;
								d.importMeshAsync(i, o, e, r, (function(e, t, i) {
									s && (o.importedMeshesFiles.push(r + n), s(e, t, i), o._removePendingData(l))
								}), (function() {
									h && h(o, "Unable to import meshes from " + r + n), o._removePendingData(l)
								}))
							}
						} catch (f) {
							h && h(o, "Unable to import meshes from " + r + n, f), o._removePendingData(l)
						}
					};
				return c ? void _(c) : void e.Tools.LoadFile(r + n, (function(e) {
					_(e)
				}), a, d, m)
			};
			if (o.getEngine().enableOfflineSupport && !c) var d = new e.Database(r + n, u);
			else u(!0)
		}, t.Load = function(i, r, n, o, s, a) {
			t.Append(i, r, new e.Scene(n), o, s, a)
		}, t.Append = function(i, r, n, o, s, a) {
			if (r.substr && "/" === r.substr(0, 1)) return void e.Tools.Error("Wrong sceneFilename parameter");
			var h, c = t._getDirectLoad(r),
				l = c ? t._getDefaultPlugin() : t._getPluginForFilename(r),
				u = l.plugin,
				d = l.isBinary,
				f = {};
			n._addPendingData(f), t.ShowLoadingScreen && n.getEngine().displayLoadingUI();
			var p = function(e) {
					if (n.database = h, u.load) {
						var r = u;
						if (!r.load(n, e, i)) return a && a(n), n._removePendingData(f), void n.getEngine().hideLoadingUI();
						o && o(n), n._removePendingData(f)
					} else {
						var s = u;
						s.loadAsync(n, e, i, (function() {
							o && o(n), n._removePendingData(f)
						}), (function() {
							a && a(n), n._removePendingData(f), n.getEngine().hideLoadingUI()
						}))
					}
					t.ShowLoadingScreen && n.executeWhenReady((function() {
						n.getEngine().hideLoadingUI()
					}))
				},
				m = function(t) {
					e.Tools.LoadFile(i + r, p, s, h, d)
				};
			return c ? void p(c) : void(i.indexOf("file:") === -1 ? n.getEngine().enableOfflineSupport ? h = new e.Database(i + r, m) : m(!0) : e.Tools.ReadFile(r, p, s, d))
		}, t._ForceFullSceneLoadingForIncremental = !1, t._ShowLoadingScreen = !0, t._loggingLevel = t.NO_LOGGING, t._registeredPlugins = {}, t
	})();
	e.SceneLoader = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = function(t, i, r, n) {
				for (var o = 0, s = i.materials.length; o < s; o++) {
					var a = i.materials[o];
					if (a.id === t) return e.Material.Parse(a, r, n)
				}
				return null
			},
			r = function(e, t, i) {
				t = t instanceof Array ? t : [t];
				for (var r in t)
					if (e.name === t[r]) return i.push(e.id), !0;
				return !(!e.parentId || i.indexOf(e.parentId) === -1) && (i.push(e.id), !0)
			},
			n = function(e, t) {
				return e + " of " + (t ? t.file + " from " + t.name + " version: " + t.version + ", exporter version: " + t.exporter_version : "unknown")
			};
		e.SceneLoader.RegisterPlugin({
			extensions: ".babylon",
			importMesh: function(t, o, s, a, h, c, l) {
				var u = "importMesh has failed JSON parse";
				try {
					var d = JSON.parse(s);
					u = "";
					var f, p, m = e.SceneLoader.loggingLevel === e.SceneLoader.DETAILED_LOGGING,
						_ = [],
						g = [],
						v = [];
					for (f = 0, p = d.meshes.length; f < p; f++) {
						var y = d.meshes[f];
						if (!t || r(y, t, v)) {
							if (t instanceof Array && delete t[t.indexOf(y.name)], y.geometryId && d.geometries) {
								var x = !1;
								["boxes", "spheres", "cylinders", "toruses", "grounds", "planes", "torusKnots", "vertexData"].forEach((function(t) {
									!x && d.geometries[t] && d.geometries[t] instanceof Array && d.geometries[t].forEach((function(i) {
										if (i.id === y.geometryId) {
											switch (t) {
												case "boxes":
													e.Geometry.Primitives.Box.Parse(i, o);
													break;
												case "spheres":
													e.Geometry.Primitives.Sphere.Parse(i, o);
													break;
												case "cylinders":
													e.Geometry.Primitives.Cylinder.Parse(i, o);
													break;
												case "toruses":
													e.Geometry.Primitives.Torus.Parse(i, o);
													break;
												case "grounds":
													e.Geometry.Primitives.Ground.Parse(i, o);
													break;
												case "planes":
													e.Geometry.Primitives.Plane.Parse(i, o);
													break;
												case "torusKnots":
													e.Geometry.Primitives.TorusKnot.Parse(i, o);
													break;
												case "vertexData":
													e.Geometry.Parse(i, o, a)
											}
											x = !0
										}
									}))
								})), x || e.Tools.Warn("Geometry not found for mesh " + y.id)
							}
							if (y.materialId) {
								var b = g.indexOf(y.materialId) !== -1;
								if (!b && d.multiMaterials)
									for (var T = 0, A = d.multiMaterials.length; T < A; T++) {
										var E = d.multiMaterials[T];
										if (E.id === y.materialId) {
											for (var P = 0, M = E.materials.length; P < M; P++) {
												var S = E.materials[P];
												g.push(S);
												var C = i(S, d, o, a);
												u += "\n\tMaterial " + C.toString(m)
											}
											g.push(E.id);
											var R = e.Material.ParseMultiMaterial(E, o);
											b = !0, u += "\n\tMulti-Material " + R.toString(m);
											break
										}
									}
								if (!b) {
									g.push(y.materialId);
									var C = i(y.materialId, d, o, a);
									C ? u += "\n\tMaterial " + C.toString(m) : e.Tools.Warn("Material not found for mesh " + y.id)
								}
							}
							if (y.skeletonId > -1 && o.skeletons) {
								var O = _.indexOf(y.skeletonId) > -1;
								if (!O)
									for (var D = 0, I = d.skeletons.length; D < I; D++) {
										var w = d.skeletons[D];
										if (w.id === y.skeletonId) {
											var L = e.Skeleton.Parse(w, o);
											l.push(L), _.push(w.id), u += "\n\tSkeleton " + L.toString(m)
										}
									}
							}
							var B = e.Mesh.Parse(y, o, a);
							h.push(B), u += "\n\tMesh " + B.toString(m)
						}
					}
					var F;
					for (f = 0, p = o.meshes.length; f < p; f++) F = o.meshes[f], F._waitingParentId && (F.parent = o.getLastEntryByID(F._waitingParentId), F._waitingParentId = void 0);
					for (f = 0, p = o.meshes.length; f < p; f++) F = o.meshes[f], F._waitingFreezeWorldMatrix ? (F.freezeWorldMatrix(), F._waitingFreezeWorldMatrix = void 0) : F.computeWorldMatrix(!0);
					if (d.particleSystems)
						for (f = 0, p = d.particleSystems.length; f < p; f++) {
							var V = d.particleSystems[f];
							v.indexOf(V.emitterId) !== -1 && c.push(e.ParticleSystem.Parse(V, o, a))
						}
					return !0
				} catch (N) {
					throw e.Tools.Log(n("importMesh", d ? d.producer : "Unknown") + u), u = null, N
				} finally {
					null !== u && e.SceneLoader.loggingLevel !== e.SceneLoader.NO_LOGGING && e.Tools.Log(n("importMesh", d ? d.producer : "Unknown") + (e.SceneLoader.loggingLevel !== e.SceneLoader.MINIMAL_LOGGING ? u : ""))
				}
			},
			load: function(t, i, r) {
				var o = "importScene has failed JSON parse";
				try {
					var s = JSON.parse(i);
					o = "";
					var a = e.SceneLoader.loggingLevel === e.SceneLoader.DETAILED_LOGGING;
					if (t.useDelayedTextureLoading = s.useDelayedTextureLoading && !e.SceneLoader.ForceFullSceneLoadingForIncremental, t.autoClear = s.autoClear, t.clearColor = e.Color4.FromArray(s.clearColor), t.ambientColor = e.Color3.FromArray(s.ambientColor), s.gravity && (t.gravity = e.Vector3.FromArray(s.gravity)), s.fogMode && 0 !== s.fogMode) switch (t.fogMode = s.fogMode, t.fogColor = e.Color3.FromArray(s.fogColor), t.fogStart = s.fogStart, t.fogEnd = s.fogEnd, t.fogDensity = s.fogDensity, o += "\tFog mode for scene:  ", t.fogMode) {
						case 1:
							o += "exp\n";
							break;
						case 2:
							o += "exp2\n";
							break;
						case 3:
							o += "linear\n"
					}
					if (s.physicsEnabled) {
						var h;
						"cannon" === s.physicsEngine ? h = new e.CannonJSPlugin : "oimo" === s.physicsEngine && (h = new e.OimoJSPlugin), o = "\tPhysics engine " + (s.physicsEngine ? s.physicsEngine : "oimo") + " enabled\n";
						var c = s.physicsGravity ? e.Vector3.FromArray(s.physicsGravity) : null;
						t.enablePhysics(c, h)
					}
					void 0 !== s.metadata && (t.metadata = s.metadata), void 0 != s.collisionsEnabled && (t.collisionsEnabled = s.collisionsEnabled), t.workerCollisions = !!s.workerCollisions;
					var l, u;
					for (l = 0, u = s.lights.length; l < u; l++) {
						var d = s.lights[l],
							f = e.Light.Parse(d, t);
						o += 0 === l ? "\n\tLights:" : "", o += "\n\t\t" + f.toString(a)
					}
					if (s.animations)
						for (l = 0, u = s.animations.length; l < u; l++) {
							var p = s.animations[l],
								m = e.Animation.Parse(p);
							t.animations.push(m), o += 0 === l ? "\n\tAnimations:" : "", o += "\n\t\t" + m.toString(a)
						}
					if (s.autoAnimate && t.beginAnimation(t, s.autoAnimateFrom, s.autoAnimateTo, s.autoAnimateLoop, s.autoAnimateSpeed || 1), s.materials)
						for (l = 0, u = s.materials.length; l < u; l++) {
							var _ = s.materials[l],
								g = e.Material.Parse(_, t, r);
							o += 0 === l ? "\n\tMaterials:" : "", o += "\n\t\t" + g.toString(a)
						}
					if (s.multiMaterials)
						for (l = 0, u = s.multiMaterials.length; l < u; l++) {
							var v = s.multiMaterials[l],
								y = e.Material.ParseMultiMaterial(v, t);
							o += 0 === l ? "\n\tMultiMaterials:" : "", o += "\n\t\t" + y.toString(a)
						}
					if (s.skeletons)
						for (l = 0, u = s.skeletons.length; l < u; l++) {
							var x = s.skeletons[l],
								b = e.Skeleton.Parse(x, t);
							o += 0 === l ? "\n\tSkeletons:" : "", o += "\n\t\t" + b.toString(a)
						}
					var T = s.geometries;
					if (T) {
						var A = T.boxes;
						if (A)
							for (l = 0, u = A.length; l < u; l++) {
								var E = A[l];
								e.Geometry.Primitives.Box.Parse(E, t)
							}
						var P = T.spheres;
						if (P)
							for (l = 0, u = P.length; l < u; l++) {
								var M = P[l];
								e.Geometry.Primitives.Sphere.Parse(M, t)
							}
						var S = T.cylinders;
						if (S)
							for (l = 0, u = S.length; l < u; l++) {
								var C = S[l];
								e.Geometry.Primitives.Cylinder.Parse(C, t)
							}
						var R = T.toruses;
						if (R)
							for (l = 0, u = R.length; l < u; l++) {
								var O = R[l];
								e.Geometry.Primitives.Torus.Parse(O, t)
							}
						var D = T.grounds;
						if (D)
							for (l = 0, u = D.length; l < u; l++) {
								var I = D[l];
								e.Geometry.Primitives.Ground.Parse(I, t)
							}
						var w = T.planes;
						if (w)
							for (l = 0, u = w.length; l < u; l++) {
								var L = w[l];
								e.Geometry.Primitives.Plane.Parse(L, t)
							}
						var B = T.torusKnots;
						if (B)
							for (l = 0, u = B.length; l < u; l++) {
								var F = B[l];
								e.Geometry.Primitives.TorusKnot.Parse(F, t)
							}
						var V = T.vertexData;
						if (V)
							for (l = 0, u = V.length; l < u; l++) {
								var N = V[l];
								e.Geometry.Parse(N, t, r)
							}
					}
					for (l = 0, u = s.meshes.length; l < u; l++) {
						var z = s.meshes[l],
							U = e.Mesh.Parse(z, t, r);
						o += 0 === l ? "\n\tMeshes:" : "", o += "\n\t\t" + U.toString(a)
					}
					for (l = 0, u = s.cameras.length; l < u; l++) {
						var k = s.cameras[l],
							G = e.Camera.Parse(k, t);
						o += 0 === l ? "\n\tCameras:" : "", o += "\n\t\t" + G.toString(a)
					}
					for (s.activeCameraID && t.setActiveCameraByID(s.activeCameraID), l = 0, u = t.cameras.length; l < u; l++) {
						var G = t.cameras[l];
						G._waitingParentId && (G.parent = t.getLastEntryByID(G._waitingParentId), G._waitingParentId = void 0)
					}
					for (l = 0, u = t.lights.length; l < u; l++) {
						var f = t.lights[l];
						f._waitingParentId && (f.parent = t.getLastEntryByID(f._waitingParentId), f._waitingParentId = void 0)
					}
					var W, Y = [];
					if (e.AudioEngine && s.sounds)
						for (l = 0, u = s.sounds.length; l < u; l++) {
							var H = s.sounds[l];
							if (e.Engine.audioEngine.canUseWebAudio) H.url || (H.url = H.name), Y[H.url] ? e.Sound.Parse(H, t, r, Y[H.url]) : (W = e.Sound.Parse(H, t, r), Y[H.url] = W);
							else {
								new e.Sound(H.name, null, t)
							}
						}
					for (Y = [], l = 0, u = t.meshes.length; l < u; l++) {
						var U = t.meshes[l];
						U._waitingParentId && (U.parent = t.getLastEntryByID(U._waitingParentId), U._waitingParentId = void 0), U._waitingActions && (e.ActionManager.Parse(U._waitingActions, U, t), U._waitingActions = void 0)
					}
					for (l = 0, u = t.meshes.length; l < u; l++) {
						var j = t.meshes[l];
						j._waitingFreezeWorldMatrix ? (j.freezeWorldMatrix(), j._waitingFreezeWorldMatrix = void 0) : j.computeWorldMatrix(!0)
					}
					if (s.particleSystems)
						for (l = 0, u = s.particleSystems.length; l < u; l++) {
							var X = s.particleSystems[l];
							e.ParticleSystem.Parse(X, t, r)
						}
					if (s.lensFlareSystems)
						for (l = 0, u = s.lensFlareSystems.length; l < u; l++) {
							var K = s.lensFlareSystems[l];
							e.LensFlareSystem.Parse(K, t, r)
						}
					if (s.shadowGenerators)
						for (l = 0, u = s.shadowGenerators.length; l < u; l++) {
							var Z = s.shadowGenerators[l];
							e.ShadowGenerator.Parse(Z, t)
						}
					return s.actions && e.ActionManager.Parse(s.actions, null, t), !0
				} catch (q) {
					throw e.Tools.Log(n("importScene", s ? s.producer : "Unknown") + o), o = null, q
				} finally {
					null !== o && e.SceneLoader.loggingLevel !== e.SceneLoader.NO_LOGGING && e.Tools.Log(n("importScene", s ? s.producer : "Unknown") + (e.SceneLoader.loggingLevel !== e.SceneLoader.MINIMAL_LOGGING ? o : ""))
				}
			}
		})
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o, s, a) {
			if (void 0 === s && (s = .01), void 0 === a && (a = e.Texture.TRILINEAR_SAMPLINGMODE), this.name = t, this.sprites = new Array, this.renderingGroupId = 0, this.layerMask = 268435455, this.fogEnabled = !0, this.isPickable = !1, this.onDisposeObservable = new e.Observable, this._vertexBuffers = {}, this._capacity = r, this._spriteTexture = new e.Texture(i, o, (!0), (!1), a), this._spriteTexture.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._spriteTexture.wrapV = e.Texture.CLAMP_ADDRESSMODE, n.width && n.height) this.cellWidth = n.width, this.cellHeight = n.height;
			else {
				if (void 0 === n) return;
				this.cellWidth = n, this.cellHeight = n
			}
			this._epsilon = s, this._scene = o, this._scene.spriteManagers.push(this);
			for (var h = [], c = 0, l = 0; l < r; l++) h.push(c), h.push(c + 1), h.push(c + 2), h.push(c), h.push(c + 2), h.push(c + 3), c += 4;
			this._indexBuffer = o.getEngine().createIndexBuffer(h), this._vertexData = new Float32Array(16 * r * 4), this._buffer = new e.Buffer(o.getEngine(), this._vertexData, (!0), 16);
			var u = this._buffer.createVertexBuffer(e.VertexBuffer.PositionKind, 0, 4),
				d = this._buffer.createVertexBuffer("options", 4, 4),
				f = this._buffer.createVertexBuffer("cellInfo", 8, 4),
				p = this._buffer.createVertexBuffer(e.VertexBuffer.ColorKind, 12, 4);
			this._vertexBuffers[e.VertexBuffer.PositionKind] = u, this._vertexBuffers.options = d, this._vertexBuffers.cellInfo = f, this._vertexBuffers[e.VertexBuffer.ColorKind] = p, this._effectBase = this._scene.getEngine().createEffect("sprites", [e.VertexBuffer.PositionKind, "options", "cellInfo", e.VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest"], ["diffuseSampler"], ""), this._effectFog = this._scene.getEngine().createEffect("sprites", [e.VertexBuffer.PositionKind, "options", "cellInfo", e.VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor"], ["diffuseSampler"], "#define FOG")
		}
		return Object.defineProperty(t.prototype, "onDispose", {
			set: function(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "texture", {
			get: function() {
				return this._spriteTexture
			},
			set: function(e) {
				this._spriteTexture = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype._appendSpriteVertex = function(e, t, i, r, n) {
			var o = 16 * e;
			0 === i ? i = this._epsilon : 1 === i && (i = 1 - this._epsilon), 0 === r ? r = this._epsilon : 1 === r && (r = 1 - this._epsilon), this._vertexData[o] = t.position.x, this._vertexData[o + 1] = t.position.y, this._vertexData[o + 2] = t.position.z, this._vertexData[o + 3] = t.angle, this._vertexData[o + 4] = t.width, this._vertexData[o + 5] = t.height, this._vertexData[o + 6] = i, this._vertexData[o + 7] = r, this._vertexData[o + 8] = t.invertU ? 1 : 0, this._vertexData[o + 9] = t.invertV ? 1 : 0;
			var s = t.cellIndex / n >> 0;
			this._vertexData[o + 10] = t.cellIndex - s * n, this._vertexData[o + 11] = s, this._vertexData[o + 12] = t.color.r, this._vertexData[o + 13] = t.color.g, this._vertexData[o + 14] = t.color.b, this._vertexData[o + 15] = t.color.a
		}, t.prototype.intersects = function(t, i, r, n) {
			for (var o, s = Math.min(this._capacity, this.sprites.length), a = e.Vector3.Zero(), h = e.Vector3.Zero(), c = Number.MAX_VALUE, l = e.Vector3.Zero(), u = i.getViewMatrix(), d = 0; d < s; d++) {
				var f = this.sprites[d];
				if (f) {
					if (r) {
						if (!r(f)) continue
					} else if (!f.isPickable) continue;
					if (e.Vector3.TransformCoordinatesToRef(f.position, u, l), a.copyFromFloats(l.x - f.width / 2, l.y - f.height / 2, l.z), h.copyFromFloats(l.x + f.width / 2, l.y + f.height / 2, l.z), t.intersectsBoxMinMax(a, h)) {
						var p = e.Vector3.Distance(l, t.origin);
						if (c > p && (c = p, o = f, n)) break
					}
				}
			}
			if (o) {
				var m = new e.PickingInfo;
				return m.hit = !0, m.pickedSprite = o, m.distance = c, m
			}
			return null
		}, t.prototype.render = function() {
			if (this._effectBase.isReady() && this._effectFog.isReady() && this._spriteTexture && this._spriteTexture.isReady()) {
				for (var t = this._scene.getEngine(), i = this._spriteTexture.getBaseSize(), r = t.getDeltaTime(), n = Math.min(this._capacity, this.sprites.length), o = i.width / this.cellWidth, s = 0, a = 0; a < n; a++) {
					var h = this.sprites[a];
					h && (h._animate(r), this._appendSpriteVertex(s++, h, 0, 0, o), this._appendSpriteVertex(s++, h, 1, 0, o), this._appendSpriteVertex(s++, h, 1, 1, o), this._appendSpriteVertex(s++, h, 0, 1, o))
				}
				this._buffer.update(this._vertexData);
				var c = this._effectBase;
				this._scene.fogEnabled && this._scene.fogMode !== e.Scene.FOGMODE_NONE && this.fogEnabled && (c = this._effectFog), t.enableEffect(c);
				var l = this._scene.getViewMatrix();
				c.setTexture("diffuseSampler", this._spriteTexture), c.setMatrix("view", l), c.setMatrix("projection", this._scene.getProjectionMatrix()), c.setFloat2("textureInfos", this.cellWidth / i.width, this.cellHeight / i.height), this._scene.fogEnabled && this._scene.fogMode !== e.Scene.FOGMODE_NONE && this.fogEnabled && (c.setFloat4("vFogInfos", this._scene.fogMode, this._scene.fogStart, this._scene.fogEnd, this._scene.fogDensity), c.setColor3("vFogColor", this._scene.fogColor)), t.bindBuffers(this._vertexBuffers, this._indexBuffer, c), t.setDepthFunctionToLessOrEqual(), c.setBool("alphaTest", !0), t.setColorWrite(!1), t.draw(!0, 0, 6 * n), t.setColorWrite(!0), c.setBool("alphaTest", !1), t.setAlphaMode(e.Engine.ALPHA_COMBINE), t.draw(!0, 0, 6 * n), t.setAlphaMode(e.Engine.ALPHA_DISABLE)
			}
		}, t.prototype.dispose = function() {
			this._buffer && (this._buffer.dispose(), this._buffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this._spriteTexture && (this._spriteTexture.dispose(), this._spriteTexture = null);
			var e = this._scene.spriteManagers.indexOf(this);
			this._scene.spriteManagers.splice(e, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear()
		}, t
	})();
	e.SpriteManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			this.name = t, this.color = new e.Color4(1, 1, 1, 1), this.width = 1, this.height = 1, this.angle = 0, this.cellIndex = 0, this.invertU = 0, this.invertV = 0, this.animations = new Array, this.isPickable = !1, this._animationStarted = !1, this._loopAnimation = !1, this._fromIndex = 0, this._toIndex = 0, this._delay = 0, this._direction = 1, this._frameCount = 0, this._time = 0, this._manager = i, this._manager.sprites.push(this), this.position = e.Vector3.Zero()
		}
		return Object.defineProperty(t.prototype, "size", {
			get: function() {
				return this.width
			},
			set: function(e) {
				this.width = e, this.height = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.playAnimation = function(e, t, i, r, n) {
			this._fromIndex = e, this._toIndex = t, this._loopAnimation = i, this._delay = r, this._animationStarted = !0, this._direction = e < t ? 1 : -1, this.cellIndex = e, this._time = 0, this._onAnimationEnd = n
		}, t.prototype.stopAnimation = function() {
			this._animationStarted = !1
		}, t.prototype._animate = function(e) {
			this._animationStarted && (this._time += e, this._time > this._delay && (this._time = this._time % this._delay, this.cellIndex += this._direction, this.cellIndex === this._toIndex && (this._loopAnimation ? this.cellIndex = this._fromIndex : (this._animationStarted = !1, this._onAnimationEnd && this._onAnimationEnd(), this.disposeWhenFinishedAnimating && this.dispose()))))
		}, t.prototype.dispose = function() {
			for (var e = 0; e < this._manager.sprites.length; e++) this._manager.sprites[e] == this && this._manager.sprites.splice(e, 1)
		}, t
	})();
	e.Sprite = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o) {
			this.name = t, this.scale = new e.Vector2(1, 1), this.offset = new e.Vector2(0, 0), this.alphaBlendingMode = e.Engine.ALPHA_COMBINE, this._vertexBuffers = {}, this.onDisposeObservable = new e.Observable, this.onBeforeRenderObservable = new e.Observable, this.onAfterRenderObservable = new e.Observable, this.texture = i ? new e.Texture(i, r, (!0)) : null, this.isBackground = void 0 === n || n, this.color = void 0 === o ? new e.Color4(1, 1, 1, 1) : o, this._scene = r, this._scene.layers.push(this);
			var s = r.getEngine(),
				a = [];
			a.push(1, 1), a.push(-1, 1), a.push(-1, -1), a.push(1, -1);
			var h = new e.VertexBuffer(s, a, e.VertexBuffer.PositionKind, (!1), (!1), 2);
			this._vertexBuffers[e.VertexBuffer.PositionKind] = h;
			var c = [];
			c.push(0), c.push(1), c.push(2), c.push(0), c.push(2), c.push(3), this._indexBuffer = s.createIndexBuffer(c), this._effect = s.createEffect("layer", [e.VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], ""), this._alphaTestEffect = s.createEffect("layer", [e.VertexBuffer.PositionKind], ["textureMatrix", "color", "scale", "offset"], ["textureSampler"], "#define ALPHATEST")
		}
		return Object.defineProperty(t.prototype, "onDispose", {
			set: function(e) {
				this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onBeforeRender", {
			set: function(e) {
				this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onAfterRender", {
			set: function(e) {
				this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.render = function() {
			var t = this.alphaTest ? this._alphaTestEffect : this._effect;
			if (t.isReady() && this.texture && this.texture.isReady()) {
				var i = this._scene.getEngine();
				this.onBeforeRenderObservable.notifyObservers(this), i.enableEffect(t), i.setState(!1), t.setTexture("textureSampler", this.texture), t.setMatrix("textureMatrix", this.texture.getTextureMatrix()), t.setFloat4("color", this.color.r, this.color.g, this.color.b, this.color.a), t.setVector2("offset", this.offset), t.setVector2("scale", this.scale), i.bindBuffers(this._vertexBuffers, this._indexBuffer, t), this.alphaTest ? i.draw(!0, 0, 6) : (i.setAlphaMode(this.alphaBlendingMode), i.draw(!0, 0, 6), i.setAlphaMode(e.Engine.ALPHA_DISABLE)), this.onAfterRenderObservable.notifyObservers(this)
			}
		}, t.prototype.dispose = function() {
			var t = this._vertexBuffers[e.VertexBuffer.PositionKind];
			t && (t.dispose(), this._vertexBuffers[e.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this.texture && (this.texture.dispose(), this.texture = null);
			var i = this._scene.layers.indexOf(this);
			this._scene.layers.splice(i, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderObservable.clear()
		}, t
	})();
	e.Layer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this.position = e.Vector3.Zero(), this.direction = e.Vector3.Zero(), this.color = new e.Color4(0, 0, 0, 0), this.colorStep = new e.Color4(0, 0, 0, 0), this.lifeTime = 1, this.age = 0, this.size = 0, this.angle = 0, this.angularSpeed = 0
		}
		return t.prototype.copyTo = function(e) {
			e.position.copyFrom(this.position), e.direction.copyFrom(this.direction), e.color.copyFrom(this.color), e.colorStep.copyFrom(this.colorStep), e.lifeTime = this.lifeTime, e.age = this.age, e.size = this.size, e.angle = this.angle, e.angularSpeed = this.angularSpeed
		}, t
	})();
	e.Particle = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = function(e, t) {
			if (e === t) return e;
			var i = Math.random();
			return i * (t - e) + e
		},
		i = (function() {
			function i(r, n, o, s) {
				var a = this;
				this.name = r, this.animations = [], this.renderingGroupId = 0, this.emitter = null, this.emitRate = 10, this.manualEmitCount = -1, this.updateSpeed = .01, this.targetStopDuration = 0, this.disposeOnStop = !1, this.minEmitPower = 1, this.maxEmitPower = 1, this.minLifeTime = 1, this.maxLifeTime = 1, this.minSize = 1, this.maxSize = 1, this.minAngularSpeed = 0, this.maxAngularSpeed = 0, this.layerMask = 268435455, this.onDisposeObservable = new e.Observable, this.blendMode = i.BLENDMODE_ONEONE, this.forceDepthWrite = !1, this.gravity = e.Vector3.Zero(), this.direction1 = new e.Vector3(0, 1, 0), this.direction2 = new e.Vector3(0, 1, 0), this.minEmitBox = new e.Vector3((-.5), (-.5), (-.5)), this.maxEmitBox = new e.Vector3(.5, .5, .5), this.color1 = new e.Color4(1, 1, 1, 1), this.color2 = new e.Color4(1, 1, 1, 1), this.colorDead = new e.Color4(0, 0, 0, 1), this.textureMask = new e.Color4(1, 1, 1, 1), this.particles = new Array, this._stockParticles = new Array, this._newPartsExcess = 0, this._vertexBuffers = {}, this._scaledColorStep = new e.Color4(0, 0, 0, 0), this._colorDiff = new e.Color4(0, 0, 0, 0), this._scaledDirection = e.Vector3.Zero(), this._scaledGravity = e.Vector3.Zero(), this._currentRenderId = -1, this._started = !1, this._stopped = !1, this._actualFrame = 0, this.id = r, this._capacity = n, this._scene = o, this._customEffect = s, o.particleSystems.push(this);
				for (var h = [], c = 0, l = 0; l < n; l++) h.push(c), h.push(c + 1), h.push(c + 2), h.push(c), h.push(c + 2), h.push(c + 3), c += 4;
				this._indexBuffer = o.getEngine().createIndexBuffer(h), this._vertexData = new Float32Array(11 * n * 4), this._vertexBuffer = new e.Buffer(o.getEngine(), this._vertexData, (!0), 11);
				var u = this._vertexBuffer.createVertexBuffer(e.VertexBuffer.PositionKind, 0, 3),
					d = this._vertexBuffer.createVertexBuffer(e.VertexBuffer.ColorKind, 3, 4),
					f = this._vertexBuffer.createVertexBuffer("options", 7, 4);
				this._vertexBuffers[e.VertexBuffer.PositionKind] = u, this._vertexBuffers[e.VertexBuffer.ColorKind] = d, this._vertexBuffers.options = f, this.startDirectionFunction = function(i, r, n, o) {
					var s = t(a.direction1.x, a.direction2.x),
						h = t(a.direction1.y, a.direction2.y),
						c = t(a.direction1.z, a.direction2.z);
					e.Vector3.TransformNormalFromFloatsToRef(s * i, h * i, c * i, r, n)
				}, this.startPositionFunction = function(i, r, n) {
					var o = t(a.minEmitBox.x, a.maxEmitBox.x),
						s = t(a.minEmitBox.y, a.maxEmitBox.y),
						h = t(a.minEmitBox.z, a.maxEmitBox.z);
					e.Vector3.TransformCoordinatesFromFloatsToRef(o, s, h, i, r);
				}, this.updateFunction = function(e) {
					for (var t = 0; t < e.length; t++) {
						var i = e[t];
						i.age += a._scaledUpdateSpeed, i.age >= i.lifeTime ? (a.recycleParticle(i), t--) : (i.colorStep.scaleToRef(a._scaledUpdateSpeed, a._scaledColorStep), i.color.addInPlace(a._scaledColorStep), i.color.a < 0 && (i.color.a = 0), i.angle += i.angularSpeed * a._scaledUpdateSpeed, i.direction.scaleToRef(a._scaledUpdateSpeed, a._scaledDirection), i.position.addInPlace(a._scaledDirection), a.gravity.scaleToRef(a._scaledUpdateSpeed, a._scaledGravity), i.direction.addInPlace(a._scaledGravity))
					}
				}
			}
			return Object.defineProperty(i.prototype, "onDispose", {
				set: function(e) {
					this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e)
				},
				enumerable: !0,
				configurable: !0
			}), i.prototype.recycleParticle = function(e) {
				var t = this.particles.pop();
				t !== e && (t.copyTo(e), this._stockParticles.push(t))
			}, i.prototype.getCapacity = function() {
				return this._capacity
			}, i.prototype.isAlive = function() {
				return this._alive
			}, i.prototype.isStarted = function() {
				return this._started
			}, i.prototype.start = function() {
				this._started = !0, this._stopped = !1, this._actualFrame = 0
			}, i.prototype.stop = function() {
				this._stopped = !0
			}, i.prototype._appendParticleVertex = function(e, t, i, r) {
				var n = 11 * e;
				this._vertexData[n] = t.position.x, this._vertexData[n + 1] = t.position.y, this._vertexData[n + 2] = t.position.z, this._vertexData[n + 3] = t.color.r, this._vertexData[n + 4] = t.color.g, this._vertexData[n + 5] = t.color.b, this._vertexData[n + 6] = t.color.a, this._vertexData[n + 7] = t.angle, this._vertexData[n + 8] = t.size, this._vertexData[n + 9] = i, this._vertexData[n + 10] = r
			}, i.prototype._update = function(i) {
				this._alive = this.particles.length > 0, this.updateFunction(this.particles);
				var r;
				r = this.emitter.position ? this.emitter.getWorldMatrix() : e.Matrix.Translation(this.emitter.x, this.emitter.y, this.emitter.z);
				for (var n, o = 0; o < i && this.particles.length !== this._capacity; o++) {
					0 !== this._stockParticles.length ? (n = this._stockParticles.pop(), n.age = 0) : n = new e.Particle, this.particles.push(n);
					var s = t(this.minEmitPower, this.maxEmitPower);
					this.startDirectionFunction(s, r, n.direction, n), n.lifeTime = t(this.minLifeTime, this.maxLifeTime), n.size = t(this.minSize, this.maxSize), n.angularSpeed = t(this.minAngularSpeed, this.maxAngularSpeed), this.startPositionFunction(r, n.position, n);
					var a = t(0, 1);
					e.Color4.LerpToRef(this.color1, this.color2, a, n.color), this.colorDead.subtractToRef(n.color, this._colorDiff), this._colorDiff.scaleToRef(1 / n.lifeTime, n.colorStep)
				}
			}, i.prototype._getEffect = function() {
				if (this._customEffect) return this._customEffect;
				var t = [];
				this._scene.clipPlane && t.push("#define CLIPPLANE");
				var i = t.join("\n");
				return this._cachedDefines !== i && (this._cachedDefines = i, this._effect = this._scene.getEngine().createEffect("particles", [e.VertexBuffer.PositionKind, e.VertexBuffer.ColorKind, "options"], ["invView", "view", "projection", "vClipPlane", "textureMask"], ["diffuseSampler"], i)), this._effect
			}, i.prototype.animate = function() {
				if (this._started) {
					var e = this._getEffect();
					if (this.emitter && e.isReady() && this.particleTexture && this.particleTexture.isReady() && this._currentRenderId !== this._scene.getRenderId()) {
						this._currentRenderId = this._scene.getRenderId(), this._scaledUpdateSpeed = this.updateSpeed * this._scene.getAnimationRatio();
						var t;
						this.manualEmitCount > -1 ? (t = this.manualEmitCount, this._newPartsExcess = 0, this.manualEmitCount = 0) : (t = this.emitRate * this._scaledUpdateSpeed >> 0, this._newPartsExcess += this.emitRate * this._scaledUpdateSpeed - t), this._newPartsExcess > 1 && (t += this._newPartsExcess >> 0, this._newPartsExcess -= this._newPartsExcess >> 0), this._alive = !1, this._stopped ? t = 0 : (this._actualFrame += this._scaledUpdateSpeed, this.targetStopDuration && this._actualFrame >= this.targetStopDuration && this.stop()), this._update(t), this._stopped && (this._alive || (this._started = !1, this.disposeOnStop && this._scene._toBeDisposed.push(this)));
						for (var i = 0, r = 0; r < this.particles.length; r++) {
							var n = this.particles[r];
							this._appendParticleVertex(i++, n, 0, 0), this._appendParticleVertex(i++, n, 1, 0), this._appendParticleVertex(i++, n, 1, 1), this._appendParticleVertex(i++, n, 0, 1)
						}
						this._vertexBuffer.update(this._vertexData)
					}
				}
			}, i.prototype.render = function() {
				var t = this._getEffect();
				if (!(this.emitter && t.isReady() && this.particleTexture && this.particleTexture.isReady() && this.particles.length)) return 0;
				var r = this._scene.getEngine();
				r.enableEffect(t), r.setState(!1);
				var n = this._scene.getViewMatrix();
				if (t.setTexture("diffuseSampler", this.particleTexture), t.setMatrix("view", n), t.setMatrix("projection", this._scene.getProjectionMatrix()), t.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a), this._scene.clipPlane) {
					var o = this._scene.clipPlane,
						s = n.clone();
					s.invert(), t.setMatrix("invView", s), t.setFloat4("vClipPlane", o.normal.x, o.normal.y, o.normal.z, o.d)
				}
				return r.bindBuffers(this._vertexBuffers, this._indexBuffer, t), this.blendMode === i.BLENDMODE_ONEONE ? r.setAlphaMode(e.Engine.ALPHA_ONEONE) : r.setAlphaMode(e.Engine.ALPHA_COMBINE), this.forceDepthWrite && r.setDepthWrite(!0), r.draw(!0, 0, 6 * this.particles.length), r.setAlphaMode(e.Engine.ALPHA_DISABLE), this.particles.length
			}, i.prototype.dispose = function() {
				this._vertexBuffer && (this._vertexBuffer.dispose(), this._vertexBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this.particleTexture && (this.particleTexture.dispose(), this.particleTexture = null);
				var e = this._scene.particleSystems.indexOf(this);
				this._scene.particleSystems.splice(e, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear()
			}, i.prototype.clone = function(t, r) {
				var n = new i(t, this._capacity, this._scene);
				return e.Tools.DeepCopy(this, n, ["particles"]), void 0 === r && (r = this.emitter), n.emitter = r, this.particleTexture && (n.particleTexture = new e.Texture(this.particleTexture.url, this._scene)), n.start(), n
			}, i.prototype.serialize = function() {
				var t = {};
				return t.name = this.name, t.id = this.id, this.emitter.position ? t.emitterId = this.emitter.id : t.emitter = this.emitter.asArray(), t.capacity = this.getCapacity(), this.particleTexture && (t.textureName = this.particleTexture.name), e.Animation.AppendSerializedAnimations(this, t), t.minAngularSpeed = this.minAngularSpeed, t.maxAngularSpeed = this.maxAngularSpeed, t.minSize = this.minSize, t.maxSize = this.maxSize, t.minEmitPower = this.minEmitPower, t.maxEmitPower = this.maxEmitPower, t.minLifeTime = this.minLifeTime, t.maxLifeTime = this.maxLifeTime, t.emitRate = this.emitRate, t.minEmitBox = this.minEmitBox.asArray(), t.maxEmitBox = this.maxEmitBox.asArray(), t.gravity = this.gravity.asArray(), t.direction1 = this.direction1.asArray(), t.direction2 = this.direction2.asArray(), t.color1 = this.color1.asArray(), t.color2 = this.color2.asArray(), t.colorDead = this.colorDead.asArray(), t.updateSpeed = this.updateSpeed, t.targetStopDuration = this.targetStopDuration, t.textureMask = this.textureMask.asArray(), t.blendMode = this.blendMode, t
			}, i.Parse = function(t, r, n) {
				var o = t.name,
					s = new i(o, t.capacity, r);
				if (t.id && (s.id = t.id), t.textureName && (s.particleTexture = new e.Texture(n + t.textureName, r), s.particleTexture.name = t.textureName), t.emitterId ? s.emitter = r.getLastMeshByID(t.emitterId) : s.emitter = e.Vector3.FromArray(t.emitter), t.animations)
					for (var a = 0; a < t.animations.length; a++) {
						var h = t.animations[a];
						s.animations.push(e.Animation.Parse(h))
					}
				return t.autoAnimate && r.beginAnimation(s, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), s.minAngularSpeed = t.minAngularSpeed, s.maxAngularSpeed = t.maxAngularSpeed, s.minSize = t.minSize, s.maxSize = t.maxSize, s.minLifeTime = t.minLifeTime, s.maxLifeTime = t.maxLifeTime, s.minEmitPower = t.minEmitPower, s.maxEmitPower = t.maxEmitPower, s.emitRate = t.emitRate, s.minEmitBox = e.Vector3.FromArray(t.minEmitBox), s.maxEmitBox = e.Vector3.FromArray(t.maxEmitBox), s.gravity = e.Vector3.FromArray(t.gravity), s.direction1 = e.Vector3.FromArray(t.direction1), s.direction2 = e.Vector3.FromArray(t.direction2), s.color1 = e.Color4.FromArray(t.color1), s.color2 = e.Color4.FromArray(t.color2), s.colorDead = e.Color4.FromArray(t.colorDead), s.updateSpeed = t.updateSpeed, s.targetStopDuration = t.targetStopDuration, s.textureMask = e.Color4.FromArray(t.textureMask), s.blendMode = t.blendMode, t.preventAutoStart || s.start(), s
			}, i.BLENDMODE_ONEONE = 0, i.BLENDMODE_STANDARD = 1, i
		})();
	e.ParticleSystem = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t, i) {
			this.name = e, this.from = t, this.to = i
		}
		return e.prototype.clone = function() {
			return new e(this.name, this.from, this.to)
		}, e
	})();
	e.AnimationRange = t;
	var i = (function() {
		function e(e, t, i) {
			this.frame = e, this.action = t, this.onlyOnce = i, this.isDone = !1
		}
		return e
	})();
	e.AnimationEvent = i;
	var r = (function() {
		function t(e) {
			this.path = e, this._onchange = new Array, this.value = 0, this.animations = new Array
		}
		return t.prototype.getPoint = function() {
			var t = this.path.getPointAtLengthPosition(this.value);
			return new e.Vector3(t.x, 0, t.y)
		}, t.prototype.moveAhead = function(e) {
			return void 0 === e && (e = .002), this.move(e), this
		}, t.prototype.moveBack = function(e) {
			return void 0 === e && (e = .002), this.move(-e), this
		}, t.prototype.move = function(e) {
			if (Math.abs(e) > 1) throw "step size should be less than 1.";
			return this.value += e, this.ensureLimits(), this.raiseOnChange(), this
		}, t.prototype.ensureLimits = function() {
			for (; this.value > 1;) this.value -= 1;
			for (; this.value < 0;) this.value += 1;
			return this
		}, t.prototype.markAsDirty = function(e) {
			return this.ensureLimits(), this.raiseOnChange(), this
		}, t.prototype.raiseOnChange = function() {
			var e = this;
			return this._onchange.forEach((function(t) {
				return t(e)
			})), this
		}, t.prototype.onchange = function(e) {
			return this._onchange.push(e), this
		}, t
	})();
	e.PathCursor = r;
	var n = (function() {
		function i(e, t, r, n, o, s) {
			this.name = e, this.targetProperty = t, this.framePerSecond = r, this.dataType = n, this.loopMode = o, this.enableBlending = s, this._offsetsCache = {}, this._highLimitsCache = {}, this._stopped = !1, this._blendingFactor = 0, this._events = new Array, this.allowMatricesInterpolation = !1, this.blendingSpeed = .01, this._ranges = {}, this.targetPropertyPath = t.split("."), this.dataType = n, this.loopMode = void 0 === o ? i.ANIMATIONLOOPMODE_CYCLE : o
		}
		return i._PrepareAnimation = function(t, r, n, o, s, a, h, c) {
			var l = void 0;
			if (!isNaN(parseFloat(s)) && isFinite(s) ? l = i.ANIMATIONTYPE_FLOAT : s instanceof e.Quaternion ? l = i.ANIMATIONTYPE_QUATERNION : s instanceof e.Vector3 ? l = i.ANIMATIONTYPE_VECTOR3 : s instanceof e.Vector2 ? l = i.ANIMATIONTYPE_VECTOR2 : s instanceof e.Color3 ? l = i.ANIMATIONTYPE_COLOR3 : s instanceof e.Size && (l = i.ANIMATIONTYPE_SIZE), void 0 == l) return null;
			var u = new i(t, r, n, l, h),
				d = [{
					frame: 0,
					value: s
				}, {
					frame: o,
					value: a
				}];
			return u.setKeys(d), void 0 !== c && u.setEasingFunction(c), u
		}, i.CreateAndStartAnimation = function(e, t, r, n, o, s, a, h, c, l) {
			var u = i._PrepareAnimation(e, r, n, o, s, a, h, c);
			return t.getScene().beginDirectAnimation(t, [u], 0, o, 1 === u.loopMode, 1, l)
		}, i.CreateMergeAndStartAnimation = function(e, t, r, n, o, s, a, h, c, l) {
			var u = i._PrepareAnimation(e, r, n, o, s, a, h, c);
			return t.animations.push(u), t.getScene().beginAnimation(t, 0, o, 1 === u.loopMode, 1, l)
		}, i.prototype.toString = function(e) {
			var t = "Name: " + this.name + ", property: " + this.targetProperty;
			if (t += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType], t += ", nKeys: " + (this._keys ? this._keys.length : "none"), t += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none"), e) {
				t += ", Ranges: {";
				var i = !0;
				for (var r in this._ranges) i && (t += ", ", i = !1), t += r;
				t += "}"
			}
			return t
		}, i.prototype.addEvent = function(e) {
			this._events.push(e)
		}, i.prototype.removeEvents = function(e) {
			for (var t = 0; t < this._events.length; t++) this._events[t].frame === e && (this._events.splice(t, 1), t--)
		}, i.prototype.createRange = function(e, i, r) {
			this._ranges[e] || (this._ranges[e] = new t(e, i, r))
		}, i.prototype.deleteRange = function(e, t) {
			if (void 0 === t && (t = !0), this._ranges[e]) {
				if (t)
					for (var i = this._ranges[e].from, r = this._ranges[e].to, n = this._keys.length - 1; n >= 0; n--) this._keys[n].frame >= i && this._keys[n].frame <= r && this._keys.splice(n, 1);
				this._ranges[e] = void 0
			}
		}, i.prototype.getRange = function(e) {
			return this._ranges[e]
		}, i.prototype.reset = function() {
			this._offsetsCache = {}, this._highLimitsCache = {}, this.currentFrame = 0, this._blendingFactor = 0, this._originalBlendValue = null
		}, i.prototype.isStopped = function() {
			return this._stopped
		}, i.prototype.getKeys = function() {
			return this._keys
		}, i.prototype.getHighestFrame = function() {
			for (var e = 0, t = 0, i = this._keys.length; t < i; t++) e < this._keys[t].frame && (e = this._keys[t].frame);
			return e
		}, i.prototype.getEasingFunction = function() {
			return this._easingFunction
		}, i.prototype.setEasingFunction = function(e) {
			this._easingFunction = e
		}, i.prototype.floatInterpolateFunction = function(e, t, i) {
			return e + (t - e) * i
		}, i.prototype.quaternionInterpolateFunction = function(t, i, r) {
			return e.Quaternion.Slerp(t, i, r)
		}, i.prototype.vector3InterpolateFunction = function(t, i, r) {
			return e.Vector3.Lerp(t, i, r)
		}, i.prototype.vector2InterpolateFunction = function(t, i, r) {
			return e.Vector2.Lerp(t, i, r)
		}, i.prototype.sizeInterpolateFunction = function(t, i, r) {
			return e.Size.Lerp(t, i, r)
		}, i.prototype.color3InterpolateFunction = function(t, i, r) {
			return e.Color3.Lerp(t, i, r)
		}, i.prototype.matrixInterpolateFunction = function(t, i, r) {
			return e.Matrix.Lerp(t, i, r)
		}, i.prototype.clone = function() {
			var e = new i(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
			if (this._keys && e.setKeys(this._keys), this._ranges) {
				e._ranges = {};
				for (var t in this._ranges) e._ranges[t] = this._ranges[t].clone()
			}
			return e
		}, i.prototype.setKeys = function(e) {
			this._keys = e.slice(0), this._offsetsCache = {}, this._highLimitsCache = {}
		}, i.prototype._getKeyValue = function(e) {
			return "function" == typeof e ? e() : e
		}, i.prototype._interpolate = function(e, t, r, n, o) {
			if (r === i.ANIMATIONLOOPMODE_CONSTANT && t > 0) return o.clone ? o.clone() : o;
			this.currentFrame = e;
			var s = Math.max(0, Math.min(this._keys.length - 1, Math.floor(this._keys.length * (e - this._keys[0].frame) / (this._keys[this._keys.length - 1].frame - this._keys[0].frame)) - 1));
			if (this._keys[s].frame >= e)
				for (; s - 1 >= 0 && this._keys[s].frame >= e;) s--;
			for (var a = s; a < this._keys.length; a++)
				if (this._keys[a + 1].frame >= e) {
					var h = this._getKeyValue(this._keys[a].value),
						c = this._getKeyValue(this._keys[a + 1].value),
						l = (e - this._keys[a].frame) / (this._keys[a + 1].frame - this._keys[a].frame);
					switch (null != this._easingFunction && (l = this._easingFunction.ease(l)), this.dataType) {
						case i.ANIMATIONTYPE_FLOAT:
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									return this.floatInterpolateFunction(h, c, l);
								case i.ANIMATIONLOOPMODE_RELATIVE:
									return n * t + this.floatInterpolateFunction(h, c, l)
							}
							break;
						case i.ANIMATIONTYPE_QUATERNION:
							var u = null;
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									u = this.quaternionInterpolateFunction(h, c, l);
									break;
								case i.ANIMATIONLOOPMODE_RELATIVE:
									u = this.quaternionInterpolateFunction(h, c, l).add(n.scale(t))
							}
							return u;
						case i.ANIMATIONTYPE_VECTOR3:
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									return this.vector3InterpolateFunction(h, c, l);
								case i.ANIMATIONLOOPMODE_RELATIVE:
									return this.vector3InterpolateFunction(h, c, l).add(n.scale(t))
							}
						case i.ANIMATIONTYPE_VECTOR2:
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									return this.vector2InterpolateFunction(h, c, l);
								case i.ANIMATIONLOOPMODE_RELATIVE:
									return this.vector2InterpolateFunction(h, c, l).add(n.scale(t))
							}
						case i.ANIMATIONTYPE_SIZE:
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									return this.sizeInterpolateFunction(h, c, l);
								case i.ANIMATIONLOOPMODE_RELATIVE:
									return this.sizeInterpolateFunction(h, c, l).add(n.scale(t))
							}
						case i.ANIMATIONTYPE_COLOR3:
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									return this.color3InterpolateFunction(h, c, l);
								case i.ANIMATIONLOOPMODE_RELATIVE:
									return this.color3InterpolateFunction(h, c, l).add(n.scale(t))
							}
						case i.ANIMATIONTYPE_MATRIX:
							switch (r) {
								case i.ANIMATIONLOOPMODE_CYCLE:
								case i.ANIMATIONLOOPMODE_CONSTANT:
									if (this.allowMatricesInterpolation) return this.matrixInterpolateFunction(h, c, l);
								case i.ANIMATIONLOOPMODE_RELATIVE:
									return h
							}
					}
					break
				}
			return this._getKeyValue(this._keys[this._keys.length - 1].value)
		}, i.prototype.setValue = function(t, i) {
			void 0 === i && (i = !1);
			var r, n;
			if (this.targetPropertyPath.length > 1) {
				for (var o = this._target[this.targetPropertyPath[0]], s = 1; s < this.targetPropertyPath.length - 1; s++) o = o[this.targetPropertyPath[s]];
				r = this.targetPropertyPath[this.targetPropertyPath.length - 1], n = o
			} else r = this.targetPropertyPath[0], n = this._target;
			this.enableBlending && this._blendingFactor <= 1 ? (this._originalBlendValue || (n[r].clone ? this._originalBlendValue = n[r].clone() : this._originalBlendValue = n[r]), this._originalBlendValue.prototype ? this._originalBlendValue.prototype.Lerp ? n[r] = this._originalBlendValue.construtor.prototype.Lerp(t, this._originalBlendValue, this._blendingFactor) : n[r] = t : this._originalBlendValue.m ? n[r] = e.Matrix.Lerp(this._originalBlendValue, t, this._blendingFactor) : n[r] = this._originalBlendValue * (1 - this._blendingFactor) + this._blendingFactor * t, this._blendingFactor += this.blendingSpeed) : n[r] = t, this._target.markAsDirty && this._target.markAsDirty(this.targetProperty)
		}, i.prototype.goToFrame = function(e) {
			e < this._keys[0].frame ? e = this._keys[0].frame : e > this._keys[this._keys.length - 1].frame && (e = this._keys[this._keys.length - 1].frame);
			var t = this._interpolate(e, 0, this.loopMode);
			this.setValue(t)
		}, i.prototype.animate = function(t, r, n, o, s, a) {
			if (void 0 === a && (a = !1), !this.targetPropertyPath || this.targetPropertyPath.length < 1) return this._stopped = !0, !1;
			var h = !0;
			if (0 !== this._keys[0].frame) {
				var c = {
					frame: 0,
					value: this._keys[0].value
				};
				this._keys.splice(0, 0, c)
			}(r < this._keys[0].frame || r > this._keys[this._keys.length - 1].frame) && (r = this._keys[0].frame), (n < this._keys[0].frame || n > this._keys[this._keys.length - 1].frame) && (n = this._keys[this._keys.length - 1].frame), r === n && r++;
			var l, u = n - r,
				d = t * (this.framePerSecond * s) / 1e3,
				f = 0;
			if (d > u && !o) h = !1, f = this._getKeyValue(this._keys[this._keys.length - 1].value);
			else if (this.loopMode !== i.ANIMATIONLOOPMODE_CYCLE) {
				var p = n.toString() + r.toString();
				if (!this._offsetsCache[p]) {
					var m = this._interpolate(r, 0, i.ANIMATIONLOOPMODE_CYCLE),
						_ = this._interpolate(n, 0, i.ANIMATIONLOOPMODE_CYCLE);
					switch (this.dataType) {
						case i.ANIMATIONTYPE_FLOAT:
							this._offsetsCache[p] = _ - m;
							break;
						case i.ANIMATIONTYPE_QUATERNION:
							this._offsetsCache[p] = _.subtract(m);
							break;
						case i.ANIMATIONTYPE_VECTOR3:
							this._offsetsCache[p] = _.subtract(m);
						case i.ANIMATIONTYPE_VECTOR2:
							this._offsetsCache[p] = _.subtract(m);
						case i.ANIMATIONTYPE_SIZE:
							this._offsetsCache[p] = _.subtract(m);
						case i.ANIMATIONTYPE_COLOR3:
							this._offsetsCache[p] = _.subtract(m)
					}
					this._highLimitsCache[p] = _
				}
				f = this._highLimitsCache[p], l = this._offsetsCache[p]
			}
			if (void 0 === l) switch (this.dataType) {
				case i.ANIMATIONTYPE_FLOAT:
					l = 0;
					break;
				case i.ANIMATIONTYPE_QUATERNION:
					l = new e.Quaternion(0, 0, 0, 0);
					break;
				case i.ANIMATIONTYPE_VECTOR3:
					l = e.Vector3.Zero();
					break;
				case i.ANIMATIONTYPE_VECTOR2:
					l = e.Vector2.Zero();
					break;
				case i.ANIMATIONTYPE_SIZE:
					l = e.Size.Zero();
					break;
				case i.ANIMATIONTYPE_COLOR3:
					l = e.Color3.Black()
			}
			var g = d / u >> 0,
				v = h ? r + d % u : n,
				y = this._interpolate(v, g, this.loopMode, l, f);
			this.setValue(y);
			for (var x = 0; x < this._events.length; x++)
				if (v >= this._events[x].frame) {
					var b = this._events[x];
					b.isDone || (b.onlyOnce && (this._events.splice(x, 1), x--), b.isDone = !0, b.action())
				} else this._events[x].isDone && !this._events[x].onlyOnce && (this._events[x].isDone = !1);
			return h || (this._stopped = !0), h
		}, i.prototype.serialize = function() {
			var e = {};
			e.name = this.name, e.property = this.targetProperty, e.framePerSecond = this.framePerSecond, e.dataType = this.dataType, e.loopBehavior = this.loopMode;
			var t = this.dataType;
			e.keys = [];
			for (var r = this.getKeys(), n = 0; n < r.length; n++) {
				var o = r[n],
					s = {};
				switch (s.frame = o.frame, t) {
					case i.ANIMATIONTYPE_FLOAT:
						s.values = [o.value];
						break;
					case i.ANIMATIONTYPE_QUATERNION:
					case i.ANIMATIONTYPE_MATRIX:
					case i.ANIMATIONTYPE_VECTOR3:
					case i.ANIMATIONTYPE_COLOR3:
						s.values = o.value.asArray()
				}
				e.keys.push(s)
			}
			e.ranges = [];
			for (var a in this._ranges) {
				var h = {};
				h.name = a, h.from = this._ranges[a].from, h.to = this._ranges[a].to, e.ranges.push(h)
			}
			return e
		}, Object.defineProperty(i, "ANIMATIONTYPE_FLOAT", {
			get: function() {
				return i._ANIMATIONTYPE_FLOAT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONTYPE_VECTOR3", {
			get: function() {
				return i._ANIMATIONTYPE_VECTOR3
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONTYPE_VECTOR2", {
			get: function() {
				return i._ANIMATIONTYPE_VECTOR2
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONTYPE_SIZE", {
			get: function() {
				return i._ANIMATIONTYPE_SIZE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONTYPE_QUATERNION", {
			get: function() {
				return i._ANIMATIONTYPE_QUATERNION
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONTYPE_MATRIX", {
			get: function() {
				return i._ANIMATIONTYPE_MATRIX
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONTYPE_COLOR3", {
			get: function() {
				return i._ANIMATIONTYPE_COLOR3
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONLOOPMODE_RELATIVE", {
			get: function() {
				return i._ANIMATIONLOOPMODE_RELATIVE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONLOOPMODE_CYCLE", {
			get: function() {
				return i._ANIMATIONLOOPMODE_CYCLE
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "ANIMATIONLOOPMODE_CONSTANT", {
			get: function() {
				return i._ANIMATIONLOOPMODE_CONSTANT
			},
			enumerable: !0,
			configurable: !0
		}), i.Parse = function(t) {
			var r, n, o = new i(t.name, t.property, t.framePerSecond, t.dataType, t.loopBehavior),
				s = t.dataType,
				a = [];
			for (n = 0; n < t.keys.length; n++) {
				var h = t.keys[n];
				switch (s) {
					case i.ANIMATIONTYPE_FLOAT:
						r = h.values[0];
						break;
					case i.ANIMATIONTYPE_QUATERNION:
						r = e.Quaternion.FromArray(h.values);
						break;
					case i.ANIMATIONTYPE_MATRIX:
						r = e.Matrix.FromArray(h.values);
						break;
					case i.ANIMATIONTYPE_COLOR3:
						r = e.Color3.FromArray(h.values);
						break;
					case i.ANIMATIONTYPE_VECTOR3:
					default:
						r = e.Vector3.FromArray(h.values)
				}
				a.push({
					frame: h.frame,
					value: r
				})
			}
			if (o.setKeys(a), t.ranges)
				for (n = 0; n < t.ranges.length; n++) r = t.ranges[n], o.createRange(r.name, r.from, r.to);
			return o
		}, i.AppendSerializedAnimations = function(e, t) {
			if (e.animations) {
				t.animations = [];
				for (var i = 0; i < e.animations.length; i++) {
					var r = e.animations[i];
					t.animations.push(r.serialize())
				}
			}
		}, i._ANIMATIONTYPE_FLOAT = 0, i._ANIMATIONTYPE_VECTOR3 = 1, i._ANIMATIONTYPE_QUATERNION = 2, i._ANIMATIONTYPE_MATRIX = 3, i._ANIMATIONTYPE_COLOR3 = 4, i._ANIMATIONTYPE_VECTOR2 = 5, i._ANIMATIONTYPE_SIZE = 6, i._ANIMATIONLOOPMODE_RELATIVE = 0, i._ANIMATIONLOOPMODE_CYCLE = 1, i._ANIMATIONLOOPMODE_CONSTANT = 2, i
	})();
	e.Animation = n
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t, i, r, n, o, s, a) {
			void 0 === i && (i = 0), void 0 === r && (r = 100), void 0 === n && (n = !1), void 0 === o && (o = 1), this.target = t, this.fromFrame = i, this.toFrame = r, this.loopAnimation = n, this.speedRatio = o, this.onAnimationEnd = s, this._animations = new Array, this._paused = !1, this.animationStarted = !1, a && this.appendAnimations(t, a), this._scene = e, e._activeAnimatables.push(this)
		}
		return e.prototype.getAnimations = function() {
			return this._animations
		}, e.prototype.appendAnimations = function(e, t) {
			for (var i = 0; i < t.length; i++) {
				var r = t[i];
				r._target = e, this._animations.push(r)
			}
		}, e.prototype.getAnimationByTargetProperty = function(e) {
			for (var t = this._animations, i = 0; i < t.length; i++)
				if (t[i].targetProperty === e) return t[i];
			return null
		}, e.prototype.reset = function() {
			for (var e = this._animations, t = 0; t < e.length; t++) e[t].reset();
			this._localDelayOffset = null, this._pausedDelay = null
		}, e.prototype.enableBlending = function(e) {
			for (var t = this._animations, i = 0; i < t.length; i++) t[i].enableBlending = !0, t[i].blendingSpeed = e
		}, e.prototype.disableBlending = function() {
			for (var e = this._animations, t = 0; t < e.length; t++) e[t].enableBlending = !1
		}, e.prototype.goToFrame = function(e) {
			var t = this._animations;
			if (t[0]) {
				var i = t[0].framePerSecond,
					r = t[0].currentFrame,
					n = e - r,
					o = 1e3 * n / i;
				this._localDelayOffset -= o
			}
			for (var s = 0; s < t.length; s++) t[s].goToFrame(e)
		}, e.prototype.pause = function() {
			this._paused || (this._paused = !0)
		}, e.prototype.restart = function() {
			this._paused = !1
		}, e.prototype.stop = function(e) {
			var t = this._scene._activeAnimatables.indexOf(this);
			if (t > -1) {
				for (var i = this._animations, r = 0, t = i.length - 1; t >= 0; t--) "string" == typeof e && i[t].name != e || (i[t].reset(), i.splice(t, 1), r++);
				i.length == r && (this._scene._activeAnimatables.splice(t, 1), this.onAnimationEnd && this.onAnimationEnd())
			}
		}, e.prototype._animate = function(e) {
			if (this._paused) return this.animationStarted = !1, this._pausedDelay || (this._pausedDelay = e), !0;
			this._localDelayOffset ? this._pausedDelay && (this._localDelayOffset += e - this._pausedDelay, this._pausedDelay = null) : this._localDelayOffset = e;
			var t, i = !1,
				r = this._animations;
			for (t = 0; t < r.length; t++) {
				var n = r[t],
					o = n.animate(e - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this.speedRatio);
				i = i || o
			}
			return this.animationStarted = i, i || (t = this._scene._activeAnimatables.indexOf(this), this._scene._activeAnimatables.splice(t, 1)), !i && this.onAnimationEnd && (this.onAnimationEnd(), this.onAnimationEnd = null), i
		}, e
	})();
	e.Animatable = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {
			this._easingMode = e.EASINGMODE_EASEIN
		}
		return Object.defineProperty(e, "EASINGMODE_EASEIN", {
			get: function() {
				return e._EASINGMODE_EASEIN
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e, "EASINGMODE_EASEOUT", {
			get: function() {
				return e._EASINGMODE_EASEOUT
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e, "EASINGMODE_EASEINOUT", {
			get: function() {
				return e._EASINGMODE_EASEINOUT
			},
			enumerable: !0,
			configurable: !0
		}), e.prototype.setEasingMode = function(e) {
			var t = Math.min(Math.max(e, 0), 2);
			this._easingMode = t
		}, e.prototype.getEasingMode = function() {
			return this._easingMode
		}, e.prototype.easeInCore = function(e) {
			throw new Error("You must implement this method")
		}, e.prototype.ease = function(t) {
			switch (this._easingMode) {
				case e.EASINGMODE_EASEIN:
					return this.easeInCore(t);
				case e.EASINGMODE_EASEOUT:
					return 1 - this.easeInCore(1 - t)
			}
			return t >= .5 ? .5 * (1 - this.easeInCore(2 * (1 - t))) + .5 : .5 * this.easeInCore(2 * t)
		}, e._EASINGMODE_EASEIN = 0, e._EASINGMODE_EASEOUT = 1, e._EASINGMODE_EASEINOUT = 2, e
	})();
	e.EasingFunction = t;
	var i = (function(e) {
		function t() {
			e.apply(this, arguments)
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return e = Math.max(0, Math.min(1, e)), 1 - Math.sqrt(1 - e * e)
		}, t
	})(t);
	e.CircleEase = i;
	var r = (function(e) {
		function t(t) {
			void 0 === t && (t = 1), e.call(this), this.amplitude = t
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			var t = Math.max(0, this.amplitude);
			return Math.pow(e, 3) - e * t * Math.sin(3.141592653589793 * e)
		}, t
	})(t);
	e.BackEase = r;
	var n = (function(e) {
		function t(t, i) {
			void 0 === t && (t = 3), void 0 === i && (i = 2), e.call(this), this.bounces = t, this.bounciness = i
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			var t = Math.max(0, this.bounces),
				i = this.bounciness;
			i <= 1 && (i = 1.001);
			var r = Math.pow(i, t),
				n = 1 - i,
				o = (1 - r) / n + .5 * r,
				s = e * o,
				a = Math.log(-s * (1 - i) + 1) / Math.log(i),
				h = Math.floor(a),
				c = h + 1,
				l = (1 - Math.pow(i, h)) / (n * o),
				u = (1 - Math.pow(i, c)) / (n * o),
				d = .5 * (l + u),
				f = e - d,
				p = d - l;
			return -Math.pow(1 / i, t - h) / (p * p) * (f - p) * (f + p)
		}, t
	})(t);
	e.BounceEase = n;
	var o = (function(e) {
		function t() {
			e.apply(this, arguments)
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return e * e * e
		}, t
	})(t);
	e.CubicEase = o;
	var s = (function(e) {
		function t(t, i) {
			void 0 === t && (t = 3), void 0 === i && (i = 3), e.call(this), this.oscillations = t, this.springiness = i
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			var t, i = Math.max(0, this.oscillations),
				r = Math.max(0, this.springiness);
			return t = 0 == r ? e : (Math.exp(r * e) - 1) / (Math.exp(r) - 1), t * Math.sin((6.283185307179586 * i + 1.5707963267948966) * e)
		}, t
	})(t);
	e.ElasticEase = s;
	var a = (function(e) {
		function t(t) {
			void 0 === t && (t = 2), e.call(this), this.exponent = t
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return this.exponent <= 0 ? e : (Math.exp(this.exponent * e) - 1) / (Math.exp(this.exponent) - 1)
		}, t
	})(t);
	e.ExponentialEase = a;
	var h = (function(e) {
		function t(t) {
			void 0 === t && (t = 2), e.call(this), this.power = t
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			var t = Math.max(0, this.power);
			return Math.pow(e, t)
		}, t
	})(t);
	e.PowerEase = h;
	var c = (function(e) {
		function t() {
			e.apply(this, arguments)
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return e * e
		}, t
	})(t);
	e.QuadraticEase = c;
	var l = (function(e) {
		function t() {
			e.apply(this, arguments)
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return e * e * e * e
		}, t
	})(t);
	e.QuarticEase = l;
	var u = (function(e) {
		function t() {
			e.apply(this, arguments)
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return e * e * e * e * e
		}, t
	})(t);
	e.QuinticEase = u;
	var d = (function(e) {
		function t() {
			e.apply(this, arguments)
		}
		return __extends(t, e), t.prototype.easeInCore = function(e) {
			return 1 - Math.sin(1.5707963267948966 * (1 - e))
		}, t
	})(t);
	e.SineEase = d;
	var f = (function(t) {
		function i(e, i, r, n) {
			void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === r && (r = 1), void 0 === n && (n = 1), t.call(this), this.x1 = e, this.y1 = i, this.x2 = r, this.y2 = n
		}
		return __extends(i, t), i.prototype.easeInCore = function(t) {
			return e.BezierCurve.interpolate(t, this.x1, this.y1, this.x2, this.y2)
		}, i
	})(t);
	e.BezierCurveEase = f
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			t.call(this, i, r.getScene()), this.name = i, this.children = new Array, this.animations = new Array, this._worldTransform = new e.Matrix, this._absoluteTransform = new e.Matrix, this._invertedAbsoluteTransform = new e.Matrix, this._scaleMatrix = e.Matrix.Identity(), this._scaleVector = new e.Vector3(1, 1, 1), this._negateScaleChildren = new e.Vector3(1, 1, 1), this._scalingDeterminant = 1, this._syncScaleVector = function() {
				var t = this.getLocalMatrix(),
					i = t.m[0] * t.m[0] + t.m[1] * t.m[1] + t.m[2] * t.m[2],
					r = t.m[4] * t.m[4] + t.m[5] * t.m[5] + t.m[6] * t.m[6],
					n = t.m[8] * t.m[8] + t.m[9] * t.m[9] + t.m[10] * t.m[10],
					o = t.m[0] * t.m[1] * t.m[2] * t.m[3] < 0 ? -1 : 1,
					s = t.m[4] * t.m[5] * t.m[6] * t.m[7] < 0 ? -1 : 1,
					a = t.m[8] * t.m[9] * t.m[10] * t.m[11] < 0 ? -1 : 1;
				this._scaleVector.x = o * Math.sqrt(i), this._scaleVector.y = s * Math.sqrt(r), this._scaleVector.z = a * Math.sqrt(n), this._parent && (this._scaleVector.x /= this._parent._negateScaleChildren.x, this._scaleVector.y /= this._parent._negateScaleChildren.y, this._scaleVector.z /= this._parent._negateScaleChildren.z), e.Matrix.FromValuesToRef(this._scaleVector.x, 0, 0, 0, 0, this._scaleVector.y, 0, 0, 0, 0, this._scaleVector.z, 0, 0, 0, 0, 1, this._scaleMatrix)
			}, this._skeleton = r, this._matrix = o, this._baseMatrix = o, this._restPose = s ? s : o.clone(), r.bones.push(this), n ? (this._parent = n, n.children.push(this)) : this._parent = null, this._updateDifferenceMatrix(), this.getAbsoluteTransform().determinant() < 0 && (this._scalingDeterminant *= -1)
		}
		return __extends(i, t), i.prototype.getParent = function() {
			return this._parent
		}, i.prototype.getLocalMatrix = function() {
			return this._matrix
		}, i.prototype.getBaseMatrix = function() {
			return this._baseMatrix
		}, i.prototype.getRestPose = function() {
			return this._restPose
		}, i.prototype.returnToRest = function() {
			this.updateMatrix(this._restPose.clone())
		}, i.prototype.getWorldMatrix = function() {
			return this._worldTransform
		}, i.prototype.getInvertedAbsoluteTransform = function() {
			return this._invertedAbsoluteTransform
		}, i.prototype.getAbsoluteTransform = function() {
			return this._absoluteTransform
		}, i.prototype.updateMatrix = function(e, t) {
			void 0 === t && (t = !0), this._baseMatrix = e.clone(), this._matrix = e.clone(), this._skeleton._markAsDirty(), t && this._updateDifferenceMatrix()
		}, i.prototype._updateDifferenceMatrix = function(e) {
			e || (e = this._baseMatrix), this._parent ? e.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform) : this._absoluteTransform.copyFrom(e), this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);
			for (var t = 0; t < this.children.length; t++) this.children[t]._updateDifferenceMatrix()
		}, i.prototype.markAsDirty = function() {
			this._currentRenderId++, this._skeleton._markAsDirty()
		}, i.prototype.copyAnimationRange = function(t, i, r, n, o) {
			void 0 === n && (n = !1), void 0 === o && (o = null), 0 === this.animations.length && (this.animations.push(new e.Animation(this.name, "_matrix", t.animations[0].framePerSecond, e.Animation.ANIMATIONTYPE_MATRIX, 0)), this.animations[0].setKeys([]));
			var s = t.animations[0].getRange(i);
			if (!s) return !1;
			for (var a, h, c, l = s.from, u = s.to, d = t.animations[0].getKeys(), f = t.length, p = t.getParent(), m = this.getParent(), _ = n && p && f && this.length && f !== this.length, g = _ ? m.length / p.length : null, v = n && !m && o && (1 !== o.x || 1 !== o.y || 1 !== o.z), y = this.animations[0].getKeys(), x = 0, b = d.length; x < b; x++) a = d[x], a.frame >= l && a.frame <= u && (n ? (c = a.value.clone(), _ ? (h = c.getTranslation(), c.setTranslation(h.scaleInPlace(g))) : v ? (h = c.getTranslation(), c.setTranslation(h.multiplyInPlace(o))) : c = a.value) : c = a.value, y.push({
				frame: a.frame + r,
				value: c
			}));
			return this.animations[0].createRange(i, l + r, u + r), !0
		}, i.prototype.translate = function(t, i, r) {
			void 0 === i && (i = e.Space.LOCAL);
			var n = this.getLocalMatrix();
			if (i == e.Space.LOCAL) n.m[12] += t.x, n.m[13] += t.y, n.m[14] += t.z;
			else {
				this._skeleton.computeAbsoluteTransforms();
				var o = e.Tmp.Matrix[0],
					s = e.Tmp.Vector3[0];
				r ? (o.copyFrom(this._parent.getAbsoluteTransform()), o.multiplyToRef(r.getWorldMatrix(), o)) : o.copyFrom(this._parent.getAbsoluteTransform()), o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, o.invert(), e.Vector3.TransformCoordinatesToRef(t, o, s), n.m[12] += s.x, n.m[13] += s.y, n.m[14] += s.z
			}
			this.markAsDirty()
		}, i.prototype.setPosition = function(t, i, r) {
			void 0 === i && (i = e.Space.LOCAL);
			var n = this.getLocalMatrix();
			if (i == e.Space.LOCAL) n.m[12] = t.x, n.m[13] = t.y, n.m[14] = t.z;
			else {
				this._skeleton.computeAbsoluteTransforms();
				var o = e.Tmp.Matrix[0],
					s = e.Tmp.Vector3[0];
				r ? (o.copyFrom(this._parent.getAbsoluteTransform()), o.multiplyToRef(r.getWorldMatrix(), o)) : o.copyFrom(this._parent.getAbsoluteTransform()), o.invert(), e.Vector3.TransformCoordinatesToRef(t, o, s), n.m[12] = s.x, n.m[13] = s.y, n.m[14] = s.z
			}
			this.markAsDirty()
		}, i.prototype.setAbsolutePosition = function(t, i) {
			this.setPosition(t, e.Space.WORLD, i)
		}, i.prototype.setScale = function(e, t, i, r) {
			void 0 === r && (r = !1), this.animations[0] && !this.animations[0].isStopped() && (r || (this._negateScaleChildren.x = 1 / e, this._negateScaleChildren.y = 1 / t, this._negateScaleChildren.z = 1 / i), this._syncScaleVector()), this.scale(e / this._scaleVector.x, t / this._scaleVector.y, i / this._scaleVector.z, r)
		}, i.prototype.scale = function(t, i, r, n) {
			void 0 === n && (n = !1);
			var o = this.getLocalMatrix(),
				s = e.Tmp.Matrix[0];
			s.copyFrom(o);
			var a = e.Tmp.Matrix[1];
			a.copyFrom(s), a.invert();
			var h = e.Tmp.Matrix[2];
			e.Matrix.FromValuesToRef(t, 0, 0, 0, 0, i, 0, 0, 0, 0, r, 0, 0, 0, 0, 1, h), this._scaleMatrix.multiplyToRef(h, this._scaleMatrix), this._scaleVector.x *= t, this._scaleVector.y *= i, this._scaleVector.z *= r, o.multiplyToRef(a, o), o.multiplyToRef(h, o), o.multiplyToRef(s, o);
			var c = this.getParent();
			c ? o.multiplyToRef(c.getAbsoluteTransform(), this.getAbsoluteTransform()) : this.getAbsoluteTransform().copyFrom(o);
			var l = this.children.length;
			h.invert();
			for (var u = 0; u < l; u++) {
				var d = this.children[u],
					f = d.getLocalMatrix();
				f.multiplyToRef(h, f);
				var p = d.getLocalMatrix();
				p.m[12] *= t, p.m[13] *= i, p.m[14] *= r
			}
			if (this.computeAbsoluteTransforms(), n)
				for (var u = 0; u < l; u++) this.children[u].scale(t, i, r, n);
			this.markAsDirty()
		}, i.prototype.setYawPitchRoll = function(t, i, r, n, o) {
			void 0 === n && (n = e.Space.LOCAL);
			var s = e.Tmp.Matrix[0];
			e.Matrix.RotationYawPitchRollToRef(t, i, r, s);
			var a = e.Tmp.Matrix[1];
			this._getNegativeRotationToRef(a, n, o), a.multiplyToRef(s, s), this._rotateWithMatrix(s, n, o)
		}, i.prototype.rotate = function(t, i, r, n) {
			void 0 === r && (r = e.Space.LOCAL);
			var o = e.Tmp.Matrix[0];
			o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, e.Matrix.RotationAxisToRef(t, i, o), this._rotateWithMatrix(o, r, n)
		}, i.prototype.setAxisAngle = function(t, i, r, n) {
			void 0 === r && (r = e.Space.LOCAL);
			var o = e.Tmp.Matrix[0];
			e.Matrix.RotationAxisToRef(t, i, o);
			var s = e.Tmp.Matrix[1];
			this._getNegativeRotationToRef(s, r, n), s.multiplyToRef(o, o), this._rotateWithMatrix(o, r, n)
		}, i.prototype.setRotation = function(t, i, r) {
			void 0 === i && (i = e.Space.LOCAL), this.setYawPitchRoll(t.y, t.x, t.z, i, r)
		}, i.prototype.setRotationQuaternion = function(t, i, r) {
			void 0 === i && (i = e.Space.LOCAL);
			var n = e.Tmp.Matrix[0];
			this._getNegativeRotationToRef(n, i, r);
			var o = e.Tmp.Matrix[1];
			e.Matrix.FromQuaternionToRef(t, o), n.multiplyToRef(o, o), this._rotateWithMatrix(o, i, r)
		}, i.prototype.setRotationMatrix = function(t, i, r) {
			void 0 === i && (i = e.Space.LOCAL);
			var n = e.Tmp.Matrix[0];
			this._getNegativeRotationToRef(n, i, r);
			var o = e.Tmp.Matrix[1];
			o.copyFrom(t), n.multiplyToRef(t, o), this._rotateWithMatrix(o, i, r)
		}, i.prototype._rotateWithMatrix = function(t, i, r) {
			void 0 === i && (i = e.Space.LOCAL);
			var n = this.getLocalMatrix(),
				o = n.m[12],
				s = n.m[13],
				a = n.m[14],
				h = this.getParent(),
				c = e.Tmp.Matrix[3],
				l = e.Tmp.Matrix[4];
			h ? (i == e.Space.WORLD ? r ? (c.copyFrom(r.getWorldMatrix()), h.getAbsoluteTransform().multiplyToRef(c, c)) : c.copyFrom(h.getAbsoluteTransform()) : c = h._scaleMatrix, l.copyFrom(c), l.invert(), n.multiplyToRef(c, n), n.multiplyToRef(t, n), n.multiplyToRef(l, n)) : i == e.Space.WORLD && r ? (c.copyFrom(r.getWorldMatrix()), l.copyFrom(c), l.invert(), n.multiplyToRef(c, n), n.multiplyToRef(t, n), n.multiplyToRef(l, n)) : n.multiplyToRef(t, n), n.m[12] = o, n.m[13] = s, n.m[14] = a, this.computeAbsoluteTransforms(), this.markAsDirty()
		}, i.prototype._getNegativeRotationToRef = function(t, i, r) {
			if (void 0 === i && (i = e.Space.LOCAL), i == e.Space.WORLD) {
				var n = e.Tmp.Matrix[2];
				if (n.copyFrom(this._scaleMatrix), t.copyFrom(this.getAbsoluteTransform()), r) {
					t.multiplyToRef(r.getWorldMatrix(), t);
					var o = e.Tmp.Matrix[3];
					e.Matrix.ScalingToRef(r.scaling.x, r.scaling.y, r.scaling.z, o), n.multiplyToRef(o, n)
				}
				t.invert(), n.m[0] *= this._scalingDeterminant, t.multiplyToRef(n, t)
			} else {
				t.copyFrom(this.getLocalMatrix()), t.invert();
				var n = e.Tmp.Matrix[2];
				if (n.copyFrom(this._scaleMatrix), this._parent) {
					var s = e.Tmp.Matrix[3];
					s.copyFrom(this._parent._scaleMatrix), s.invert(), s.multiplyToRef(t, t)
				} else n.m[0] *= this._scalingDeterminant;
				t.multiplyToRef(n, t)
			}
		}, i.prototype.getScale = function() {
			return this._scaleVector.clone()
		}, i.prototype.getScaleToRef = function(e) {
			e.copyFrom(this._scaleVector)
		}, i.prototype.getPosition = function(t, i) {
			void 0 === t && (t = e.Space.LOCAL);
			var r = e.Vector3.Zero();
			return this.getPositionToRef(t, i, r), r
		}, i.prototype.getPositionToRef = function(t, i, r) {
			if (void 0 === t && (t = e.Space.LOCAL), t == e.Space.LOCAL) {
				var n = this.getLocalMatrix();
				r.x = n.m[12], r.y = n.m[13], r.z = n.m[14]
			} else {
				this._skeleton.computeAbsoluteTransforms();
				var o = e.Tmp.Matrix[0];
				i ? (o.copyFrom(this.getAbsoluteTransform()), o.multiplyToRef(i.getWorldMatrix(), o)) : o = this.getAbsoluteTransform(), r.x = o.m[12], r.y = o.m[13], r.z = o.m[14]
			}
		}, i.prototype.getAbsolutePosition = function(t) {
			var i = e.Vector3.Zero();
			return this.getPositionToRef(e.Space.WORLD, t, i), i
		}, i.prototype.getAbsolutePositionToRef = function(t, i) {
			this.getPositionToRef(e.Space.WORLD, t, i)
		}, i.prototype.computeAbsoluteTransforms = function() {
			if (this._parent) this._matrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);
			else {
				this._absoluteTransform.copyFrom(this._matrix);
				var e = this._skeleton.getPoseMatrix();
				e && this._absoluteTransform.multiplyToRef(e, this._absoluteTransform)
			}
			for (var t = this.children, i = t.length, r = 0; r < i; r++) t[r].computeAbsoluteTransforms()
		}, i.prototype.getDirection = function(t, i) {
			var r = e.Vector3.Zero();
			return this.getDirectionToRef(t, i, r), r
		}, i.prototype.getDirectionToRef = function(t, i, r) {
			this._skeleton.computeAbsoluteTransforms();
			var n = e.Tmp.Matrix[0];
			n.copyFrom(this.getAbsoluteTransform()), i && n.multiplyToRef(i.getWorldMatrix(), n), e.Vector3.TransformNormalToRef(t, n, r), r.normalize()
		}, i.prototype.getRotation = function(t, i) {
			void 0 === t && (t = e.Space.LOCAL);
			var r = e.Vector3.Zero();
			return this.getRotationToRef(t, i, r), r
		}, i.prototype.getRotationToRef = function(t, i, r) {
			void 0 === t && (t = e.Space.LOCAL);
			var n = e.Tmp.Quaternion[0];
			this.getRotationQuaternionToRef(t, i, n), n.toEulerAnglesToRef(r)
		}, i.prototype.getRotationQuaternion = function(t, i) {
			void 0 === t && (t = e.Space.LOCAL);
			var r = e.Quaternion.Identity();
			return this.getRotationQuaternionToRef(t, i, r), r
		}, i.prototype.getRotationQuaternionToRef = function(t, i, r) {
			if (void 0 === t && (t = e.Space.LOCAL), t == e.Space.LOCAL) this.getLocalMatrix().decompose(e.Tmp.Vector3[0], r, e.Tmp.Vector3[1]);
			else {
				var n = e.Tmp.Matrix[0],
					o = this.getAbsoluteTransform();
				i ? o.multiplyToRef(i.getWorldMatrix(), n) : n.copyFrom(o), n.m[0] *= this._scalingDeterminant, n.m[1] *= this._scalingDeterminant, n.m[2] *= this._scalingDeterminant, n.decompose(e.Tmp.Vector3[0], r, e.Tmp.Vector3[1])
			}
		}, i.prototype.getRotationMatrix = function(t, i) {
			void 0 === t && (t = e.Space.LOCAL);
			var r = e.Matrix.Identity();
			return this.getRotationMatrixToRef(t, i, r), r
		}, i.prototype.getRotationMatrixToRef = function(t, i, r) {
			if (void 0 === t && (t = e.Space.LOCAL), t == e.Space.LOCAL) this.getLocalMatrix().getRotationMatrixToRef(r);
			else {
				var n = e.Tmp.Matrix[0],
					o = this.getAbsoluteTransform();
				i ? o.multiplyToRef(i.getWorldMatrix(), n) : n.copyFrom(o), n.m[0] *= this._scalingDeterminant, n.m[1] *= this._scalingDeterminant, n.m[2] *= this._scalingDeterminant, n.getRotationMatrixToRef(r)
			}
		}, i.prototype.getAbsolutePositionFromLocal = function(t, i) {
			var r = e.Vector3.Zero();
			return this.getAbsolutePositionFromLocalToRef(t, i, r), r
		}, i.prototype.getAbsolutePositionFromLocalToRef = function(t, i, r) {
			this._skeleton.computeAbsoluteTransforms();
			var n = e.Tmp.Matrix[0];
			i ? (n.copyFrom(this.getAbsoluteTransform()), n.multiplyToRef(i.getWorldMatrix(), n)) : n = this.getAbsoluteTransform(), e.Vector3.TransformCoordinatesToRef(t, n, r)
		}, i.prototype.getLocalPositionFromAbsolute = function(t, i) {
			var r = e.Vector3.Zero();
			return this.getLocalPositionFromAbsoluteToRef(t, i, r), r
		}, i.prototype.getLocalPositionFromAbsoluteToRef = function(t, i, r) {
			this._skeleton.computeAbsoluteTransforms();
			var n = e.Tmp.Matrix[0];
			n.copyFrom(this.getAbsoluteTransform()), i && n.multiplyToRef(i.getWorldMatrix(), n), n.invert(), e.Vector3.TransformCoordinatesToRef(t, n, r)
		}, i
	})(e.Node);
	e.Bone = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r) {
			if (this.targetPosition = e.Vector3.Zero(), this.poleTargetPosition = e.Vector3.Zero(), this.poleTargetLocalOffset = e.Vector3.Zero(), this.poleAngle = 0, this.slerpAmount = 1, this._bone1Quat = e.Quaternion.Identity(), this._bone1Mat = e.Matrix.Identity(), this._bone2Ang = Math.PI, this._maxAngle = Math.PI, this._tmpVec1 = e.Vector3.Zero(), this._tmpVec2 = e.Vector3.Zero(), this._tmpVec3 = e.Vector3.Zero(), this._tmpVec4 = e.Vector3.Zero(), this._tmpVec5 = e.Vector3.Zero(), this._tmpMat1 = e.Matrix.Identity(), this._tmpMat2 = e.Matrix.Identity(), this._tmpQuat1 = e.Quaternion.Identity(), this._rightHandedSystem = !1, this._bendAxis = e.Vector3.Right(), this._slerping = !1, this._bone2 = i, this._bone1 = i.getParent(), this.mesh = t, i.getAbsoluteTransform().determinant() > 0 && (this._rightHandedSystem = !0, this._bendAxis.x = 0, this._bendAxis.y = 0, this._bendAxis.z = 1), this._bone1.length) {
				var n = this._bone1.getScale(),
					o = this._bone2.getScale();
				this._bone1Length = this._bone1.length * n.y * this.mesh.scaling.y, this._bone2Length = this._bone2.length * o.y * this.mesh.scaling.y
			} else if (this._bone1.children[0]) {
				t.computeWorldMatrix(!0);
				var s = this._bone2.children[0].getAbsolutePosition(t),
					a = this._bone2.getAbsolutePosition(t),
					h = this._bone1.getAbsolutePosition(t);
				this._bone1Length = e.Vector3.Distance(s, a), this._bone2Length = e.Vector3.Distance(a, h)
			}
			this._bone1.getRotationMatrixToRef(e.Space.WORLD, t, this._bone1Mat), this.maxAngle = Math.PI, r && (r.targetMesh && (this.targetMesh = r.targetMesh, this.targetMesh.computeWorldMatrix(!0)), r.poleTargetMesh ? (this.poleTargetMesh = r.poleTargetMesh, this.poleTargetMesh.computeWorldMatrix(!0)) : r.poleTargetBone ? this.poleTargetBone = r.poleTargetBone : this._bone1.getParent() && (this.poleTargetBone = this._bone1.getParent()), r.poleTargetLocalOffset && this.poleTargetLocalOffset.copyFrom(r.poleTargetLocalOffset), r.poleAngle && (this.poleAngle = r.poleAngle), r.bendAxis && this._bendAxis.copyFrom(r.bendAxis), r.maxAngle && (this.maxAngle = r.maxAngle), r.slerpAmount && (this.slerpAmount = r.slerpAmount))
		}
		return Object.defineProperty(t.prototype, "maxAngle", {
			get: function() {
				return this._maxAngle
			},
			set: function(e) {
				this._setMaxAngle(e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype._setMaxAngle = function(e) {
			e < 0 && (e = 0), (e > Math.PI || void 0 == e) && (e = Math.PI), this._maxAngle = e;
			var t = this._bone1Length,
				i = this._bone2Length;
			this._maxReach = Math.sqrt(t * t + i * i - 2 * t * i * Math.cos(e))
		}, t.prototype.update = function() {
			var t = this._bone1,
				i = this.targetPosition,
				r = this.poleTargetPosition,
				n = this._tmpMat1,
				o = this._tmpMat2;
			this.targetMesh && i.copyFrom(this.targetMesh.getAbsolutePosition()), this.poleTargetBone ? this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, r) : this.poleTargetMesh && e.Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), r);
			var s = this._tmpVec1,
				a = this._tmpVec2,
				h = this._tmpVec3,
				c = this._tmpVec4,
				l = this._tmpVec5;
			t.getAbsolutePositionToRef(this.mesh, s), r.subtractToRef(s, l), 0 == l.x && 0 == l.y && 0 == l.z ? l.y = 1 : l.normalize(), i.subtractToRef(s, c), c.normalize(), e.Vector3.CrossToRef(c, l, a), a.normalize(), e.Vector3.CrossToRef(c, a, h), h.normalize(), e.Matrix.FromXYZAxesToRef(h, c, a, n);
			var u = this._bone1Length,
				d = this._bone2Length,
				f = e.Vector3.Distance(s, i);
			this._maxReach > 0 && (f = Math.min(this._maxReach, f));
			var p = (d * d + f * f - u * u) / (2 * d * f),
				m = (f * f + u * u - d * d) / (2 * f * u);
			p > 1 && (p = 1), m > 1 && (m = 1), p < -1 && (p = -1), m < -1 && (m = -1);
			var _ = Math.acos(p),
				g = Math.acos(m),
				v = -_ - g;
			this._rightHandedSystem ? (e.Matrix.RotationYawPitchRollToRef(0, 0, .5 * Math.PI, o), o.multiplyToRef(n, n), e.Matrix.RotationAxisToRef(this._bendAxis, g, o), o.multiplyToRef(n, n)) : (this._tmpVec1.copyFrom(this._bendAxis), this._tmpVec1.x *= -1, e.Matrix.RotationAxisToRef(this._tmpVec1, -g, o), o.multiplyToRef(n, n)), this.poleAngle && (e.Matrix.RotationAxisToRef(c, this.poleAngle, o), n.multiplyToRef(o, n)), this.slerpAmount < 1 ? (this._slerping || e.Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat), e.Quaternion.FromRotationMatrixToRef(n, this._tmpQuat1), e.Quaternion.SlerpToRef(this._bone1Quat, this._tmpQuat1, this.slerpAmount, this._bone1Quat), v = this._bone2Ang * (1 - this.slerpAmount) + v * this.slerpAmount, this._bone1.setRotationQuaternion(this._bone1Quat, e.Space.WORLD, this.mesh), this._slerping = !0) : (this._bone1.setRotationMatrix(n, e.Space.WORLD, this.mesh), this._bone1Mat.copyFrom(n), this._slerping = !1), this._bone2.setAxisAngle(this._bendAxis, v, e.Space.LOCAL), this._bone2Ang = v
		}, t
	})();
	e.BoneIKController = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n) {
			this.upAxis = e.Vector3.Up(), this.adjustYaw = 0, this.adjustPitch = 0, this.adjustRoll = 0, this._tmpVec1 = e.Vector3.Zero(), this._tmpVec2 = e.Vector3.Zero(), this._tmpVec3 = e.Vector3.Zero(), this._tmpVec4 = e.Vector3.Zero(), this._tmpMat1 = e.Matrix.Identity(), this._tmpMat2 = e.Matrix.Identity(), this.mesh = t, this.bone = i, this.target = r, n && (n.adjustYaw && (this.adjustYaw = n.adjustYaw), n.adjustPitch && (this.adjustPitch = n.adjustPitch), n.adjustRoll && (this.adjustRoll = n.adjustRoll))
		}
		return t.prototype.update = function() {
			var t = this.bone,
				i = this.target,
				r = this._tmpVec1,
				n = this._tmpVec2,
				o = this._tmpVec3,
				s = this._tmpVec4,
				a = this._tmpMat1,
				h = this._tmpMat2;
			t.getAbsolutePositionToRef(this.mesh, r), i.subtractToRef(r, n), n.normalize(), e.Vector3.CrossToRef(this.upAxis, n, o), o.normalize(), e.Vector3.CrossToRef(n, o, s), s.normalize(), e.Matrix.FromXYZAxesToRef(o, s, n, a), (this.adjustYaw || this.adjustPitch || this.adjustRoll) && (e.Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, h), h.multiplyToRef(a, a)), this.bone.setRotationMatrix(a, e.Space.WORLD, this.mesh)
		}, t
	})();
	e.BoneLookController = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r) {
			this.name = t, this.id = i, this.bones = new Array, this.needInitialSkinMatrix = !1, this._isDirty = !0, this._meshesWithPoseMatrix = new Array, this._identity = e.Matrix.Identity(), this._ranges = {}, this._lastAbsoluteTransformsUpdateId = -1, this.bones = [], this._scene = r, r.skeletons.push(this), this._isDirty = !0
		}
		return t.prototype.getTransformMatrices = function(e) {
			return this.needInitialSkinMatrix && e._bonesTransformMatrices ? e._bonesTransformMatrices : this._transformMatrices
		}, t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.toString = function(e) {
			var t = "Name: " + this.name + ", nBones: " + this.bones.length;
			if (t += ", nAnimationRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none"), e) {
				t += ", Ranges: {";
				var i = !0;
				for (var r in this._ranges) i && (t += ", ", i = !1), t += r;
				t += "}"
			}
			return t
		}, t.prototype.getBoneIndexByName = function(e) {
			for (var t = 0, i = this.bones.length; t < i; t++)
				if (this.bones[t].name === e) return t;
			return -1
		}, t.prototype.createAnimationRange = function(t, i, r) {
			if (!this._ranges[t]) {
				this._ranges[t] = new e.AnimationRange(t, i, r);
				for (var n = 0, o = this.bones.length; n < o; n++) this.bones[n].animations[0] && this.bones[n].animations[0].createRange(t, i, r)
			}
		}, t.prototype.deleteAnimationRange = function(e, t) {
			void 0 === t && (t = !0);
			for (var i = 0, r = this.bones.length; i < r; i++) this.bones[i].animations[0] && this.bones[i].animations[0].deleteRange(e, t);
			this._ranges[e] = void 0
		}, t.prototype.getAnimationRange = function(e) {
			return this._ranges[e]
		}, t.prototype.getAnimationRanges = function() {
			var e, t = [],
				i = 0;
			for (e in this._ranges) t[i] = this._ranges[e], i++;
			return t
		}, t.prototype.copyAnimationRange = function(t, i, r) {
			if (void 0 === r && (r = !1), this._ranges[i] || !t.getAnimationRange(i)) return !1;
			var n, o, s = !0,
				a = this._getHighestAnimationFrame() + 1,
				h = {},
				c = t.bones;
			for (o = 0, n = c.length; o < n; o++) h[c[o].name] = c[o];
			this.bones.length !== c.length && (e.Tools.Warn("copyAnimationRange: this rig has " + this.bones.length + " bones, while source as " + c.length), s = !1);
			var l = r && this.dimensionsAtRest && t.dimensionsAtRest ? this.dimensionsAtRest.divide(t.dimensionsAtRest) : null;
			for (o = 0, n = this.bones.length; o < n; o++) {
				var u = this.bones[o].name,
					d = h[u];
				d ? s = s && this.bones[o].copyAnimationRange(d, i, a, r, l) : (e.Tools.Warn("copyAnimationRange: not same rig, missing source bone " + u), s = !1)
			}
			var f = t.getAnimationRange(i);
			return this._ranges[i] = new e.AnimationRange(i, f.from + a, f.to + a), s
		}, t.prototype.returnToRest = function() {
			for (var e = 0; e < this.bones.length; e++) this.bones[e].returnToRest()
		}, t.prototype._getHighestAnimationFrame = function() {
			for (var e = 0, t = 0, i = this.bones.length; t < i; t++)
				if (this.bones[t].animations[0]) {
					var r = this.bones[t].animations[0].getHighestFrame();
					e < r && (e = r)
				}
			return e
		}, t.prototype.beginAnimation = function(e, t, i, r) {
			var n = this.getAnimationRange(e);
			return n ? this._scene.beginAnimation(this, n.from, n.to, t, i, r) : null
		}, t.prototype._markAsDirty = function() {
			this._isDirty = !0
		}, t.prototype._registerMeshWithPoseMatrix = function(e) {
			this._meshesWithPoseMatrix.push(e)
		}, t.prototype._unregisterMeshWithPoseMatrix = function(e) {
			var t = this._meshesWithPoseMatrix.indexOf(e);
			t > -1 && this._meshesWithPoseMatrix.splice(t, 1)
		}, t.prototype._computeTransformMatrices = function(e, t) {
			for (var i = 0; i < this.bones.length; i++) {
				var r = this.bones[i],
					n = r.getParent();
				n ? r.getLocalMatrix().multiplyToRef(n.getWorldMatrix(), r.getWorldMatrix()) : t ? r.getLocalMatrix().multiplyToRef(t, r.getWorldMatrix()) : r.getWorldMatrix().copyFrom(r.getLocalMatrix()), r.getInvertedAbsoluteTransform().multiplyToArray(r.getWorldMatrix(), e, 16 * i)
			}
			this._identity.copyToArray(e, 16 * this.bones.length)
		}, t.prototype.prepare = function() {
			if (this._isDirty) {
				if (this.needInitialSkinMatrix)
					for (var t = 0; t < this._meshesWithPoseMatrix.length; t++) {
						var i = this._meshesWithPoseMatrix[t];
						i._bonesTransformMatrices && i._bonesTransformMatrices.length === 16 * (this.bones.length + 1) || (i._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1)));
						for (var r = i.getPoseMatrix(), n = 0; n < this.bones.length; n++) {
							var o = this.bones[n];
							if (!o.getParent()) {
								var s = o.getBaseMatrix();
								s.multiplyToRef(r, e.Tmp.Matrix[0]), o._updateDifferenceMatrix(e.Tmp.Matrix[0])
							}
						}
						this._computeTransformMatrices(i._bonesTransformMatrices, r)
					} else this._transformMatrices && this._transformMatrices.length === 16 * (this.bones.length + 1) || (this._transformMatrices = new Float32Array(16 * (this.bones.length + 1))), this._computeTransformMatrices(this._transformMatrices, null);
				this._isDirty = !1, this._scene._activeBones.addCount(this.bones.length, !1)
			}
		}, t.prototype.getAnimatables = function() {
			if (!this._animatables || this._animatables.length !== this.bones.length) {
				this._animatables = [];
				for (var e = 0; e < this.bones.length; e++) this._animatables.push(this.bones[e])
			}
			return this._animatables
		}, t.prototype.clone = function(i, r) {
			var n = new t(i, r || i, this._scene);
			n.needInitialSkinMatrix = this.needInitialSkinMatrix;
			for (var o = 0; o < this.bones.length; o++) {
				var s = this.bones[o],
					a = null;
				if (s.getParent()) {
					var h = this.bones.indexOf(s.getParent());
					a = n.bones[h]
				}
				var c = new e.Bone(s.name, n, a, s.getBaseMatrix().clone(), s.getRestPose().clone());
				e.Tools.DeepCopy(s.animations, c.animations)
			}
			if (this._ranges) {
				n._ranges = {};
				for (var l in this._ranges) n._ranges[l] = this._ranges[l].clone()
			}
			return this._isDirty = !0, n
		}, t.prototype.enableBlending = function(e) {
			void 0 === e && (e = .01), this.bones.forEach((function(t) {
				t.animations.forEach((function(t) {
					t.enableBlending = !0, t.blendingSpeed = e
				}))
			}))
		}, t.prototype.dispose = function() {
			this._meshesWithPoseMatrix = [], this.getScene().stopAnimation(this), this.getScene().removeSkeleton(this)
		}, t.prototype.serialize = function() {
			var e = {};
			e.name = this.name, e.id = this.id, e.dimensionsAtRest = this.dimensionsAtRest, e.bones = [], e.needInitialSkinMatrix = this.needInitialSkinMatrix;
			for (var t = 0; t < this.bones.length; t++) {
				var i = this.bones[t],
					r = {
						parentBoneIndex: i.getParent() ? this.bones.indexOf(i.getParent()) : -1,
						name: i.name,
						matrix: i.getLocalMatrix().toArray(),
						rest: i.getRestPose().toArray()
					};
				e.bones.push(r), i.length && (r.length = i.length), i.animations && i.animations.length > 0 && (r.animation = i.animations[0].serialize()), e.ranges = [];
				for (var n in this._ranges) {
					var o = {};
					o.name = n, o.from = this._ranges[n].from, o.to = this._ranges[n].to, e.ranges.push(o)
				}
			}
			return e
		}, t.Parse = function(i, r) {
			var n = new t(i.name, i.id, r);
			i.dimensionsAtRest && (n.dimensionsAtRest = e.Vector3.FromArray(i.dimensionsAtRest)), n.needInitialSkinMatrix = i.needInitialSkinMatrix;
			var o;
			for (o = 0; o < i.bones.length; o++) {
				var s = i.bones[o],
					a = null;
				s.parentBoneIndex > -1 && (a = n.bones[s.parentBoneIndex]);
				var h = s.rest ? e.Matrix.FromArray(s.rest) : null,
					c = new e.Bone(s.name, n, a, e.Matrix.FromArray(s.matrix), h);
				s.length && (c.length = s.length), s.animation && c.animations.push(e.Animation.Parse(s.animation))
			}
			if (i.ranges)
				for (o = 0; o < i.ranges.length; o++) {
					var l = i.ranges[o];
					n.createAnimationRange(l.name, l.from, l.to)
				}
			return n
		}, t.prototype.computeAbsoluteTransforms = function(e) {
			void 0 === e && (e = !1);
			var t = this._scene.getRenderId();
			(this._lastAbsoluteTransformsUpdateId != t || e) && (this.bones[0].computeAbsoluteTransforms(), this._lastAbsoluteTransformsUpdateId = t)
		}, t.prototype.getPoseMatrix = function() {
			var e;
			return this._meshesWithPoseMatrix.length > 0 && (e = this._meshesWithPoseMatrix[0].getPoseMatrix()), e
		}, t
	})();
	e.Skeleton = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o, s, a, h, c, l, u) {
			void 0 === a && (a = e.Texture.NEAREST_SAMPLINGMODE), void 0 === u && (u = e.Engine.TEXTURETYPE_UNSIGNED_INT), this.name = t, this.width = -1, this.height = -1, this.enablePixelPerfectMode = !1, this._reusable = !1, this._textures = new e.SmartArray(2), this._currentRenderTextureInd = 0, this._scaleRatio = new e.Vector2(1, 1), this.onActivateObservable = new e.Observable, this.onSizeChangedObservable = new e.Observable, this.onApplyObservable = new e.Observable, this.onBeforeRenderObservable = new e.Observable, this.onAfterRenderObservable = new e.Observable, null != s ? (this._camera = s, this._scene = s.getScene(), s.attachPostProcess(this), this._engine = this._scene.getEngine()) : this._engine = h, this._options = o, this.renderTargetSamplingMode = a ? a : e.Texture.NEAREST_SAMPLINGMODE, this._reusable = c || !1, this._textureType = u, this._samplers = n || [], this._samplers.push("textureSampler"), this._fragmentUrl = i, this._parameters = r || [], this._parameters.push("scale"), this.updateEffect(l)
		}
		return Object.defineProperty(t.prototype, "onActivate", {
			set: function(e) {
				this._onActivateObserver && this.onActivateObservable.remove(this._onActivateObserver), this._onActivateObserver = this.onActivateObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onSizeChanged", {
			set: function(e) {
				this._onSizeChangedObserver && this.onSizeChangedObservable.remove(this._onSizeChangedObserver), this._onSizeChangedObserver = this.onSizeChangedObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onApply", {
			set: function(e) {
				this._onApplyObserver && this.onApplyObservable.remove(this._onApplyObserver), this._onApplyObserver = this.onApplyObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onBeforeRender", {
			set: function(e) {
				this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "onAfterRender", {
			set: function(e) {
				this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.updateEffect = function(e) {
			this._effect = this._engine.createEffect({
				vertex: "postprocess",
				fragment: this._fragmentUrl
			}, ["position"], this._parameters, this._samplers, void 0 !== e ? e : "")
		}, t.prototype.isReusable = function() {
			return this._reusable
		}, t.prototype.markTextureDirty = function() {
			this.width = -1
		}, t.prototype.activate = function(t, i) {
			t = t || this._camera;
			var r = t.getScene(),
				n = t.getEngine().getCaps().maxTextureSize,
				o = (i ? i._width : this._engine.getRenderingCanvas().width) * this._options | 0,
				s = (i ? i._height : this._engine.getRenderingCanvas().height) * this._options | 0,
				a = this._options.width || o,
				h = this._options.height || s;
			if (this.renderTargetSamplingMode !== e.Texture.NEAREST_SAMPLINGMODE && (this._options.width || (a = e.Tools.GetExponentOfTwo(a, n)), this._options.height || (h = e.Tools.GetExponentOfTwo(h, n))), this.width !== a || this.height !== h) {
				if (this._textures.length > 0) {
					for (var c = 0; c < this._textures.length; c++) this._engine._releaseTexture(this._textures.data[c]);
					this._textures.reset()
				}
				this.width = a, this.height = h;
				var l = {
						width: this.width,
						height: this.height
					},
					u = {
						generateMipMaps: !1,
						generateDepthBuffer: 0 === t._postProcesses.indexOf(this),
						generateStencilBuffer: 0 === t._postProcesses.indexOf(this) && this._engine.isStencilEnable,
						samplingMode: this.renderTargetSamplingMode,
						type: this._textureType
					};
				this._textures.push(this._engine.createRenderTargetTexture(l, u)), this._reusable && this._textures.push(this._engine.createRenderTargetTexture(l, u)), this.onSizeChangedObservable.notifyObservers(this)
			}
			this.enablePixelPerfectMode ? (this._scaleRatio.copyFromFloats(o / a, s / h), this._engine.bindFramebuffer(this._textures.data[this._currentRenderTextureInd], 0, o, s)) : (this._scaleRatio.copyFromFloats(1, 1), this._engine.bindFramebuffer(this._textures.data[this._currentRenderTextureInd])), this.onActivateObservable.notifyObservers(t), this.clearColor ? this._engine.clear(this.clearColor, !0, !0, !0) : this._engine.clear(r.clearColor, r.autoClear || r.forceWireframe, !0, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2)
		}, Object.defineProperty(t.prototype, "isSupported", {
			get: function() {
				return this._effect.isSupported
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.apply = function() {
			return this._effect.isReady() ? (this._engine.enableEffect(this._effect), this._engine.setState(!1), this._engine.setAlphaMode(e.Engine.ALPHA_DISABLE), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._effect._bindTexture("textureSampler", this._textures.data[this._currentRenderTextureInd]), this._effect.setVector2("scale", this._scaleRatio), this.onApplyObservable.notifyObservers(this._effect), this._effect) : null
		}, t.prototype.dispose = function(e) {
			if (e = e || this._camera, this._textures.length > 0) {
				for (var t = 0; t < this._textures.length; t++) this._engine._releaseTexture(this._textures.data[t]);
				this._textures.reset()
			}
			if (e) {
				e.detachPostProcess(this);
				var i = e._postProcesses.indexOf(this);
				0 === i && e._postProcesses.length > 0 && this._camera._postProcesses[0].markTextureDirty(), this.onActivateObservable.clear(), this.onAfterRenderObservable.clear(), this.onApplyObservable.clear(), this.onBeforeRenderObservable.clear(), this.onSizeChangedObservable.clear()
			}
		}, t
	})();
	e.PostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e) {
			this._vertexBuffers = {}, this._scene = e
		}
		return t.prototype._prepareBuffers = function() {
			if (!this._vertexBuffers[e.VertexBuffer.PositionKind]) {
				var t = [];
				t.push(1, 1), t.push(-1, 1), t.push(-1, -1), t.push(1, -1), this._vertexBuffers[e.VertexBuffer.PositionKind] = new e.VertexBuffer(this._scene.getEngine(), t, e.VertexBuffer.PositionKind, (!1), (!1), 2);
				var i = [];
				i.push(0), i.push(1), i.push(2), i.push(0), i.push(2), i.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(i)
			}
		}, t.prototype._prepareFrame = function(e) {
			var t = this._scene.activeCamera._postProcesses;
			return !(0 === t.length || !this._scene.postProcessesEnabled) && (t[0].activate(this._scene.activeCamera, e), !0)
		}, t.prototype.directRender = function(e, t) {
			for (var i = this._scene.getEngine(), r = 0; r < e.length; r++) {
				r < e.length - 1 ? e[r + 1].activate(this._scene.activeCamera, t) : t ? i.bindFramebuffer(t) : i.restoreDefaultFramebuffer();
				var n = e[r],
					o = n.apply();
				o && (n.onBeforeRenderObservable.notifyObservers(o), this._prepareBuffers(), i.bindBuffers(this._vertexBuffers, this._indexBuffer, o), i.draw(!0, 0, 6), n.onAfterRenderObservable.notifyObservers(o))
			}
			i.setDepthBuffer(!0), i.setDepthWrite(!0)
		}, t.prototype._finalizeFrame = function(e, t, i, r) {
			if (r = r || this._scene.activeCamera._postProcesses, 0 !== r.length && this._scene.postProcessesEnabled) {
				for (var n = this._scene.getEngine(), o = 0, s = r.length; o < s && (o < s - 1 ? r[o + 1].activate(this._scene.activeCamera, t) : t ? n.bindFramebuffer(t, i) : n.restoreDefaultFramebuffer(), !e); o++) {
					var a = r[o],
						h = a.apply();
					h && (a.onBeforeRenderObservable.notifyObservers(h), this._prepareBuffers(), n.bindBuffers(this._vertexBuffers, this._indexBuffer, h), n.draw(!0, 0, 6), a.onAfterRenderObservable.notifyObservers(h))
				}
				n.setDepthBuffer(!0), n.setDepthWrite(!0)
			}
		}, t.prototype.dispose = function() {
			var t = this._vertexBuffers[e.VertexBuffer.PositionKind];
			t && (t.dispose(), this._vertexBuffers[e.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null)
		}, t
	})();
	e.PostProcessManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s) {
			e.call(this, t, "pass", null, null, i, r, n, o, s)
		}
		return __extends(t, e), t
	})(e.PostProcess);
	e.PassPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t) {
			this.type = e, this.jointData = t, t.nativeParams = t.nativeParams || {}
		}
		return Object.defineProperty(e.prototype, "physicsJoint", {
			get: function() {
				return this._physicsJoint
			},
			set: function(e) {
				this._physicsJoint, this._physicsJoint = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "physicsPlugin", {
			set: function(e) {
				this._physicsPlugin = e
			},
			enumerable: !0,
			configurable: !0
		}), e.prototype.executeNativeFunction = function(e) {
			e(this._physicsPlugin.world, this._physicsJoint)
		}, e.DistanceJoint = 0, e.HingeJoint = 1, e.BallAndSocketJoint = 2, e.WheelJoint = 3, e.SliderJoint = 4, e.PrismaticJoint = 5, e.UniversalJoint = 6, e.Hinge2Joint = e.WheelJoint, e.PointToPointJoint = 8, e.SpringJoint = 9, e.LockJoint = 10, e
	})();
	e.PhysicsJoint = t;
	var i = (function(e) {
		function i(i) {
			e.call(this, t.DistanceJoint, i)
		}
		return __extends(i, e), i.prototype.updateDistance = function(e, t) {
			this._physicsPlugin.updateDistanceJoint(this, e, t)
		}, i
	})(t);
	e.DistanceJoint = i;
	var r = (function(e) {
		function t(t, i) {
			e.call(this, t, i)
		}
		return __extends(t, e), t.prototype.setMotor = function(e, t) {
			this._physicsPlugin.setMotor(this, e, t)
		}, t.prototype.setLimit = function(e, t) {
			this._physicsPlugin.setLimit(this, e, t)
		}, t
	})(t);
	e.MotorEnabledJoint = r;
	var n = (function(e) {
		function i(i) {
			e.call(this, t.HingeJoint, i)
		}
		return __extends(i, e), i.prototype.setMotor = function(e, t) {
			this._physicsPlugin.setMotor(this, e, t)
		}, i.prototype.setLimit = function(e, t) {
			this._physicsPlugin.setLimit(this, e, t)
		}, i
	})(r);
	e.HingeJoint = n;
	var o = (function(e) {
		function i(i) {
			e.call(this, t.Hinge2Joint, i)
		}
		return __extends(i, e), i.prototype.setMotor = function(e, t, i) {
			void 0 === i && (i = 0), this._physicsPlugin.setMotor(this, e, t, i)
		}, i.prototype.setLimit = function(e, t, i) {
			void 0 === i && (i = 0), this._physicsPlugin.setLimit(this, e, t, i)
		}, i
	})(r);
	e.Hinge2Joint = o
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n) {
			var o = this;
			return void 0 === r && (r = {
				mass: 0
			}), this.object = t, this.type = i, this._options = r, this._scene = n, this._bodyUpdateRequired = !1, this._onBeforePhysicsStepCallbacks = new Array, this._onAfterPhysicsStepCallbacks = new Array, this._onPhysicsCollideCallbacks = [], this._deltaPosition = e.Vector3.Zero(), this._tmpPositionWithDelta = e.Vector3.Zero(), this._tmpRotationWithDelta = new e.Quaternion, this.beforeStep = function() {
				o.object.position.subtractToRef(o._deltaPosition, o._tmpPositionWithDelta), o._deltaRotationConjugated ? o.object.rotationQuaternion.multiplyToRef(o._deltaRotationConjugated, o._tmpRotationWithDelta) : o._tmpRotationWithDelta.copyFrom(o.object.rotationQuaternion), o._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(o, o._tmpPositionWithDelta, o._tmpRotationWithDelta), o._onBeforePhysicsStepCallbacks.forEach((function(e) {
					e(o)
				}))
			}, this.afterStep = function() {
				o._onAfterPhysicsStepCallbacks.forEach((function(e) {
					e(o)
				})), o._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(o), o.object.position.addInPlace(o._deltaPosition), o._deltaRotation && o.object.rotationQuaternion.multiplyInPlace(o._deltaRotation)
			}, this.onCollide = function(e) {
				if (o._onPhysicsCollideCallbacks.length) {
					var t = o._physicsEngine.getImpostorWithPhysicsBody(e.body);
					t && o._onPhysicsCollideCallbacks.filter((function(e) {
						return e.otherImpostors.indexOf(t) !== -1
					})).forEach((function(e) {
						e.callback(o, t)
					}))
				}
			}, this.object ? (!this._scene && t.getScene && (this._scene = t.getScene()), this._physicsEngine = this._scene.getPhysicsEngine(), void(this._physicsEngine ? (this.object.rotationQuaternion || (this.object.rotation ? this.object.rotationQuaternion = e.Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z) : this.object.rotationQuaternion = new e.Quaternion), this._options.mass = void 0 === r.mass ? 0 : r.mass, this._options.friction = void 0 === r.friction ? .2 : r.friction, this._options.restitution = void 0 === r.restitution ? .2 : r.restitution, this._joints = [], this.object.parent || this._init()) : e.Tools.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors."))) : void e.Tools.Error("No object was provided. A physics object is obligatory")
		}
		return t.prototype._init = function() {
			this._physicsEngine.removeImpostor(this), this.physicsBody = null, this._parent = this._parent || this._getPhysicsParent(), this.parent || this._physicsEngine.addImpostor(this)
		}, t.prototype._getPhysicsParent = function() {
			if (this.object.parent instanceof e.AbstractMesh) {
				var t = this.object.parent;
				return t.physicsImpostor
			}
		}, t.prototype.isBodyInitRequired = function() {
			return this._bodyUpdateRequired || !this._physicsBody && !this._parent
		}, t.prototype.setScalingUpdated = function(e) {
			this.forceUpdate()
		}, t.prototype.forceUpdate = function() {
			this._init(), this.parent && this.parent.forceUpdate()
		}, Object.defineProperty(t.prototype, "physicsBody", {
			get: function() {
				return this._parent ? this._parent.physicsBody : this._physicsBody
			},
			set: function(e) {
				this._physicsBody && this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this), this._physicsBody = e, this.resetUpdateFlags()
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "parent", {
			get: function() {
				return this._parent
			},
			set: function(e) {
				this._parent = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.resetUpdateFlags = function() {
			this._bodyUpdateRequired = !1
		}, t.prototype.getObjectExtendSize = function() {
			return this.object.getBoundingInfo ? (this.object.computeWorldMatrix && this.object.computeWorldMatrix(!0), this.object.getBoundingInfo().boundingBox.extendSize.scale(2).multiply(this.object.scaling)) : t.DEFAULT_OBJECT_SIZE
		}, t.prototype.getObjectCenter = function() {
			return this.object.getBoundingInfo ? this.object.getBoundingInfo().boundingBox.center : this.object.position
		}, t.prototype.getParam = function(e) {
			return this._options[e]
		}, t.prototype.setParam = function(e, t) {
			this._options[e] = t, this._bodyUpdateRequired = !0
		}, t.prototype.setMass = function(e) {
			this.getParam("mass") !== e && this.setParam("mass", e), this._physicsEngine.getPhysicsPlugin().setBodyMass(this, e)
		}, t.prototype.getLinearVelocity = function() {
			return this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this)
		}, t.prototype.setLinearVelocity = function(e) {
			this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, e)
		}, t.prototype.getAngularVelocity = function() {
			return this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this)
		}, t.prototype.setAngularVelocity = function(e) {
			this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, e)
		}, t.prototype.executeNativeFunction = function(e) {
			e(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody)
		}, t.prototype.registerBeforePhysicsStep = function(e) {
			this._onBeforePhysicsStepCallbacks.push(e)
		}, t.prototype.unregisterBeforePhysicsStep = function(t) {
			var i = this._onBeforePhysicsStepCallbacks.indexOf(t);
			i > -1 ? this._onBeforePhysicsStepCallbacks.splice(i, 1) : e.Tools.Warn("Function to remove was not found")
		}, t.prototype.registerAfterPhysicsStep = function(e) {
			this._onAfterPhysicsStepCallbacks.push(e)
		}, t.prototype.unregisterAfterPhysicsStep = function(t) {
			var i = this._onAfterPhysicsStepCallbacks.indexOf(t);
			i > -1 ? this._onAfterPhysicsStepCallbacks.splice(i, 1) : e.Tools.Warn("Function to remove was not found")
		}, t.prototype.registerOnPhysicsCollide = function(e, t) {
			var i = e instanceof Array ? e : [e];
			this._onPhysicsCollideCallbacks.push({
				callback: t,
				otherImpostors: i
			})
		}, t.prototype.unregisterOnPhysicsCollide = function(t, i) {
			var r = t instanceof Array ? t : [t],
				n = this._onPhysicsCollideCallbacks.indexOf({
					callback: i,
					otherImpostors: r
				});
			n > -1 ? this._onPhysicsCollideCallbacks.splice(n, 1) : e.Tools.Warn("Function to remove was not found")
		}, t.prototype.applyForce = function(e, t) {
			this._physicsEngine.getPhysicsPlugin().applyForce(this, e, t)
		}, t.prototype.applyImpulse = function(e, t) {
			this._physicsEngine.getPhysicsPlugin().applyImpulse(this, e, t)
		}, t.prototype.createJoint = function(t, i, r) {
			var n = new e.PhysicsJoint(i, r);
			this.addJoint(t, n)
		}, t.prototype.addJoint = function(e, t) {
			this._joints.push({
				otherImpostor: e,
				joint: t
			}), this._physicsEngine.addJoint(this, e, t)
		}, t.prototype.sleep = function() {
			this._physicsEngine.getPhysicsPlugin().sleepBody(this)
		}, t.prototype.wakeUp = function() {
			this._physicsEngine.getPhysicsPlugin().wakeUpBody(this)
		}, t.prototype.clone = function(e) {
			return e ? new t(e, this.type, this._options, this._scene) : null
		}, t.prototype.dispose = function() {
			var e = this;
			this._physicsEngine && (this._joints.forEach((function(t) {
				e._physicsEngine.removeJoint(e, t.otherImpostor, t.joint)
			})), this._physicsEngine.removeImpostor(this), this.parent && this.parent.forceUpdate())
		}, t.prototype.setDeltaPosition = function(e) {
			this._deltaPosition.copyFrom(e)
		}, t.prototype.setDeltaRotation = function(t) {
			this._deltaRotation || (this._deltaRotation = new e.Quaternion), this._deltaRotation.copyFrom(t), this._deltaRotationConjugated = this._deltaRotation.conjugate()
		}, t.DEFAULT_OBJECT_SIZE = new e.Vector3(1, 1, 1), t.NoImpostor = 0, t.SphereImpostor = 1, t.BoxImpostor = 2, t.PlaneImpostor = 3, t.MeshImpostor = 4, t.CylinderImpostor = 7, t.ParticleImpostor = 8, t.HeightmapImpostor = 9, t
	})();
	e.PhysicsImpostor = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			if (void 0 === i && (i = new e.CannonJSPlugin), this._physicsPlugin = i, this._impostors = [], this._joints = [], !this._physicsPlugin.isSupported()) throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. Please make sure it is included.");
			t = t || new e.Vector3(0, (-9.807), 0), this.setGravity(t), this.setTimeStep()
		}
		return t.prototype.setGravity = function(e) {
			this.gravity = e, this._physicsPlugin.setGravity(this.gravity)
		}, t.prototype.setTimeStep = function(e) {
			void 0 === e && (e = 1 / 60), this._physicsPlugin.setTimeStep(e)
		}, t.prototype.dispose = function() {
			this._impostors.forEach((function(e) {
				e.dispose()
			})), this._physicsPlugin.dispose()
		}, t.prototype.getPhysicsPluginName = function() {
			return this._physicsPlugin.name
		}, t.prototype.addImpostor = function(e) {
			e.uniqueId = this._impostors.push(e), e.parent || this._physicsPlugin.generatePhysicsBody(e)
		}, t.prototype.removeImpostor = function(e) {
			var t = this._impostors.indexOf(e);
			if (t > -1) {
				var i = this._impostors.splice(t, 1);
				i.length && (i[0].physicsBody = null)
			}
		}, t.prototype.addJoint = function(e, t, i) {
			var r = {
				mainImpostor: e,
				connectedImpostor: t,
				joint: i
			};
			i.physicsPlugin = this._physicsPlugin, this._joints.push(r), this._physicsPlugin.generateJoint(r)
		}, t.prototype.removeJoint = function(e, t, i) {
			var r = this._joints.filter((function(r) {
				return r.connectedImpostor === t && r.joint === i && r.mainImpostor === e
			}));
			r.length && this._physicsPlugin.removeJoint(r[0])
		}, t.prototype._step = function(e) {
			var t = this;
			this._impostors.forEach((function(e) {
				e.isBodyInitRequired() && t._physicsPlugin.generatePhysicsBody(e)
			})), e > .1 ? e = .1 : e <= 0 && (e = 1 / 60), this._physicsPlugin.executeStep(e, this._impostors)
		}, t.prototype.getPhysicsPlugin = function() {
			return this._physicsPlugin
		}, t.prototype.getImpostorForPhysicsObject = function(e) {
			for (var t = 0; t < this._impostors.length; ++t)
				if (this._impostors[t].object === e) return this._impostors[t]
		}, t.prototype.getImpostorWithPhysicsBody = function(e) {
			for (var t = 0; t < this._impostors.length; ++t)
				if (this._impostors[t].physicsBody === e) return this._impostors[t]
		}, t.NoImpostor = e.PhysicsImpostor.NoImpostor, t.SphereImpostor = e.PhysicsImpostor.SphereImpostor, t.BoxImpostor = e.PhysicsImpostor.BoxImpostor, t.PlaneImpostor = e.PhysicsImpostor.PlaneImpostor, t.MeshImpostor = e.PhysicsImpostor.MeshImpostor, t.CylinderImpostor = e.PhysicsImpostor.CylinderImpostor, t.HeightmapImpostor = e.PhysicsImpostor.HeightmapImpostor, t.CapsuleImpostor = -1, t.ConeImpostor = -1, t.ConvexHullImpostor = -1, t.Epsilon = .001, t
	})();
	e.PhysicsEngine = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {}
		return t.prototype.set = function(t, i) {
			switch (i) {
				case e.VertexBuffer.PositionKind:
					this.positions = t;
					break;
				case e.VertexBuffer.NormalKind:
					this.normals = t;
					break;
				case e.VertexBuffer.UVKind:
					this.uvs = t;
					break;
				case e.VertexBuffer.UV2Kind:
					this.uvs2 = t;
					break;
				case e.VertexBuffer.UV3Kind:
					this.uvs3 = t;
					break;
				case e.VertexBuffer.UV4Kind:
					this.uvs4 = t;
					break;
				case e.VertexBuffer.UV5Kind:
					this.uvs5 = t;
					break;
				case e.VertexBuffer.UV6Kind:
					this.uvs6 = t;
					break;
				case e.VertexBuffer.ColorKind:
					this.colors = t;
					break;
				case e.VertexBuffer.MatricesIndicesKind:
					this.matricesIndices = t;
					break;
				case e.VertexBuffer.MatricesWeightsKind:
					this.matricesWeights = t;
					break;
				case e.VertexBuffer.MatricesIndicesExtraKind:
					this.matricesIndicesExtra = t;
					break;
				case e.VertexBuffer.MatricesWeightsExtraKind:
					this.matricesWeightsExtra = t
			}
		}, t.prototype.applyToMesh = function(e, t) {
			this._applyTo(e, t)
		}, t.prototype.applyToGeometry = function(e, t) {
			this._applyTo(e, t)
		}, t.prototype.updateMesh = function(e, t, i) {
			this._update(e)
		}, t.prototype.updateGeometry = function(e, t, i) {
			this._update(e)
		}, t.prototype._applyTo = function(t, i) {
			this.positions && t.setVerticesData(e.VertexBuffer.PositionKind, this.positions, i), this.normals && t.setVerticesData(e.VertexBuffer.NormalKind, this.normals, i), this.uvs && t.setVerticesData(e.VertexBuffer.UVKind, this.uvs, i), this.uvs2 && t.setVerticesData(e.VertexBuffer.UV2Kind, this.uvs2, i), this.uvs3 && t.setVerticesData(e.VertexBuffer.UV3Kind, this.uvs3, i), this.uvs4 && t.setVerticesData(e.VertexBuffer.UV4Kind, this.uvs4, i), this.uvs5 && t.setVerticesData(e.VertexBuffer.UV5Kind, this.uvs5, i), this.uvs6 && t.setVerticesData(e.VertexBuffer.UV6Kind, this.uvs6, i), this.colors && t.setVerticesData(e.VertexBuffer.ColorKind, this.colors, i), this.matricesIndices && t.setVerticesData(e.VertexBuffer.MatricesIndicesKind, this.matricesIndices, i), this.matricesWeights && t.setVerticesData(e.VertexBuffer.MatricesWeightsKind, this.matricesWeights, i), this.matricesIndicesExtra && t.setVerticesData(e.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, i), this.matricesWeightsExtra && t.setVerticesData(e.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, i), this.indices && t.setIndices(this.indices)
		}, t.prototype._update = function(t, i, r) {
			this.positions && t.updateVerticesData(e.VertexBuffer.PositionKind, this.positions, i, r), this.normals && t.updateVerticesData(e.VertexBuffer.NormalKind, this.normals, i, r), this.uvs && t.updateVerticesData(e.VertexBuffer.UVKind, this.uvs, i, r), this.uvs2 && t.updateVerticesData(e.VertexBuffer.UV2Kind, this.uvs2, i, r), this.uvs3 && t.updateVerticesData(e.VertexBuffer.UV3Kind, this.uvs3, i, r), this.uvs4 && t.updateVerticesData(e.VertexBuffer.UV4Kind, this.uvs4, i, r), this.uvs5 && t.updateVerticesData(e.VertexBuffer.UV5Kind, this.uvs5, i, r), this.uvs6 && t.updateVerticesData(e.VertexBuffer.UV6Kind, this.uvs6, i, r), this.colors && t.updateVerticesData(e.VertexBuffer.ColorKind, this.colors, i, r), this.matricesIndices && t.updateVerticesData(e.VertexBuffer.MatricesIndicesKind, this.matricesIndices, i, r), this.matricesWeights && t.updateVerticesData(e.VertexBuffer.MatricesWeightsKind, this.matricesWeights, i, r), this.matricesIndicesExtra && t.updateVerticesData(e.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, i, r), this.matricesWeightsExtra && t.updateVerticesData(e.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, i, r), this.indices && t.setIndices(this.indices)
		}, t.prototype.transform = function(t) {
			var i, r = e.Vector3.Zero();
			if (this.positions) {
				var n = e.Vector3.Zero();
				for (i = 0; i < this.positions.length; i += 3) e.Vector3.FromArrayToRef(this.positions, i, n), e.Vector3.TransformCoordinatesToRef(n, t, r), this.positions[i] = r.x, this.positions[i + 1] = r.y, this.positions[i + 2] = r.z
			}
			if (this.normals) {
				var o = e.Vector3.Zero();
				for (i = 0; i < this.normals.length; i += 3) e.Vector3.FromArrayToRef(this.normals, i, o), e.Vector3.TransformNormalToRef(o, t, r), this.normals[i] = r.x, this.normals[i + 1] = r.y, this.normals[i + 2] = r.z
			}
		}, t.prototype.merge = function(e) {
			if (e.indices) {
				this.indices || (this.indices = []);
				for (var t = this.positions ? this.positions.length / 3 : 0, i = 0; i < e.indices.length; i++) this.indices.push(e.indices[i] + t)
			}
			this.positions = this._mergeElement(this.positions, e.positions), this.normals = this._mergeElement(this.normals, e.normals), this.uvs = this._mergeElement(this.uvs, e.uvs), this.uvs2 = this._mergeElement(this.uvs2, e.uvs2), this.uvs3 = this._mergeElement(this.uvs3, e.uvs3), this.uvs4 = this._mergeElement(this.uvs4, e.uvs4), this.uvs5 = this._mergeElement(this.uvs5, e.uvs5), this.uvs6 = this._mergeElement(this.uvs6, e.uvs6), this.colors = this._mergeElement(this.colors, e.colors), this.matricesIndices = this._mergeElement(this.matricesIndices, e.matricesIndices), this.matricesWeights = this._mergeElement(this.matricesWeights, e.matricesWeights), this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, e.matricesIndicesExtra), this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, e.matricesWeightsExtra)
		}, t.prototype._mergeElement = function(e, t) {
			if (!t) return e;
			if (!e) return t;
			var i = t.length + e.length,
				r = e instanceof Float32Array,
				n = t instanceof Float32Array;
			if (r) {
				var o = new Float32Array(i);
				return o.set(e), o.set(t, e.length), o
			}
			if (n) {
				for (var s = e.slice(0), a = 0, i = t.length; a < i; a++) s.push(t[a]);
				return s
			}
			return e.concat(t)
		}, t.prototype.serialize = function() {
			var e = this.serialize();
			return this.positions && (e.positions = this.positions), this.normals && (e.normals = this.normals), this.uvs && (e.uvs = this.uvs), this.uvs2 && (e.uvs2 = this.uvs2), this.uvs3 && (e.uvs3 = this.uvs3), this.uvs4 && (e.uvs4 = this.uvs4), this.uvs5 && (e.uvs5 = this.uvs5), this.uvs6 && (e.uvs6 = this.uvs6), this.colors && (e.colors = this.colors), this.matricesIndices && (e.matricesIndices = this.matricesIndices, e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = this.matricesWeights), this.matricesIndicesExtra && (e.matricesIndicesExtra = this.matricesIndicesExtra, e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = this.matricesWeightsExtra), e.indices = this.indices, e
		}, t.ExtractFromMesh = function(e, i) {
			return t._ExtractFrom(e, i)
		}, t.ExtractFromGeometry = function(e, i) {
			return t._ExtractFrom(e, i)
		}, t._ExtractFrom = function(i, r) {
			var n = new t;
			return i.isVerticesDataPresent(e.VertexBuffer.PositionKind) && (n.positions = i.getVerticesData(e.VertexBuffer.PositionKind, r)), i.isVerticesDataPresent(e.VertexBuffer.NormalKind) && (n.normals = i.getVerticesData(e.VertexBuffer.NormalKind, r)), i.isVerticesDataPresent(e.VertexBuffer.UVKind) && (n.uvs = i.getVerticesData(e.VertexBuffer.UVKind, r)), i.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (n.uvs2 = i.getVerticesData(e.VertexBuffer.UV2Kind, r)), i.isVerticesDataPresent(e.VertexBuffer.UV3Kind) && (n.uvs3 = i.getVerticesData(e.VertexBuffer.UV3Kind, r)), i.isVerticesDataPresent(e.VertexBuffer.UV4Kind) && (n.uvs4 = i.getVerticesData(e.VertexBuffer.UV4Kind, r)), i.isVerticesDataPresent(e.VertexBuffer.UV5Kind) && (n.uvs5 = i.getVerticesData(e.VertexBuffer.UV5Kind, r)), i.isVerticesDataPresent(e.VertexBuffer.UV6Kind) && (n.uvs6 = i.getVerticesData(e.VertexBuffer.UV6Kind, r)), i.isVerticesDataPresent(e.VertexBuffer.ColorKind) && (n.colors = i.getVerticesData(e.VertexBuffer.ColorKind, r)), i.isVerticesDataPresent(e.VertexBuffer.MatricesIndicesKind) && (n.matricesIndices = i.getVerticesData(e.VertexBuffer.MatricesIndicesKind, r)), i.isVerticesDataPresent(e.VertexBuffer.MatricesWeightsKind) && (n.matricesWeights = i.getVerticesData(e.VertexBuffer.MatricesWeightsKind, r)), i.isVerticesDataPresent(e.VertexBuffer.MatricesIndicesExtraKind) && (n.matricesIndicesExtra = i.getVerticesData(e.VertexBuffer.MatricesIndicesExtraKind, r)), i.isVerticesDataPresent(e.VertexBuffer.MatricesWeightsExtraKind) && (n.matricesWeightsExtra = i.getVerticesData(e.VertexBuffer.MatricesWeightsExtraKind, r)), n.indices = i.getIndices(r), n
		}, t.CreateRibbon = function(i) {
			var r = i.pathArray,
				n = i.closeArray || !1,
				o = i.closePath || !1,
				s = i.invertUV || !1,
				a = Math.floor(r[0].length / 2),
				h = i.offset || a;
			h = h > a ? a : Math.floor(h);
			var c, l, u, d, f = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE,
				p = [],
				m = [],
				_ = [],
				g = [],
				v = [],
				y = [],
				x = [],
				b = [],
				T = [],
				A = [];
			if (r.length < 2) {
				var E = [],
					P = [];
				for (u = 0; u < r[0].length - h; u++) E.push(r[0][u]), P.push(r[0][u + h]);
				r = [E, P]
			}
			var M, S, C = 0,
				R = o ? 1 : 0;
			c = r[0].length;
			var O, D;
			for (l = 0; l < r.length; l++) {
				for (x[l] = 0, v[l] = [0], M = r[l], S = M.length, c = c < S ? c : S, d = 0; d < S;) p.push(M[d].x, M[d].y, M[d].z), d > 0 && (O = M[d].subtract(M[d - 1]).length(), D = O + x[l], v[l].push(D), x[l] = D), d++;
				o && (d--, p.push(M[0].x, M[0].y, M[0].z), O = M[d].subtract(M[0]).length(), D = O + x[l], v[l].push(D), x[l] = D), T[l] = S + R, A[l] = C, C += S + R
			}
			var I, w, L, B;
			for (u = 0; u < c + R; u++) {
				for (b[u] = 0, y[u] = [0], l = 0; l < r.length - 1; l++) I = r[l], w = r[l + 1], u === c ? (L = I[0], B = w[0]) : (L = I[u], B = w[u]), O = B.subtract(L).length(), D = O + b[u], y[u].push(D), b[u] = D;
				n && (I = r[l], w = r[0], u === c && (B = w[0]), O = B.subtract(L).length(), D = O + b[u], b[u] = D)
			}
			var F, V;
			for (l = 0; l < r.length; l++)
				for (u = 0; u < c + R; u++) F = v[l][u] / x[l], V = y[u][l] / b[u], s ? g.push(V, F) : g.push(F, V);
			l = 0;
			for (var N = 0, z = T[l] - 1, U = T[l + 1] - 1, k = z < U ? z : U, G = A[1] - A[0], W = n ? T.length : T.length - 1; N <= k && l < W;) m.push(N, N + G, N + 1), m.push(N + G + 1, N + 1, N + G), N += 1, N === k && (l++, l === T.length - 1 ? (G = A[0] - A[l], z = T[l] - 1, U = T[0] - 1) : (G = A[l + 1] - A[l], z = T[l] - 1, U = T[l + 1] - 1), N = A[l], k = z < U ? z + N : U + N);
			if (t.ComputeNormals(p, m, _), o) {
				var Y = 0,
					H = 0;
				for (l = 0; l < r.length; l++) Y = 3 * A[l], H = l + 1 < r.length ? 3 * (A[l + 1] - 1) : _.length - 3, _[Y] = .5 * (_[Y] + _[H]), _[Y + 1] = .5 * (_[Y + 1] + _[H + 1]), _[Y + 2] = .5 * (_[Y + 2] + _[H + 2]), _[H] = _[Y], _[H + 1] = _[Y + 1], _[H + 2] = _[Y + 2]
			}
			t._ComputeSides(f, p, m, _, g);
			var j = new t;
			return j.indices = m, j.positions = p, j.normals = _, j.uvs = g, o && (j._idx = A), j
		}, t.CreateBox = function(i) {
			for (var r = [new e.Vector3(0, 0, 1), new e.Vector3(0, 0, (-1)), new e.Vector3(1, 0, 0), new e.Vector3((-1), 0, 0), new e.Vector3(0, 1, 0), new e.Vector3(0, (-1), 0)], n = [], o = [], s = [], a = [], h = i.width || i.size || 1, c = i.height || i.size || 1, l = i.depth || i.size || 1, u = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE, d = i.faceUV || new Array(6), f = i.faceColors, p = [], m = 0; m < 6; m++) void 0 === d[m] && (d[m] = new e.Vector4(0, 0, 1, 1)), f && void 0 === f[m] && (f[m] = new e.Color4(1, 1, 1, 1));
			for (var _ = new e.Vector3(h / 2, c / 2, l / 2), g = 0; g < r.length; g++) {
				var v = r[g],
					y = new e.Vector3(v.y, v.z, v.x),
					x = e.Vector3.Cross(v, y),
					b = o.length / 3;
				n.push(b), n.push(b + 1), n.push(b + 2), n.push(b), n.push(b + 2), n.push(b + 3);
				var T = v.subtract(y).subtract(x).multiply(_);
				o.push(T.x, T.y, T.z), s.push(v.x, v.y, v.z), a.push(d[g].z, d[g].w), f && p.push(f[g].r, f[g].g, f[g].b, f[g].a), T = v.subtract(y).add(x).multiply(_), o.push(T.x, T.y, T.z), s.push(v.x, v.y, v.z), a.push(d[g].x, d[g].w), f && p.push(f[g].r, f[g].g, f[g].b, f[g].a), T = v.add(y).add(x).multiply(_), o.push(T.x, T.y, T.z), s.push(v.x, v.y, v.z), a.push(d[g].x, d[g].y), f && p.push(f[g].r, f[g].g, f[g].b, f[g].a), T = v.add(y).subtract(x).multiply(_), o.push(T.x, T.y, T.z), s.push(v.x, v.y, v.z), a.push(d[g].z, d[g].y), f && p.push(f[g].r, f[g].g, f[g].b, f[g].a)
			}
			t._ComputeSides(u, o, n, s, a);
			var A = new t;
			if (A.indices = n, A.positions = o, A.normals = s, A.uvs = a, f) {
				var E = u === e.Mesh.DOUBLESIDE ? p.concat(p) : p;
				A.colors = E
			}
			return A
		}, t.CreateSphere = function(i) {
			for (var r = i.segments || 32, n = i.diameterX || i.diameter || 1, o = i.diameterY || i.diameter || 1, s = i.diameterZ || i.diameter || 1, a = i.arc <= 0 || i.arc > 1 ? 1 : i.arc || 1, h = i.slice <= 0 ? 1 : i.slice || 1, c = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE, l = new e.Vector3(n / 2, o / 2, s / 2), u = 2 + r, d = 2 * u, f = [], p = [], m = [], _ = [], g = 0; g <= u; g++) {
				for (var v = g / u, y = v * Math.PI * h, x = 0; x <= d; x++) {
					var b = x / d,
						T = b * Math.PI * 2 * a,
						A = e.Matrix.RotationZ(-y),
						E = e.Matrix.RotationY(T),
						P = e.Vector3.TransformCoordinates(e.Vector3.Up(), A),
						M = e.Vector3.TransformCoordinates(P, E),
						S = M.multiply(l),
						C = M.divide(l).normalize();
					p.push(S.x, S.y, S.z), m.push(C.x, C.y, C.z), _.push(b, v)
				}
				if (g > 0)
					for (var R = p.length / 3, O = R - 2 * (d + 1); O + d + 2 < R; O++) f.push(O), f.push(O + 1), f.push(O + d + 1), f.push(O + d + 1), f.push(O + 1), f.push(O + d + 2)
			}
			t._ComputeSides(c, p, f, m, _);
			var D = new t;
			return D.indices = f, D.positions = p, D.normals = m, D.uvs = _, D
		}, t.CreateCylinder = function(i) {
			var r, n = i.height || 2,
				o = 0 === i.diameterTop ? 0 : i.diameterTop || i.diameter || 1,
				s = 0 === i.diameterBottom ? 0 : i.diameterBottom || i.diameter || 1,
				a = i.tessellation || 24,
				h = i.subdivisions || 1,
				c = i.hasRings,
				l = i.enclose,
				u = i.arc <= 0 || i.arc > 1 ? 1 : i.arc || 1,
				d = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE,
				f = i.faceUV || new Array(3),
				p = i.faceColors,
				m = 1 !== u && l ? 2 : 0,
				_ = c ? h : 1,
				g = 2 + (1 + m) * _;
			for (r = 0; r < g; r++) p && void 0 === p[r] && (p[r] = new e.Color4(1, 1, 1, 1));
			for (r = 0; r < g; r++) f && void 0 === f[r] && (f[r] = new e.Vector4(0, 0, 1, 1));
			var v, y, x, b, T, A, E = [],
				P = [],
				M = [],
				S = [],
				C = [],
				R = 2 * Math.PI * u / a,
				O = (s - o) / 2 / n,
				D = e.Vector3.Zero(),
				I = e.Vector3.Zero(),
				w = e.Vector3.Zero(),
				L = e.Vector3.Zero(),
				B = e.Vector3.Zero(),
				F = e.Axis.Y,
				V = 1,
				N = 1,
				z = 0,
				U = 0;
			for (b = 0; b <= h; b++)
				for (y = b / h, x = (y * (o - s) + s) / 2, V = c && 0 !== b && b !== h ? 2 : 1, A = 0; A < V; A++) {
					for (c && (N += A), l && (N += 2 * A), T = 0; T <= a; T++) v = T * R, D.x = Math.cos(-v) * x, D.y = -n / 2 + y * n, D.z = Math.sin(-v) * x, 0 === o && b === h ? (I.x = M[M.length - 3 * (a + 1)], I.y = M[M.length - 3 * (a + 1) + 1], I.z = M[M.length - 3 * (a + 1) + 2]) : (I.x = D.x, I.z = D.z, I.y = Math.sqrt(I.x * I.x + I.z * I.z) * O, I.normalize()), 0 === T && (w.copyFrom(D), L.copyFrom(I)), P.push(D.x, D.y, D.z), M.push(I.x, I.y, I.z), U = c ? z !== N ? f[N].y : f[N].w : f[N].y + (f[N].w - f[N].y) * y, S.push(f[N].x + (f[N].z - f[N].x) * T / a, U), p && C.push(p[N].r, p[N].g, p[N].b, p[N].a);
					1 !== u && l && (P.push(D.x, D.y, D.z), P.push(0, D.y, 0), P.push(0, D.y, 0), P.push(w.x, w.y, w.z), e.Vector3.CrossToRef(F, I, B), B.normalize(), M.push(B.x, B.y, B.z, B.x, B.y, B.z), e.Vector3.CrossToRef(L, F, B), B.normalize(), M.push(B.x, B.y, B.z, B.x, B.y, B.z), U = c ? z !== N ? f[N + 1].y : f[N + 1].w : f[N + 1].y + (f[N + 1].w - f[N + 1].y) * y, S.push(f[N + 1].x, U), S.push(f[N + 1].z, U), U = c ? z !== N ? f[N + 2].y : f[N + 2].w : f[N + 2].y + (f[N + 2].w - f[N + 2].y) * y, S.push(f[N + 2].x, U), S.push(f[N + 2].z, U), p && (C.push(p[N + 1].r, p[N + 1].g, p[N + 1].b, p[N + 1].a), C.push(p[N + 1].r, p[N + 1].g, p[N + 1].b, p[N + 1].a), C.push(p[N + 2].r, p[N + 2].g, p[N + 2].b, p[N + 2].a), C.push(p[N + 2].r, p[N + 2].g, p[N + 2].b, p[N + 2].a))), z !== N && (z = N)
				}
			var N, k = 1 !== u && l ? a + 4 : a;
			for (b = 0, N = 0; N < h; N++) {
				for (T = 0; T < a; T++) {
					var G = b * (k + 1) + T,
						W = (b + 1) * (k + 1) + T,
						Y = b * (k + 1) + (T + 1),
						H = (b + 1) * (k + 1) + (T + 1);
					E.push(G, W, Y), E.push(H, Y, W)
				}
				1 !== u && l && (E.push(G + 2, W + 2, Y + 2), E.push(H + 2, Y + 2, W + 2), E.push(G + 4, W + 4, Y + 4), E.push(H + 4, Y + 4, W + 4)), b = c ? b + 2 : b + 1
			}
			var j = function(t) {
				var i = t ? o / 2 : s / 2;
				if (0 !== i) {
					var r, h, c, l, d = t ? f[g - 1] : f[0];
					p && (l = t ? p[g - 1] : p[0]);
					var m = P.length / 3,
						_ = t ? n / 2 : -n / 2,
						v = new e.Vector3(0, _, 0);
					P.push(v.x, v.y, v.z), M.push(0, t ? 1 : -1, 0), S.push(d.x + .5 * (d.z - d.x), d.y + .5 * (d.w - d.y)), p && C.push(l.r, l.g, l.b, l.a);
					var y = new e.Vector2(.5, .5);
					for (c = 0; c <= a; c++) {
						r = 2 * Math.PI * c * u / a;
						var x = Math.cos(-r),
							b = Math.sin(-r);
						h = new e.Vector3(x * i, _, b * i);
						var T = new e.Vector2(x * y.x + .5, b * y.y + .5);
						P.push(h.x, h.y, h.z), M.push(0, t ? 1 : -1, 0), S.push(d.x + (d.z - d.x) * T.x, d.y + (d.w - d.y) * T.y), p && C.push(l.r, l.g, l.b, l.a)
					}
					for (c = 0; c < a; c++) t ? (E.push(m), E.push(m + (c + 2)), E.push(m + (c + 1))) : (E.push(m), E.push(m + (c + 1)), E.push(m + (c + 2)))
				}
			};
			j(!1), j(!0), t._ComputeSides(d, P, E, M, S);
			var X = new t;
			return X.indices = E, X.positions = P, X.normals = M, X.uvs = S, p && (X.colors = C), X
		}, t.CreateTorus = function(i) {
			for (var r = [], n = [], o = [], s = [], a = i.diameter || 1, h = i.thickness || .5, c = i.tessellation || 16, l = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE, u = c + 1, d = 0; d <= c; d++)
				for (var f = d / c, p = d * Math.PI * 2 / c - Math.PI / 2, m = e.Matrix.Translation(a / 2, 0, 0).multiply(e.Matrix.RotationY(p)), _ = 0; _ <= c; _++) {
					var g = 1 - _ / c,
						v = _ * Math.PI * 2 / c + Math.PI,
						y = Math.cos(v),
						x = Math.sin(v),
						b = new e.Vector3(y, x, 0),
						T = b.scale(h / 2),
						A = new e.Vector2(f, g);
					T = e.Vector3.TransformCoordinates(T, m), b = e.Vector3.TransformNormal(b, m), n.push(T.x, T.y, T.z), o.push(b.x, b.y, b.z), s.push(A.x, A.y);
					var E = (d + 1) % u,
						P = (_ + 1) % u;
					r.push(d * u + _), r.push(d * u + P), r.push(E * u + _), r.push(d * u + P), r.push(E * u + P), r.push(E * u + _)
				}
			t._ComputeSides(l, n, r, o, s);
			var M = new t;
			return M.indices = r, M.positions = n, M.normals = o, M.uvs = s, M
		}, t.CreateLineSystem = function(e) {
			for (var i = [], r = [], n = e.lines, o = 0, s = 0; s < n.length; s++)
				for (var a = n[s], h = 0; h < a.length; h++) r.push(a[h].x, a[h].y, a[h].z), h > 0 && (i.push(o - 1), i.push(o)), o++;
			var c = new t;
			return c.indices = i, c.positions = r, c
		}, t.CreateDashedLines = function(i) {
			var r = i.dashSize || 3,
				n = i.gapSize || 1,
				o = i.dashNb || 200,
				s = i.points,
				a = new Array,
				h = new Array,
				c = e.Vector3.Zero(),
				l = 0,
				u = 0,
				d = 0,
				f = 0,
				p = 0,
				m = 0,
				_ = 0;
			for (_ = 0; _ < s.length - 1; _++) s[_ + 1].subtractToRef(s[_], c), l += c.length();
			for (d = l / o, f = r * d / (r + n), _ = 0; _ < s.length - 1; _++) {
				s[_ + 1].subtractToRef(s[_], c), u = Math.floor(c.length() / d), c.normalize();
				for (var g = 0; g < u; g++) p = d * g, a.push(s[_].x + p * c.x, s[_].y + p * c.y, s[_].z + p * c.z), a.push(s[_].x + (p + f) * c.x, s[_].y + (p + f) * c.y, s[_].z + (p + f) * c.z), h.push(m, m + 1), m += 2
			}
			var v = new t;
			return v.positions = a, v.indices = h, v
		}, t.CreateGround = function(i) {
			var r, n, o = [],
				s = [],
				a = [],
				h = [],
				c = i.width || 1,
				l = i.height || 1,
				u = i.subdivisionsX || i.subdivisions || 1,
				d = i.subdivisionsY || i.subdivisions || 1;
			for (r = 0; r <= d; r++)
				for (n = 0; n <= u; n++) {
					var f = new e.Vector3(n * c / u - c / 2, 0, (d - r) * l / d - l / 2),
						p = new e.Vector3(0, 1, 0);
					s.push(f.x, f.y, f.z), a.push(p.x, p.y, p.z), h.push(n / u, 1 - r / u)
				}
			for (r = 0; r < d; r++)
				for (n = 0; n < u; n++) o.push(n + 1 + (r + 1) * (u + 1)), o.push(n + 1 + r * (u + 1)), o.push(n + r * (u + 1)), o.push(n + (r + 1) * (u + 1)), o.push(n + 1 + (r + 1) * (u + 1)), o.push(n + r * (u + 1));
			var m = new t;
			return m.indices = o, m.positions = s, m.normals = a, m.uvs = h, m
		}, t.CreateTiledGround = function(i) {
			function r(t, i, r, s) {
				var a = m.length / 3,
					h = f.w + 1;
				for (n = 0; n < f.h; n++)
					for (o = 0; o < f.w; o++) {
						var c = [a + o + n * h, a + (o + 1) + n * h, a + (o + 1) + (n + 1) * h, a + o + (n + 1) * h];
						p.push(c[1]), p.push(c[2]), p.push(c[3]), p.push(c[0]), p.push(c[1]), p.push(c[3])
					}
				var l = e.Vector3.Zero(),
					u = new e.Vector3(0, 1, 0);
				for (n = 0; n <= f.h; n++)
					for (l.z = n * (s - i) / f.h + i, o = 0; o <= f.w; o++) l.x = o * (r - t) / f.w + t, l.y = 0, m.push(l.x, l.y, l.z), _.push(u.x, u.y, u.z), g.push(o / f.w, n / f.h)
			}
			var n, o, s, a, h = i.xmin || -1,
				c = i.zmin || -1,
				l = i.xmax || 1,
				u = i.zmax || 1,
				d = i.subdivisions || {
					w: 1,
					h: 1
				},
				f = i.precision || {
					w: 1,
					h: 1
				},
				p = [],
				m = [],
				_ = [],
				g = [];
			d.h = d.h < 1 ? 1 : d.h, d.w = d.w < 1 ? 1 : d.w, f.w = f.w < 1 ? 1 : f.w, f.h = f.h < 1 ? 1 : f.h;
			var v = {
				w: (l - h) / d.w,
				h: (u - c) / d.h
			};
			for (s = 0; s < d.h; s++)
				for (a = 0; a < d.w; a++) r(h + a * v.w, c + s * v.h, h + (a + 1) * v.w, c + (s + 1) * v.h);
			var y = new t;
			return y.indices = p, y.positions = m, y.normals = _, y.uvs = g, y
		}, t.CreateGroundFromHeightMap = function(i) {
			var r, n, o = [],
				s = [],
				a = [],
				h = [];
			for (r = 0; r <= i.subdivisions; r++)
				for (n = 0; n <= i.subdivisions; n++) {
					var c = new e.Vector3(n * i.width / i.subdivisions - i.width / 2, 0, (i.subdivisions - r) * i.height / i.subdivisions - i.height / 2),
						l = (c.x + i.width / 2) / i.width * (i.bufferWidth - 1) | 0,
						u = (1 - (c.z + i.height / 2) / i.height) * (i.bufferHeight - 1) | 0,
						d = 4 * (l + u * i.bufferWidth),
						f = i.buffer[d] / 255,
						p = i.buffer[d + 1] / 255,
						m = i.buffer[d + 2] / 255,
						_ = .3 * f + .59 * p + .11 * m;
					c.y = i.minHeight + (i.maxHeight - i.minHeight) * _, s.push(c.x, c.y, c.z), a.push(0, 0, 0), h.push(n / i.subdivisions, 1 - r / i.subdivisions)
				}
			for (r = 0; r < i.subdivisions; r++)
				for (n = 0; n < i.subdivisions; n++) o.push(n + 1 + (r + 1) * (i.subdivisions + 1)), o.push(n + 1 + r * (i.subdivisions + 1)), o.push(n + r * (i.subdivisions + 1)), o.push(n + (r + 1) * (i.subdivisions + 1)), o.push(n + 1 + (r + 1) * (i.subdivisions + 1)), o.push(n + r * (i.subdivisions + 1));
			t.ComputeNormals(s, o, a);
			var g = new t;
			return g.indices = o, g.positions = s, g.normals = a, g.uvs = h, g
		}, t.CreatePlane = function(i) {
			var r = [],
				n = [],
				o = [],
				s = [],
				a = i.width || i.size || 1,
				h = i.height || i.size || 1,
				c = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE,
				l = a / 2,
				u = h / 2;
			n.push(-l, -u, 0), o.push(0, 0, -1), s.push(0, 0), n.push(l, -u, 0), o.push(0, 0, -1), s.push(1, 0), n.push(l, u, 0), o.push(0, 0, -1), s.push(1, 1), n.push(-l, u, 0), o.push(0, 0, -1), s.push(0, 1), r.push(0), r.push(1), r.push(2), r.push(0), r.push(2), r.push(3), t._ComputeSides(c, n, r, o, s);
			var d = new t;
			return d.indices = r, d.positions = n, d.normals = o, d.uvs = s, d
		}, t.CreateDisc = function(i) {
			var r = [],
				n = [],
				o = [],
				s = [],
				a = i.radius || .5,
				h = i.tessellation || 64,
				c = i.arc <= 0 || i.arc > 1 ? 1 : i.arc || 1,
				l = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE;
			r.push(0, 0, 0), s.push(.5, .5);
			for (var u = 2 * Math.PI * c, d = u / h, f = 0; f < u; f += d) {
				var p = Math.cos(f),
					m = Math.sin(f),
					_ = (p + 1) / 2,
					g = (1 - m) / 2;
				r.push(a * p, a * m, 0), s.push(_, g)
			}
			1 === c && (r.push(r[3], r[4], r[5]), s.push(s[2], s[3]));
			for (var v = r.length / 3, y = 1; y < v - 1; y++) n.push(y + 1, 0, y);
			t.ComputeNormals(r, n, o), t._ComputeSides(l, r, n, o, s);
			var x = new t;
			return x.indices = n, x.positions = r, x.normals = o, x.uvs = s, x
		}, t.CreateIcoSphere = function(i) {
			var r, n = i.sideOrientation || e.Mesh.DEFAULTSIDE,
				o = i.radius || 1,
				s = void 0 === i.flat || i.flat,
				a = i.subdivisions || 4,
				h = i.radiusX || o,
				c = i.radiusY || o,
				l = i.radiusZ || o,
				u = (1 + Math.sqrt(5)) / 2,
				d = [-1, u, -0, 1, u, 0, -1, -u, 0, 1, -u, 0, 0, -1, -u, 0, 1, -u, 0, -1, u, 0, 1, u, u, 0, 1, u, 0, -1, -u, 0, 1, -u, 0, -1],
				f = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1],
				p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 2, 3, 3, 3, 4, 7, 8, 9, 9, 10, 11],
				m = [5, 1, 3, 1, 6, 4, 0, 0, 5, 3, 4, 2, 2, 2, 4, 0, 2, 0, 1, 1, 6, 0, 6, 2, 0, 4, 3, 3, 4, 4, 3, 1, 4, 2, 4, 4, 0, 2, 1, 1, 2, 2, 3, 3, 1, 3, 2, 4],
				_ = 138 / 1024,
				g = 239 / 1024,
				v = 60 / 1024,
				y = 26 / 1024,
				x = -40 / 1024,
				b = 20 / 1024,
				T = [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0],
				A = [],
				E = [],
				P = [],
				M = [],
				S = 0,
				C = new Array(3),
				R = new Array(3);
			for (r = 0; r < 3; r++) C[r] = e.Vector3.Zero(), R[r] = e.Vector2.Zero();
			for (var O = 0; O < 20; O++) {
				for (r = 0; r < 3; r++) {
					var D = f[3 * O + r];
					C[r].copyFromFloats(d[3 * p[D]], d[3 * p[D] + 1], d[3 * p[D] + 2]), C[r].normalize().scaleInPlace(o), R[r].copyFromFloats(m[2 * D] * _ + v + T[O] * x, m[2 * D + 1] * g + y + T[O] * b)
				}
				for (var I = function(t, i, r, n) {
						var o = e.Vector3.Lerp(C[0], C[2], i / a),
							u = e.Vector3.Lerp(C[1], C[2], i / a),
							d = a === i ? C[2] : e.Vector3.Lerp(o, u, t / (a - i));
						d.normalize();
						var f;
						if (s) {
							var p = e.Vector3.Lerp(C[0], C[2], n / a),
								m = e.Vector3.Lerp(C[1], C[2], n / a);
							f = e.Vector3.Lerp(p, m, r / (a - n))
						} else f = new e.Vector3(d.x, d.y, d.z);
						f.x /= h, f.y /= c, f.z /= l, f.normalize();
						var _ = e.Vector2.Lerp(R[0], R[2], i / a),
							g = e.Vector2.Lerp(R[1], R[2], i / a),
							v = a === i ? R[2] : e.Vector2.Lerp(_, g, t / (a - i));
						E.push(d.x * h, d.y * c, d.z * l), P.push(f.x, f.y, f.z), M.push(v.x, v.y), A.push(S), S++
					}, w = 0; w < a; w++)
					for (var L = 0; L + w < a; L++) I(L, w, L + 1 / 3, w + 1 / 3), I(L + 1, w, L + 1 / 3, w + 1 / 3), I(L, w + 1, L + 1 / 3, w + 1 / 3), L + w + 1 < a && (I(L + 1, w, L + 2 / 3, w + 2 / 3), I(L + 1, w + 1, L + 2 / 3, w + 2 / 3), I(L, w + 1, L + 2 / 3, w + 2 / 3))
			}
			t._ComputeSides(n, E, A, P, M);
			var B = new t;
			return B.indices = A, B.positions = E, B.normals = P, B.uvs = M, B
		}, t.CreatePolyhedron = function(i) {
			var r = [];
			r[0] = {
				vertex: [
					[0, 0, 1.732051],
					[1.632993, 0, -.5773503],
					[-.8164966, 1.414214, -.5773503],
					[-.8164966, -1.414214, -.5773503]
				],
				face: [
					[0, 1, 2],
					[0, 2, 3],
					[0, 3, 1],
					[1, 3, 2]
				]
			}, r[1] = {
				vertex: [
					[0, 0, 1.414214],
					[1.414214, 0, 0],
					[0, 1.414214, 0],
					[-1.414214, 0, 0],
					[0, -1.414214, 0],
					[0, 0, -1.414214]
				],
				face: [
					[0, 1, 2],
					[0, 2, 3],
					[0, 3, 4],
					[0, 4, 1],
					[1, 4, 5],
					[1, 5, 2],
					[2, 5, 3],
					[3, 5, 4]
				]
			}, r[2] = {
				vertex: [
					[0, 0, 1.070466],
					[.7136442, 0, .7978784],
					[-.3568221, .618034, .7978784],
					[-.3568221, -.618034, .7978784],
					[.7978784, .618034, .3568221],
					[.7978784, -.618034, .3568221],
					[-.9341724, .381966, .3568221],
					[.1362939, 1, .3568221],
					[.1362939, -1, .3568221],
					[-.9341724, -.381966, .3568221],
					[.9341724, .381966, -.3568221],
					[.9341724, -.381966, -.3568221],
					[-.7978784, .618034, -.3568221],
					[-.1362939, 1, -.3568221],
					[-.1362939, -1, -.3568221],
					[-.7978784, -.618034, -.3568221],
					[.3568221, .618034, -.7978784],
					[.3568221, -.618034, -.7978784],
					[-.7136442, 0, -.7978784],
					[0, 0, -1.070466]
				],
				face: [
					[0, 1, 4, 7, 2],
					[0, 2, 6, 9, 3],
					[0, 3, 8, 5, 1],
					[1, 5, 11, 10, 4],
					[2, 7, 13, 12, 6],
					[3, 9, 15, 14, 8],
					[4, 10, 16, 13, 7],
					[5, 8, 14, 17, 11],
					[6, 12, 18, 15, 9],
					[10, 11, 17, 19, 16],
					[12, 13, 16, 19, 18],
					[14, 15, 18, 19, 17]
				]
			}, r[3] = {
				vertex: [
					[0, 0, 1.175571],
					[1.051462, 0, .5257311],
					[.3249197, 1, .5257311],
					[-.8506508, .618034, .5257311],
					[-.8506508, -.618034, .5257311],
					[.3249197, -1, .5257311],
					[.8506508, .618034, -.5257311],
					[.8506508, -.618034, -.5257311],
					[-.3249197, 1, -.5257311],
					[-1.051462, 0, -.5257311],
					[-.3249197, -1, -.5257311],
					[0, 0, -1.175571]
				],
				face: [
					[0, 1, 2],
					[0, 2, 3],
					[0, 3, 4],
					[0, 4, 5],
					[0, 5, 1],
					[1, 5, 7],
					[1, 7, 6],
					[1, 6, 2],
					[2, 6, 8],
					[2, 8, 3],
					[3, 8, 9],
					[3, 9, 4],
					[4, 9, 10],
					[4, 10, 5],
					[5, 10, 7],
					[6, 7, 11],
					[6, 11, 8],
					[7, 10, 11],
					[8, 11, 9],
					[9, 11, 10]
				]
			}, r[4] = {
				vertex: [
					[0, 0, 1.070722],
					[.7148135, 0, .7971752],
					[-.104682, .7071068, .7971752],
					[-.6841528, .2071068, .7971752],
					[-.104682, -.7071068, .7971752],
					[.6101315, .7071068, .5236279],
					[1.04156, .2071068, .1367736],
					[.6101315, -.7071068, .5236279],
					[-.3574067, 1, .1367736],
					[-.7888348, -.5, .5236279],
					[-.9368776, .5, .1367736],
					[-.3574067, -1, .1367736],
					[.3574067, 1, -.1367736],
					[.9368776, -.5, -.1367736],
					[.7888348, .5, -.5236279],
					[.3574067, -1, -.1367736],
					[-.6101315, .7071068, -.5236279],
					[-1.04156, -.2071068, -.1367736],
					[-.6101315, -.7071068, -.5236279],
					[.104682, .7071068, -.7971752],
					[.6841528, -.2071068, -.7971752],
					[.104682, -.7071068, -.7971752],
					[-.7148135, 0, -.7971752],
					[0, 0, -1.070722]
				],
				face: [
					[0, 2, 3],
					[1, 6, 5],
					[4, 9, 11],
					[7, 15, 13],
					[8, 16, 10],
					[12, 14, 19],
					[17, 22, 18],
					[20, 21, 23],
					[0, 1, 5, 2],
					[0, 3, 9, 4],
					[0, 4, 7, 1],
					[1, 7, 13, 6],
					[2, 5, 12, 8],
					[2, 8, 10, 3],
					[3, 10, 17, 9],
					[4, 11, 15, 7],
					[5, 6, 14, 12],
					[6, 13, 20, 14],
					[8, 12, 19, 16],
					[9, 17, 18, 11],
					[10, 16, 22, 17],
					[11, 18, 21, 15],
					[13, 15, 21, 20],
					[14, 20, 23, 19],
					[16, 19, 23, 22],
					[18, 22, 23, 21]
				]
			}, r[5] = {
				vertex: [
					[0, 0, 1.322876],
					[1.309307, 0, .1889822],
					[-.9819805, .8660254, .1889822],
					[.1636634, -1.299038, .1889822],
					[.3273268, .8660254, -.9449112],
					[-.8183171, -.4330127, -.9449112]
				],
				face: [
					[0, 3, 1],
					[2, 4, 5],
					[0, 1, 4, 2],
					[0, 2, 5, 3],
					[1, 3, 5, 4]
				]
			}, r[6] = {
				vertex: [
					[0, 0, 1.159953],
					[1.013464, 0, .5642542],
					[-.3501431, .9510565, .5642542],
					[-.7715208, -.6571639, .5642542],
					[.6633206, .9510565, -.03144481],
					[.8682979, -.6571639, -.3996071],
					[-1.121664, .2938926, -.03144481],
					[-.2348831, -1.063314, -.3996071],
					[.5181548, .2938926, -.9953061],
					[-.5850262, -.112257, -.9953061]
				],
				face: [
					[0, 1, 4, 2],
					[0, 2, 6, 3],
					[1, 5, 8, 4],
					[3, 6, 9, 7],
					[5, 7, 9, 8],
					[0, 3, 7, 5, 1],
					[2, 4, 8, 9, 6]
				]
			}, r[7] = {
				vertex: [
					[0, 0, 1.118034],
					[.8944272, 0, .6708204],
					[-.2236068, .8660254, .6708204],
					[-.7826238, -.4330127, .6708204],
					[.6708204, .8660254, .2236068],
					[1.006231, -.4330127, -.2236068],
					[-1.006231, .4330127, .2236068],
					[-.6708204, -.8660254, -.2236068],
					[.7826238, .4330127, -.6708204],
					[.2236068, -.8660254, -.6708204],
					[-.8944272, 0, -.6708204],
					[0, 0, -1.118034]
				],
				face: [
					[0, 1, 4, 2],
					[0, 2, 6, 3],
					[1, 5, 8, 4],
					[3, 6, 10, 7],
					[5, 9, 11, 8],
					[7, 10, 11, 9],
					[0, 3, 7, 9, 5, 1],
					[2, 4, 8, 11, 10, 6]
				]
			}, r[8] = {
				vertex: [
					[-.729665, .670121, .319155],
					[-.655235, -.29213, -.754096],
					[-.093922, -.607123, .537818],
					[.702196, .595691, .485187],
					[.776626, -.36656, -.588064]
				],
				face: [
					[1, 4, 2],
					[0, 1, 2],
					[3, 0, 2],
					[4, 3, 2],
					[4, 1, 0, 3]
				]
			}, r[9] = {
				vertex: [
					[-.868849, -.100041, .61257],
					[-.329458, .976099, .28078],
					[-.26629, -.013796, -.477654],
					[-.13392, -1.034115, .229829],
					[.738834, .707117, -.307018],
					[.859683, -.535264, -.338508]
				],
				face: [
					[3, 0, 2],
					[5, 3, 2],
					[4, 5, 2],
					[1, 4, 2],
					[0, 1, 2],
					[0, 3, 5, 4, 1]
				]
			}, r[10] = {
				vertex: [
					[-.610389, .243975, .531213],
					[-.187812, -.48795, -.664016],
					[-.187812, .9759, -.664016],
					[.187812, -.9759, .664016],
					[.798201, .243975, .132803]
				],
				face: [
					[1, 3, 0],
					[3, 4, 0],
					[3, 1, 4],
					[0, 2, 1],
					[0, 4, 2],
					[2, 4, 1]
				]
			}, r[11] = {
				vertex: [
					[-1.028778, .392027, -.048786],
					[-.640503, -.646161, .621837],
					[-.125162, -.395663, -.540059],
					[.004683, .888447, -.651988],
					[.125161, .395663, .540059],
					[.632925, -.791376, .433102],
					[1.031672, .157063, -.354165]
				],
				face: [
					[3, 2, 0],
					[2, 1, 0],
					[2, 5, 1],
					[0, 4, 3],
					[0, 1, 4],
					[4, 1, 5],
					[2, 3, 6],
					[3, 4, 6],
					[5, 2, 6],
					[4, 5, 6]
				]
			}, r[12] = {
				vertex: [
					[-.669867, .334933, -.529576],
					[-.669867, .334933, .529577],
					[-.4043, 1.212901, 0],
					[-.334933, -.669867, -.529576],
					[-.334933, -.669867, .529577],
					[.334933, .669867, -.529576],
					[.334933, .669867, .529577],
					[.4043, -1.212901, 0],
					[.669867, -.334933, -.529576],
					[.669867, -.334933, .529577]
				],
				face: [
					[8, 9, 7],
					[6, 5, 2],
					[3, 8, 7],
					[5, 0, 2],
					[4, 3, 7],
					[0, 1, 2],
					[9, 4, 7],
					[1, 6, 2],
					[9, 8, 5, 6],
					[8, 3, 0, 5],
					[3, 4, 1, 0],
					[4, 9, 6, 1]
				]
			}, r[13] = {
				vertex: [
					[-.931836, .219976, -.264632],
					[-.636706, .318353, .692816],
					[-.613483, -.735083, -.264632],
					[-.326545, .979634, 0],
					[-.318353, -.636706, .692816],
					[-.159176, .477529, -.856368],
					[.159176, -.477529, -.856368],
					[.318353, .636706, .692816],
					[.326545, -.979634, 0],
					[.613482, .735082, -.264632],
					[.636706, -.318353, .692816],
					[.931835, -.219977, -.264632]
				],
				face: [
					[11, 10, 8],
					[7, 9, 3],
					[6, 11, 8],
					[9, 5, 3],
					[2, 6, 8],
					[5, 0, 3],
					[4, 2, 8],
					[0, 1, 3],
					[10, 4, 8],
					[1, 7, 3],
					[10, 11, 9, 7],
					[11, 6, 5, 9],
					[6, 2, 0, 5],
					[2, 4, 1, 0],
					[4, 10, 7, 1]
				]
			}, r[14] = {
				vertex: [
					[-.93465, .300459, -.271185],
					[-.838689, -.260219, -.516017],
					[-.711319, .717591, .128359],
					[-.710334, -.156922, .080946],
					[-.599799, .556003, -.725148],
					[-.503838, -.004675, -.969981],
					[-.487004, .26021, .48049],
					[-.460089, -.750282, -.512622],
					[-.376468, .973135, -.325605],
					[-.331735, -.646985, .084342],
					[-.254001, .831847, .530001],
					[-.125239, -.494738, -.966586],
					[.029622, .027949, .730817],
					[.056536, -.982543, -.262295],
					[.08085, 1.087391, .076037],
					[.125583, -.532729, .485984],
					[.262625, .599586, .780328],
					[.391387, -.726999, -.716259],
					[.513854, -.868287, .139347],
					[.597475, .85513, .326364],
					[.641224, .109523, .783723],
					[.737185, -.451155, .538891],
					[.848705, -.612742, -.314616],
					[.976075, .365067, .32976],
					[1.072036, -.19561, .084927]
				],
				face: [
					[15, 18, 21],
					[12, 20, 16],
					[6, 10, 2],
					[3, 0, 1],
					[9, 7, 13],
					[2, 8, 4, 0],
					[0, 4, 5, 1],
					[1, 5, 11, 7],
					[7, 11, 17, 13],
					[13, 17, 22, 18],
					[18, 22, 24, 21],
					[21, 24, 23, 20],
					[20, 23, 19, 16],
					[16, 19, 14, 10],
					[10, 14, 8, 2],
					[15, 9, 13, 18],
					[12, 15, 21, 20],
					[6, 12, 16, 10],
					[3, 6, 2, 0],
					[9, 3, 1, 7],
					[9, 15, 12, 6, 3],
					[22, 17, 11, 5, 4, 8, 14, 19, 23, 24]
				]
			};
			var n, o, s, a, h, c, l = i.type < 0 || i.type >= r.length ? 0 : i.type || 0,
				u = i.size,
				d = i.sizeX || u || 1,
				f = i.sizeY || u || 1,
				p = i.sizeZ || u || 1,
				m = i.custom || r[l],
				_ = m.face.length,
				g = i.faceUV || new Array(_),
				v = i.faceColors,
				y = void 0 === i.flat || i.flat,
				x = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE,
				b = [],
				T = [],
				A = [],
				E = [],
				P = [],
				M = 0,
				S = 0,
				C = [],
				R = 0,
				O = 0;
			if (y)
				for (O = 0; O < _; O++) v && void 0 === v[O] && (v[O] = new e.Color4(1, 1, 1, 1)), g && void 0 === g[O] && (g[O] = new e.Vector4(0, 0, 1, 1));
			if (y)
				for (O = 0; O < _; O++) {
					var D = m.face[O].length;
					for (s = 2 * Math.PI / D, a = .5 * Math.tan(s / 2), h = .5, R = 0; R < D; R++) b.push(m.vertex[m.face[O][R]][0] * d, m.vertex[m.face[O][R]][1] * f, m.vertex[m.face[O][R]][2] * p), C.push(M), M++, n = g[O].x + (g[O].z - g[O].x) * (.5 + a), o = g[O].y + (g[O].w - g[O].y) * (h - .5), E.push(n, o), c = a * Math.cos(s) - h * Math.sin(s), h = a * Math.sin(s) + h * Math.cos(s), a = c, v && P.push(v[O].r, v[O].g, v[O].b, v[O].a);
					for (R = 0; R < D - 2; R++) T.push(C[0 + S], C[R + 2 + S], C[R + 1 + S]);
					S += D
				} else {
					for (R = 0; R < m.vertex.length; R++) b.push(m.vertex[R][0] * d, m.vertex[R][1] * f, m.vertex[R][2] * p), E.push(0, 0);
					for (O = 0; O < _; O++)
						for (R = 0; R < m.face[O].length - 2; R++) T.push(m.face[O][0], m.face[O][R + 2], m.face[O][R + 1])
				}
			t.ComputeNormals(b, T, A), t._ComputeSides(x, b, T, A, E);
			var I = new t;
			return I.positions = b, I.indices = T, I.normals = A, I.uvs = E, v && y && (I.colors = P), I
		}, t.CreateTorusKnot = function(i) {
			var r, n, o = [],
				s = [],
				a = [],
				h = [],
				c = i.radius || 2,
				l = i.tube || .5,
				u = i.radialSegments || 32,
				d = i.tubularSegments || 32,
				f = i.p || 2,
				p = i.q || 3,
				m = 0 === i.sideOrientation ? 0 : i.sideOrientation || e.Mesh.DEFAULTSIDE,
				_ = function(t) {
					var i = Math.cos(t),
						r = Math.sin(t),
						n = p / f * t,
						o = Math.cos(n),
						s = c * (2 + o) * .5 * i,
						a = c * (2 + o) * r * .5,
						h = c * Math.sin(n) * .5;
					return new e.Vector3(s, a, h)
				};
			for (r = 0; r <= u; r++) {
				var g = r % u,
					v = g / u * 2 * f * Math.PI,
					y = _(v),
					x = _(v + .01),
					b = x.subtract(y),
					T = x.add(y),
					A = e.Vector3.Cross(b, T);
				for (T = e.Vector3.Cross(A, b), A.normalize(), T.normalize(), n = 0; n < d; n++) {
					var E = n % d,
						P = E / d * 2 * Math.PI,
						M = -l * Math.cos(P),
						S = l * Math.sin(P);
					s.push(y.x + M * T.x + S * A.x), s.push(y.y + M * T.y + S * A.y), s.push(y.z + M * T.z + S * A.z), h.push(r / u), h.push(n / d)
				}
			}
			for (r = 0; r < u; r++)
				for (n = 0; n < d; n++) {
					var C = (n + 1) % d,
						R = r * d + n,
						O = (r + 1) * d + n,
						D = (r + 1) * d + C,
						I = r * d + C;
					o.push(I), o.push(O), o.push(R), o.push(I), o.push(D), o.push(O)
				}
			t.ComputeNormals(s, o, a), t._ComputeSides(m, s, o, a, h);
			var w = new t;
			return w.indices = o, w.positions = s, w.normals = a, w.uvs = h, w
		}, t.ComputeNormals = function(e, t, i) {
			var r = 0,
				n = 0,
				o = 0,
				s = 0,
				a = 0,
				h = 0,
				c = 0,
				l = 0,
				u = 0,
				d = 0,
				f = 0,
				p = 0,
				m = 0,
				_ = 0;
			for (r = 0; r < e.length; r++) i[r] = 0;
			var g = t.length / 3;
			for (r = 0; r < g; r++) p = t[3 * r], m = t[3 * r + 1], _ = t[3 * r + 2], n = e[3 * p] - e[3 * m], o = e[3 * p + 1] - e[3 * m + 1], s = e[3 * p + 2] - e[3 * m + 2], a = e[3 * _] - e[3 * m], h = e[3 * _ + 1] - e[3 * m + 1], c = e[3 * _ + 2] - e[3 * m + 2], l = o * c - s * h, u = s * a - n * c, d = n * h - o * a, f = Math.sqrt(l * l + u * u + d * d), f = 0 === f ? 1 : f, l /= f, u /= f, d /= f, i[3 * p] += l, i[3 * p + 1] += u, i[3 * p + 2] += d, i[3 * m] += l, i[3 * m + 1] += u, i[3 * m + 2] += d, i[3 * _] += l, i[3 * _ + 1] += u, i[3 * _ + 2] += d;
			for (r = 0; r < i.length / 3; r++) l = i[3 * r], u = i[3 * r + 1], d = i[3 * r + 2], f = Math.sqrt(l * l + u * u + d * d), f = 0 === f ? 1 : f, l /= f, u /= f, d /= f, i[3 * r] = l, i[3 * r + 1] = u, i[3 * r + 2] = d
		}, t._ComputeSides = function(t, i, r, n, o) {
			var s, a, h = r.length,
				c = n.length;
			switch (t = t || e.Mesh.DEFAULTSIDE) {
				case e.Mesh.FRONTSIDE:
					break;
				case e.Mesh.BACKSIDE:
					var l;
					for (s = 0; s < h; s += 3) l = r[s], r[s] = r[s + 2], r[s + 2] = l;
					for (a = 0; a < c; a++) n[a] = -n[a];
					break;
				case e.Mesh.DOUBLESIDE:
					for (var u = i.length, d = u / 3, f = 0; f < u; f++) i[u + f] = i[f];
					for (s = 0; s < h; s += 3) r[s + h] = r[s + 2] + d, r[s + 1 + h] = r[s + 1] + d, r[s + 2 + h] = r[s] + d;
					for (a = 0; a < c; a++) n[c + a] = -n[a];
					for (var p = o.length, m = 0; m < p; m++) o[m + p] = o[m]
			}
		}, t.ImportVertexData = function(i, r) {
			var n = new t,
				o = i.positions;
			o && n.set(o, e.VertexBuffer.PositionKind);
			var s = i.normals;
			s && n.set(s, e.VertexBuffer.NormalKind);
			var a = i.uvs;
			a && n.set(a, e.VertexBuffer.UVKind);
			var h = i.uv2s;
			h && n.set(h, e.VertexBuffer.UV2Kind);
			var c = i.uv3s;
			c && n.set(c, e.VertexBuffer.UV3Kind);
			var l = i.uv4s;
			l && n.set(l, e.VertexBuffer.UV4Kind);
			var u = i.uv5s;
			u && n.set(u, e.VertexBuffer.UV5Kind);
			var d = i.uv6s;
			d && n.set(d, e.VertexBuffer.UV6Kind);
			var f = i.colors;
			f && n.set(e.Color4.CheckColors4(f, o.length / 3), e.VertexBuffer.ColorKind);
			var p = i.matricesIndices;
			p && n.set(p, e.VertexBuffer.MatricesIndicesKind);
			var m = i.matricesWeights;
			m && n.set(m, e.VertexBuffer.MatricesWeightsKind);
			var _ = i.indices;
			_ && (n.indices = _), r.setAllVerticesData(n, i.updatable)
		}, t
	})();
	e.VertexData = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {}
		return t.EnableFor = function(e) {
			e._tags = e._tags || {}, e.hasTags = function() {
				return t.HasTags(e)
			}, e.addTags = function(i) {
				return t.AddTagsTo(e, i)
			}, e.removeTags = function(i) {
				return t.RemoveTagsFrom(e, i)
			}, e.matchesTagsQuery = function(i) {
				return t.MatchesQuery(e, i)
			}
		}, t.DisableFor = function(e) {
			delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery
		}, t.HasTags = function(t) {
			return !!t._tags && !e.Tools.IsEmpty(t._tags)
		}, t.GetTags = function(e, t) {
			if (void 0 === t && (t = !0), !e._tags) return null;
			if (t) {
				var i = [];
				for (var r in e._tags) e._tags.hasOwnProperty(r) && e._tags[r] === !0 && i.push(r);
				return i.join(" ")
			}
			return e._tags
		}, t.AddTagsTo = function(e, i) {
			if (i && "string" == typeof i) {
				var r = i.split(" ");
				r.forEach((function(i, r, n) {
					t._AddTagTo(e, i)
				}))
			}
		}, t._AddTagTo = function(e, i) {
			i = i.trim(), "" !== i && "true" !== i && "false" !== i && (i.match(/[\s]/) || i.match(/^([!]|([|]|[&]){2})/) || (t.EnableFor(e), e._tags[i] = !0))
		}, t.RemoveTagsFrom = function(e, i) {
			if (t.HasTags(e)) {
				var r = i.split(" ");
				for (var n in r) t._RemoveTagFrom(e, r[n])
			}
		}, t._RemoveTagFrom = function(e, t) {
			delete e._tags[t]
		}, t.MatchesQuery = function(i, r) {
			return void 0 === r || ("" === r ? t.HasTags(i) : e.Internals.AndOrNotEvaluator.Eval(r, (function(e) {
				return t.HasTags(i) && i._tags[e]
			})))
		}, t
	})();
	e.Tags = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(e) {
		var t = (function() {
			function e() {}
			return e.Eval = function(t, i) {
				return t = t.match(/\([^\(\)]*\)/g) ? t.replace(/\([^\(\)]*\)/g, (function(t) {
					return t = t.slice(1, t.length - 1), e._HandleParenthesisContent(t, i)
				})) : e._HandleParenthesisContent(t, i), "true" === t || "false" !== t && e.Eval(t, i)
			}, e._HandleParenthesisContent = function(t, i) {
				i = i || function(e) {
					return "true" === e
				};
				var r, n = t.split("||");
				for (var o in n)
					if (n.hasOwnProperty(o)) {
						var s = e._SimplifyNegation(n[o].trim()),
							a = s.split("&&");
						if (a.length > 1)
							for (var h = 0; h < a.length; ++h) {
								var c = e._SimplifyNegation(a[h].trim());
								if (r = "true" !== c && "false" !== c ? "!" === c[0] ? !i(c.substring(1)) : i(c) : "true" === c, !r) {
									s = "false";
									break
								}
							}
						if (r || "true" === s) {
							r = !0;
							break
						}
						r = "true" !== s && "false" !== s ? "!" === s[0] ? !i(s.substring(1)) : i(s) : "true" === s
					}
				return r ? "true" : "false"
			}, e._SimplifyNegation = function(e) {
				return e = e.replace(/^[\s!]+/, (function(e) {
					return e = e.replace(/[\s]/g, (function() {
						return ""
					})), e.length % 2 ? "!" : ""
				})), e = e.trim(), "!true" === e ? e = "false" : "!false" === e && (e = "true"), e
			}, e
		})();
		e.AndOrNotEvaluator = t
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o, s) {
			this._enabled = !0, this._refCount = 0, this._name = i, this._renderTexture = new e.RenderTargetTexture(i, r, t), this.setRenderList(n), this._renderTexture.onBeforeRenderObservable.add(o), this._renderTexture.onAfterRenderObservable.add(s), this._scene = t, this._renderList = n
		}
		return t.prototype._incRefCount = function() {
			return 0 === this._refCount && this._scene.customRenderTargets.push(this._renderTexture), ++this._refCount
		}, t.prototype._decRefCount = function() {
			return this._refCount--, this._refCount <= 0 && this._scene.customRenderTargets.splice(this._scene.customRenderTargets.indexOf(this._renderTexture), 1), this._refCount
		}, t.prototype._update = function() {
			this.setRenderList(this._renderList)
		}, t.prototype.setRenderList = function(e) {
			this._renderTexture.renderList = e
		}, t.prototype.getRenderTexture = function() {
			return this._renderTexture
		}, t
	})();
	e.PostProcessRenderPass = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i, r) {
			this._engine = e, this._name = t, this._singleInstance = r || !0, this._getPostProcess = i, this._cameras = [], this._indicesForCamera = [], this._postProcesses = {}, this._renderPasses = {}, this._renderEffectAsPasses = {}
		}
		return Object.defineProperty(t.prototype, "isSupported", {
			get: function() {
				for (var e in this._postProcesses)
					if (!this._postProcesses[e].isSupported) return !1;
				return !0
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype._update = function() {
			for (var e in this._renderPasses) this._renderPasses[e]._update()
		}, t.prototype.addPass = function(e) {
			this._renderPasses[e._name] = e, this._linkParameters()
		}, t.prototype.removePass = function(e) {
			delete this._renderPasses[e._name], this._linkParameters()
		}, t.prototype.addRenderEffectAsPass = function(e) {
			this._renderEffectAsPasses[e._name] = e, this._linkParameters()
		}, t.prototype.getPass = function(e) {
			for (var t in this._renderPasses)
				if (t === e) return this._renderPasses[e]
		}, t.prototype.emptyPasses = function() {
			this._renderPasses = {}, this._linkParameters()
		}, t.prototype._attachCameras = function(t) {
			for (var i, r = e.Tools.MakeArray(t || this._cameras), n = 0; n < r.length; n++) {
				var o = r[n],
					s = o.name;
				i = this._singleInstance ? 0 : s, this._postProcesses[i] = this._postProcesses[i] || this._getPostProcess();
				var a = o.attachPostProcess(this._postProcesses[i]);
				this._indicesForCamera[s] || (this._indicesForCamera[s] = []), this._indicesForCamera[s].push(a), this._cameras.indexOf(o) === -1 && (this._cameras[s] = o);
				for (var h in this._renderPasses) this._renderPasses[h]._incRefCount()
			}
			this._linkParameters()
		}, t.prototype._detachCameras = function(t) {
			for (var i = e.Tools.MakeArray(t || this._cameras), r = 0; r < i.length; r++) {
				var n = i[r],
					o = n.name;
				n.detachPostProcess(this._postProcesses[this._singleInstance ? 0 : o], this._indicesForCamera[o]);
				var s = this._cameras.indexOf(o);
				this._indicesForCamera.splice(s, 1), this._cameras.splice(s, 1);
				for (var a in this._renderPasses) this._renderPasses[a]._decRefCount()
			}
		}, t.prototype._enable = function(t) {
			for (var i = e.Tools.MakeArray(t || this._cameras), r = 0; r < i.length; r++) {
				for (var n = i[r], o = n.name, s = 0; s < this._indicesForCamera[o].length; s++) void 0 === n._postProcesses[this._indicesForCamera[o][s]] && t[r].attachPostProcess(this._postProcesses[this._singleInstance ? 0 : o], this._indicesForCamera[o][s]);
				for (var a in this._renderPasses) this._renderPasses[a]._incRefCount()
			}
		}, t.prototype._disable = function(t) {
			for (var i = e.Tools.MakeArray(t || this._cameras), r = 0; r < i.length; r++) {
				var n = i[r],
					o = n.Name;
				n.detachPostProcess(this._postProcesses[this._singleInstance ? 0 : o], this._indicesForCamera[o]);
				for (var s in this._renderPasses) this._renderPasses[s]._decRefCount()
			}
		}, t.prototype.getPostProcess = function(e) {
			return this._singleInstance ? this._postProcesses[0] : this._postProcesses[e.name]
		}, t.prototype._linkParameters = function() {
			var e = this;
			for (var t in this._postProcesses) this.applyParameters && this.applyParameters(this._postProcesses[t]), this._postProcesses[t].onBeforeRenderObservable.add((function(t) {
				e._linkTextures(t)
			}))
		}, t.prototype._linkTextures = function(e) {
			for (var t in this._renderPasses) e.setTexture(t, this._renderPasses[t].getRenderTexture());
			for (var i in this._renderEffectAsPasses) e.setTextureFromPostProcess(i + "Sampler", this._renderEffectAsPasses[i].getPostProcess())
		}, t
	})();
	e.PostProcessRenderEffect = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t) {
			this._engine = e, this._name = t, this._renderEffects = {}, this._renderEffectsForIsolatedPass = {}, this._cameras = []
		}
		return Object.defineProperty(t.prototype, "isSupported", {
			get: function() {
				for (var e in this._renderEffects)
					if (!this._renderEffects[e].isSupported) return !1;
				return !0
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.addEffect = function(e) {
			this._renderEffects[e._name] = e
		}, t.prototype._enableEffect = function(t, i) {
			var r = this._renderEffects[t];
			r && r._enable(e.Tools.MakeArray(i || this._cameras))
		}, t.prototype._disableEffect = function(t, i) {
			var r = this._renderEffects[t];
			r && r._disable(e.Tools.MakeArray(i || this._cameras))
		}, t.prototype._attachCameras = function(t, i) {
			var r, n = e.Tools.MakeArray(t || this._cameras),
				o = [];
			for (r = 0; r < n.length; r++) {
				var s = n[r],
					a = s.name;
				this._cameras.indexOf(s) === -1 ? this._cameras[a] = s : i && o.push(r)
			}
			for (r = 0; r < o.length; r++) t.splice(o[r], 1);
			for (var h in this._renderEffects) this._renderEffects[h]._attachCameras(n)
		}, t.prototype._detachCameras = function(t) {
			var i = e.Tools.MakeArray(t || this._cameras);
			for (var r in this._renderEffects) this._renderEffects[r]._detachCameras(i);
			for (var n = 0; n < i.length; n++) this._cameras.splice(this._cameras.indexOf(i[n]), 1)
		}, t.prototype._enableDisplayOnlyPass = function(i, r) {
			var n, o = this,
				s = e.Tools.MakeArray(r || this._cameras),
				a = null;
			for (n in this._renderEffects)
				if (a = this._renderEffects[n].getPass(i), null != a) break;
			if (null !== a) {
				for (n in this._renderEffects) this._renderEffects[n]._disable(s);
				a._name = t.PASS_SAMPLER_NAME;
				for (var h = 0; h < s.length; h++) {
					var c = s[h],
						l = c.name;
					this._renderEffectsForIsolatedPass[l] = this._renderEffectsForIsolatedPass[l] || new e.PostProcessRenderEffect(this._engine, t.PASS_EFFECT_NAME, function() {
						return new e.DisplayPassPostProcess(t.PASS_EFFECT_NAME, 1, null, null, o._engine, (!0))
					}), this._renderEffectsForIsolatedPass[l].emptyPasses(), this._renderEffectsForIsolatedPass[l].addPass(a), this._renderEffectsForIsolatedPass[l]._attachCameras(c)
				}
			}
		}, t.prototype._disableDisplayOnlyPass = function(i) {
			for (var r = this, n = e.Tools.MakeArray(i || this._cameras), o = 0; o < n.length; o++) {
				var s = n[o],
					a = s.name;
				this._renderEffectsForIsolatedPass[a] = this._renderEffectsForIsolatedPass[a] || new e.PostProcessRenderEffect(this._engine, t.PASS_EFFECT_NAME, function() {
					return new e.DisplayPassPostProcess(t.PASS_EFFECT_NAME, 1, null, null, r._engine, (!0))
				}), this._renderEffectsForIsolatedPass[a]._disable(s)
			}
			for (var h in this._renderEffects) this._renderEffects[h]._enable(n)
		}, t.prototype._update = function() {
			for (var e in this._renderEffects) this._renderEffects[e]._update();
			for (var t = 0; t < this._cameras.length; t++) {
				var i = this._cameras[t].name;
				this._renderEffectsForIsolatedPass[i] && this._renderEffectsForIsolatedPass[i]._update()
			}
		}, t.prototype.dispose = function() {}, t.PASS_EFFECT_NAME = "passEffect", t.PASS_SAMPLER_NAME = "passSampler", t
	})();
	e.PostProcessRenderPipeline = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {
			this._renderPipelines = {}
		}
		return e.prototype.addPipeline = function(e) {
			this._renderPipelines[e._name] = e
		}, e.prototype.attachCamerasToRenderPipeline = function(e, t, i) {
			var r = this._renderPipelines[e];
			r && r._attachCameras(t, i)
		}, e.prototype.detachCamerasFromRenderPipeline = function(e, t) {
			var i = this._renderPipelines[e];
			i && i._detachCameras(t)
		}, e.prototype.enableEffectInPipeline = function(e, t, i) {
			var r = this._renderPipelines[e];
			r && r._enableEffect(t, i)
		}, e.prototype.disableEffectInPipeline = function(e, t, i) {
			var r = this._renderPipelines[e];
			r && r._disableEffect(t, i)
		}, e.prototype.enableDisplayOnlyPassInPipeline = function(e, t, i) {
			var r = this._renderPipelines[e];
			r && r._enableDisplayOnlyPass(t, i)
		}, e.prototype.disableDisplayOnlyPassInPipeline = function(e, t) {
			var i = this._renderPipelines[e];
			i && i._disableDisplayOnlyPass(t)
		}, e.prototype.update = function() {
			for (var e in this._renderPipelines) {
				var t = this._renderPipelines[e];
				t.isSupported ? t._update() : (t.dispose(), delete this._renderPipelines[e])
			}
		}, e
	})();
	e.PostProcessRenderPipelineManager = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t) {
			this.frontColor = new e.Color3(1, 1, 1), this.backColor = new e.Color3(.1, .1, .1), this.showBackLines = !0, this.renderList = new e.SmartArray(32), this._vertexBuffers = {}, this._scene = t
		}
		return t.prototype._prepareRessources = function() {
			if (!this._colorShader) {
				this._colorShader = new e.ShaderMaterial("colorShader", this._scene, "color", {
					attributes: [e.VertexBuffer.PositionKind],
					uniforms: ["worldViewProjection", "color"]
				});
				var t = this._scene.getEngine(),
					i = e.VertexData.CreateBox(1);
				this._vertexBuffers[e.VertexBuffer.PositionKind] = new e.VertexBuffer(t, i.positions, e.VertexBuffer.PositionKind, (!1)), this._indexBuffer = t.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4])
			}
		}, t.prototype.reset = function() {
			this.renderList.reset()
		}, t.prototype.render = function() {
			if (0 !== this.renderList.length && (this._prepareRessources(), this._colorShader.isReady())) {
				var t = this._scene.getEngine();
				t.setDepthWrite(!1), this._colorShader._preBind();
				for (var i = 0; i < this.renderList.length; i++) {
					var r = this.renderList.data[i],
						n = r.minimum,
						o = r.maximum,
						s = o.subtract(n),
						a = n.add(s.scale(.5)),
						h = e.Matrix.Scaling(s.x, s.y, s.z).multiply(e.Matrix.Translation(a.x, a.y, a.z)).multiply(r.getWorldMatrix());
					t.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect()), this.showBackLines && (t.setDepthFunctionToGreaterOrEqual(), this._scene.resetCachedMaterial(), this._colorShader.setColor4("color", this.backColor.toColor4()), this._colorShader.bind(h), t.draw(!1, 0, 24)), t.setDepthFunctionToLess(), this._scene.resetCachedMaterial(), this._colorShader.setColor4("color", this.frontColor.toColor4()), this._colorShader.bind(h), t.draw(!1, 0, 24)
				}
				this._colorShader.unbind(), t.setDepthFunctionToLessOrEqual(), t.setDepthWrite(!0)
			}
		}, t.prototype.dispose = function() {
			if (this._colorShader) {
				this._colorShader.dispose();
				var t = this._vertexBuffers[e.VertexBuffer.PositionKind];
				t && (t.dispose(), this._vertexBuffers[e.VertexBuffer.PositionKind] = null), this._scene.getEngine()._releaseBuffer(this._indexBuffer)
			}
		}, t
	})();
	e.BoundingBoxRenderer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e) {
			this._actionManager = e
		}
		return e.prototype.isValid = function() {
			return !0
		}, e.prototype._getProperty = function(e) {
			return this._actionManager._getProperty(e)
		}, e.prototype._getEffectiveTarget = function(e, t) {
			return this._actionManager._getEffectiveTarget(e, t)
		}, e.prototype.serialize = function() {}, e.prototype._serialize = function(e) {
			return {
				type: 2,
				children: [],
				name: e.name,
				properties: e.properties
			}
		}, e
	})();
	e.Condition = t;
	var i = (function(t) {
		function i(e, r, n, o, s) {
			void 0 === s && (s = i.IsEqual), t.call(this, e), this.propertyPath = n, this.value = o, this.operator = s, this._target = r, this._effectiveTarget = this._getEffectiveTarget(r, this.propertyPath), this._property = this._getProperty(this.propertyPath)
		}
		return __extends(i, t), Object.defineProperty(i, "IsEqual", {
			get: function() {
				return i._IsEqual
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "IsDifferent", {
			get: function() {
				return i._IsDifferent
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "IsGreater", {
			get: function() {
				return i._IsGreater
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i, "IsLesser", {
			get: function() {
				return i._IsLesser
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.isValid = function() {
			switch (this.operator) {
				case i.IsGreater:
					return this._effectiveTarget[this._property] > this.value;
				case i.IsLesser:
					return this._effectiveTarget[this._property] < this.value;
				case i.IsEqual:
				case i.IsDifferent:
					var e;
					return e = this.value.equals ? this.value.equals(this._effectiveTarget[this._property]) : this.value === this._effectiveTarget[this._property], this.operator === i.IsEqual ? e : !e
			}
			return !1
		}, i.prototype.serialize = function() {
			return this._serialize({
				name: "ValueCondition",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "propertyPath",
					value: this.propertyPath
				}, {
					name: "value",
					value: e.Action._SerializeValueAsString(this.value)
				}, {
					name: "operator",
					value: i.GetOperatorName(this.operator)
				}]
			})
		}, i.GetOperatorName = function(e) {
			switch (e) {
				case i._IsEqual:
					return "IsEqual";
				case i._IsDifferent:
					return "IsDifferent";
				case i._IsGreater:
					return "IsGreater";
				case i._IsLesser:
					return "IsLesser";
				default:
					return ""
			}
		}, i._IsEqual = 0, i._IsDifferent = 1, i._IsGreater = 2, i._IsLesser = 3, i
	})(t);
	e.ValueCondition = i;
	var r = (function(e) {
		function t(t, i) {
			e.call(this, t), this.predicate = i
		}
		return __extends(t, e), t.prototype.isValid = function() {
			return this.predicate()
		}, t
	})(t);
	e.PredicateCondition = r;
	var n = (function(t) {
		function i(e, i, r) {
			t.call(this, e), this.value = r, this._target = i
		}
		return __extends(i, t), i.prototype.isValid = function() {
			return this._target.state === this.value
		}, i.prototype.serialize = function() {
			return this._serialize({
				name: "StateCondition",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "value",
					value: this.value
				}]
			})
		}, i
	})(t);
	e.StateCondition = n
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t) {
			this.triggerOptions = e, e.parameter ? (this.trigger = e.trigger, this._triggerParameter = e.parameter) : this.trigger = e, this._nextActiveAction = this, this._condition = t
		}
		return t.prototype._prepare = function() {}, t.prototype.getTriggerParameter = function() {
			return this._triggerParameter
		}, t.prototype._executeCurrent = function(e) {
			if (this._nextActiveAction._condition) {
				var t = this._nextActiveAction._condition,
					i = this._actionManager.getScene().getRenderId();
				if (t._evaluationId === i) {
					if (!t._currentResult) return
				} else {
					if (t._evaluationId = i, !t.isValid()) return void(t._currentResult = !1);
					t._currentResult = !0
				}
			}
			this._nextActiveAction.execute(e), this.skipToNextActiveAction()
		}, t.prototype.execute = function(e) {}, t.prototype.skipToNextActiveAction = function() {
			this._nextActiveAction._child ? (this._nextActiveAction._child._actionManager || (this._nextActiveAction._child._actionManager = this._actionManager), this._nextActiveAction = this._nextActiveAction._child) : this._nextActiveAction = this
		}, t.prototype.then = function(e) {
			return this._child = e, e._actionManager = this._actionManager, e._prepare(), e
		}, t.prototype._getProperty = function(e) {
			return this._actionManager._getProperty(e)
		}, t.prototype._getEffectiveTarget = function(e, t) {
			return this._actionManager._getEffectiveTarget(e, t)
		}, t.prototype.serialize = function(e) {}, t.prototype._serialize = function(e, t) {
			var i = {
				type: 1,
				children: [],
				name: e.name,
				properties: e.properties || []
			};
			if (this._child && this._child.serialize(i), this._condition) {
				var r = this._condition.serialize();
				return r.children.push(i), t && t.children.push(r), r
			}
			return t && t.children.push(i), i
		}, t._SerializeValueAsString = function(t) {
			return "number" == typeof t ? t.toString() : "boolean" == typeof t ? t ? "true" : "false" : t instanceof e.Vector2 ? t.x + ", " + t.y : t instanceof e.Vector3 ? t.x + ", " + t.y + ", " + t.z : t instanceof e.Color3 ? t.r + ", " + t.g + ", " + t.b : t instanceof e.Color4 ? t.r + ", " + t.g + ", " + t.b + ", " + t.a : t
		}, t._GetTargetProperty = function(t) {
			return {
				name: "target",
				targetType: t instanceof e.Mesh ? "MeshProperties" : t instanceof e.Light ? "LightProperties" : t instanceof e.Camera ? "CameraProperties" : "SceneProperties",
				value: t instanceof e.Scene ? "Scene" : t.name
			}
		}, t
	})();
	e.Action = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t, i, r, n, o) {
			this.source = e, this.pointerX = t, this.pointerY = i, this.meshUnderPointer = r, this.sourceEvent = n, this.additionalData = o
		}
		return e.CreateNew = function(t, i, r) {
			var n = t.getScene();
			return new e(t, n.pointerX, n.pointerY, n.meshUnderPointer, i, r)
		}, e.CreateNewFromSprite = function(t, i, r, n) {
			return new e(t, i.pointerX, i.pointerY, i.meshUnderPointer, r, n)
		}, e.CreateNewFromScene = function(t, i) {
			return new e(null, t.pointerX, t.pointerY, t.meshUnderPointer, i)
		}, e.CreateNewFromPrimitive = function(t, i, r, n) {
			return new e(t, i.x, i.y, null, r, n)
		}, e
	})();
	e.ActionEvent = t;
	var i = (function() {
		function t(e) {
			this.actions = new Array, this.hoverCursor = "", this._scene = e, e._actionManagers.push(this)
		}
		return Object.defineProperty(t, "NothingTrigger", {
			get: function() {
				return t._NothingTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnPickTrigger", {
			get: function() {
				return t._OnPickTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnLeftPickTrigger", {
			get: function() {
				return t._OnLeftPickTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnRightPickTrigger", {
			get: function() {
				return t._OnRightPickTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnCenterPickTrigger", {
			get: function() {
				return t._OnCenterPickTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnPickDownTrigger", {
			get: function() {
				return t._OnPickDownTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnPickUpTrigger", {
			get: function() {
				return t._OnPickUpTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnPickOutTrigger", {
			get: function() {
				return t._OnPickOutTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnLongPressTrigger", {
			get: function() {
				return t._OnLongPressTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnPointerOverTrigger", {
			get: function() {
				return t._OnPointerOverTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnPointerOutTrigger", {
			get: function() {
				return t._OnPointerOutTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnEveryFrameTrigger", {
			get: function() {
				return t._OnEveryFrameTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnIntersectionEnterTrigger", {
			get: function() {
				return t._OnIntersectionEnterTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnIntersectionExitTrigger", {
			get: function() {
				return t._OnIntersectionExitTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnKeyDownTrigger", {
			get: function() {
				return t._OnKeyDownTrigger
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t, "OnKeyUpTrigger", {
			get: function() {
				return t._OnKeyUpTrigger
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.dispose = function() {
			var e = this._scene._actionManagers.indexOf(this);
			e > -1 && this._scene._actionManagers.splice(e, 1)
		}, t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.hasSpecificTriggers = function(e) {
			for (var t = 0; t < this.actions.length; t++) {
				var i = this.actions[t];
				if (e.indexOf(i.trigger) > -1) return !0
			}
			return !1
		}, t.prototype.hasSpecificTrigger = function(e) {
			for (var t = 0; t < this.actions.length; t++) {
				var i = this.actions[t];
				if (i.trigger === e) return !0
			}
			return !1
		}, Object.defineProperty(t.prototype, "hasPointerTriggers", {
			get: function() {
				for (var e = 0; e < this.actions.length; e++) {
					var i = this.actions[e];
					if (i.trigger >= t._OnPickTrigger && i.trigger <= t._OnPointerOutTrigger) return !0
				}
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "hasPickTriggers", {
			get: function() {
				for (var e = 0; e < this.actions.length; e++) {
					var i = this.actions[e];
					if (i.trigger >= t._OnPickTrigger && i.trigger <= t._OnPickUpTrigger) return !0
				}
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.registerAction = function(i) {
			return i.trigger === t.OnEveryFrameTrigger && this.getScene().actionManager !== this ? (e.Tools.Warn("OnEveryFrameTrigger can only be used with scene.actionManager"), null) : (this.actions.push(i), i._actionManager = this, i._prepare(), i)
		}, t.prototype.processTrigger = function(e, i) {
			for (var r = 0; r < this.actions.length; r++) {
				var n = this.actions[r];
				if (n.trigger === e) {
					if (e === t.OnKeyUpTrigger || e === t.OnKeyDownTrigger) {
						var o = n.getTriggerParameter();
						if (o) {
							var s = i.sourceEvent.charCode ? i.sourceEvent.charCode : i.sourceEvent.keyCode,
								a = String.fromCharCode(s).toLowerCase();
							if (a !== o.toLowerCase()) continue
						}
					}
					n._executeCurrent(i)
				}
			}
		}, t.prototype._getEffectiveTarget = function(e, t) {
			for (var i = t.split("."), r = 0; r < i.length - 1; r++) e = e[i[r]];
			return e
		}, t.prototype._getProperty = function(e) {
			var t = e.split(".");
			return t[t.length - 1]
		}, t.prototype.serialize = function(i) {
			for (var r = {
					children: [],
					name: i,
					type: 3,
					properties: []
				}, n = 0; n < this.actions.length; n++) {
				var o = {
						type: 0,
						children: [],
						name: t.GetTriggerName(this.actions[n].trigger),
						properties: []
					},
					s = this.actions[n].triggerOptions;
				if (s && "number" != typeof s)
					if (s.parameter instanceof e.Node) o.properties.push(e.Action._GetTargetProperty(s.parameter));
					else {
						var a = {};
						e.Tools.DeepCopy(s.parameter, a, ["mesh"]), s.parameter.mesh && (a._meshId = s.parameter.mesh.id), o.properties.push({
							name: "parameter",
							targetType: null,
							value: a
						})
					}
				this.actions[n].serialize(o), r.children.push(o)
			}
			return r
		}, t.Parse = function(i, r, n) {
			var o = new e.ActionManager(n);
			null === r ? n.actionManager = o : r.actionManager = o;
			for (var s = function(t, i) {
					var r = Object.create(e[t].prototype);
					return r.constructor.apply(r, i), r
				}, a = function(t, i, r, n) {
					if (null === n) {
						var o = parseFloat(i);
						return "true" === i || "false" === i ? "true" === i : isNaN(o) ? i : o
					}
					for (var s = n.split("."), a = i.split(","), h = 0; h < s.length; h++) r = r[s[h]];
					if ("boolean" == typeof r) return "true" === a[0];
					if ("string" == typeof r) return a[0];
					for (var c = new Array, h = 0; h < a.length; h++) c.push(parseFloat(a[h]));
					return r instanceof e.Vector3 ? e.Vector3.FromArray(c) : r instanceof e.Vector4 ? e.Vector4.FromArray(c) : r instanceof e.Color3 ? e.Color3.FromArray(c) : r instanceof e.Color4 ? e.Color4.FromArray(c) : parseFloat(a[0])
				}, h = function(i, r, c, l, u) {
					if (void 0 === u && (u = null), !i.detached) {
						var d = new Array,
							f = null,
							p = null,
							m = i.combine && i.combine.length > 0;
						if (2 === i.type ? d.push(o) : d.push(r), m) {
							for (var _ = new Array, g = 0; g < i.combine.length; g++) h(i.combine[g], t.NothingTrigger, c, l, _);
							d.push(_)
						} else
							for (var v = 0; v < i.properties.length; v++) {
								var y = i.properties[v].value,
									x = i.properties[v].name,
									b = i.properties[v].targetType;
								"target" === x ? y = f = null !== b && "SceneProperties" === b ? n : n.getNodeByName(y) : "parent" === x ? y = n.getNodeByName(y) : "sound" === x ? y = n.getSoundByName(y) : "propertyPath" !== x ? y = 2 === i.type && "operator" === x ? e.ValueCondition[y] : a(x, y, f, "value" === x ? p : null) : p = y, d.push(y)
							}
						if (null === u ? d.push(c) : d.push(null), "InterpolateValueAction" === i.name) {
							var T = d[d.length - 2];
							d[d.length - 1] = T, d[d.length - 2] = c
						}
						var A = s(i.name, d);
						if (A instanceof e.Condition && null !== c) {
							var E = new e.DoNothingAction(r, c);
							l ? l.then(E) : o.registerAction(E), l = E
						}
						null === u ? A instanceof e.Condition ? (c = A, A = l) : (c = null, l ? l.then(A) : o.registerAction(A)) : u.push(A);
						for (var v = 0; v < i.children.length; v++) h(i.children[v], r, c, A, null)
					}
				}, c = 0; c < i.children.length; c++) {
				var l, u = i.children[c];
				if (u.properties.length > 0) {
					var d = u.properties[0].value,
						f = null === u.properties[0].targetType ? d : n.getMeshByName(d);
					f._meshId && (f.mesh = n.getMeshByID(f._meshId)), l = {
						trigger: e.ActionManager[u.name],
						parameter: f
					}
				} else l = e.ActionManager[u.name];
				for (var p = 0; p < u.children.length; p++) u.detached || h(u.children[p], l, null, null);
			}
		}, t.GetTriggerName = function(e) {
			switch (e) {
				case 0:
					return "NothingTrigger";
				case 1:
					return "OnPickTrigger";
				case 2:
					return "OnLeftPickTrigger";
				case 3:
					return "OnRightPickTrigger";
				case 4:
					return "OnCenterPickTrigger";
				case 5:
					return "OnPickDownTrigger";
				case 6:
					return "OnPickUpTrigger";
				case 7:
					return "OnLongPressTrigger";
				case 8:
					return "OnPointerOverTrigger";
				case 9:
					return "OnPointerOutTrigger";
				case 10:
					return "OnEveryFrameTrigger";
				case 11:
					return "OnIntersectionEnterTrigger";
				case 12:
					return "OnIntersectionExitTrigger";
				case 13:
					return "OnKeyDownTrigger";
				case 14:
					return "OnKeyUpTrigger";
				case 15:
					return "OnPickOutTrigger";
				default:
					return ""
			}
		}, t._NothingTrigger = 0, t._OnPickTrigger = 1, t._OnLeftPickTrigger = 2, t._OnRightPickTrigger = 3, t._OnCenterPickTrigger = 4, t._OnPickDownTrigger = 5, t._OnPickUpTrigger = 6, t._OnLongPressTrigger = 7, t._OnPointerOverTrigger = 8, t._OnPointerOutTrigger = 9, t._OnEveryFrameTrigger = 10, t._OnIntersectionEnterTrigger = 11, t._OnIntersectionExitTrigger = 12, t._OnKeyDownTrigger = 13, t._OnKeyUpTrigger = 14, t._OnPickOutTrigger = 15, t.DragMovementThreshold = 10, t.LongPressDelay = 500, t
	})();
	e.ActionManager = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r, n, o, s, a, h) {
			void 0 === o && (o = 1e3), t.call(this, e, s), this.propertyPath = r, this.value = n, this.duration = o, this.stopOtherAnimations = a, this.onInterpolationDone = h, this._target = this._effectiveTarget = i
		}
		return __extends(i, t), i.prototype._prepare = function() {
			this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath)
		}, i.prototype.execute = function() {
			var t, i = this._actionManager.getScene(),
				r = [{
					frame: 0,
					value: this._effectiveTarget[this._property]
				}, {
					frame: 100,
					value: this.value
				}];
			if ("number" == typeof this.value) t = e.Animation.ANIMATIONTYPE_FLOAT;
			else if (this.value instanceof e.Color3) t = e.Animation.ANIMATIONTYPE_COLOR3;
			else if (this.value instanceof e.Vector3) t = e.Animation.ANIMATIONTYPE_VECTOR3;
			else if (this.value instanceof e.Matrix) t = e.Animation.ANIMATIONTYPE_MATRIX;
			else {
				if (!(this.value instanceof e.Quaternion)) return void e.Tools.Warn("InterpolateValueAction: Unsupported type (" + typeof this.value + ")");
				t = e.Animation.ANIMATIONTYPE_QUATERNION
			}
			var n = new e.Animation("InterpolateValueAction", this._property, 100 * (1e3 / this.duration), t, e.Animation.ANIMATIONLOOPMODE_CONSTANT);
			n.setKeys(r), this.stopOtherAnimations && i.stopAnimation(this._effectiveTarget), i.beginDirectAnimation(this._effectiveTarget, [n], 0, 100, !1, 1, this.onInterpolationDone)
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "InterpolateValueAction",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "propertyPath",
					value: this.propertyPath
				}, {
					name: "value",
					value: e.Action._SerializeValueAsString(this.value)
				}, {
					name: "duration",
					value: e.Action._SerializeValueAsString(this.duration)
				}, {
					name: "stopOtherAnimations",
					value: e.Action._SerializeValueAsString(this.stopOtherAnimations) || !1
				}]
			}, i)
		}, i
	})(e.Action);
	e.InterpolateValueAction = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(e, i, r, n) {
			t.call(this, e, n), this.propertyPath = r, this._target = this._effectiveTarget = i
		}
		return __extends(i, t), i.prototype._prepare = function() {
			this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath)
		}, i.prototype.execute = function() {
			this._effectiveTarget[this._property] = !this._effectiveTarget[this._property]
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "SwitchBooleanAction",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "propertyPath",
					value: this.propertyPath
				}]
			}, i)
		}, i
	})(e.Action);
	e.SwitchBooleanAction = t;
	var i = (function(t) {
		function i(e, i, r, n) {
			t.call(this, e, n), this.value = r, this._target = i
		}
		return __extends(i, t), i.prototype.execute = function() {
			this._target.state = this.value
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "SetStateAction",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "value",
					value: this.value
				}]
			}, i)
		}, i
	})(e.Action);
	e.SetStateAction = i;
	var r = (function(t) {
		function i(e, i, r, n, o) {
			t.call(this, e, o), this.propertyPath = r, this.value = n, this._target = this._effectiveTarget = i
		}
		return __extends(i, t), i.prototype._prepare = function() {
			this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath)
		}, i.prototype.execute = function() {
			this._effectiveTarget[this._property] = this.value, this._target.markAsDirty && this._target.markAsDirty(this._property)
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "SetValueAction",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "propertyPath",
					value: this.propertyPath
				}, {
					name: "value",
					value: e.Action._SerializeValueAsString(this.value)
				}]
			}, i)
		}, i
	})(e.Action);
	e.SetValueAction = r;
	var n = (function(t) {
		function i(e, i, r, n, o) {
			t.call(this, e, o), this.propertyPath = r, this.value = n, this._target = this._effectiveTarget = i
		}
		return __extends(i, t), i.prototype._prepare = function() {
			this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath), "number" != typeof this._effectiveTarget[this._property] && e.Tools.Warn("Warning: IncrementValueAction can only be used with number values")
		}, i.prototype.execute = function() {
			this._effectiveTarget[this._property] += this.value, this._target.markAsDirty && this._target.markAsDirty(this._property)
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "IncrementValueAction",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "propertyPath",
					value: this.propertyPath
				}, {
					name: "value",
					value: e.Action._SerializeValueAsString(this.value)
				}]
			}, i)
		}, i
	})(e.Action);
	e.IncrementValueAction = n;
	var o = (function(t) {
		function i(e, i, r, n, o, s) {
			t.call(this, e, s), this.from = r, this.to = n, this.loop = o, this._target = i
		}
		return __extends(i, t), i.prototype._prepare = function() {}, i.prototype.execute = function() {
			var e = this._actionManager.getScene();
			e.beginAnimation(this._target, this.from, this.to, this.loop)
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "PlayAnimationAction",
				properties: [e.Action._GetTargetProperty(this._target), {
					name: "from",
					value: String(this.from)
				}, {
					name: "to",
					value: String(this.to)
				}, {
					name: "loop",
					value: e.Action._SerializeValueAsString(this.loop) || !1
				}]
			}, i)
		}, i
	})(e.Action);
	e.PlayAnimationAction = o;
	var s = (function(t) {
		function i(e, i, r) {
			t.call(this, e, r), this._target = i
		}
		return __extends(i, t), i.prototype._prepare = function() {}, i.prototype.execute = function() {
			var e = this._actionManager.getScene();
			e.stopAnimation(this._target)
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "StopAnimationAction",
				properties: [e.Action._GetTargetProperty(this._target)]
			}, i)
		}, i
	})(e.Action);
	e.StopAnimationAction = s;
	var a = (function(t) {
		function i(i, r) {
			void 0 === i && (i = e.ActionManager.NothingTrigger), t.call(this, i, r)
		}
		return __extends(i, t), i.prototype.execute = function() {}, i.prototype.serialize = function(e) {
			return t.prototype._serialize.call(this, {
				name: "DoNothingAction",
				properties: []
			}, e)
		}, i
	})(e.Action);
	e.DoNothingAction = a;
	var h = (function(e) {
		function t(t, i, r) {
			e.call(this, t, r), this.children = i
		}
		return __extends(t, e), t.prototype._prepare = function() {
			for (var e = 0; e < this.children.length; e++) this.children[e]._actionManager = this._actionManager, this.children[e]._prepare()
		}, t.prototype.execute = function(e) {
			for (var t = 0; t < this.children.length; t++) this.children[t].execute(e)
		}, t.prototype.serialize = function(t) {
			for (var i = e.prototype._serialize.call(this, {
					name: "CombineAction",
					properties: [],
					combine: []
				}, t), r = 0; r < this.children.length; r++) i.combine.push(this.children[r].serialize(null));
			return i
		}, t
	})(e.Action);
	e.CombineAction = h;
	var c = (function(e) {
		function t(t, i, r) {
			e.call(this, t, r), this.func = i
		}
		return __extends(t, e), t.prototype.execute = function(e) {
			this.func(e)
		}, t
	})(e.Action);
	e.ExecuteCodeAction = c;
	var l = (function(t) {
		function i(e, i, r, n) {
			t.call(this, e, n), this._target = i, this._parent = r
		}
		return __extends(i, t), i.prototype._prepare = function() {}, i.prototype.execute = function() {
			if (this._target.parent !== this._parent) {
				var t = this._parent.getWorldMatrix().clone();
				t.invert(), this._target.position = e.Vector3.TransformCoordinates(this._target.position, t), this._target.parent = this._parent
			}
		}, i.prototype.serialize = function(i) {
			return t.prototype._serialize.call(this, {
				name: "SetParentAction",
				properties: [e.Action._GetTargetProperty(this._target), e.Action._GetTargetProperty(this._parent)]
			}, i)
		}, i
	})(e.Action);
	e.SetParentAction = l;
	var u = (function(e) {
		function t(t, i, r) {
			e.call(this, t, r), this._sound = i
		}
		return __extends(t, e), t.prototype._prepare = function() {}, t.prototype.execute = function() {
			void 0 !== this._sound && this._sound.play()
		}, t.prototype.serialize = function(t) {
			return e.prototype._serialize.call(this, {
				name: "PlaySoundAction",
				properties: [{
					name: "sound",
					value: this._sound.name
				}]
			}, t)
		}, t
	})(e.Action);
	e.PlaySoundAction = u;
	var d = (function(e) {
		function t(t, i, r) {
			e.call(this, t, r), this._sound = i
		}
		return __extends(t, e), t.prototype._prepare = function() {}, t.prototype.execute = function() {
			void 0 !== this._sound && this._sound.stop()
		}, t.prototype.serialize = function(t) {
			return e.prototype._serialize.call(this, {
				name: "StopSoundAction",
				properties: [{
					name: "sound",
					value: this._sound.name
				}]
			}, t)
		}, t
	})(e.Action);
	e.StopSoundAction = d
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o) {
			this.delayLoadState = e.Engine.DELAYLOADSTATE_NONE, this._totalVertices = 0, this._isDisposed = !1, this.id = t, this._engine = i.getEngine(), this._meshes = [], this._scene = i, this._vertexBuffers = {}, this._indices = [], r ? this.setAllVerticesData(r, n) : (this._totalVertices = 0, this._indices = []), o && (o instanceof e.LinesMesh && (this.boundingBias = new e.Vector2(0, o.intersectionThreshold), this.updateExtend()), this.applyToMesh(o), o.computeWorldMatrix(!0))
		}
		return Object.defineProperty(t.prototype, "boundingBias", {
			get: function() {
				return this._boundingBias
			},
			set: function(e) {
				this._boundingBias && this._boundingBias.equals(e) || (this._boundingBias = e.clone(), this.updateBoundingInfo(!0, null))
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "extend", {
			get: function() {
				return this._extend
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.getEngine = function() {
			return this._engine
		}, t.prototype.isReady = function() {
			return this.delayLoadState === e.Engine.DELAYLOADSTATE_LOADED || this.delayLoadState === e.Engine.DELAYLOADSTATE_NONE
		}, Object.defineProperty(t.prototype, "doNotSerialize", {
			get: function() {
				for (var e = 0; e < this._meshes.length; e++)
					if (!this._meshes[e].doNotSerialize) return !1;
				return !0
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.setAllVerticesData = function(e, t) {
			e.applyToGeometry(this, t), this.notifyUpdate()
		}, t.prototype.setVerticesData = function(t, i, r, n) {
			var o = new e.VertexBuffer(this._engine, i, t, r, 0 === this._meshes.length, n);
			this.setVerticesBuffer(o)
		}, t.prototype.setVerticesBuffer = function(t) {
			var i = t.getKind();
			if (this._vertexBuffers[i] && this._vertexBuffers[i].dispose(), this._vertexBuffers[i] = t, i === e.VertexBuffer.PositionKind) {
				var r = t.getData(),
					n = t.getStrideSize();
				this._totalVertices = r.length / n, this.updateExtend(r, n);
				for (var o = this._meshes, s = o.length, a = 0; a < s; a++) {
					var h = o[a];
					h._resetPointsArrayCache(), h._boundingInfo = new e.BoundingInfo(this._extend.minimum, this._extend.maximum), h._createGlobalSubMesh(), h.computeWorldMatrix(!0)
				}
			}
			this.notifyUpdate(i)
		}, t.prototype.updateVerticesDataDirectly = function(e, t, i) {
			var r = this.getVertexBuffer(e);
			r && (r.updateDirectly(t, i), this.notifyUpdate(e))
		}, t.prototype.updateVerticesData = function(t, i, r) {
			var n = this.getVertexBuffer(t);
			if (n) {
				if (n.update(i), t === e.VertexBuffer.PositionKind) {
					var o = n.getStrideSize();
					this._totalVertices = i.length / o, this.updateBoundingInfo(r, i)
				}
				this.notifyUpdate(t)
			}
		}, t.prototype.updateBoundingInfo = function(t, i) {
			t && this.updateExtend(i);
			for (var r = this._meshes, n = r.length, o = 0; o < n; o++) {
				var s = r[o];
				if (s._resetPointsArrayCache(), t) {
					s._boundingInfo = new e.BoundingInfo(this._extend.minimum, this._extend.maximum);
					for (var a = 0; a < s.subMeshes.length; a++) {
						var h = s.subMeshes[a];
						h.refreshBoundingInfo()
					}
				}
			}
		}, t.prototype.getTotalVertices = function() {
			return this.isReady() ? this._totalVertices : 0
		}, t.prototype.getVerticesData = function(e, t) {
			var i = this.getVertexBuffer(e);
			if (!i) return null;
			var r = i.getData();
			if (t && 1 !== this._meshes.length) {
				for (var n = r.length, o = [], s = 0; s < n; s++) o.push(r[s]);
				return o
			}
			return r
		}, t.prototype.getVertexBuffer = function(e) {
			return this.isReady() ? this._vertexBuffers[e] : null
		}, t.prototype.getVertexBuffers = function() {
			return this.isReady() ? this._vertexBuffers : null
		}, t.prototype.isVerticesDataPresent = function(e) {
			return this._vertexBuffers ? void 0 !== this._vertexBuffers[e] : !!this._delayInfo && this._delayInfo.indexOf(e) !== -1
		}, t.prototype.getVerticesDataKinds = function() {
			var e, t = [];
			if (!this._vertexBuffers && this._delayInfo)
				for (e in this._delayInfo) t.push(e);
			else
				for (e in this._vertexBuffers) t.push(e);
			return t
		}, t.prototype.setIndices = function(e, t) {
			this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = e, 0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices)), void 0 !== t && (this._totalVertices = t);
			for (var i = this._meshes, r = i.length, n = 0; n < r; n++) i[n]._createGlobalSubMesh();
			this.notifyUpdate()
		}, t.prototype.getTotalIndices = function() {
			return this.isReady() ? this._indices.length : 0
		}, t.prototype.getIndices = function(e) {
			if (!this.isReady()) return null;
			var t = this._indices;
			if (e && 1 !== this._meshes.length) {
				for (var i = t.length, r = [], n = 0; n < i; n++) r.push(t[n]);
				return r
			}
			return t
		}, t.prototype.getIndexBuffer = function() {
			return this.isReady() ? this._indexBuffer : null
		}, t.prototype.releaseForMesh = function(e, t) {
			var i = this._meshes,
				r = i.indexOf(e);
			if (r !== -1) {
				for (var n in this._vertexBuffers) this._vertexBuffers[n].dispose();
				this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer) && (this._indexBuffer = null), i.splice(r, 1), e._geometry = null, 0 === i.length && t && this.dispose()
			}
		}, t.prototype.applyToMesh = function(e) {
			if (e._geometry !== this) {
				var t = e._geometry;
				t && t.releaseForMesh(e);
				var i = this._meshes;
				e._geometry = this, this._scene.pushGeometry(this), i.push(e), this.isReady() ? this._applyToMesh(e) : e._boundingInfo = this._boundingInfo
			}
		}, t.prototype.updateExtend = function(t, i) {
			void 0 === t && (t = null), t || (t = this._vertexBuffers[e.VertexBuffer.PositionKind].getData()), this._extend = e.Tools.ExtractMinAndMax(t, 0, this._totalVertices, this.boundingBias, i)
		}, t.prototype._applyToMesh = function(t) {
			var i = this._meshes.length;
			for (var r in this._vertexBuffers) 1 === i && this._vertexBuffers[r].create(), this._vertexBuffers[r].getBuffer().references = i, r === e.VertexBuffer.PositionKind && (t._resetPointsArrayCache(), this._extend || this.updateExtend(this._vertexBuffers[r].getData()), t._boundingInfo = new e.BoundingInfo(this._extend.minimum, this._extend.maximum), t._createGlobalSubMesh(), t._updateBoundingInfo());
			1 === i && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices)), this._indexBuffer && (this._indexBuffer.references = i)
		}, t.prototype.notifyUpdate = function(e) {
			this.onGeometryUpdated && this.onGeometryUpdated(this, e)
		}, t.prototype.load = function(t, i) {
			if (this.delayLoadState !== e.Engine.DELAYLOADSTATE_LOADING) {
				if (this.isReady()) return void(i && i());
				this.delayLoadState = e.Engine.DELAYLOADSTATE_LOADING, this._queueLoad(t, i)
			}
		}, t.prototype._queueLoad = function(t, i) {
			var r = this;
			t._addPendingData(this), e.Tools.LoadFile(this.delayLoadingFile, (function(n) {
				r._delayLoadingFunction(JSON.parse(n), r), r.delayLoadState = e.Engine.DELAYLOADSTATE_LOADED, r._delayInfo = [], t._removePendingData(r);
				for (var o = r._meshes, s = o.length, a = 0; a < s; a++) r._applyToMesh(o[a]);
				i && i()
			}), (function() {}), t.database)
		}, t.prototype.toLeftHanded = function() {
			var t = this.getIndices(!1);
			if (null != t && t.length > 0) {
				for (var i = 0; i < t.length; i += 3) {
					var r = t[i + 0];
					t[i + 0] = t[i + 2], t[i + 2] = r
				}
				this.setIndices(t)
			}
			var n = this.getVerticesData(e.VertexBuffer.PositionKind, !1);
			if (null != n && n.length > 0) {
				for (var i = 0; i < n.length; i += 3) n[i + 2] = -n[i + 2];
				this.setVerticesData(e.VertexBuffer.PositionKind, n, !1)
			}
			var o = this.getVerticesData(e.VertexBuffer.NormalKind, !1);
			if (null != o && o.length > 0) {
				for (var i = 0; i < o.length; i += 3) o[i + 2] = -o[i + 2];
				this.setVerticesData(e.VertexBuffer.NormalKind, o, !1)
			}
		}, t.prototype.isDisposed = function() {
			return this._isDisposed
		}, t.prototype.dispose = function() {
			var t, i = this._meshes,
				r = i.length;
			for (t = 0; t < r; t++) this.releaseForMesh(i[t]);
			this._meshes = [];
			for (var n in this._vertexBuffers) this._vertexBuffers[n].dispose();
			this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = e.Engine.DELAYLOADSTATE_NONE, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._isDisposed = !0
		}, t.prototype.copy = function(i) {
			var r = new e.VertexData;
			r.indices = [];
			for (var n = this.getIndices(), o = 0; o < n.length; o++) r.indices.push(n[o]);
			var s, a = !1,
				h = !1;
			for (s in this._vertexBuffers) {
				var c = this.getVerticesData(s);
				c instanceof Float32Array ? r.set(new Float32Array(c), s) : r.set(c.slice(0), s), h || (a = this.getVertexBuffer(s).isUpdatable(), h = !a)
			}
			var l = new t(i, this._scene, r, a, null);
			l.delayLoadState = this.delayLoadState, l.delayLoadingFile = this.delayLoadingFile, l._delayLoadingFunction = this._delayLoadingFunction;
			for (s in this._delayInfo) l._delayInfo = l._delayInfo || [], l._delayInfo.push(s);
			return l._boundingInfo = new e.BoundingInfo(this._extend.minimum, this._extend.maximum), l
		}, t.prototype.serialize = function() {
			var t = {};
			return t.id = this.id, e.Tags.HasTags(this) && (t.tags = e.Tags.GetTags(this)), t
		}, t.prototype.serializeVerticeData = function() {
			var t = this.serialize();
			return this.isVerticesDataPresent(e.VertexBuffer.PositionKind) && (t.positions = this.getVerticesData(e.VertexBuffer.PositionKind)), this.isVerticesDataPresent(e.VertexBuffer.NormalKind) && (t.normals = this.getVerticesData(e.VertexBuffer.NormalKind)), this.isVerticesDataPresent(e.VertexBuffer.UVKind) && (t.uvs = this.getVerticesData(e.VertexBuffer.UVKind)), this.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (t.uv2s = this.getVerticesData(e.VertexBuffer.UV2Kind)), this.isVerticesDataPresent(e.VertexBuffer.UV3Kind) && (t.uv3s = this.getVerticesData(e.VertexBuffer.UV3Kind)), this.isVerticesDataPresent(e.VertexBuffer.UV4Kind) && (t.uv4s = this.getVerticesData(e.VertexBuffer.UV4Kind)), this.isVerticesDataPresent(e.VertexBuffer.UV5Kind) && (t.uv5s = this.getVerticesData(e.VertexBuffer.UV5Kind)), this.isVerticesDataPresent(e.VertexBuffer.UV6Kind) && (t.uv6s = this.getVerticesData(e.VertexBuffer.UV6Kind)), this.isVerticesDataPresent(e.VertexBuffer.ColorKind) && (t.colors = this.getVerticesData(e.VertexBuffer.ColorKind)), this.isVerticesDataPresent(e.VertexBuffer.MatricesIndicesKind) && (t.matricesIndices = this.getVerticesData(e.VertexBuffer.MatricesIndicesKind), t.matricesIndices._isExpanded = !0), this.isVerticesDataPresent(e.VertexBuffer.MatricesWeightsKind) && (t.matricesWeights = this.getVerticesData(e.VertexBuffer.MatricesWeightsKind)), t.indices = this.getIndices(), t
		}, t.ExtractFromMesh = function(e, t) {
			var i = e._geometry;
			return i ? i.copy(t) : null
		}, t.RandomId = function() {
			return e.Tools.RandomId()
		}, t.ImportGeometry = function(t, i) {
			var r = i.getScene(),
				n = t.geometryId;
			if (n) {
				var o = r.getGeometryByID(n);
				o && o.applyToMesh(i)
			} else if (t instanceof ArrayBuffer) {
				var s = i._binaryInfo;
				if (s.positionsAttrDesc && s.positionsAttrDesc.count > 0) {
					var a = new Float32Array(t, s.positionsAttrDesc.offset, s.positionsAttrDesc.count);
					i.setVerticesData(e.VertexBuffer.PositionKind, a, !1)
				}
				if (s.normalsAttrDesc && s.normalsAttrDesc.count > 0) {
					var h = new Float32Array(t, s.normalsAttrDesc.offset, s.normalsAttrDesc.count);
					i.setVerticesData(e.VertexBuffer.NormalKind, h, !1)
				}
				if (s.uvsAttrDesc && s.uvsAttrDesc.count > 0) {
					var c = new Float32Array(t, s.uvsAttrDesc.offset, s.uvsAttrDesc.count);
					i.setVerticesData(e.VertexBuffer.UVKind, c, !1)
				}
				if (s.uvs2AttrDesc && s.uvs2AttrDesc.count > 0) {
					var l = new Float32Array(t, s.uvs2AttrDesc.offset, s.uvs2AttrDesc.count);
					i.setVerticesData(e.VertexBuffer.UV2Kind, l, !1)
				}
				if (s.uvs3AttrDesc && s.uvs3AttrDesc.count > 0) {
					var u = new Float32Array(t, s.uvs3AttrDesc.offset, s.uvs3AttrDesc.count);
					i.setVerticesData(e.VertexBuffer.UV3Kind, u, !1)
				}
				if (s.uvs4AttrDesc && s.uvs4AttrDesc.count > 0) {
					var d = new Float32Array(t, s.uvs4AttrDesc.offset, s.uvs4AttrDesc.count);
					i.setVerticesData(e.VertexBuffer.UV4Kind, d, !1)
				}
				if (s.uvs5AttrDesc && s.uvs5AttrDesc.count > 0) {
					var f = new Float32Array(t, s.uvs5AttrDesc.offset, s.uvs5AttrDesc.count);
					i.setVerticesData(e.VertexBuffer.UV5Kind, f, !1)
				}
				if (s.uvs6AttrDesc && s.uvs6AttrDesc.count > 0) {
					var p = new Float32Array(t, s.uvs6AttrDesc.offset, s.uvs6AttrDesc.count);
					i.setVerticesData(e.VertexBuffer.UV6Kind, p, !1)
				}
				if (s.colorsAttrDesc && s.colorsAttrDesc.count > 0) {
					var m = new Float32Array(t, s.colorsAttrDesc.offset, s.colorsAttrDesc.count);
					i.setVerticesData(e.VertexBuffer.ColorKind, m, !1, s.colorsAttrDesc.stride)
				}
				if (s.matricesIndicesAttrDesc && s.matricesIndicesAttrDesc.count > 0) {
					var _ = new Int32Array(t, s.matricesIndicesAttrDesc.offset, s.matricesIndicesAttrDesc.count);
					i.setVerticesData(e.VertexBuffer.MatricesIndicesKind, _, !1)
				}
				if (s.matricesWeightsAttrDesc && s.matricesWeightsAttrDesc.count > 0) {
					var g = new Float32Array(t, s.matricesWeightsAttrDesc.offset, s.matricesWeightsAttrDesc.count);
					i.setVerticesData(e.VertexBuffer.MatricesWeightsKind, g, !1)
				}
				if (s.indicesAttrDesc && s.indicesAttrDesc.count > 0) {
					var v = new Int32Array(t, s.indicesAttrDesc.offset, s.indicesAttrDesc.count);
					i.setIndices(v)
				}
				if (s.subMeshesAttrDesc && s.subMeshesAttrDesc.count > 0) {
					var y = new Int32Array(t, s.subMeshesAttrDesc.offset, 5 * s.subMeshesAttrDesc.count);
					i.subMeshes = [];
					for (var x = 0; x < s.subMeshesAttrDesc.count; x++) {
						var b = y[5 * x + 0],
							T = y[5 * x + 1],
							A = y[5 * x + 2],
							E = y[5 * x + 3],
							P = y[5 * x + 4];
						new e.SubMesh(b, T, A, E, P, i)
					}
				}
			} else if (t.positions && t.normals && t.indices) {
				if (i.setVerticesData(e.VertexBuffer.PositionKind, t.positions, !1), i.setVerticesData(e.VertexBuffer.NormalKind, t.normals, !1), t.uvs && i.setVerticesData(e.VertexBuffer.UVKind, t.uvs, !1), t.uvs2 && i.setVerticesData(e.VertexBuffer.UV2Kind, t.uvs2, !1), t.uvs3 && i.setVerticesData(e.VertexBuffer.UV3Kind, t.uvs3, !1), t.uvs4 && i.setVerticesData(e.VertexBuffer.UV4Kind, t.uvs4, !1), t.uvs5 && i.setVerticesData(e.VertexBuffer.UV5Kind, t.uvs5, !1), t.uvs6 && i.setVerticesData(e.VertexBuffer.UV6Kind, t.uvs6, !1), t.colors && i.setVerticesData(e.VertexBuffer.ColorKind, e.Color4.CheckColors4(t.colors, t.positions.length / 3), !1), t.matricesIndices)
					if (t.matricesIndices._isExpanded) delete t.matricesIndices._isExpanded, i.setVerticesData(e.VertexBuffer.MatricesIndicesKind, t.matricesIndices, !1);
					else {
						for (var M = [], x = 0; x < t.matricesIndices.length; x++) {
							var S = t.matricesIndices[x];
							M.push(255 & S), M.push((65280 & S) >> 8), M.push((16711680 & S) >> 16), M.push(S >> 24)
						}
						i.setVerticesData(e.VertexBuffer.MatricesIndicesKind, M, !1)
					}
				if (t.matricesIndicesExtra)
					if (t.matricesIndicesExtra._isExpanded) delete t.matricesIndices._isExpanded, i.setVerticesData(e.VertexBuffer.MatricesIndicesExtraKind, t.matricesIndicesExtra, !1);
					else {
						for (var M = [], x = 0; x < t.matricesIndicesExtra.length; x++) {
							var S = t.matricesIndicesExtra[x];
							M.push(255 & S), M.push((65280 & S) >> 8), M.push((16711680 & S) >> 16), M.push(S >> 24)
						}
						i.setVerticesData(e.VertexBuffer.MatricesIndicesExtraKind, M, !1)
					}
				t.matricesWeights && i.setVerticesData(e.VertexBuffer.MatricesWeightsKind, t.matricesWeights, !1), t.matricesWeightsExtra && i.setVerticesData(e.VertexBuffer.MatricesWeightsExtraKind, t.matricesWeightsExtra, !1), i.setIndices(t.indices)
			}
			if (t.subMeshes) {
				i.subMeshes = [];
				for (var C = 0; C < t.subMeshes.length; C++) {
					var R = t.subMeshes[C];
					new e.SubMesh(R.materialIndex, R.verticesStart, R.verticesCount, R.indexStart, R.indexCount, i)
				}
			}
			i._shouldGenerateFlatShading && (i.convertToFlatShadedMesh(), delete i._shouldGenerateFlatShading), i.computeWorldMatrix(!0), r._selectionOctree && r._selectionOctree.addMesh(i)
		}, t.Parse = function(i, r, n) {
			if (r.getGeometryByID(i.id)) return null;
			var o = new t(i.id, r);
			return e.Tags.AddTagsTo(o, i.tags), i.delayLoadingFile ? (o.delayLoadState = e.Engine.DELAYLOADSTATE_NOTLOADED, o.delayLoadingFile = n + i.delayLoadingFile, o._boundingInfo = new e.BoundingInfo(e.Vector3.FromArray(i.boundingBoxMinimum), e.Vector3.FromArray(i.boundingBoxMaximum)), o._delayInfo = [], i.hasUVs && o._delayInfo.push(e.VertexBuffer.UVKind), i.hasUVs2 && o._delayInfo.push(e.VertexBuffer.UV2Kind), i.hasUVs3 && o._delayInfo.push(e.VertexBuffer.UV3Kind), i.hasUVs4 && o._delayInfo.push(e.VertexBuffer.UV4Kind), i.hasUVs5 && o._delayInfo.push(e.VertexBuffer.UV5Kind), i.hasUVs6 && o._delayInfo.push(e.VertexBuffer.UV6Kind), i.hasColors && o._delayInfo.push(e.VertexBuffer.ColorKind), i.hasMatricesIndices && o._delayInfo.push(e.VertexBuffer.MatricesIndicesKind), i.hasMatricesWeights && o._delayInfo.push(e.VertexBuffer.MatricesWeightsKind), o._delayLoadingFunction = e.VertexData.ImportVertexData) : e.VertexData.ImportVertexData(i, o), r.pushGeometry(o, !0), o
		}, t
	})();
	e.Geometry = t;
	var t;
	!(function(t) {
		var i;
		!(function(i) {
			var r = (function(e) {
				function t(t, i, r, n) {
					e.call(this, t, i, null, !1, n), this._canBeRegenerated = r, this._beingRegenerated = !0, this.regenerate(), this._beingRegenerated = !1
				}
				return __extends(t, e), t.prototype.canBeRegenerated = function() {
					return this._canBeRegenerated
				}, t.prototype.regenerate = function() {
					this._canBeRegenerated && (this._beingRegenerated = !0, this.setAllVerticesData(this._regenerateVertexData(), !1), this._beingRegenerated = !1)
				}, t.prototype.asNewGeometry = function(t) {
					return e.prototype.copy.call(this, t)
				}, t.prototype.setAllVerticesData = function(t, i) {
					this._beingRegenerated && e.prototype.setAllVerticesData.call(this, t, !1)
				}, t.prototype.setVerticesData = function(t, i, r) {
					this._beingRegenerated && e.prototype.setVerticesData.call(this, t, i, !1)
				}, t.prototype._regenerateVertexData = function() {
					throw new Error("Abstract method")
				}, t.prototype.copy = function(e) {
					throw new Error("Must be overriden in sub-classes.")
				}, t.prototype.serialize = function() {
					var t = e.prototype.serialize.call(this);
					return t.canBeRegenerated = this.canBeRegenerated(), t
				}, t
			})(t);
			i._Primitive = r;
			var n = (function(t) {
				function i(i, r, n, o, s, a, h, c, l) {
					void 0 === l && (l = e.Mesh.DEFAULTSIDE), t.call(this, i, r, h, c), this.pathArray = n, this.closeArray = o, this.closePath = s, this.offset = a, this.side = l
				}
				return __extends(i, t), i.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateRibbon({
						pathArray: this.pathArray,
						closeArray: this.closeArray,
						closePath: this.closePath,
						offset: this.offset,
						sideOrientation: this.side
					})
				}, i.prototype.copy = function(e) {
					return new i(e, this.getScene(), this.pathArray, this.closeArray, this.closePath, this.offset, this.canBeRegenerated(), null, this.side)
				}, i
			})(r);
			i.Ribbon = n;
			var o = (function(i) {
				function r(t, r, n, o, s, a) {
					void 0 === a && (a = e.Mesh.DEFAULTSIDE), i.call(this, t, r, o, s), this.size = n, this.side = a
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateBox({
						size: this.size,
						sideOrientation: this.side
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.size, this.canBeRegenerated(), null, this.side)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.size = this.size, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.Box(i.id, r, i.size, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.Box = o;
			var s = (function(i) {
				function r(t, r, n, o, s, a, h) {
					void 0 === h && (h = e.Mesh.DEFAULTSIDE), i.call(this, t, r, s, a), this.segments = n, this.diameter = o, this.side = h
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateSphere({
						segments: this.segments,
						diameter: this.diameter,
						sideOrientation: this.side
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.segments, this.diameter, this.canBeRegenerated(), null, this.side)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.segments = this.segments, e.diameter = this.diameter, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.Sphere(i.id, r, i.segments, i.diameter, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.Sphere = s;
			var a = (function(t) {
				function i(i, r, n, o, s, a, h) {
					void 0 === h && (h = e.Mesh.DEFAULTSIDE), t.call(this, i, r, s, a), this.radius = n, this.tessellation = o, this.side = h
				}
				return __extends(i, t), i.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateDisc({
						radius: this.radius,
						tessellation: this.tessellation,
						sideOrientation: this.side
					})
				}, i.prototype.copy = function(e) {
					return new i(e, this.getScene(), this.radius, this.tessellation, this.canBeRegenerated(), null, this.side)
				}, i
			})(r);
			i.Disc = a;
			var h = (function(i) {
				function r(t, r, n, o, s, a, h, c, l, u) {
					void 0 === h && (h = 1), void 0 === u && (u = e.Mesh.DEFAULTSIDE), i.call(this, t, r, c, l), this.height = n, this.diameterTop = o, this.diameterBottom = s, this.tessellation = a, this.subdivisions = h, this.side = u
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateCylinder({
						height: this.height,
						diameterTop: this.diameterTop,
						diameterBottom: this.diameterBottom,
						tessellation: this.tessellation,
						subdivisions: this.subdivisions,
						sideOrientation: this.side
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.height, this.diameterTop, this.diameterBottom, this.tessellation, this.subdivisions, this.canBeRegenerated(), null, this.side)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.height = this.height, e.diameterTop = this.diameterTop, e.diameterBottom = this.diameterBottom, e.tessellation = this.tessellation, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.Cylinder(i.id, r, i.height, i.diameterTop, i.diameterBottom, i.tessellation, i.subdivisions, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.Cylinder = h;
			var c = (function(i) {
				function r(t, r, n, o, s, a, h, c) {
					void 0 === c && (c = e.Mesh.DEFAULTSIDE), i.call(this, t, r, a, h), this.diameter = n, this.thickness = o, this.tessellation = s, this.side = c
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateTorus({
						diameter: this.diameter,
						thickness: this.thickness,
						tessellation: this.tessellation,
						sideOrientation: this.side
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.diameter, this.thickness, this.tessellation, this.canBeRegenerated(), null, this.side)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.diameter = this.diameter, e.thickness = this.thickness, e.tessellation = this.tessellation, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.Torus(i.id, r, i.diameter, i.thickness, i.tessellation, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.Torus = c;
			var l = (function(i) {
				function r(e, t, r, n, o, s, a) {
					i.call(this, e, t, s, a), this.width = r, this.height = n, this.subdivisions = o
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateGround({
						width: this.width,
						height: this.height,
						subdivisions: this.subdivisions
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.width, this.height, this.subdivisions, this.canBeRegenerated(), null)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.width = this.width, e.height = this.height, e.subdivisions = this.subdivisions, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.Ground(i.id, r, i.width, i.height, i.subdivisions, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.Ground = l;
			var u = (function(t) {
				function i(e, i, r, n, o, s, a, h, c, l) {
					t.call(this, e, i, c, l), this.xmin = r, this.zmin = n, this.xmax = o, this.zmax = s, this.subdivisions = a, this.precision = h
				}
				return __extends(i, t), i.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateTiledGround({
						xmin: this.xmin,
						zmin: this.zmin,
						xmax: this.xmax,
						zmax: this.zmax,
						subdivisions: this.subdivisions,
						precision: this.precision
					})
				}, i.prototype.copy = function(e) {
					return new i(e, this.getScene(), this.xmin, this.zmin, this.xmax, this.zmax, this.subdivisions, this.precision, this.canBeRegenerated(), null)
				}, i
			})(r);
			i.TiledGround = u;
			var d = (function(i) {
				function r(t, r, n, o, s, a) {
					void 0 === a && (a = e.Mesh.DEFAULTSIDE), i.call(this, t, r, o, s), this.size = n, this.side = a
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreatePlane({
						size: this.size,
						sideOrientation: this.side
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.size, this.canBeRegenerated(), null, this.side)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.size = this.size, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.Plane(i.id, r, i.size, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.Plane = d;
			var f = (function(i) {
				function r(t, r, n, o, s, a, h, c, l, u, d) {
					void 0 === d && (d = e.Mesh.DEFAULTSIDE), i.call(this, t, r, l, u), this.radius = n, this.tube = o, this.radialSegments = s, this.tubularSegments = a, this.p = h, this.q = c, this.side = d
				}
				return __extends(r, i), r.prototype._regenerateVertexData = function() {
					return e.VertexData.CreateTorusKnot({
						radius: this.radius,
						tube: this.tube,
						radialSegments: this.radialSegments,
						tubularSegments: this.tubularSegments,
						p: this.p,
						q: this.q,
						sideOrientation: this.side
					})
				}, r.prototype.copy = function(e) {
					return new r(e, this.getScene(), this.radius, this.tube, this.radialSegments, this.tubularSegments, this.p, this.q, this.canBeRegenerated(), null, this.side)
				}, r.prototype.serialize = function() {
					var e = i.prototype.serialize.call(this);
					return e.radius = this.radius, e.tube = this.tube, e.radialSegments = this.radialSegments, e.tubularSegments = this.tubularSegments, e.p = this.p, e.q = this.q, e
				}, r.Parse = function(i, r) {
					if (r.getGeometryByID(i.id)) return null;
					var n = new t.Primitives.TorusKnot(i.id, r, i.radius, i.tube, i.radialSegments, i.tubularSegments, i.p, i.q, i.canBeRegenerated, null);
					return e.Tags.AddTagsTo(n, i.tags), r.pushGeometry(n, !0), n
				}, r
			})(r);
			i.TorusKnot = f
		})(i = t.Primitives || (t.Primitives = {}))
	})(t = e.Geometry || (e.Geometry = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r) {
			t.call(this, i, r), this.generateOctree = !1, this._worldInverse = new e.Matrix
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "subdivisions", {
			get: function() {
				return Math.min(this._subdivisionsX, this._subdivisionsY)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "subdivisionsX", {
			get: function() {
				return this._subdivisionsX
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "subdivisionsY", {
			get: function() {
				return this._subdivisionsY
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.optimize = function(e, t) {
			void 0 === t && (t = 32), this._subdivisionsX = e, this._subdivisionsY = e, this.subdivide(e), this.createOrUpdateSubmeshesOctree(t)
		}, i.prototype.getHeightAtCoordinates = function(e, t) {
			if (e -= this.position.x, t -= this.position.z, e /= this.scaling.x, t /= this.scaling.z, e < this._minX || e > this._maxX || t < this._minZ || t > this._maxZ) return this.position.y;
			this._heightQuads && 0 != this._heightQuads.length || (this._initHeightQuads(), this._computeHeightQuads());
			var i = this._getFacetAt(e, t),
				r = -(i.x * e + i.z * t + i.w) / i.y;
			return r * this.scaling.y + this.position.y
		}, i.prototype.getNormalAtCoordinates = function(t, i) {
			var r = new e.Vector3(0, 1, 0);
			return this.getNormalAtCoordinatesToRef(t, i, r), r
		}, i.prototype.getNormalAtCoordinatesToRef = function(e, t, i) {
			if (e -= this.position.x, t -= this.position.z, e /= this.scaling.x, t /= this.scaling.z, !(e < this._minX || e > this._maxX || t < this._minZ || t > this._maxZ)) {
				this._heightQuads && 0 != this._heightQuads.length || (this._initHeightQuads(), this._computeHeightQuads());
				var r = this._getFacetAt(e, t);
				i.x = r.x, i.y = r.y, i.z = r.z
			}
		}, i.prototype.updateCoordinateHeights = function() {
			this._heightQuads && 0 != this._heightQuads.length || this._initHeightQuads(), this._computeHeightQuads()
		}, i.prototype._getFacetAt = function(e, t) {
			var i, r = (this._subdivisionsX, this._subdivisionsY, Math.floor((e + this._maxX) * this._subdivisionsX / this._width)),
				n = Math.floor(-(t + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY),
				o = this._heightQuads[n * this._subdivisionsX + r];
			return i = t < o.slope.x * e + o.slope.y ? o.facet1 : o.facet2
		}, i.prototype._initHeightQuads = function() {
			var t = this._subdivisionsX,
				i = this._subdivisionsY;
			this._heightQuads = new Array;
			for (var r = 0; r < i; r++)
				for (var n = 0; n < t; n++) {
					var o = {
						slope: e.Vector2.Zero(),
						facet1: new e.Vector4(0, 0, 0, 0),
						facet2: new e.Vector4(0, 0, 0, 0)
					};
					this._heightQuads[r * t + n] = o
				}
		}, i.prototype._computeHeightQuads = function() {
			for (var t = this.getVerticesData(e.VertexBuffer.PositionKind), i = e.Tmp.Vector3[3], r = e.Tmp.Vector3[2], n = e.Tmp.Vector3[1], o = e.Tmp.Vector3[0], s = e.Tmp.Vector3[4], a = e.Tmp.Vector3[5], h = e.Tmp.Vector3[6], c = e.Tmp.Vector3[7], l = e.Tmp.Vector3[8], u = 0, d = 0, f = 0, p = 0, m = 0, _ = 0, g = 0, v = this._subdivisionsX, y = this._subdivisionsY, x = 0; x < y; x++)
				for (var b = 0; b < v; b++) {
					u = 3 * b, d = x * (v + 1) * 3, f = (x + 1) * (v + 1) * 3, i.x = t[d + u], i.y = t[d + u + 1], i.z = t[d + u + 2], r.x = t[d + u + 3], r.y = t[d + u + 4], r.z = t[d + u + 5], n.x = t[f + u], n.y = t[f + u + 1], n.z = t[f + u + 2], o.x = t[f + u + 3], o.y = t[f + u + 4], o.z = t[f + u + 5], p = (o.z - i.z) / (o.x - i.x), m = i.z - p * i.x, r.subtractToRef(i, s), n.subtractToRef(i, a), o.subtractToRef(i, h), e.Vector3.CrossToRef(h, a, c), e.Vector3.CrossToRef(s, h, l), c.normalize(), l.normalize(), _ = -(c.x * i.x + c.y * i.y + c.z * i.z), g = -(l.x * r.x + l.y * r.y + l.z * r.z);
					var T = this._heightQuads[x * v + b];
					T.slope.copyFromFloats(p, m), T.facet1.copyFromFloats(c.x, c.y, c.z, _), T.facet2.copyFromFloats(l.x, l.y, l.z, g)
				}
		}, i
	})(e.Mesh);
	e.GroundMesh = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			void 0 === n && (n = null), t.call(this, i, r, n, o, s), this.color = new e.Color3(1, 1, 1), this.alpha = 1, this._positionBuffer = {}, o && (this.color = o.color.clone(), this.alpha = o.alpha), this._intersectionThreshold = .1, this._colorShader = new e.ShaderMaterial("colorShader", r, "color", {
				attributes: [e.VertexBuffer.PositionKind],
				uniforms: ["worldViewProjection", "color"],
				needAlphaBlending: !0
			}), this._positionBuffer[e.VertexBuffer.PositionKind] = null
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "intersectionThreshold", {
			get: function() {
				return this._intersectionThreshold
			},
			set: function(t) {
				this._intersectionThreshold !== t && (this._intersectionThreshold = t, this.geometry && (this.geometry.boundingBias = new e.Vector2(0, t)))
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "material", {
			get: function() {
				return this._colorShader
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "checkCollisions", {
			get: function() {
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.createInstance = function(t) {
			return e.Tools.Log("LinesMeshes do not support createInstance."), null
		}, i.prototype._bind = function(t, i, r) {
			var n = this.getScene().getEngine();
			this._positionBuffer[e.VertexBuffer.PositionKind] = this._geometry.getVertexBuffer(e.VertexBuffer.PositionKind), n.bindBuffers(this._positionBuffer, this._geometry.getIndexBuffer(), this._colorShader.getEffect()), this._colorShader.setColor4("color", this.color.toColor4(this.alpha))
		}, i.prototype._draw = function(e, t, i) {
			if (this._geometry && this._geometry.getVertexBuffers() && this._geometry.getIndexBuffer()) {
				var r = this.getScene().getEngine();
				r.draw(!1, e.indexStart, e.indexCount)
			}
		}, i.prototype.dispose = function(e) {
			this._colorShader.dispose(), t.prototype.dispose.call(this, e)
		}, i.prototype.clone = function(e, t, r) {
			return new i(e, this.getScene(), t, this, r)
		}, i
	})(e.Mesh);
	e.LinesMesh = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t, i) {
			var r = this;
			void 0 === t && (t = ""), void 0 === i && (i = "black"), this._renderingCanvas = e, this._loadingText = t, this._loadingDivBackgroundColor = i, this._resizeLoadingUI = function() {
				var e = r._renderingCanvas.getBoundingClientRect();
				r._loadingDiv.style.position = "absolute", r._loadingDiv.style.left = e.left + "px", r._loadingDiv.style.top = e.top + "px", r._loadingDiv.style.width = e.width + "px", r._loadingDiv.style.height = e.height + "px"
			}
		}
		return e.prototype.displayLoadingUI = function() {
			var e = this;
			if (!this._loadingDiv) {
				this._loadingDiv = document.createElement("div"), this._loadingDiv.id = "babylonjsLoadingDiv", this._loadingDiv.style.opacity = "0", this._loadingDiv.style.transition = "opacity 1.5s ease", this._loadingTextDiv = document.createElement("div"), this._loadingTextDiv.style.position = "absolute", this._loadingTextDiv.style.left = "0", this._loadingTextDiv.style.top = "50%", this._loadingTextDiv.style.marginTop = "80px", this._loadingTextDiv.style.width = "100%", this._loadingTextDiv.style.height = "20px", this._loadingTextDiv.style.fontFamily = "Arial", this._loadingTextDiv.style.fontSize = "14px", this._loadingTextDiv.style.color = "white", this._loadingTextDiv.style.textAlign = "center", this._loadingTextDiv.innerHTML = "Loading", this._loadingDiv.appendChild(this._loadingTextDiv), this._loadingTextDiv.innerHTML = this._loadingText;
				var t = new Image;
				t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuM4zml1AAAARbSURBVHhe7Z09aFNRFMc716kuLrq4FdyLq4Wi4CAoRQcR0UJBUBdRiuLSIYMo6CA4FF2sgw6CFAdFUOpSQYcWO4hD26UQCfXrIQrx/JJzw1OSWq3NPeL/B4Fy+0jg/HO+7j3vpUcI8b/Q39+/49ihfWdPHT94Yf/e3Se3bd263f8lus218TPn6vV6Ya8Wi/MzNRNmj18iusX9W1evmP1/EKNEIVG6CMbG6E3bt+fT++pHha8NoHdT72bLE8NDg7tGU64gLLndV4Wc4m8j/pS+vr4tGB/DT16v3Fyr8dvBe/jbit8BL0AES9LX1iPAz+BR/hFiLVCynj95dPzNy6fv3IZ/k4L3948Sq7FzYGBg4vLFGxitabuOFCbWNKGrMnbiUuo18KaV6tIHv6YtvL9/nOgE31jCktmrY7k6+/zhE4yP4Vf7hiNqh/BWWEl8mzDol4p22Lf7cIdvdUMEvv0Y2S9fE5S1hLzpqTsPkiep//gFGPnR3Yl7GL5p/xYFBrTwM+iXio3GqpwDGL5p/xYNIX7XG8Q6IJRgdIzf1KBBgafII7oMidhyQtVFaMA2Bt7il4huQRhaXphbcR2g4RXqBzKAGHiCCwGFVUAj/m/RTRDj29cvn10I0PZ3LghH5f4CL1EFlQmqqXK3jDDKFxmhQ3Yt6oQseUZGKmMnTpsOqc8o1F9kBOMjQlOLeqEeIyOc6JV6jYLJD/+XyIFvnzdgl9aXRQ5I2qZDK1SpospMqaoqON/wZZGDciLnMMiXRS7IF4hhqMTNTdk7CFu+LHLhR7BQqBvPDJUUQqCGvCMATHUgBmhWNgApmdOda9YpM+VwRYfuyyIXDK8hBlilNerLIheMZCKGwlUAyru6GlwOgPUbRxADdJ9FAChxXY864viyyEXqPxhc0M2TAfAbatSdRyHtXymhByEdRnE3ky+JnHAIhSA0h74kckETmHoQbSgGwJrCIRMEPSRIBCRIMAhZaYhaggQhJXUJEoRU9mofKwh+F22dLRRfEjlJM7w6KQwCoQpBOKTyJZETjmwRxKqtGV8SOSkNOGjKPQppBEgDDkFgpxdBVGkFgaYQQXRIFQSObk0P5ZFIpAZRHXsQ0r0hCluBWKkuvVbYCkQaCdL5ehBScudJP4yY+rLISdps1NBDEJKXMMmoSfggWC4ZQRR17oFYXph7hSiquIKQ+hJGTX1J5MYSPD/GVdNzsgLBwZVCVyAQAkF0ohiI/c1fS6tNXq9UfEnkhudmIQolsS+J3Hh/UtNDzQLhj42VKJFInqLwFYiUU5ToA+HdfI0JevUpQUAIn+vSz2lHIuUV/dJOIHhOY/IWVWGBIHQtzs88s9zyWBuTgcBLzGOmeNnfF/QslSDgMeQW85i3DOQxuipxAkCyZ8SIm4Omp+7MMlCB59j6sKZcMoM4iIEoeI2J9AKxrFobZx0v4vYInuHFS4J1GQRCAGaLEYQXfyMML5XSQgghhBBCCCH+cXp6vgNhKpSKX/XdOAAAAABJRU5ErkJggg==", t.style.position = "absolute", t.style.left = "50%", t.style.top = "50%", t.style.marginLeft = "-50px", t.style.marginTop = "-50px", t.style.transition = "transform 1.0s ease", t.style.webkitTransition = "-webkit-transform 1.0s ease";
				var i = 360,
					r = function() {
						i += 360, t.style.transform = "rotateZ(" + i + "deg)", t.style.webkitTransform = "rotateZ(" + i + "deg)"
					};
				t.addEventListener("transitionend", r), t.addEventListener("webkitTransitionEnd", r), this._loadingDiv.appendChild(t);
				var n = new Image;
				n.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuM4zml1AAAAYJSURBVHhe7Zy/qx1FFMff/2Av2Nvbi4WFiiAEY/OQ2IgQsbCJQoqkCAgpFLXyoZURLfwBIiIpgqZJoYQYlWelNsIrNOxDJcrzfHe+G97dnTl75u7euzv7zgcWHrlnZmfOmXPmzI/NjuM4juM4juM4juM4juM4juM4juM4juM45fPic08/uHf5/CvffH7lnT8PfrtxdHS0n3p+/fHGl5+89/prr5599iEWd8bg0rkXHoFyqehKnlxQpjYSDHTm9JMPsGrHylOPPXofvICKXMcIGtXdf/76AYbm6xyNW9e/eAtKC7rbKLXnvHHx5Sf4auc4Ek7OQkFU1Dap/vv37k/wSjblZANFiFIGzw98hhizwqBgs04mCBdQRNCHidoAEtY+lLIvtSdoGFeyql2ZH57HBH4sE7O+o/r9l+8/ZXUni68+2jsHBQQ9qNRGeP/tSxdSYQX/roUcpL4/f3vtM9TD+jTq92n1LQ7jxF1hhGPtwWL3gGccy8JuS1r8sVWBGXNVdSKMYjBGPUJjCzooiGuSpnwlnnOGP2dhHRSLNgpHp2oMKIriK8TmG4Qh/rwW8D6pps9b9im+LDDipXOqMVJrAngBfg9i98gevWKA+/nnCod3Dr5GfaHaDgidVym6HKRjGIkpqthcAVKGxNqBImbEo66kjCih8AOpNmkUmbMuUrR8kEqiU6FvHZLGAPJ71JCYSyhiBqmwFE2GoD6jLGIfDHtG6EzoU4dK21PCqIRMEF0FGRjFzGDtIkXVAdATvsqfT9CJ0JcOFdYiFIsiMlqYy1YOFpQo2OddqBtyEaq9y+efoVh5oPHoROjLKn0j3JIE5Ka8UqZRtGrMnneX6yVofOhDh94MSbznTcpqmDOt1vyQzOgaJAF4F3JBfIXesrNEGWWmjIX7UBZ6jRJbBMLg/DmJiKUGVHleIpnVNTa+jakzkAviJqLhi4MC9XQGBrZeKJZESSrKy7ik0VGFWhQBRDTHIACKQ5l9nAjy75gya4a2w+Jhs0FJdc0xX/GwUbAqFBkZi7QpJ2w16WUbjFyK9MJF3KaoEM74KhVtLrQOrsmRxkbdHEqmSC/c+EuGnIFkjW7Ih2Kr4CCMIvNG2hrrgLpCjiFloooYCjyYrzCRyvhyBthkIPuQtsZGdnbMTezyDiU71KTC5zr7aVsHbsz2tllrEkS5UHwU1tq1HbtPW4UbeB0O7xx8R5EsMJql+BheUmHjkNVmIRP7LutoM3+D4O4tG7vCkNO9ESZ4lL3J6rKRMPx4qKbD/A0icf8CG7tC7kTahnMTwleuYSrsS7GatRAvfZh1tTm5BmmQCdZ8a0Sefe28xUrRBkmFLKy8KTIKUDRX0Y1xagPgwbaIdeFnQULmKak3xvwNMkVGgok/N5XNoehJvejRlCDl9escI28dJU0tZ++nBTJE9mEF647x5Ehbo4s5hDOKFIU0PdofeA5F5k1q63zIWmQqNI/P3ZubjFTqKxQ3jyjHAOX0RdlgVO9hzRFpczRcjZ3Gbxxpc7Qj6+5pTYF2OFXawNI+yDGf1k2NcvOlzBQeDQ/t7zD7DsEDpJ2xATXaNtDWUS4IzP4DS2ljajAVu57SUkYw245ptxZxA5JiZaJ0DswudGn3kYUy54426EjoT4dZfYbccxC2nI92cDkZHQr96jD4AGkMDKeSy/COBsRe6VTSKFN6irLeaCh3IteQjt1E5+oudsG/b/2DfZ5AqsYo8vMDK9LB1HzSsLWvlGThdxXvC6+NsqyPPWP0pMINtbdsajfVeC6f/GZ+cdAofQoB1d+Hf9waY98I7+RXWab3Lt4zYkjHtTnlOLXHYMsCh1zWeQYehu1zfNPOOiys/d91LAKEBSgh6MJMbSA82AaHofDgAIwbgvVvlLNS11nModMm4UZergLHZBZrodmBuA3lBB1thdorSjkOmATMDwg/UBQVtglqQyx6fbEJ+H3IWIapjYAjAfeIgeCMHldueJvFaqDaAHhwf8qNsEEQ1iQbOoUUGIbCLRc8+Bvfp4jyd2FEijuO4ziO4ziO4ziO4ziO4ziO4ziO4ziOUzw7O/8D0P7rcZ/GEboAAAAASUVORK5CYII=", n.style.position = "absolute", n.style.left = "50%", n.style.top = "50%", n.style.marginLeft = "-50px", n.style.marginTop = "-50px", this._loadingDiv.appendChild(n), this._resizeLoadingUI(), window.addEventListener("resize", this._resizeLoadingUI), this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor, document.body.appendChild(this._loadingDiv), setTimeout((function() {
					e._loadingDiv.style.opacity = "1", t.style.transform = "rotateZ(360deg)", t.style.webkitTransform = "rotateZ(360deg)"
				}), 0)
			}
		}, e.prototype.hideLoadingUI = function() {
			var e = this;
			if (this._loadingDiv) {
				var t = function() {
					e._loadingDiv && (document.body.removeChild(e._loadingDiv), window.removeEventListener("resize", e._resizeLoadingUI), e._loadingDiv = null)
				};
				this._loadingDiv.style.opacity = "0", this._loadingDiv.addEventListener("transitionend", t)
			}
		}, Object.defineProperty(e.prototype, "loadingUIText", {
			set: function(e) {
				this._loadingText = e, this._loadingTextDiv && (this._loadingTextDiv.innerHTML = this._loadingText)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "loadingUIBackgroundColor", {
			get: function() {
				return this._loadingDivBackgroundColor
			},
			set: function(e) {
				this._loadingDivBackgroundColor = e, this._loadingDiv && (this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor)
			},
			enumerable: !0,
			configurable: !0
		}), e
	})();
	e.DefaultLoadingScreen = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this._audioContext = null, this._audioContextInitialized = !1, this.canUseWebAudio = !1, this.WarnedWebAudioUnsupported = !1, this.unlocked = !1, this.isMP3supported = !1, this.isOGGsupported = !1, "undefined" == typeof window.AudioContext && "undefined" == typeof window.webkitAudioContext || (window.AudioContext = window.AudioContext || window.webkitAudioContext, this.canUseWebAudio = !0);
			var e = document.createElement("audio");
			e && e.canPlayType && e.canPlayType('audio/mpeg; codecs="mp3"').replace(/^no$/, "") && (this.isMP3supported = !0), e && e.canPlayType && e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (this.isOGGsupported = !0), /iPad|iPhone|iPod/.test(navigator.platform) ? this._unlockiOSaudio() : this.unlocked = !0
		}
		return Object.defineProperty(t.prototype, "audioContext", {
			get: function() {
				return this._audioContextInitialized || this._initializeAudioContext(), this._audioContext
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype._unlockiOSaudio = function() {
			var e = this,
				t = function() {
					var i = e.audioContext.createBuffer(1, 1, 22050),
						r = e.audioContext.createBufferSource();
					r.buffer = i, r.connect(e.audioContext.destination), r.start(0), setTimeout((function() {
						r.playbackState !== r.PLAYING_STATE && r.playbackState !== r.FINISHED_STATE || (e.unlocked = !0, window.removeEventListener("touchend", t, !1), e.onAudioUnlocked && e.onAudioUnlocked())
					}), 0)
				};
			window.addEventListener("touchend", t, !1)
		}, t.prototype._initializeAudioContext = function() {
			try {
				this.canUseWebAudio && (this._audioContext = new AudioContext, this.masterGain = this._audioContext.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this._audioContext.destination), this._audioContextInitialized = !0)
			} catch (t) {
				this.canUseWebAudio = !1, e.Tools.Error("Web Audio: " + t.message)
			}
		}, t.prototype.dispose = function() {
			this.canUseWebAudio && this._audioContextInitialized && (this._connectedAnalyser && (this._connectedAnalyser.stopDebugCanvas(), this._connectedAnalyser.dispose(), this.masterGain.disconnect(), this.masterGain.connect(this._audioContext.destination), this._connectedAnalyser = null), this.masterGain.gain.value = 1), this.WarnedWebAudioUnsupported = !1
		}, t.prototype.getGlobalVolume = function() {
			return this.canUseWebAudio && this._audioContextInitialized ? this.masterGain.gain.value : -1
		}, t.prototype.setGlobalVolume = function(e) {
			this.canUseWebAudio && this._audioContextInitialized && (this.masterGain.gain.value = e)
		}, t.prototype.connectToAnalyser = function(e) {
			this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(), this.canUseWebAudio && this._audioContextInitialized && (this._connectedAnalyser = e, this.masterGain.disconnect(), this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination))
		}, t
	})();
	e.AudioEngine = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o) {
			var s = this;
			if (this.autoplay = !1, this.loop = !1, this.useCustomAttenuation = !1, this.spatialSound = !1, this.refDistance = 1, this.rolloffFactor = 1, this.maxDistance = 100, this.distanceModel = "linear", this._panningModel = "equalpower", this._playbackRate = 1, this._streaming = !1, this._startTime = 0, this._startOffset = 0, this._position = e.Vector3.Zero(), this._localDirection = new e.Vector3(1, 0, 0), this._volume = 1, this._isLoaded = !1, this._isReadyToPlay = !1, this.isPlaying = !1, this.isPaused = !1, this._isDirectional = !1, this._coneInnerAngle = 360, this._coneOuterAngle = 360, this._coneOuterGain = 0, this._isOutputConnected = !1, this._urlType = "Unknown", this.name = t, this._scene = r, this._readyToPlayCallback = n, this._customAttenuationFunction = function(e, t, i, r, n) {
					return t < i ? e * (1 - t / i) : 0
				}, o && (this.autoplay = o.autoplay || !1, this.loop = o.loop || !1, void 0 !== o.volume && (this._volume = o.volume), this.spatialSound = o.spatialSound || !1, this.maxDistance = o.maxDistance || 100, this.useCustomAttenuation = o.useCustomAttenuation || !1, this.rolloffFactor = o.rolloffFactor || 1, this.refDistance = o.refDistance || 1, this.distanceModel = o.distanceModel || "linear", this._playbackRate = o.playbackRate || 1, this._streaming = o.streaming || !1), e.Engine.audioEngine.canUseWebAudio) {
				this._soundGain = e.Engine.audioEngine.audioContext.createGain(), this._soundGain.gain.value = this._volume, this._inputAudioNode = this._soundGain, this._ouputAudioNode = this._soundGain, this.spatialSound && this._createSpatialParameters(), this._scene.mainSoundTrack.AddSound(this);
				var a = !0;
				if (i) {
					"string" == typeof i && (this._urlType = "String"), Array.isArray(i) && (this._urlType = "Array"), i instanceof ArrayBuffer && (this._urlType = "ArrayBuffer");
					var h = [],
						c = !1;
					switch (this._urlType) {
						case "ArrayBuffer":
							i.byteLength > 0 && (c = !0, this._soundLoaded(i));
							break;
						case "String":
							h.push(i);
						case "Array":
							0 === h.length && (h = i);
							for (var l = 0; l < h.length; l++) {
								var u = h[l];
								if (u.indexOf(".mp3", u.length - 4) !== -1 && e.Engine.audioEngine.isMP3supported && (c = !0), u.indexOf(".ogg", u.length - 4) !== -1 && e.Engine.audioEngine.isOGGsupported && (c = !0), u.indexOf(".wav", u.length - 4) !== -1 && (c = !0), c) {
									this._streaming ? (this._htmlAudioElement = new Audio(u), this._htmlAudioElement.controls = !1, this._htmlAudioElement.loop = this.loop, this._htmlAudioElement.crossOrigin = "anonymous", this._htmlAudioElement.preload = "auto", this._htmlAudioElement.addEventListener("canplaythrough", (function() {
										s._isReadyToPlay = !0, s.autoplay && s.play(), s._readyToPlayCallback && s._readyToPlayCallback()
									})), document.body.appendChild(this._htmlAudioElement)) : e.Tools.LoadFile(u, (function(e) {
										s._soundLoaded(e)
									}), null, this._scene.database, !0);
									break
								}
							}
							break;
						default:
							a = !1
					}
					a ? c || (this._isReadyToPlay = !0, this._readyToPlayCallback && window.setTimeout((function() {
						s._readyToPlayCallback()
					}), 1e3)) : e.Tools.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.")
				}
			} else this._scene.mainSoundTrack.AddSound(this), e.Engine.audioEngine.WarnedWebAudioUnsupported || (e.Tools.Error("Web Audio is not supported by your browser."), e.Engine.audioEngine.WarnedWebAudioUnsupported = !0), this._readyToPlayCallback && window.setTimeout((function() {
				s._readyToPlayCallback()
			}), 1e3)
		}
		return t.prototype.dispose = function() {
			e.Engine.audioEngine.canUseWebAudio && this._isReadyToPlay && (this.isPlaying && this.stop(), this._isReadyToPlay = !1, this.soundTrackId === -1 ? this._scene.mainSoundTrack.RemoveSound(this) : this._scene.soundTracks[this.soundTrackId].RemoveSound(this), this._soundGain && (this._soundGain.disconnect(), this._soundGain = null), this._soundPanner && (this._soundPanner.disconnect(), this._soundPanner = null), this._soundSource && (this._soundSource.disconnect(), this._soundSource = null), this._audioBuffer = null, this._htmlAudioElement && (this._htmlAudioElement.pause(), this._htmlAudioElement.src = "", document.body.removeChild(this._htmlAudioElement)), this._connectedMesh && (this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._connectedMesh = null))
		}, t.prototype._soundLoaded = function(t) {
			var i = this;
			this._isLoaded = !0, e.Engine.audioEngine.audioContext.decodeAudioData(t, (function(e) {
				i._audioBuffer = e, i._isReadyToPlay = !0, i.autoplay && i.play(), i._readyToPlayCallback && i._readyToPlayCallback()
			}), (function(t) {
				e.Tools.Error("Error while decoding audio data for: " + i.name + " / Error: " + t)
			}))
		}, t.prototype.setAudioBuffer = function(t) {
			e.Engine.audioEngine.canUseWebAudio && (this._audioBuffer = t, this._isReadyToPlay = !0)
		}, t.prototype.updateOptions = function(e) {
			e && (this.loop = e.loop || this.loop, this.maxDistance = e.maxDistance || this.maxDistance, this.useCustomAttenuation = e.useCustomAttenuation || this.useCustomAttenuation, this.rolloffFactor = e.rolloffFactor || this.rolloffFactor, this.refDistance = e.refDistance || this.refDistance, this.distanceModel = e.distanceModel || this.distanceModel, this._playbackRate = e.playbackRate || this._playbackRate, this._updateSpatialParameters(), this.isPlaying && (this._streaming ? this._htmlAudioElement.playbackRate = this._playbackRate : this._soundSource.playbackRate.value = this._playbackRate))
		}, t.prototype._createSpatialParameters = function() {
			e.Engine.audioEngine.canUseWebAudio && (this._scene.headphone && (this._panningModel = "HRTF"), this._soundPanner = e.Engine.audioEngine.audioContext.createPanner(), this._updateSpatialParameters(), this._soundPanner.connect(this._ouputAudioNode), this._inputAudioNode = this._soundPanner)
		}, t.prototype._updateSpatialParameters = function() {
			this.spatialSound && (this.useCustomAttenuation ? (this._soundPanner.distanceModel = "linear", this._soundPanner.maxDistance = Number.MAX_VALUE, this._soundPanner.refDistance = 1, this._soundPanner.rolloffFactor = 1, this._soundPanner.panningModel = this._panningModel) : (this._soundPanner.distanceModel = this.distanceModel, this._soundPanner.maxDistance = this.maxDistance, this._soundPanner.refDistance = this.refDistance, this._soundPanner.rolloffFactor = this.rolloffFactor, this._soundPanner.panningModel = this._panningModel))
		}, t.prototype.switchPanningModelToHRTF = function() {
			this._panningModel = "HRTF", this._switchPanningModel()
		}, t.prototype.switchPanningModelToEqualPower = function() {
			this._panningModel = "equalpower", this._switchPanningModel()
		}, t.prototype._switchPanningModel = function() {
			e.Engine.audioEngine.canUseWebAudio && this.spatialSound && (this._soundPanner.panningModel = this._panningModel)
		}, t.prototype.connectToSoundTrackAudioNode = function(t) {
			e.Engine.audioEngine.canUseWebAudio && (this._isOutputConnected && this._ouputAudioNode.disconnect(), this._ouputAudioNode.connect(t), this._isOutputConnected = !0)
		}, t.prototype.setDirectionalCone = function(t, i, r) {
			return i < t ? void e.Tools.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.") : (this._coneInnerAngle = t, this._coneOuterAngle = i, this._coneOuterGain = r, this._isDirectional = !0, void(this.isPlaying && this.loop && (this.stop(), this.play())))
		}, t.prototype.setPosition = function(t) {
			this._position = t, e.Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z)
		}, t.prototype.setLocalDirectionToMesh = function(t) {
			this._localDirection = t, e.Engine.audioEngine.canUseWebAudio && this._connectedMesh && this.isPlaying && this._updateDirection()
		}, t.prototype._updateDirection = function() {
			var t = this._connectedMesh.getWorldMatrix(),
				i = e.Vector3.TransformNormal(this._localDirection, t);
			i.normalize(), this._soundPanner.setOrientation(i.x, i.y, i.z)
		}, t.prototype.updateDistanceFromListener = function() {
			if (e.Engine.audioEngine.canUseWebAudio && this._connectedMesh && this.useCustomAttenuation) {
				var t = this._connectedMesh.getDistanceToCamera(this._scene.activeCamera);
				this._soundGain.gain.value = this._customAttenuationFunction(this._volume, t, this.maxDistance, this.refDistance, this.rolloffFactor)
			}
		}, t.prototype.setAttenuationFunction = function(e) {
			this._customAttenuationFunction = e
		}, t.prototype.play = function(t, i) {
			var r = this;
			if (this._isReadyToPlay && this._scene.audioEnabled) try {
				this._startOffset < 0 && (t = -this._startOffset, this._startOffset = 0);
				var n = t ? e.Engine.audioEngine.audioContext.currentTime + t : e.Engine.audioEngine.audioContext.currentTime;
				this._soundSource && this._streamingSource || this.spatialSound && (this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z), this._isDirectional && (this._soundPanner.coneInnerAngle = this._coneInnerAngle, this._soundPanner.coneOuterAngle = this._coneOuterAngle, this._soundPanner.coneOuterGain = this._coneOuterGain, this._connectedMesh ? this._updateDirection() : this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z))), this._streaming ? (this._streamingSource || (this._streamingSource = e.Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement), this._htmlAudioElement.onended = function() {
					r._onended()
				}, this._htmlAudioElement.playbackRate = this._playbackRate), this._streamingSource.disconnect(), this._streamingSource.connect(this._inputAudioNode), this._htmlAudioElement.play()) : (this._soundSource = e.Engine.audioEngine.audioContext.createBufferSource(), this._soundSource.buffer = this._audioBuffer, this._soundSource.connect(this._inputAudioNode), this._soundSource.loop = this.loop, this._soundSource.playbackRate.value = this._playbackRate, this._soundSource.onended = function() {
					r._onended()
				}, this._soundSource.start(n, this.isPaused ? this._startOffset % this._soundSource.buffer.duration : i ? i : 0)), this._startTime = n, this.isPlaying = !0, this.isPaused = !1
			} catch (o) {
				e.Tools.Error("Error while trying to play audio: " + this.name + ", " + o.message)
			}
		}, t.prototype._onended = function() {
			this.isPlaying = !1, this.onended && this.onended()
		}, t.prototype.stop = function(t) {
			if (this.isPlaying) {
				if (this._streaming) this._htmlAudioElement.pause(), this._htmlAudioElement.currentTime > 0 && (this._htmlAudioElement.currentTime = 0);
				else {
					var i = t ? e.Engine.audioEngine.audioContext.currentTime + t : e.Engine.audioEngine.audioContext.currentTime;
					this._soundSource.stop(i), this._soundSource.onended = null, this.isPaused || (this._startOffset = 0)
				}
				this.isPlaying = !1
			}
		}, t.prototype.pause = function() {
			this.isPlaying && (this.isPaused = !0, this._streaming ? this._htmlAudioElement.pause() : (this.stop(0), this._startOffset += e.Engine.audioEngine.audioContext.currentTime - this._startTime))
		}, t.prototype.setVolume = function(t, i) {
			e.Engine.audioEngine.canUseWebAudio && (i ? (this._soundGain.gain.cancelScheduledValues(e.Engine.audioEngine.audioContext.currentTime), this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, e.Engine.audioEngine.audioContext.currentTime), this._soundGain.gain.linearRampToValueAtTime(t, e.Engine.audioEngine.audioContext.currentTime + i)) : this._soundGain.gain.value = t), this._volume = t
		}, t.prototype.setPlaybackRate = function(e) {
			this._playbackRate = e, this.isPlaying && (this._streaming ? this._htmlAudioElement.playbackRate = this._playbackRate : this._soundSource.playbackRate.value = this._playbackRate)
		}, t.prototype.getVolume = function() {
			return this._volume
		}, t.prototype.attachToMesh = function(e) {
			var t = this;
			this._connectedMesh && (this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._registerFunc = null), this._connectedMesh = e, this.spatialSound || (this.spatialSound = !0, this._createSpatialParameters(), this.isPlaying && this.loop && (this.stop(), this.play())), this._onRegisterAfterWorldMatrixUpdate(this._connectedMesh), this._registerFunc = function(e) {
				return t._onRegisterAfterWorldMatrixUpdate(e)
			}, e.registerAfterWorldMatrixUpdate(this._registerFunc)
		}, t.prototype.detachFromMesh = function() {
			this._connectedMesh && (this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._registerFunc = null, this._connectedMesh = null)
		}, t.prototype._onRegisterAfterWorldMatrixUpdate = function(t) {
			this.setPosition(t.getBoundingInfo().boundingSphere.centerWorld), e.Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying && this._updateDirection()
		}, t.prototype.clone = function() {
			var e = this;
			if (this._streaming) return null;
			var i = function() {
					e._isReadyToPlay ? (n._audioBuffer = e.getAudioBuffer(), n._isReadyToPlay = !0, n.autoplay && n.play()) : window.setTimeout(i, 300)
				},
				r = {
					autoplay: this.autoplay,
					loop: this.loop,
					volume: this._volume,
					spatialSound: this.spatialSound,
					maxDistance: this.maxDistance,
					useCustomAttenuation: this.useCustomAttenuation,
					rolloffFactor: this.rolloffFactor,
					refDistance: this.refDistance,
					distanceModel: this.distanceModel
				},
				n = new t(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, r);
			return this.useCustomAttenuation && n.setAttenuationFunction(this._customAttenuationFunction), n.setPosition(this._position), n.setPlaybackRate(this._playbackRate), i(), n
		}, t.prototype.getAudioBuffer = function() {
			return this._audioBuffer
		}, t.prototype.serialize = function() {
			var e = {
				name: this.name,
				url: this.name,
				autoplay: this.autoplay,
				loop: this.loop,
				volume: this._volume,
				spatialSound: this.spatialSound,
				maxDistance: this.maxDistance,
				rolloffFactor: this.rolloffFactor,
				refDistance: this.refDistance,
				distanceModel: this.distanceModel,
				playbackRate: this._playbackRate,
				panningModel: this._panningModel,
				soundTrackId: this.soundTrackId
			};
			return this.spatialSound && (this._connectedMesh && (e.connectedMeshId = this._connectedMesh.id), e.position = this._position.asArray(), e.refDistance = this.refDistance, e.distanceModel = this.distanceModel, e.isDirectional = this._isDirectional, e.localDirectionToMesh = this._localDirection.asArray(), e.coneInnerAngle = this._coneInnerAngle, e.coneOuterAngle = this._coneOuterAngle, e.coneOuterGain = this._coneOuterGain), e
		}, t.Parse = function(i, r, n, o) {
			var s, a = i.name;
			s = i.url ? n + i.url : n + a;
			var h, c = {
				autoplay: i.autoplay,
				loop: i.loop,
				volume: i.volume,
				spatialSound: i.spatialSound,
				maxDistance: i.maxDistance,
				rolloffFactor: i.rolloffFactor,
				refDistance: i.refDistance,
				distanceModel: i.distanceModel,
				playbackRate: i.playbackRate
			};
			if (o) {
				var l = function() {
					o._isReadyToPlay ? (h._audioBuffer = o.getAudioBuffer(), h._isReadyToPlay = !0, h.autoplay && h.play()) : window.setTimeout(l, 300)
				};
				h = new t(a, new ArrayBuffer(0), r, null, c), l()
			} else h = new t(a, s, r, function() {
				r._removePendingData(h)
			}, c), r._addPendingData(h);
			if (i.position) {
				var u = e.Vector3.FromArray(i.position);
				h.setPosition(u)
			}
			if (i.isDirectional && (h.setDirectionalCone(i.coneInnerAngle || 360, i.coneOuterAngle || 360, i.coneOuterGain || 0), i.localDirectionToMesh)) {
				var d = e.Vector3.FromArray(i.localDirectionToMesh);
				h.setLocalDirectionToMesh(d)
			}
			if (i.connectedMeshId) {
				var f = r.getMeshByID(i.connectedMeshId);
				f && h.attachToMesh(f)
			}
			return h
		}, t
	})();
	e.Sound = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t) {
			this.id = -1, this._isMainTrack = !1, this._isInitialized = !1, this._scene = e, this.soundCollection = new Array, this._options = t, this._isMainTrack || (this._scene.soundTracks.push(this), this.id = this._scene.soundTracks.length - 1)
		}
		return t.prototype._initializeSoundTrackAudioGraph = function() {
			e.Engine.audioEngine.canUseWebAudio && (this._outputAudioNode = e.Engine.audioEngine.audioContext.createGain(), this._outputAudioNode.connect(e.Engine.audioEngine.masterGain), this._options && (this._options.volume && (this._outputAudioNode.gain.value = this._options.volume), this._options.mainTrack && (this._isMainTrack = this._options.mainTrack)), this._isInitialized = !0)
		}, t.prototype.dispose = function() {
			if (e.Engine.audioEngine.canUseWebAudio) {
				for (this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(); this.soundCollection.length;) this.soundCollection[0].dispose();
				this._outputAudioNode && this._outputAudioNode.disconnect(), this._outputAudioNode = null
			}
		}, t.prototype.AddSound = function(t) {
			this._isInitialized || this._initializeSoundTrackAudioGraph(), e.Engine.audioEngine.canUseWebAudio && t.connectToSoundTrackAudioNode(this._outputAudioNode), t.soundTrackId && (t.soundTrackId === -1 ? this._scene.mainSoundTrack.RemoveSound(t) : this._scene.soundTracks[t.soundTrackId].RemoveSound(t)), this.soundCollection.push(t),
				t.soundTrackId = this.id
		}, t.prototype.RemoveSound = function(e) {
			var t = this.soundCollection.indexOf(e);
			t !== -1 && this.soundCollection.splice(t, 1)
		}, t.prototype.setVolume = function(t) {
			e.Engine.audioEngine.canUseWebAudio && (this._outputAudioNode.gain.value = t)
		}, t.prototype.switchPanningModelToHRTF = function() {
			if (e.Engine.audioEngine.canUseWebAudio)
				for (var t = 0; t < this.soundCollection.length; t++) this.soundCollection[t].switchPanningModelToHRTF()
		}, t.prototype.switchPanningModelToEqualPower = function() {
			if (e.Engine.audioEngine.canUseWebAudio)
				for (var t = 0; t < this.soundCollection.length; t++) this.soundCollection[t].switchPanningModelToEqualPower()
		}, t.prototype.connectToAnalyser = function(t) {
			this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(), this._connectedAnalyser = t, e.Engine.audioEngine.canUseWebAudio && (this._outputAudioNode.disconnect(), this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, e.Engine.audioEngine.masterGain))
		}, t
	})();
	e.SoundTrack = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
			function i(i, r, n, o, s, a, h, c) {
				var l = this;
				void 0 === a && (a = e.Texture.BILINEAR_SAMPLINGMODE), t.call(this, i, "glowBlurPostProcess", ["screenSize", "direction", "blurWidth"], null, o, s, a, h, c), this.direction = r, this.blurWidth = n, this.onApplyObservable.add((function(e) {
					e.setFloat2("screenSize", l.width, l.height), e.setVector2("direction", l.direction), e.setFloat("blurWidth", l.blurWidth)
				}))
			}
			return __extends(i, t), i
		})(e.PostProcess),
		i = (function() {
			function i(t, r, n) {
				this._vertexBuffers = {}, this._mainTextureDesiredSize = {
					width: 0,
					height: 0
				}, this._meshes = {}, this._maxSize = 0, this._shouldRender = !1, this._instanceGlowingMeshStencilReference = i.glowingMeshStencilReference++, this._excludedMeshes = {}, this.innerGlow = !0, this.outerGlow = !0, this.isEnabled = !0, this.onDisposeObservable = new e.Observable, this.onBeforeRenderMainTextureObservable = new e.Observable, this.onBeforeBlurObservable = new e.Observable, this.onAfterBlurObservable = new e.Observable, this.onBeforeComposeObservable = new e.Observable, this.onAfterComposeObservable = new e.Observable, this.onSizeChangedObservable = new e.Observable, this._scene = r;
				var o = r.getEngine();
				this._engine = o, this._maxSize = this._engine.getCaps().maxTextureSize, this._scene.highlightLayers.push(this), this._engine.isStencilEnable || e.Tools.Warn("Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new BABYLON.Engine(canvas, antialias, { stencil: true }"), this._options = n || {
					mainTextureRatio: .25,
					blurTextureSizeRatio: .5,
					blurHorizontalSize: 1,
					blurVerticalSize: 1,
					alphaBlendingMode: e.Engine.ALPHA_COMBINE
				}, this._options.mainTextureRatio = this._options.mainTextureRatio || .25, this._options.blurTextureSizeRatio = this._options.blurTextureSizeRatio || .5, this._options.blurHorizontalSize = this._options.blurHorizontalSize || 1, this._options.blurVerticalSize = this._options.blurVerticalSize || 1, this._options.alphaBlendingMode = this._options.alphaBlendingMode || e.Engine.ALPHA_COMBINE;
				var s = [];
				s.push(1, 1), s.push(-1, 1), s.push(-1, -1), s.push(1, -1);
				var a = new e.VertexBuffer(o, s, e.VertexBuffer.PositionKind, (!1), (!1), 2);
				this._vertexBuffers[e.VertexBuffer.PositionKind] = a;
				var h = [];
				h.push(0), h.push(1), h.push(2), h.push(0), h.push(2), h.push(3), this._indexBuffer = o.createIndexBuffer(h), this._glowMapMergeEffect = o.createEffect("glowMapMerge", [e.VertexBuffer.PositionKind], ["offset"], ["textureSampler"], ""), this.setMainTextureSize(), this.createTextureAndPostProcesses()
			}
			return Object.defineProperty(i.prototype, "blurHorizontalSize", {
				get: function() {
					return this._horizontalBlurPostprocess.blurWidth
				},
				set: function(e) {
					this._horizontalBlurPostprocess.blurWidth = e
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(i.prototype, "blurVerticalSize", {
				get: function() {
					return this._verticalBlurPostprocess.blurWidth
				},
				set: function(e) {
					this._verticalBlurPostprocess.blurWidth = e
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(i.prototype, "camera", {
				get: function() {
					return this._options.camera
				},
				enumerable: !0,
				configurable: !0
			}), i.prototype.createTextureAndPostProcesses = function() {
				var r = this,
					n = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio,
					o = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;
				n = e.Tools.GetExponentOfTwo(n, this._maxSize), o = e.Tools.GetExponentOfTwo(o, this._maxSize), this._mainTexture = new e.RenderTargetTexture("HighlightLayerMainRTT", {
					width: this._mainTextureDesiredSize.width,
					height: this._mainTextureDesiredSize.height
				}, this._scene, (!1), (!0), e.Engine.TEXTURETYPE_UNSIGNED_INT), this._mainTexture.activeCamera = this._options.camera, this._mainTexture.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._mainTexture.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._mainTexture.anisotropicFilteringLevel = 1, this._mainTexture.updateSamplingMode(e.Texture.BILINEAR_SAMPLINGMODE), this._mainTexture.renderParticles = !1, this._mainTexture.renderList = null, this._blurTexture = new e.RenderTargetTexture("HighlightLayerBlurRTT", {
					width: n,
					height: o
				}, this._scene, (!1), (!0), e.Engine.TEXTURETYPE_UNSIGNED_INT), this._blurTexture.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._blurTexture.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._blurTexture.anisotropicFilteringLevel = 16, this._blurTexture.updateSamplingMode(e.Texture.TRILINEAR_SAMPLINGMODE), this._blurTexture.renderParticles = !1, this._downSamplePostprocess = new e.PassPostProcess("HighlightLayerPPP", this._options.blurTextureSizeRatio, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._downSamplePostprocess.onApplyObservable.add((function(e) {
					e.setTexture("textureSampler", r._mainTexture)
				})), this._options.alphaBlendingMode === e.Engine.ALPHA_COMBINE ? (this._horizontalBlurPostprocess = new t("HighlightLayerHBP", new e.Vector2(1, 0), this._options.blurHorizontalSize, 1, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._horizontalBlurPostprocess.onApplyObservable.add((function(e) {
					e.setFloat2("screenSize", n, o)
				})), this._verticalBlurPostprocess = new t("HighlightLayerVBP", new e.Vector2(0, 1), this._options.blurVerticalSize, 1, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._verticalBlurPostprocess.onApplyObservable.add((function(e) {
					e.setFloat2("screenSize", n, o)
				}))) : (this._horizontalBlurPostprocess = new e.BlurPostProcess("HighlightLayerHBP", new e.Vector2(1, 0), this._options.blurHorizontalSize, 1, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._horizontalBlurPostprocess.onApplyObservable.add((function(e) {
					e.setFloat2("screenSize", n, o)
				})), this._verticalBlurPostprocess = new e.BlurPostProcess("HighlightLayerVBP", new e.Vector2(0, 1), this._options.blurVerticalSize, 1, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._verticalBlurPostprocess.onApplyObservable.add((function(e) {
					e.setFloat2("screenSize", n, o)
				}))), this._mainTexture.onAfterUnbindObservable.add((function() {
					r.onBeforeBlurObservable.notifyObservers(r), r._scene.postProcessManager.directRender([r._downSamplePostprocess, r._horizontalBlurPostprocess, r._verticalBlurPostprocess], r._blurTexture.getInternalTexture()), r.onAfterBlurObservable.notifyObservers(r)
				}));
				var s = function(t) {
					var n = t.getRenderingMesh(),
						o = r._scene,
						s = o.getEngine();
					s.setState(t.getMaterial().backFaceCulling);
					var a = n._getInstancesRenderList(t._id);
					if (!a.mustReturn && !r._excludedMeshes[n.id]) {
						var h = null !== s.getCaps().instancedArrays && null !== a.visibleInstances[t._id] && void 0 !== a.visibleInstances[t._id],
							c = r._meshes[n.id],
							l = t.getMaterial(),
							u = null;
						if (c && c.glowEmissiveOnly && l && (u = l.emissiveTexture), r.isReady(t, h, u)) {
							if (s.enableEffect(r._glowMapGenerationEffect), n._bind(t, r._glowMapGenerationEffect, e.Material.TriangleFillMode), r._glowMapGenerationEffect.setMatrix("viewProjection", o.getTransformMatrix()), c ? r._glowMapGenerationEffect.setFloat4("color", c.color.r, c.color.g, c.color.b, 1) : r._glowMapGenerationEffect.setFloat4("color", i.neutralColor.r, i.neutralColor.g, i.neutralColor.b, i.neutralColor.a), l && l.needAlphaTesting()) {
								var d = l.getAlphaTestTexture();
								r._glowMapGenerationEffect.setTexture("diffuseSampler", d), r._glowMapGenerationEffect.setMatrix("diffuseMatrix", d.getTextureMatrix())
							}
							u && (r._glowMapGenerationEffect.setTexture("emissiveSampler", u), r._glowMapGenerationEffect.setMatrix("emissiveMatrix", u.getTextureMatrix())), n.useBones && n.computeBonesUsingShaders && r._glowMapGenerationEffect.setMatrices("mBones", n.skeleton.getTransformMatrices(n)), n._processRendering(t, r._glowMapGenerationEffect, e.Material.TriangleFillMode, a, h, (function(e, t) {
								return r._glowMapGenerationEffect.setMatrix("world", t)
							}))
						} else r._mainTexture.resetRefreshCounter()
					}
				};
				this._mainTexture.customRenderFunction = function(e, t, i) {
					r.onBeforeRenderMainTextureObservable.notifyObservers(r);
					var n;
					for (n = 0; n < e.length; n++) s(e.data[n]);
					for (n = 0; n < t.length; n++) s(t.data[n]);
					for (n = 0; n < i.length; n++) s(i.data[n])
				}, this._mainTexture.onClearObservable.add((function(e) {
					e.clear(i.neutralColor, !0, !0, !0)
				}))
			}, i.prototype.isReady = function(t, i, r) {
				if (!t.getMaterial().isReady(t.getMesh(), i)) return !1;
				var n = [],
					o = [e.VertexBuffer.PositionKind],
					s = t.getMesh(),
					a = t.getMaterial(),
					h = !1,
					c = !1;
				if (a && a.needAlphaTesting()) {
					var l = a.getAlphaTestTexture();
					l && (n.push("#define ALPHATEST"), s.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && 1 === l.coordinatesIndex ? (n.push("#define DIFFUSEUV2"), c = !0) : s.isVerticesDataPresent(e.VertexBuffer.UVKind) && (n.push("#define DIFFUSEUV1"), h = !0))
				}
				r && (n.push("#define EMISSIVE"), s.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && 1 === r.coordinatesIndex ? (n.push("#define EMISSIVEUV2"), c = !0) : s.isVerticesDataPresent(e.VertexBuffer.UVKind) && (n.push("#define EMISSIVEUV1"), h = !0)), h && (o.push(e.VertexBuffer.UVKind), n.push("#define UV1")), c && (o.push(e.VertexBuffer.UV2Kind), n.push("#define UV2")), s.useBones && s.computeBonesUsingShaders ? (o.push(e.VertexBuffer.MatricesIndicesKind), o.push(e.VertexBuffer.MatricesWeightsKind), s.numBoneInfluencers > 4 && (o.push(e.VertexBuffer.MatricesIndicesExtraKind), o.push(e.VertexBuffer.MatricesWeightsExtraKind)), n.push("#define NUM_BONE_INFLUENCERS " + s.numBoneInfluencers), n.push("#define BonesPerMesh " + (s.skeleton.bones.length + 1))) : n.push("#define NUM_BONE_INFLUENCERS 0"), i && (n.push("#define INSTANCES"), o.push("world0"), o.push("world1"), o.push("world2"), o.push("world3"));
				var u = n.join("\n");
				return this._cachedDefines !== u && (this._cachedDefines = u, this._glowMapGenerationEffect = this._scene.getEngine().createEffect("glowMapGeneration", o, ["world", "mBones", "viewProjection", "diffuseMatrix", "color", "emissiveMatrix"], ["diffuseSampler", "emissiveSampler"], u)), this._glowMapGenerationEffect.isReady()
			}, i.prototype.render = function() {
				var t = this._glowMapMergeEffect;
				if (t.isReady() && this._blurTexture.isReady()) {
					var i = this._scene.getEngine();
					this.onBeforeComposeObservable.notifyObservers(this), i.enableEffect(t), i.setState(!1);
					var r = i.getStencilBuffer(),
						n = i.getStencilFunction(),
						o = i.getStencilMask(),
						s = i.getAlphaMode();
					t.setTexture("textureSampler", this._blurTexture), i.bindBuffers(this._vertexBuffers, this._indexBuffer, t), i.setAlphaMode(this._options.alphaBlendingMode), i.setStencilMask(0), i.setStencilBuffer(!0), i.setStencilFunctionReference(this._instanceGlowingMeshStencilReference), this.outerGlow && (t.setFloat("offset", 0), i.setStencilFunction(e.Engine.NOTEQUAL), i.draw(!0, 0, 6)), this.innerGlow && (t.setFloat("offset", 1), i.setStencilFunction(e.Engine.EQUAL), i.draw(!0, 0, 6)), i.setStencilFunction(n), i.setStencilMask(o), i.setAlphaMode(s), i.setStencilBuffer(r), this.onAfterComposeObservable.notifyObservers(this);
					var a = this._mainTexture.getSize();
					this.setMainTextureSize(), a.width === this._mainTextureDesiredSize.width && a.height === this._mainTextureDesiredSize.height || (this.onSizeChangedObservable.notifyObservers(this), this.disposeTextureAndPostProcesses(), this.createTextureAndPostProcesses())
				}
			}, i.prototype.addExcludedMesh = function(e) {
				var t = this._excludedMeshes[e.id];
				t || (this._excludedMeshes[e.id] = {
					mesh: e,
					beforeRender: e.onBeforeRenderObservable.add((function(e) {
						e.getEngine().setStencilBuffer(!1)
					})),
					afterRender: e.onAfterRenderObservable.add((function(e) {
						e.getEngine().setStencilBuffer(!0)
					}))
				})
			}, i.prototype.removeExcludedMesh = function(e) {
				var t = this._excludedMeshes[e.id];
				t && (e.onBeforeRenderObservable.remove(t.beforeRender), e.onAfterRenderObservable.remove(t.afterRender)), this._excludedMeshes[e.id] = void 0
			}, i.prototype.addMesh = function(e, t, i) {
				var r = this;
				void 0 === i && (i = !1);
				var n = this._meshes[e.id];
				n ? n.color = t : this._meshes[e.id] = {
					mesh: e,
					color: t,
					observerHighlight: e.onBeforeRenderObservable.add((function(e) {
						r._excludedMeshes[e.id] ? r.defaultStencilReference(e) : e.getScene().getEngine().setStencilFunctionReference(r._instanceGlowingMeshStencilReference)
					})),
					observerDefault: e.onAfterRenderObservable.add(this.defaultStencilReference),
					glowEmissiveOnly: i
				}, this._shouldRender = !0
			}, i.prototype.removeMesh = function(e) {
				var t = this._meshes[e.id];
				t && (e.onBeforeRenderObservable.remove(t.observerHighlight), e.onAfterRenderObservable.remove(t.observerDefault)), this._meshes[e.id] = void 0, this._shouldRender = !1;
				for (var i in this._meshes)
					if (i) {
						this._shouldRender = !0;
						break
					}
			}, i.prototype.shouldRender = function() {
				return this.isEnabled && this._shouldRender
			}, i.prototype.setMainTextureSize = function() {
				this._options.mainTextureFixedSize ? (this._mainTextureDesiredSize.width = this._options.mainTextureFixedSize, this._mainTextureDesiredSize.height = this._options.mainTextureFixedSize) : (this._mainTextureDesiredSize.width = this._engine.getRenderingCanvas().width * this._options.mainTextureRatio, this._mainTextureDesiredSize.height = this._engine.getRenderingCanvas().height * this._options.mainTextureRatio, this._mainTextureDesiredSize.width = e.Tools.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize), this._mainTextureDesiredSize.height = e.Tools.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize))
			}, i.prototype.defaultStencilReference = function(e) {
				e.getScene().getEngine().setStencilFunctionReference(i.normalMeshStencilReference)
			}, i.prototype.disposeTextureAndPostProcesses = function() {
				this._blurTexture.dispose(), this._mainTexture.dispose(), this._downSamplePostprocess.dispose(), this._horizontalBlurPostprocess.dispose(), this._verticalBlurPostprocess.dispose()
			}, i.prototype.dispose = function() {
				var t = this._vertexBuffers[e.VertexBuffer.PositionKind];
				t && (t.dispose(), this._vertexBuffers[e.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this.disposeTextureAndPostProcesses();
				for (var i in this._meshes) {
					var r = this._meshes[i];
					r && r.mesh && (r.mesh.onBeforeRenderObservable.remove(r.observerHighlight), r.mesh.onAfterRenderObservable.remove(r.observerDefault))
				}
				this._meshes = null;
				for (var i in this._excludedMeshes) {
					var r = this._excludedMeshes[i];
					r && (r.mesh.onBeforeRenderObservable.remove(r.beforeRender), r.mesh.onAfterRenderObservable.remove(r.afterRender))
				}
				this._excludedMeshes = null;
				var n = this._scene.highlightLayers.indexOf(this, 0);
				n > -1 && this._scene.highlightLayers.splice(n, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBeforeRenderMainTextureObservable.clear(), this.onBeforeBlurObservable.clear(), this.onBeforeComposeObservable.clear(), this.onAfterComposeObservable.clear(), this.onSizeChangedObservable.clear()
			}, i.neutralColor = new e.Color4(0, 0, 0, 0), i.glowingMeshStencilReference = 2, i.normalMeshStencilReference = 1, i
		})();
	e.HighlightLayer = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
			function e() {}
			return e.TransformCoordinatesToRefSIMD = function(t, i, r) {
				e.TransformCoordinatesFromFloatsToRefSIMD(t.x, t.y, t.z, i, r)
			}, e.TransformCoordinatesFromFloatsToRefSIMD = function(e, t, i, r, n) {
				var o = r.m,
					s = SIMD.Float32x4.load(o, 0),
					a = SIMD.Float32x4.load(o, 4),
					h = SIMD.Float32x4.load(o, 8),
					c = SIMD.Float32x4.load(o, 12),
					l = SIMD.Float32x4.add(SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(e), s), SIMD.Float32x4.mul(SIMD.Float32x4.splat(t), a)), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(i), h), c));
				l = SIMD.Float32x4.div(l, SIMD.Float32x4.swizzle(l, 3, 3, 3, 3)), n.x = SIMD.Float32x4.extractLane(l, 0), n.y = SIMD.Float32x4.extractLane(l, 1), n.z = SIMD.Float32x4.extractLane(l, 2)
			}, e
		})(),
		i = (function() {
			function e() {}
			return e.prototype.multiplyToArraySIMD = function(e, t, i) {
				for (var r = this.m, n = e.m, o = SIMD.Float32x4.load(n, 0), s = SIMD.Float32x4.load(n, 4), a = SIMD.Float32x4.load(n, 8), h = SIMD.Float32x4.load(n, 12), c = 0; c < 16; c += 4) SIMD.Float32x4.store(t, c + i, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(r[c]), o), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(r[c + 1]), s), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(r[c + 2]), a), SIMD.Float32x4.mul(SIMD.Float32x4.splat(r[c + 3]), h)))));
				return this
			}, e.prototype.invertToRefSIMD = function(e) {
				var t = this.m,
					i = e.m,
					r = SIMD.Float32x4.load(t, 0),
					n = SIMD.Float32x4.load(t, 4),
					o = SIMD.Float32x4.load(t, 8),
					s = SIMD.Float32x4.load(t, 12),
					a = SIMD.Float32x4.shuffle(r, n, 0, 1, 4, 5),
					h = SIMD.Float32x4.shuffle(o, s, 0, 1, 4, 5),
					c = SIMD.Float32x4.shuffle(a, h, 0, 2, 4, 6);
				h = SIMD.Float32x4.shuffle(h, a, 1, 3, 5, 7), a = SIMD.Float32x4.shuffle(r, n, 2, 3, 6, 7);
				var l = SIMD.Float32x4.shuffle(o, s, 2, 3, 6, 7),
					u = SIMD.Float32x4.shuffle(a, l, 0, 2, 4, 6);
				l = SIMD.Float32x4.shuffle(l, a, 1, 3, 5, 7), a = SIMD.Float32x4.mul(u, l), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2);
				var d = SIMD.Float32x4.mul(h, a),
					f = SIMD.Float32x4.mul(c, a);
				a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), d = SIMD.Float32x4.sub(SIMD.Float32x4.mul(h, a), d), f = SIMD.Float32x4.sub(SIMD.Float32x4.mul(c, a), f), f = SIMD.Float32x4.swizzle(f, 2, 3, 0, 1), a = SIMD.Float32x4.mul(h, u), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), d = SIMD.Float32x4.add(SIMD.Float32x4.mul(l, a), d);
				var p = SIMD.Float32x4.mul(c, a);
				a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), d = SIMD.Float32x4.sub(d, SIMD.Float32x4.mul(l, a)), p = SIMD.Float32x4.sub(SIMD.Float32x4.mul(c, a), p), p = SIMD.Float32x4.swizzle(p, 2, 3, 0, 1), a = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(h, 2, 3, 0, 1), l), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), d = SIMD.Float32x4.add(SIMD.Float32x4.mul(u, a), d);
				var m = SIMD.Float32x4.mul(c, a);
				a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), d = SIMD.Float32x4.sub(d, SIMD.Float32x4.mul(u, a)), m = SIMD.Float32x4.sub(SIMD.Float32x4.mul(c, a), m), m = SIMD.Float32x4.swizzle(m, 2, 3, 0, 1), a = SIMD.Float32x4.mul(c, h), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), m = SIMD.Float32x4.add(SIMD.Float32x4.mul(l, a), m), p = SIMD.Float32x4.sub(SIMD.Float32x4.mul(u, a), p), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), m = SIMD.Float32x4.sub(SIMD.Float32x4.mul(l, a), m), p = SIMD.Float32x4.sub(p, SIMD.Float32x4.mul(u, a)), a = SIMD.Float32x4.mul(c, l), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), f = SIMD.Float32x4.sub(f, SIMD.Float32x4.mul(u, a)), m = SIMD.Float32x4.add(SIMD.Float32x4.mul(h, a), m), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), f = SIMD.Float32x4.add(SIMD.Float32x4.mul(u, a), f), m = SIMD.Float32x4.sub(m, SIMD.Float32x4.mul(h, a)), a = SIMD.Float32x4.mul(c, u), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), f = SIMD.Float32x4.add(SIMD.Float32x4.mul(l, a), f), p = SIMD.Float32x4.sub(p, SIMD.Float32x4.mul(h, a)), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), f = SIMD.Float32x4.sub(f, SIMD.Float32x4.mul(l, a)), p = SIMD.Float32x4.add(SIMD.Float32x4.mul(h, a), p);
				var _ = SIMD.Float32x4.mul(c, d);
				return _ = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(_, 2, 3, 0, 1), _), _ = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(_, 1, 0, 3, 2), _), a = SIMD.Float32x4.reciprocalApproximation(_), _ = SIMD.Float32x4.sub(SIMD.Float32x4.add(a, a), SIMD.Float32x4.mul(_, SIMD.Float32x4.mul(a, a))), _ = SIMD.Float32x4.swizzle(_, 0, 0, 0, 0), SIMD.Float32x4.store(i, 0, SIMD.Float32x4.mul(_, d)), SIMD.Float32x4.store(i, 4, SIMD.Float32x4.mul(_, f)), SIMD.Float32x4.store(i, 8, m = SIMD.Float32x4.mul(_, m)), SIMD.Float32x4.store(i, 12, SIMD.Float32x4.mul(_, p)), this
			}, e.LookAtLHToRefSIMD = function(e, t, i, r) {
				var n = r.m,
					o = SIMD.Float32x4(t.x, t.y, t.z, 0),
					s = SIMD.Float32x4(e.x, e.y, e.z, 0),
					a = SIMD.Float32x4(i.x, i.y, i.z, 0),
					h = SIMD.Float32x4.sub(o, s),
					c = SIMD.Float32x4.mul(h, h);
				c = SIMD.Float32x4.add(c, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c, 1, 2, 0, 3), SIMD.Float32x4.swizzle(c, 2, 0, 1, 3))), h = SIMD.Float32x4.mul(h, SIMD.Float32x4.reciprocalSqrtApproximation(c)), c = SIMD.Float32x4.mul(a, a), c = SIMD.Float32x4.add(c, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c, 1, 2, 0, 3), SIMD.Float32x4.swizzle(c, 2, 0, 1, 3))), a = SIMD.Float32x4.mul(a, SIMD.Float32x4.reciprocalSqrtApproximation(c));
				var l = SIMD.Float32x4.sub(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(h, 1, 2, 0, 3), SIMD.Float32x4.swizzle(a, 2, 0, 1, 3)), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(h, 2, 0, 1, 3), SIMD.Float32x4.swizzle(a, 1, 2, 0, 3)));
				c = SIMD.Float32x4.mul(l, l), c = SIMD.Float32x4.add(c, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c, 1, 2, 0, 3), SIMD.Float32x4.swizzle(c, 2, 0, 1, 3))), l = SIMD.Float32x4.mul(l, SIMD.Float32x4.reciprocalSqrtApproximation(c));
				var u = SIMD.Float32x4.sub(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(l, 1, 2, 0, 3), SIMD.Float32x4.swizzle(h, 2, 0, 1, 3)), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(l, 2, 0, 1, 3), SIMD.Float32x4.swizzle(h, 1, 2, 0, 3)));
				c = SIMD.Float32x4.mul(l, l), c = SIMD.Float32x4.add(c, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c, 1, 2, 0, 3), SIMD.Float32x4.swizzle(c, 2, 0, 1, 3))), l = SIMD.Float32x4.mul(l, SIMD.Float32x4.reciprocalSqrtApproximation(c));
				var d = SIMD.Float32x4.splat(0);
				l = SIMD.Float32x4.neg(l);
				var f = SIMD.Float32x4.shuffle(l, u, 0, 1, 4, 5),
					p = SIMD.Float32x4.shuffle(h, d, 0, 1, 4, 5),
					m = SIMD.Float32x4.shuffle(f, p, 0, 2, 4, 6),
					_ = SIMD.Float32x4.shuffle(f, p, 1, 3, 5, 7),
					g = SIMD.Float32x4.shuffle(SIMD.Float32x4.shuffle(l, u, 2, 3, 6, 7), SIMD.Float32x4.shuffle(h, d, 2, 3, 6, 7), 0, 2, 4, 6),
					v = SIMD.Float32x4(0, 0, 0, 1),
					y = SIMD.Float32x4(1, 0, 0, 0);
				SIMD.Float32x4.store(n, 0, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 0, 0, 0, 0), m), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 1, 1, 1, 1), _), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 2, 2, 2, 2), g), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 3, 3, 3, 3), v))))), y = SIMD.Float32x4(0, 1, 0, 0), SIMD.Float32x4.store(n, 4, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 0, 0, 0, 0), m), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 1, 1, 1, 1), _), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 2, 2, 2, 2), g), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 3, 3, 3, 3), v))))), y = SIMD.Float32x4(0, 0, 1, 0), SIMD.Float32x4.store(n, 8, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 0, 0, 0, 0), m), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 1, 1, 1, 1), _), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 2, 2, 2, 2), g), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 3, 3, 3, 3), v))))), y = SIMD.Float32x4.replaceLane(SIMD.Float32x4.neg(s), 3, 1), SIMD.Float32x4.store(n, 12, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 0, 0, 0, 0), m), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 1, 1, 1, 1), _), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 2, 2, 2, 2), g), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(y, 3, 3, 3, 3), v)))))
			}, e
		})(),
		r = e.Matrix.prototype.multiplyToArray,
		n = e.Matrix.prototype.invertToRef,
		o = e.Matrix.LookAtLHToRef,
		s = e.Vector3.TransformCoordinatesToRef,
		a = e.Vector3.TransformCoordinatesFromFloatsToRef,
		h = (function() {
			function h() {}
			return Object.defineProperty(h, "IsEnabled", {
				get: function() {
					return h._isEnabled
				},
				enumerable: !0,
				configurable: !0
			}), h.DisableSIMD = function() {
				e.Matrix.prototype.multiplyToArray = r, e.Matrix.prototype.invertToRef = n, e.Matrix.LookAtLHToRef = o, e.Vector3.TransformCoordinatesToRef = s, e.Vector3.TransformCoordinatesFromFloatsToRef = a, h._isEnabled = !1
			}, h.EnableSIMD = function() {
				void 0 !== self.SIMD && (self.Math.fround || (self.Math.fround = (function(e) {
					return function(t) {
						return e[0] = t, e[0]
					}
				})(new Float32Array(1))), self.Math.imul || (self.Math.imul = function(e, t) {
					var i = e >>> 16 & 65535,
						r = 65535 & e,
						n = t >>> 16 & 65535,
						o = 65535 & t;
					return r * o + (i * o + r * n << 16 >>> 0) | 0
				}), e.Matrix.prototype.multiplyToArray = i.prototype.multiplyToArraySIMD, e.Matrix.prototype.invertToRef = i.prototype.invertToRefSIMD, e.Matrix.LookAtLHToRef = i.LookAtLHToRefSIMD, e.Vector3.TransformCoordinatesToRef = t.TransformCoordinatesToRefSIMD, e.Vector3.TransformCoordinatesFromFloatsToRef = t.TransformCoordinatesFromFloatsToRefSIMD, h._isEnabled = !0)
			}, h._isEnabled = !1, h
		})();
	e.SIMDHelper = h
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i, r) {
			this._pos = i, this._size = r, this._root = e, this._parent = t, this._contentSize = null, this._bottomNode = null, this._leftNode = null, this._initialSize = null, this._rightNode = null
		}
		return Object.defineProperty(t.prototype, "pos", {
			get: function() {
				return this._pos
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "contentSize", {
			get: function() {
				return this._contentSize
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "UVs", {
			get: function() {
				return this.getUVsForCustomSize(this._root._size)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getUVsForCustomSize = function(t) {
			var i = this._root._size.width,
				r = this._root._size.height,
				n = new e.Vector2(this._pos.x / i, this._pos.y / r),
				o = new e.Vector2((this._pos.x + t.width - 1) / i, (this._pos.y + t.height - 1) / r),
				s = new Array;
			return s.push(n), s.push(new e.Vector2(o.x, n.y)), s.push(o), s.push(new e.Vector2(n.x, o.y)), s
		}, t.prototype.freeContent = function() {
			this.contentSize && (this._contentSize = null, this.attemptDefrag())
		}, Object.defineProperty(t.prototype, "isUsed", {
			get: function() {
				return null != this._contentSize || null != this._leftNode
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.findAndSplitNode = function(e) {
			var t = this.findNode(e);
			return t ? (t.splitNode(e), t) : null
		}, t.prototype.findNode = function(e) {
			var t = null;
			if (this.isUsed) this._leftNode && (t = this._leftNode.findNode(e)), !t && this._rightNode && (t = this._rightNode.findNode(e)), !t && this._bottomNode && (t = this._bottomNode.findNode(e));
			else if (this._initialSize) {
				if (!(e.width <= this._initialSize.width && e.height <= this._initialSize.height)) return null;
				t = this
			} else e.width <= this._size.width && e.height <= this._size.height && (t = this);
			return t
		}, t.prototype.splitNode = function(i) {
			return !this._contentSize && this._initialSize ? (this._contentSize = i.clone(), this._leftNode = new t(this._root, this, new e.Vector2(this._pos.x, this._pos.y), new e.Size(this._initialSize.width, this._initialSize.height)), this._leftNode.splitNode(i)) : (this._contentSize = i.clone(), this._initialSize = i.clone(), i.width !== this._size.width && (this._rightNode = new t(this._root, this, new e.Vector2(this._pos.x + i.width, this._pos.y), new e.Size(this._size.width - i.width, i.height))), i.height !== this._size.height && (this._bottomNode = new t(this._root, this, new e.Vector2(this._pos.x, this._pos.y + i.height), new e.Size(this._size.width, this._size.height - i.height))), this)
		}, t.prototype.attemptDefrag = function() {
			!this.isUsed && this.isRecursiveFree && (this.clearNode(), this._parent && this._parent.attemptDefrag())
		}, t.prototype.clearNode = function() {
			this._initialSize = null, this._rightNode = null, this._bottomNode = null
		}, Object.defineProperty(t.prototype, "isRecursiveFree", {
			get: function() {
				return !this.contentSize && (!this._leftNode || this._leftNode.isRecursiveFree) && (!this._rightNode || this._rightNode.isRecursiveFree) && (!this._bottomNode || this._bottomNode.isRecursiveFree)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.evalFreeSize = function(e) {
			var t = 0;
			return this.isUsed || (t = this._initialSize ? this._initialSize.surface : this._size.surface), this._rightNode && (t += this._rightNode.evalFreeSize(0)), this._bottomNode && (t += this._bottomNode.evalFreeSize(0)), t + e
		}, t
	})();
	e.PackedRect = t;
	var i = (function(t) {
		function i(i) {
			t.call(this, null, null, e.Vector2.Zero(), i), this._root = this
		}
		return __extends(i, t), i.prototype.addRect = function(e) {
			var t = this.findAndSplitNode(e);
			return t
		}, Object.defineProperty(i.prototype, "freeSpace", {
			get: function() {
				var e = 0;
				return e = this.evalFreeSize(e), e / (this._size.width * this._size.height)
			},
			enumerable: !0,
			configurable: !0
		}), i
	})(t);
	e.RectPackingMap = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {}
		return e
	})();
	e.DynamicFloatArrayElementInfo = t;
	var i = (function() {
		function e(e, i) {
			this.compareValueOffset = null, this.sortingAscending = !0, this._stride = e, this.buffer = new Float32Array(e * i), this._lastUsed = 0, this._firstFree = 0, this._allEntries = new Array(i), this._freeEntries = new Array(i);
			for (var r = 0; r < i; r++) {
				var n = new t;
				n.offset = r * e, this._allEntries[r] = n, this._freeEntries[i - r - 1] = n
			}
		}
		return e.prototype.allocElement = function() {
			0 === this._freeEntries.length && this._growBuffer();
			var e = this._freeEntries.pop();
			return this._lastUsed = Math.max(e.offset, this._lastUsed), e.offset === this._firstFree && (this._freeEntries.length > 0 ? this._firstFree = this._freeEntries[this._freeEntries.length - 1].offset : this._firstFree += this._stride), e
		}, e.prototype.freeElement = function(e) {
			this._firstFree = Math.min(e.offset, this._firstFree), this._freeEntries.push(e)
		}, e.prototype.pack = function() {
			if (0 === this._freeEntries.length) return this.buffer;
			if (this._lastUsed < this._firstFree) {
				var e = this.buffer.subarray(0, this._lastUsed + this._stride);
				return e
			}
			var i = this._stride,
				r = new t;
			r.offset = this.totalElementCount * i, this._freeEntries.push(r);
			for (var n = this._freeEntries.sort((function(e, t) {
					return e.offset - t.offset
				})), o = this._allEntries.sort((function(e, t) {
					return e.offset - t.offset
				})), s = n[0].offset, a = 1, h = (this.usedElementCount + 1) * i, c = n[0].offset, l = 1; l < n.length && !(s >= h); l++) {
				var u = n[l],
					d = u.offset,
					f = d - c;
				if (f !== i) {
					for (var p = f / i - 1, m = d - i, _ = Math.min(a, p), g = 0; g < _; g++) {
						var v = s / i,
							y = m / i,
							x = o[y];
						this._moveElement(x, s);
						var b = o[v];
						b.offset = m, o[v] = x, o[y] = b, m -= i, s += i
					}
					a <= p ? (s = m + i, a = 1 + _) : a = (d - s) / i + 1, c = d
				} else ++a, c = d
			}
			var T = this.buffer.subarray(0, s);
			return this._lastUsed = s - i, this._firstFree = s, n.pop(), this._freeEntries = n.sort((function(e, t) {
				return t.offset - e.offset
			})), this._allEntries = o, T
		}, e.prototype._moveElement = function(e, t) {
			for (var i = 0; i < this._stride; i++) this.buffer[t + i] = this.buffer[e.offset + i];
			e.offset = t
		}, e.prototype._growBuffer = function() {
			var e = Math.floor(1.5 * this.totalElementCount),
				i = new Float32Array(e * this._stride);
			i.set(this.buffer);
			for (var r = this.totalElementCount, n = e - this.totalElementCount, o = 0; o < n; o++) {
				var s = new t;
				s.offset = (r + o) * this.stride, this._allEntries.push(s), this._freeEntries[n - o - 1] = s
			}
			this._firstFree = r * this.stride, this.buffer = i
		}, Object.defineProperty(e.prototype, "totalElementCount", {
			get: function() {
				return this._allEntries.length
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "freeElementCount", {
			get: function() {
				return this._freeEntries.length
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "usedElementCount", {
			get: function() {
				return this._allEntries.length - this._freeEntries.length
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "stride", {
			get: function() {
				return this._stride
			},
			enumerable: !0,
			configurable: !0
		}), e.prototype.sort = function() {
			var e = this;
			if (!this.compareValueOffset) throw new Error("The DynamicFloatArray.sort() method needs a valid 'compareValueOffset' property");
			var t = this.usedElementCount;
			if (!this._sortTable || this._sortTable.length < t) {
				var i = Math.min(this.totalElementCount, 2 * t);
				this._sortTable = new Array(i)
			}
			this._sortedTable && this._sortedTable.length === t || (this._sortedTable = new Array(t)), this.pack();
			for (var n = 0, o = this.stride, s = 0; s < t; s++, n += o) {
				var a = this._sortTable[s];
				a || (a = new r, this._sortTable[s] = a), a.compareData = this.buffer[n + this.compareValueOffset], a.offset = n, a.swapedOffset = null, this._sortedTable[s] = a
			}
			this.sortingAscending ? this._sortedTable.sort((function(e, t) {
				return e.compareData - t.compareData
			})) : this._sortedTable.sort((function(e, t) {
				return t.compareData - e.compareData
			}));
			for (var h = function(t, i) {
					for (var r = 0; r < o; r++) {
						var n = e.buffer[i + r];
						e.buffer[i + r] = e.buffer[t + r], e.buffer[t + r] = n
					}
				}, s = 0; s < t; s++) {
				var c = this._sortedTable[s],
					l = this._sortTable[s],
					u = c.offset;
				if (c.swapedOffset) {
					for (var d = c; d.swapedOffset;) d = this._sortTable[d.swapedOffset / o];
					u = d.offset
				}
				l.swapedOffset = u, u !== l.offset && h(u, l.offset), this._allEntries[c.offset / o].offset = l.offset
			}
			return this._allEntries.sort((function(e, t) {
				return e.offset - t.offset
			})), !0
		}, e
	})();
	e.DynamicFloatArray = i;
	var r = (function() {
		function e() {
			this.compareData = this.offset = this.swapedOffset = null
		}
		return e
	})()
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e() {}
		return e
	})();
	e.CharInfo = t;
	var i = (function(i) {
		function r(t, r, n, o, s, a, h) {
			if (void 0 === o && (o = 200), void 0 === s && (s = e.Texture.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = !1), void 0 === h && (h = !1), i.call(this, null, n, !0, !1, s), this._charInfos = {}, this._curCharCount = 0, this._lastUpdateCharCount = -1, this._usedCounter = 1, this.name = t, this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._sdfScale = 8, this._signedDistanceField = h, this._superSample = !1, a || h) {
				var c = this.getSuperSampleFont(r);
				c && (this._superSample = !0, r = c)
			}
			this._canvas = document.createElement("canvas"), this._context = this._canvas.getContext("2d"), this._context.font = r, this._context.fillStyle = "white",
				this._context.textBaseline = "top", this._cachedFontId = null;
			var l = this.getFontHeight(r);
			this._lineHeightSuper = l.height + 4, this._lineHeight = this._superSample ? Math.ceil(this._lineHeightSuper / 2) : this._lineHeightSuper, this._offset = l.offset - 1, this._xMargin = 1 + Math.ceil(this._lineHeightSuper / 15), this._yMargin = this._xMargin;
			var u = this._context.measureText("W").width;
			this._spaceWidthSuper = this._context.measureText(" ").width, this._spaceWidth = this._superSample ? this._spaceWidthSuper / 2 : this._spaceWidthSuper;
			var d = (this._lineHeightSuper + this._yMargin) * (u + this._xMargin) * o,
				f = Math.sqrt(d),
				p = Math.pow(2, Math.ceil(Math.log(f) / Math.log(2)));
			this._texture = n.getEngine().createDynamicTexture(p, p, !1, s);
			var m = this.getSize();
			if (this.hasAlpha = this._signedDistanceField === !1, this._canvas = document.createElement("canvas"), this._canvas.width = m.width, this._canvas.height = m.height, this._context = this._canvas.getContext("2d"), this._context.textBaseline = "top", this._context.font = r, this._context.fillStyle = "white", this._context.imageSmoothingEnabled = !1, this._context.clearRect(0, 0, m.width, m.height), this._signedDistanceField) {
				var _ = document.createElement("canvas"),
					g = this._sdfScale;
				_.width = u * g, _.height = this._lineHeightSuper * g;
				var v = _.getContext("2d");
				v.scale(g, g), v.textBaseline = "top", v.font = r, v.fillStyle = "white", v.imageSmoothingEnabled = !1, this._sdfCanvas = _, this._sdfContext = v
			}
			this._currentFreePosition = e.Vector2.Zero();
			for (var y = 32; y < 127; y++) {
				var x = String.fromCharCode(y);
				this.getChar(x)
			}
			this.update()
		}
		return __extends(r, i), Object.defineProperty(r.prototype, "isSuperSampled", {
			get: function() {
				return this._superSample
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r.prototype, "isSignedDistanceField", {
			get: function() {
				return this._signedDistanceField
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r.prototype, "spaceWidth", {
			get: function() {
				return this._spaceWidth
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(r.prototype, "lineHeight", {
			get: function() {
				return this._lineHeight
			},
			enumerable: !0,
			configurable: !0
		}), r.GetCachedFontTexture = function(t, i, n, o) {
			void 0 === n && (n = !1), void 0 === o && (o = !1);
			var s = t;
			s.__fontTextureCache__ || (s.__fontTextureCache__ = new e.StringDictionary);
			var a = s.__fontTextureCache__,
				h = i.toLocaleLowerCase() + (n ? "_+SS" : "_-SS") + (o ? "_+SDF" : "_-SDF"),
				c = a.get(h);
			return c ? (++c._usedCounter, c) : (c = new r(null, i, t, n ? 100 : 200, e.Texture.BILINEAR_SAMPLINGMODE, n, o), c._cachedFontId = h, a.add(h, c), c)
		}, r.ReleaseCachedFontTexture = function(e, t, i, r) {
			void 0 === i && (i = !1), void 0 === r && (r = !1);
			var n = e,
				o = n.__fontTextureCache__;
			if (o) {
				var s = t.toLocaleLowerCase() + (i ? "_+SS" : "_-SS") + (r ? "_+SDF" : "_-SDF"),
					a = o.get(s);
				0 === --a._usedCounter && (o.remove(s), a.dispose())
			}
		}, r.prototype.getChar = function(i) {
			if (1 !== i.length) return null;
			var r = this._charInfos[i];
			if (r) return r;
			r = new t;
			var n = this._context.measureText(i),
				o = this.getSize(),
				s = Math.round(n.width);
			if (this._currentFreePosition.x + s + this._xMargin > o.width && (this._currentFreePosition.x = 0, this._currentFreePosition.y += this._lineHeightSuper + this._yMargin, this._currentFreePosition.y > o.height)) return this.getChar("!");
			if (this._signedDistanceField) {
				this._sdfContext.clearRect(0, 0, this._sdfCanvas.width, this._sdfCanvas.height), this._sdfContext.fillText(i, 0, -this._offset);
				var a = this._sdfContext.getImageData(0, 0, s * this._sdfScale, this._sdfCanvas.height),
					h = this._computeSDFChar(a);
				this._context.putImageData(h, this._currentFreePosition.x, this._currentFreePosition.y)
			} else this._context.fillText(i, this._currentFreePosition.x, this._currentFreePosition.y - this._offset);
			if (r.topLeftUV = new e.Vector2(this._currentFreePosition.x / o.width, this._currentFreePosition.y / o.height), r.bottomRightUV = new e.Vector2((this._currentFreePosition.x + s) / o.width, r.topLeftUV.y + (this._lineHeightSuper + 2) / o.height), this._signedDistanceField) {
				var c = 1 / o.width;
				r.topLeftUV.addInPlace(new e.Vector2(c, c)), r.bottomRightUV.addInPlace(new e.Vector2(c, c))
			}
			return r.charWidth = this._superSample ? s / 2 : s, this._charInfos[i] = r, this._curCharCount++, this._currentFreePosition.x += s + this._xMargin, r
		}, r.prototype._computeSDFChar = function(e) {
			for (var t = this._sdfScale, i = e.width, r = e.height, n = i / t, o = r / t, s = 0, a = 0, h = t, c = h - 1, l = function(n, o, h, c, l) {
					var u = n * t,
						d = o * t;
					if (u + h < 0 || u + h >= i || d + c < 0 || d + c >= r) return !0;
					var f = e.data[4 * ((d + c) * i + (u + h))],
						p = f > 0 === l;
					return p || (s = h, a = c), p
				}, u = function(e, t, i) {
					if (l(e, t, 0, c, i) && l(e, t, 0, -c, i) && l(e, t, -c, 0, i) && l(e, t, c, 0, i)) return 0;
					for (var r = 1; r <= h; r++) {
						if (!(l(e, t, 0, r, i) && l(e, t, 0, -r, i) && l(e, t, -r, 0, i) && l(e, t, r, 0, i))) return r * r;
						for (var n = 1; n <= r; n++)
							if (!(l(e, t, -n, r, i) && l(e, t, n, r, i) && l(e, t, r, -n, i) && l(e, t, r, n, i) && l(e, t, -n, -r, i) && l(e, t, n, -r, i) && l(e, t, -r, -n, i) && l(e, t, -r, n, i))) {
								var o = r * r + n * n,
									u = 1;
								return l(e, t, s - 1, a, i) || (o += (s - 1) * (s - 1) + a * a, ++u), l(e, t, s + 1, a, i) || (o += (s + 1) * (s + 1) + a * a, ++u), l(e, t, s, a - 1, i) || (o += s * s + (a - 1) * (a - 1), ++u), l(e, t, s, a + 1, i) || (o += s * s + (a + 1) * (a + 1), ++u), l(e, t, s - 1, a - 1, i) || (o += (s - 1) * (s - 1) + (a - 1) * (a - 1), ++u), l(e, t, s + 1, a + 1, i) || (o += (s + 1) * (s + 1) + (a + 1) * (a + 1), ++u), l(e, t, s + 1, a - 1, i) || (o += (s + 1) * (s + 1) + (a - 1) * (a - 1), ++u), l(e, t, s - 1, a + 1, i) || (o += (s - 1) * (s - 1) + (a + 1) * (a + 1), ++u), o / u
							}
					}
					return 0
				}, d = new Array(n * o), f = 0; f < o; f++)
				for (var p = 0; p < n; p++) {
					var m = l(p, f, 0, 0, !0),
						_ = u(p, f, m);
					0 === _ && (_ = h * h * 2), d[f * n + p] = m ? _ : -_
				}
			for (var g = this._context.createImageData(n, o), v = n * o, y = 0; y < v; y++) {
				var _ = d[y],
					x = _ < 0 ? -1 : 1;
				_ = Math.sqrt(Math.abs(_)) * x, _ *= 127.5 / h, _ += 127.5, _ < 0 ? _ = 0 : _ > 255 && (_ = 255), _ += .5, g.data[4 * y + 0] = _, g.data[4 * y + 1] = _, g.data[4 * y + 2] = _, g.data[4 * y + 3] = 255
			}
			return g
		}, r.prototype.measureText = function(t, i) {
			void 0 === i && (i = 4);
			for (var r = 0, n = 0, o = 1, s = 0, a = 0, h = t; a < h.length; a++) {
				var c = h[a];
				if ("\n" !== c)
					if ("\t" !== c) c < " " || (n += this.getChar(c).charWidth, ++s);
					else {
						var l = s + i;
						l -= l % i, n += (l - s) * this.spaceWidth, s = l
					}
				else r = Math.max(r, n), s = 0, n = 0, ++o
			}
			return r = Math.max(r, n), new e.Size(r, o * this.lineHeight)
		}, r.prototype.getSuperSampleFont = function(e) {
			var t = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\"\sa-z]+?)\s*$/,
				i = e.toLocaleLowerCase().match(t);
			if (null == i) return null;
			var r = parseInt(i[4]);
			i[4] = (2 * r).toString() + (i[4].match(/\D+/) || []).pop();
			for (var n = "", o = 1; o < i.length; o++) null != i[o] && (n += i[o] + " ");
			return n
		}, r.prototype.getFontHeight = function(e) {
			var t = document.createElement("canvas"),
				i = t.getContext("2d");
			i.fillRect(0, 0, t.width, t.height), i.textBaseline = "top", i.fillStyle = "white", i.font = e, i.fillText("jH|", 0, 0);
			for (var r = i.getImageData(0, 0, t.width, t.height).data, n = -1, o = -1, s = 0; s < t.height; s++)
				for (var a = 0; a < t.width; a++) {
					var h = 4 * (s * t.width + a); {
						if (0 !== r[h]) {
							n === -1 && (n = s);
							break
						}
						if (a === t.width - 1 && n !== -1) {
							o = s, s = t.height;
							break
						}
					}
				}
			return {
				height: o - n + 1,
				offset: n - 1
			}
		}, Object.defineProperty(r.prototype, "canRescale", {
			get: function() {
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), r.prototype.getContext = function() {
			return this._context
		}, r.prototype.update = function() {
			this._lastUpdateCharCount < this._curCharCount && (this.getScene().getEngine().updateDynamicTexture(this._texture, this._canvas, !1, !0), this._lastUpdateCharCount = this._curCharCount)
		}, r.prototype.clone = function() {
			return null
		}, r.prototype.incCachedFontTextureCounter = function() {
			++this._usedCounter
		}, r.prototype.decCachedFontTextureCounter = function() {
			var e = this.getScene(),
				t = e.__fontTextureCache__;
			t && 0 === --this._usedCounter && (t.remove(this._cachedFontId), this.dispose())
		}, r
	})(e.Texture);
	e.FontTexture = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			void 0 === o && (o = e.Texture.TRILINEAR_SAMPLINGMODE), void 0 === s && (s = !1), t.call(this, null, r, !s, !1, o), this.name = i, this._size = n, this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._rectPackingMap = new e.RectPackingMap(new e.Size(n.width, n.height)), this._texture = r.getEngine().createRenderTargetTexture(n, {
				generateMipMaps: !this.noMipmap,
				type: e.Engine.TEXTURETYPE_UNSIGNED_INT
			})
		}
		return __extends(i, t), i.prototype.allocateRect = function(e) {
			return this._rectPackingMap.addRect(e)
		}, i.prototype.freeRect = function(e) {
			e && e.freeContent()
		}, Object.defineProperty(i.prototype, "freeSpace", {
			get: function() {
				return this._rectPackingMap.freeSpace
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.bindTextureForRect = function(e, t) {
			return this.bindTextureForPosSize(e.pos, e.contentSize, t)
		}, i.prototype.bindTextureForPosSize = function(t, i, r) {
			var n = this.getScene().getEngine();
			n.bindFramebuffer(this._texture), this._replacedViewport = n.setDirectViewport(t.x, t.y, i.width, i.height), r && n.scissorClear(t.x, t.y, i.width, i.height, new e.Color4(0, 0, 0, 0))
		}, i.prototype.unbindTexture = function(t) {
			t && e.Tools.DumpFramebuffer(this._size.width, this._size.height, this.getScene().getEngine());
			var i = this.getScene().getEngine();
			this._replacedViewport && (i.setViewport(this._replacedViewport), this._replacedViewport = null), i.unBindFramebuffer(this._texture)
		}, Object.defineProperty(i.prototype, "canRescale", {
			get: function() {
				return !1
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.clone = function() {
			return null
		}, i
	})(e.Texture);
	e.MapTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o) {
			t.call(this, i, r), this._textures = {}, this._textureArrays = {}, this._floats = {}, this._floatsArrays = {}, this._colors3 = {}, this._colors4 = {}, this._vectors2 = {}, this._vectors3 = {}, this._vectors4 = {}, this._matrices = {}, this._matrices3x3 = {}, this._matrices2x2 = {}, this._vectors3Arrays = {}, this._cachedWorldViewMatrix = new e.Matrix, this._shaderPath = n, o.needAlphaBlending = o.needAlphaBlending || !1, o.needAlphaTesting = o.needAlphaTesting || !1, o.attributes = o.attributes || ["position", "normal", "uv"], o.uniforms = o.uniforms || ["worldViewProjection"], o.samplers = o.samplers || [], o.defines = o.defines || [], this._options = o
		}
		return __extends(i, t), i.prototype.needAlphaBlending = function() {
			return this._options.needAlphaBlending
		}, i.prototype.needAlphaTesting = function() {
			return this._options.needAlphaTesting
		}, i.prototype._checkUniform = function(e) {
			this._options.uniforms.indexOf(e) === -1 && this._options.uniforms.push(e)
		}, i.prototype.setTexture = function(e, t) {
			return this._options.samplers.indexOf(e) === -1 && this._options.samplers.push(e), this._textures[e] = t, this
		}, i.prototype.setTextureArray = function(e, t) {
			return this._options.samplers.indexOf(e) === -1 && this._options.samplers.push(e), this._checkUniform(e), this._textureArrays[e] = t, this
		}, i.prototype.setFloat = function(e, t) {
			return this._checkUniform(e), this._floats[e] = t, this
		}, i.prototype.setFloats = function(e, t) {
			return this._checkUniform(e), this._floatsArrays[e] = t, this
		}, i.prototype.setColor3 = function(e, t) {
			return this._checkUniform(e), this._colors3[e] = t, this
		}, i.prototype.setColor4 = function(e, t) {
			return this._checkUniform(e), this._colors4[e] = t, this
		}, i.prototype.setVector2 = function(e, t) {
			return this._checkUniform(e), this._vectors2[e] = t, this
		}, i.prototype.setVector3 = function(e, t) {
			return this._checkUniform(e), this._vectors3[e] = t, this
		}, i.prototype.setVector4 = function(e, t) {
			return this._checkUniform(e), this._vectors4[e] = t, this
		}, i.prototype.setMatrix = function(e, t) {
			return this._checkUniform(e), this._matrices[e] = t, this
		}, i.prototype.setMatrix3x3 = function(e, t) {
			return this._checkUniform(e), this._matrices3x3[e] = t, this
		}, i.prototype.setMatrix2x2 = function(e, t) {
			return this._checkUniform(e), this._matrices2x2[e] = t, this
		}, i.prototype.setArray3 = function(e, t) {
			return this._checkUniform(e), this._vectors3Arrays[e] = t, this
		}, i.prototype._checkCache = function(e, t, i) {
			return !t || (this._effect && this._effect.defines.indexOf("#define INSTANCES") !== -1 !== i, !1)
		}, i.prototype.isReady = function(t, i) {
			var r = this.getScene(),
				n = r.getEngine();
			if (!this.checkReadyOnEveryCall && this._renderId === r.getRenderId() && this._checkCache(r, t, i)) return !0;
			var o = [],
				s = new e.EffectFallbacks;
			i && o.push("#define INSTANCES");
			for (var a = 0; a < this._options.defines.length; a++) o.push(this._options.defines[a]);
			t && t.useBones && t.computeBonesUsingShaders && (o.push("#define NUM_BONE_INFLUENCERS " + t.numBoneInfluencers), o.push("#define BonesPerMesh " + (t.skeleton.bones.length + 1)), s.addCPUSkinningFallback(0, t)), n.getAlphaTesting() && o.push("#define ALPHATEST");
			var h = this._effect,
				c = o.join("\n");
			return this._effect = n.createEffect(this._shaderPath, this._options.attributes, this._options.uniforms, this._options.samplers, c, s, this.onCompiled, this.onError), !!this._effect.isReady() && (h !== this._effect && r.resetCachedMaterial(), this._renderId = r.getRenderId(), !0)
		}, i.prototype.bindOnlyWorldMatrix = function(e) {
			var t = this.getScene();
			this._options.uniforms.indexOf("world") !== -1 && this._effect.setMatrix("world", e), this._options.uniforms.indexOf("worldView") !== -1 && (e.multiplyToRef(t.getViewMatrix(), this._cachedWorldViewMatrix), this._effect.setMatrix("worldView", this._cachedWorldViewMatrix)), this._options.uniforms.indexOf("worldViewProjection") !== -1 && this._effect.setMatrix("worldViewProjection", e.multiply(t.getTransformMatrix()))
		}, i.prototype.bind = function(i, r) {
			if (this.bindOnlyWorldMatrix(i), this.getScene().getCachedMaterial() !== this) {
				this._options.uniforms.indexOf("view") !== -1 && this._effect.setMatrix("view", this.getScene().getViewMatrix()), this._options.uniforms.indexOf("projection") !== -1 && this._effect.setMatrix("projection", this.getScene().getProjectionMatrix()), this._options.uniforms.indexOf("viewProjection") !== -1 && this._effect.setMatrix("viewProjection", this.getScene().getTransformMatrix()), e.MaterialHelper.BindBonesParameters(r, this._effect);
				var n;
				for (n in this._textures) this._effect.setTexture(n, this._textures[n]);
				for (n in this._textureArrays) this._effect.setTextureArray(n, this._textureArrays[n]);
				for (n in this._floats) this._effect.setFloat(n, this._floats[n]);
				for (n in this._floatsArrays) this._effect.setArray(n, this._floatsArrays[n]);
				for (n in this._colors3) this._effect.setColor3(n, this._colors3[n]);
				for (n in this._colors4) {
					var o = this._colors4[n];
					this._effect.setFloat4(n, o.r, o.g, o.b, o.a)
				}
				for (n in this._vectors2) this._effect.setVector2(n, this._vectors2[n]);
				for (n in this._vectors3) this._effect.setVector3(n, this._vectors3[n]);
				for (n in this._vectors4) this._effect.setVector4(n, this._vectors4[n]);
				for (n in this._matrices) this._effect.setMatrix(n, this._matrices[n]);
				for (n in this._matrices3x3) this._effect.setMatrix3x3(n, this._matrices3x3[n]);
				for (n in this._matrices2x2) this._effect.setMatrix2x2(n, this._matrices2x2[n]);
				for (n in this._vectors3Arrays) this._effect.setArray3(n, this._vectors3Arrays[n])
			}
			t.prototype.bind.call(this, i, r)
		}, i.prototype.clone = function(e) {
			var t = new i(e, this.getScene(), this._shaderPath, this._options);
			return t
		}, i.prototype.dispose = function(e, i) {
			if (i) {
				var r;
				for (r in this._textures) this._textures[r].dispose();
				for (r in this._textureArrays)
					for (var n = this._textureArrays[r], o = 0; o < n.length; o++) n[o].dispose()
			}
			this._textures = {}, t.prototype.dispose.call(this, e, i)
		}, i.prototype.serialize = function() {
			var t = e.SerializationHelper.Serialize(this);
			t.customType = "BABYLON.ShaderMaterial", t.options = this._options, t.shaderPath = this._shaderPath;
			var i;
			t.textures = {};
			for (i in this._textures) t.textures[i] = this._textures[i].serialize();
			t.textureArrays = {};
			for (i in this._textureArrays) {
				t.textureArrays[i] = [];
				for (var r = this._textureArrays[i], n = 0; n < r.length; n++) t.textureArrays[i].push(r[n].serialize())
			}
			t.floats = {};
			for (i in this._floats) t.floats[i] = this._floats[i];
			t.floatArrays = {};
			for (i in this._floatsArrays) t.floatArrays[i] = this._floatsArrays[i];
			t.colors3 = {};
			for (i in this._colors3) t.colors3[i] = this._colors3[i].asArray();
			t.colors4 = {};
			for (i in this._colors4) t.colors4[i] = this._colors4[i].asArray();
			t.vectors2 = {};
			for (i in this._vectors2) t.vectors2[i] = this._vectors2[i].asArray();
			t.vectors3 = {};
			for (i in this._vectors3) t.vectors3[i] = this._vectors3[i].asArray();
			t.vectors4 = {};
			for (i in this._vectors4) t.vectors4[i] = this._vectors4[i].asArray();
			t.matrices = {};
			for (i in this._matrices) t.matrices[i] = this._matrices[i].asArray();
			t.matrices3x3 = {};
			for (i in this._matrices3x3) t.matrices3x3[i] = this._matrices3x3[i];
			t.matrices2x2 = {};
			for (i in this._matrices2x2) t.matrices2x2[i] = this._matrices2x2[i];
			t.vectors3Arrays = {};
			for (i in this._vectors3Arrays) t.vectors3Arrays[i] = this._vectors3Arrays[i];
			return t
		}, i.Parse = function(t, r, n) {
			var o, s = e.SerializationHelper.Parse((function() {
				return new i(t.name, r, t.shaderPath, t.options)
			}), t, r, n);
			for (o in t.textures) s.setTexture(o, e.Texture.Parse(t.textures[o], r, n));
			for (o in t.textureArrays) {
				for (var a = t.textureArrays[o], h = new Array, c = 0; c < a.length; c++) h.push(e.Texture.Parse(a[c], r, n));
				s.setTextureArray(o, h)
			}
			for (o in t.floats) s.setFloat(o, t.floats[o]);
			for (o in t.floatsArrays) s.setFloats(o, t.floatsArrays[o]);
			for (o in t.colors3) s.setColor3(o, e.Color3.FromArray(t.colors3[o]));
			for (o in t.colors4) s.setColor4(o, e.Color4.FromArray(t.colors4[o]));
			for (o in t.vectors2) s.setVector2(o, e.Vector2.FromArray(t.vectors2[o]));
			for (o in t.vectors3) s.setVector3(o, e.Vector3.FromArray(t.vectors3[o]));
			for (o in t.vectors4) s.setVector4(o, e.Vector4.FromArray(t.vectors4[o]));
			for (o in t.matrices) s.setMatrix(o, e.Matrix.FromArray(t.matrices[o]));
			for (o in t.matrices3x3) s.setMatrix3x3(o, t.matrices3x3[o]);
			for (o in t.matrices2x2) s.setMatrix2x2(o, t.matrices2x2[o]);
			for (o in t.vectors3Arrays) s.setArray3(o, t.vectors3Arrays[o]);
			return s
		}, i
	})(e.Material);
	e.ShaderMaterial = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		function i(e) {
			return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24)
		}

		function r(e) {
			return String.fromCharCode(255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255)
		}
		var n = 542327876,
			o = 131072,
			s = 512,
			a = 4,
			h = 64,
			c = 131072,
			l = i("DXT1"),
			u = i("DXT3"),
			d = i("DXT5"),
			f = 31,
			p = 0,
			m = 1,
			_ = 2,
			g = 3,
			v = 4,
			y = 7,
			x = 20,
			b = 21,
			T = 22,
			A = 28,
			E = (function() {
				function t() {}
				return t.GetDDSInfo = function(e) {
					var t = new Int32Array(e, 0, f),
						i = 1;
					return t[_] & o && (i = Math.max(1, t[y])), {
						width: t[v],
						height: t[g],
						mipmapCount: i,
						isFourCC: (t[x] & a) === a,
						isRGB: (t[x] & h) === h,
						isLuminance: (t[x] & c) === c,
						isCube: (t[A] & s) === s
					}
				}, t.GetRGBAArrayBuffer = function(e, t, i, r, n) {
					for (var o = new Uint8Array(r), s = new Uint8Array(n), a = 0, h = t - 1; h >= 0; h--)
						for (var c = 0; c < e; c++) {
							var l = i + 4 * (c + h * e);
							o[a + 2] = s[l], o[a + 1] = s[l + 1], o[a] = s[l + 2], o[a + 3] = s[l + 3], a += 4
						}
					return o
				}, t.GetRGBArrayBuffer = function(e, t, i, r, n) {
					for (var o = new Uint8Array(r), s = new Uint8Array(n), a = 0, h = t - 1; h >= 0; h--)
						for (var c = 0; c < e; c++) {
							var l = i + 3 * (c + h * e);
							o[a + 2] = s[l], o[a + 1] = s[l + 1], o[a] = s[l + 2], a += 3
						}
					return o
				}, t.GetLuminanceArrayBuffer = function(e, t, i, r, n) {
					for (var o = new Uint8Array(r), s = new Uint8Array(n), a = 0, h = t - 1; h >= 0; h--)
						for (var c = 0; c < e; c++) {
							var l = i + (c + h * e);
							o[a] = s[l], a++
						}
					return o
				}, t.UploadDDSLevels = function(i, s, a, h, c, x) {
					var A, E, P, M, S, C, R, O, D, I, w = new Int32Array(a, 0, f);
					if (w[p] != n) return void e.Tools.Error("Invalid magic number in DDS header");
					if (!h.isFourCC && !h.isRGB && !h.isLuminance) return void e.Tools.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
					if (h.isFourCC) switch (A = w[b]) {
						case l:
							E = 8, P = s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
							break;
						case u:
							E = 16, P = s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
							break;
						case d:
							E = 16, P = s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
							break;
						default:
							return void console.error("Unsupported FourCC code:", r(A))
					}
					D = 1, w[_] & o && c !== !1 && (D = Math.max(1, w[y]));
					for (var L = w[T], B = 0; B < x; B++) {
						var F = 1 === x ? i.TEXTURE_2D : i.TEXTURE_CUBE_MAP_POSITIVE_X + B;
						for (M = w[v], S = w[g], R = w[m] + 4, I = 0; I < D; ++I) {
							if (h.isRGB) 24 === L ? (C = M * S * 3, O = t.GetRGBArrayBuffer(M, S, R, C, a), i.texImage2D(F, I, i.RGB, M, S, 0, i.RGB, i.UNSIGNED_BYTE, O)) : (C = M * S * 4, O = t.GetRGBAArrayBuffer(M, S, R, C, a), i.texImage2D(F, I, i.RGBA, M, S, 0, i.RGBA, i.UNSIGNED_BYTE, O));
							else if (h.isLuminance) {
								var V = i.getParameter(i.UNPACK_ALIGNMENT),
									N = M,
									z = Math.floor((M + V - 1) / V) * V;
								C = z * (S - 1) + N, O = t.GetLuminanceArrayBuffer(M, S, R, C, a), i.texImage2D(F, I, i.LUMINANCE, M, S, 0, i.LUMINANCE, i.UNSIGNED_BYTE, O)
							} else C = Math.max(4, M) / 4 * Math.max(4, S) / 4 * E, O = new Uint8Array(a, R, C), i.compressedTexImage2D(F, I, P, M, S, 0, O);
							R += C, M *= .5, S *= .5, M = Math.max(1, M), S = Math.max(1, S)
						}
					}
				}, t
			})();
		t.DDSTools = E
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			return void 0 === t && (t = !0), void 0 === i && (i = 10), this._useDeltaForWorldStep = t, this.name = "CannonJSPlugin", this._physicsMaterials = [], this._fixedTimeStep = 1 / 60, this._currentCollisionGroup = 2, this._minus90X = new e.Quaternion((-.7071067811865475), 0, 0, .7071067811865475), this._plus90X = new e.Quaternion(.7071067811865475, 0, 0, .7071067811865475), this._tmpPosition = e.Vector3.Zero(), this._tmpQuaternion = new e.Quaternion, this._tmpDeltaPosition = e.Vector3.Zero(), this._tmpDeltaRotation = new e.Quaternion, this._tmpUnityRotation = new e.Quaternion, this.isSupported() ? (this.world = new CANNON.World, this.world.broadphase = new CANNON.NaiveBroadphase, void(this.world.solver.iterations = i)) : void e.Tools.Error("CannonJS is not available. Please make sure you included the js file.")
		}
		return t.prototype.setGravity = function(e) {
			this.world.gravity.copy(e)
		}, t.prototype.setTimeStep = function(e) {
			this._fixedTimeStep = e
		}, t.prototype.executeStep = function(e, t) {
			this.world.step(this._fixedTimeStep, this._useDeltaForWorldStep ? 1e3 * e : 0, 3)
		}, t.prototype.applyImpulse = function(e, t, i) {
			var r = new CANNON.Vec3(i.x, i.y, i.z),
				n = new CANNON.Vec3(t.x, t.y, t.z);
			e.physicsBody.applyImpulse(n, r)
		}, t.prototype.applyForce = function(e, t, i) {
			var r = new CANNON.Vec3(i.x, i.y, i.z),
				n = new CANNON.Vec3(t.x, t.y, t.z);
			e.physicsBody.applyImpulse(n, r)
		}, t.prototype.generatePhysicsBody = function(e) {
			if (e.parent) return void(e.physicsBody && (this.removePhysicsBody(e), e.forceUpdate()));
			if (e.isBodyInitRequired()) {
				var t = this._createShape(e),
					i = e.physicsBody;
				i && this.removePhysicsBody(e);
				var r = this._addMaterial("mat-" + e.uniqueId, e.getParam("friction"), e.getParam("restitution")),
					n = {
						mass: e.getParam("mass"),
						material: r
					},
					o = e.getParam("nativeOptions");
				for (var s in o) o.hasOwnProperty(s) && (n[s] = o[s]);
				e.physicsBody = new CANNON.Body(n), e.physicsBody.addEventListener("collide", e.onCollide), this.world.addEventListener("preStep", e.beforeStep), this.world.addEventListener("postStep", e.afterStep), e.physicsBody.addShape(t), this.world.add(e.physicsBody), i && ["force", "torque", "velocity", "angularVelocity"].forEach((function(t) {
					e.physicsBody[t].copy(i[t])
				})), this._processChildMeshes(e)
			}
			this._updatePhysicsBodyTransformation(e)
		}, t.prototype._processChildMeshes = function(t) {
			var i = this,
				r = t.object.getChildMeshes ? t.object.getChildMeshes() : [];
			if (r.length) {
				var n = function(e, r) {
					var o = r.getPhysicsImpostor();
					if (o) {
						var s = o.parent;
						if (s !== t) {
							var e = r.position;
							o.physicsBody && (i.removePhysicsBody(o), o.physicsBody = null), o.parent = t, o.resetUpdateFlags(), t.physicsBody.addShape(i._createShape(o), new CANNON.Vec3(e.x, e.y, e.z)), t.physicsBody.mass += o.getParam("mass")
						}
					}
					r.getChildMeshes().forEach(n.bind(i, r.position))
				};
				r.forEach(n.bind(this, e.Vector3.Zero()))
			}
		}, t.prototype.removePhysicsBody = function(e) {
			e.physicsBody.removeEventListener("collide", e.onCollide), this.world.removeEventListener("preStep", e.beforeStep), this.world.removeEventListener("postStep", e.afterStep), this.world.remove(e.physicsBody)
		}, t.prototype.generateJoint = function(t) {
			var i = t.mainImpostor.physicsBody,
				r = t.connectedImpostor.physicsBody;
			if (i && r) {
				var n, o = t.joint.jointData,
					s = {
						pivotA: o.mainPivot ? (new CANNON.Vec3).copy(o.mainPivot) : null,
						pivotB: o.connectedPivot ? (new CANNON.Vec3).copy(o.connectedPivot) : null,
						axisA: o.mainAxis ? (new CANNON.Vec3).copy(o.mainAxis) : null,
						axisB: o.connectedAxis ? (new CANNON.Vec3).copy(o.connectedAxis) : null,
						maxForce: o.nativeParams.maxForce,
						collideConnected: !!o.collision
					};
				switch (t.joint.type) {
					case e.PhysicsJoint.HingeJoint:
					case e.PhysicsJoint.Hinge2Joint:
						n = new CANNON.HingeConstraint(i, r, s);
						break;
					case e.PhysicsJoint.DistanceJoint:
						n = new CANNON.DistanceConstraint(i, r, o.maxDistance || 2);
						break;
					case e.PhysicsJoint.SpringJoint:
						var a = o;
						n = new CANNON.Spring(i, r, {
							restLength: a.length,
							stiffness: a.stiffness,
							damping: a.damping,
							localAnchorA: s.pivotA,
							localAnchorB: s.pivotB
						});
						break;
					case e.PhysicsJoint.LockJoint:
						n = new CANNON.LockConstraint(i, r, s);
						break;
					case e.PhysicsJoint.PointToPointJoint:
					case e.PhysicsJoint.BallAndSocketJoint:
					default:
						n = new CANNON.PointToPointConstraint(i, s.pivotA, r, s.pivotA, s.maxForce)
				}
				n.collideConnected = !!o.collision, t.joint.physicsJoint = n, t.joint.type !== e.PhysicsJoint.SpringJoint ? this.world.addConstraint(n) : t.mainImpostor.registerAfterPhysicsStep((function() {
					n.applyForce()
				}))
			}
		}, t.prototype.removeJoint = function(e) {
			this.world.removeConstraint(e.joint.physicsJoint)
		}, t.prototype._addMaterial = function(e, t, i) {
			var r, n;
			for (r = 0; r < this._physicsMaterials.length; r++)
				if (n = this._physicsMaterials[r], n.friction === t && n.restitution === i) return n;
			var o = new CANNON.Material(e);
			return o.friction = t, o.restitution = i, this._physicsMaterials.push(o), o
		}, t.prototype._checkWithEpsilon = function(t) {
			return t < e.PhysicsEngine.Epsilon ? e.PhysicsEngine.Epsilon : t
		}, t.prototype._createShape = function(t) {
			var i, r = t.object,
				n = t.getObjectExtendSize();
			switch (t.type) {
				case e.PhysicsEngine.SphereImpostor:
					var o = n.x,
						s = n.y,
						a = n.z;
					i = new CANNON.Sphere(Math.max(this._checkWithEpsilon(o), this._checkWithEpsilon(s), this._checkWithEpsilon(a)) / 2);
					break;
				case e.PhysicsImpostor.CylinderImpostor:
					i = new CANNON.Cylinder(this._checkWithEpsilon(n.x) / 2, this._checkWithEpsilon(n.x) / 2, this._checkWithEpsilon(n.y), 16);
					break;
				case e.PhysicsImpostor.BoxImpostor:
					var h = n.scale(.5);
					i = new CANNON.Box(new CANNON.Vec3(this._checkWithEpsilon(h.x), this._checkWithEpsilon(h.y), this._checkWithEpsilon(h.z)));
					break;
				case e.PhysicsImpostor.PlaneImpostor:
					e.Tools.Warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead"), i = new CANNON.Plane;
					break;
				case e.PhysicsImpostor.MeshImpostor:
					var c = r.getVerticesData ? r.getVerticesData(e.VertexBuffer.PositionKind) : [],
						l = r.getIndices ? r.getIndices() : [];
					e.Tools.Warn("MeshImpostor only collides against spheres."), i = new CANNON.Trimesh(c, l);
					break;
				case e.PhysicsImpostor.HeightmapImpostor:
					i = this._createHeightmap(r);
					break;
				case e.PhysicsImpostor.ParticleImpostor:
					i = new CANNON.Particle
			}
			return i
		}, t.prototype._createHeightmap = function(t, i) {
			for (var r = t.getVerticesData(e.VertexBuffer.PositionKind), n = [], o = i || ~~(Math.sqrt(r.length / 3) - 1), s = Math.min(t.getBoundingInfo().boundingBox.extendSize.x, t.getBoundingInfo().boundingBox.extendSize.z), a = 2 * s / o, h = t.getBoundingInfo().boundingBox.extendSize.y, c = 0; c < r.length; c += 3) {
				var l = Math.round(r[c + 0] / a + o / 2),
					u = Math.round((r[c + 2] / a - o / 2) * -1),
					d = r[c + 1] + h;
				n[l] || (n[l] = []), n[l][u] || (n[l][u] = d), n[l][u] = Math.max(d, n[l][u])
			}
			for (var l = 0; l <= o; ++l) {
				if (!n[l]) {
					for (var f = 1; !n[(l + f) % o];) f++;
					n[l] = n[(l + f) % o].slice()
				}
				for (var u = 0; u <= o; ++u)
					if (!n[l][u]) {
						for (var p, f = 1; void 0 === p;) p = n[l][(u + f++) % o];
						n[l][u] = p
					}
			}
			var m = new CANNON.Heightfield(n, {
				elementSize: a
			});
			return m.minY = h, m
		}, t.prototype._updatePhysicsBodyTransformation = function(t) {
			var i = t.object;
			i.computeWorldMatrix && i.computeWorldMatrix(!0);
			var r = t.getObjectCenter();
			t.getObjectExtendSize();
			this._tmpDeltaPosition.copyFrom(i.position.subtract(r)), this._tmpPosition.copyFrom(r);
			var n = i.rotationQuaternion;
			if (t.type !== e.PhysicsImpostor.PlaneImpostor && t.type !== e.PhysicsImpostor.HeightmapImpostor && t.type !== e.PhysicsImpostor.CylinderImpostor || (n = n.multiply(this._minus90X), t.setDeltaRotation(this._plus90X)), t.type === e.PhysicsEngine.HeightmapImpostor) {
				var o = i,
					s = o.rotationQuaternion;
				o.rotationQuaternion = this._tmpUnityRotation, o.computeWorldMatrix(!0);
				var a = r.clone(),
					h = o.getPivotMatrix() || e.Matrix.Translation(0, 0, 0);
				o.rotationQuaternion = s;
				var c = e.Matrix.Translation(o.getBoundingInfo().boundingBox.extendSize.x, 0, -o.getBoundingInfo().boundingBox.extendSize.z);
				o.setPivotMatrix(c), o.computeWorldMatrix(!0);
				var l = o.getBoundingInfo().boundingBox.center.subtract(r).subtract(o.position).negate();
				this._tmpPosition.copyFromFloats(l.x, l.y - o.getBoundingInfo().boundingBox.extendSize.y, l.z), this._tmpDeltaPosition.copyFrom(o.getBoundingInfo().boundingBox.center.subtract(a)), this._tmpDeltaPosition.y += o.getBoundingInfo().boundingBox.extendSize.y, o.setPivotMatrix(h), o.computeWorldMatrix(!0)
			} else t.type === e.PhysicsEngine.MeshImpostor && (this._tmpDeltaPosition.copyFromFloats(0, 0, 0), this._tmpPosition.copyFrom(i.position));
			t.setDeltaPosition(this._tmpDeltaPosition), t.physicsBody.position.copy(this._tmpPosition), t.physicsBody.quaternion.copy(n)
		}, t.prototype.setTransformationFromPhysicsBody = function(e) {
			e.object.position.copyFrom(e.physicsBody.position), e.object.rotationQuaternion.copyFrom(e.physicsBody.quaternion)
		}, t.prototype.setPhysicsBodyTransformation = function(e, t, i) {
			e.physicsBody.position.copy(t), e.physicsBody.quaternion.copy(i)
		}, t.prototype.isSupported = function() {
			return void 0 !== window.CANNON
		}, t.prototype.setLinearVelocity = function(e, t) {
			e.physicsBody.velocity.copy(t)
		}, t.prototype.setAngularVelocity = function(e, t) {
			e.physicsBody.angularVelocity.copy(t)
		}, t.prototype.getLinearVelocity = function(t) {
			var i = t.physicsBody.velocity;
			return i ? new e.Vector3(i.x, i.y, i.z) : null
		}, t.prototype.getAngularVelocity = function(t) {
			var i = t.physicsBody.angularVelocity;
			return i ? new e.Vector3(i.x, i.y, i.z) : null
		}, t.prototype.setBodyMass = function(e, t) {
			e.physicsBody.mass = t, e.physicsBody.updateMassProperties()
		}, t.prototype.sleepBody = function(e) {
			e.physicsBody.sleep()
		}, t.prototype.wakeUpBody = function(e) {
			e.physicsBody.wakeUp()
		}, t.prototype.updateDistanceJoint = function(e, t, i) {
			e.physicsJoint.distance = t
		}, t.prototype.enableMotor = function(e, t) {
			t || e.physicsJoint.enableMotor()
		}, t.prototype.disableMotor = function(e, t) {
			t || e.physicsJoint.disableMotor()
		}, t.prototype.setMotor = function(e, t, i, r) {
			r || (e.physicsJoint.enableMotor(), e.physicsJoint.setMotorSpeed(t), i && this.setLimit(e, i))
		}, t.prototype.setLimit = function(e, t, i) {
			e.physicsJoint.motorEquation.maxForce = t, e.physicsJoint.motorEquation.minForce = void 0 === i ? -t : i
		}, t.prototype.dispose = function() {}, t
	})();
	e.CannonJSPlugin = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t) {
			this.name = "OimoJSPlugin", this._tmpImpostorsArray = [], this._tmpPositionVector = e.Vector3.Zero(), this.world = new OIMO.World(1 / 60, 2, t, (!0)), this.world.worldscale(1), this.world.clear(), this.world.isNoStat = !0
		}
		return t.prototype.setGravity = function(e) {
			this.world.gravity.copy(e)
		}, t.prototype.setTimeStep = function(e) {
			this.world.timeStep = e
		}, t.prototype.executeStep = function(e, t) {
			var i = this;
			t.forEach((function(e) {
				e.beforeStep()
			})), this.world.step(), t.forEach((function(e) {
				e.afterStep(), i._tmpImpostorsArray[e.uniqueId] = e
			}));
			for (var r = this.world.contacts; null !== r;)
				if (!r.touching || r.body1.sleeping || r.body2.sleeping) {
					var n = this._tmpImpostorsArray[+r.body1.name],
						o = this._tmpImpostorsArray[+r.body2.name];
					n && o ? (n.onCollide({
						body: o.physicsBody
					}), o.onCollide({
						body: n.physicsBody
					}), r = r.next) : r = r.next
				} else r = r.next
		}, t.prototype.applyImpulse = function(e, t, i) {
			var r = e.physicsBody.massInfo.mass;
			e.physicsBody.applyImpulse(i.scale(OIMO.INV_SCALE), t.scale(OIMO.INV_SCALE * r))
		}, t.prototype.applyForce = function(t, i, r) {
			e.Tools.Warn("Oimo doesn't support applying force. Using impule instead."), this.applyImpulse(t, i, r)
		}, t.prototype.generatePhysicsBody = function(t) {
			var i = this;
			if (t.parent) return void(t.physicsBody && (this.removePhysicsBody(t), t.forceUpdate()));
			if (t.isBodyInitRequired()) {
				var r = {
						name: t.uniqueId,
						config: [t.getParam("mass") || 1, t.getParam("friction"), t.getParam("restitution")],
						size: [],
						type: [],
						pos: [],
						rot: [],
						move: 0 !== t.getParam("mass"),
						world: this.world
					},
					n = [t],
					o = function(e) {
						e.getChildMeshes && e.getChildMeshes().forEach((function(e) {
							e.physicsImpostor && (n.push(e.physicsImpostor), e.physicsImpostor._init())
						}))
					};
				o(t.object);
				var s = function(t) {
					return Math.max(t, e.PhysicsEngine.Epsilon)
				};
				n.forEach((function(n) {
					var o = n.object.rotationQuaternion,
						a = (new OIMO.Euler).setFromQuaternion({
							x: t.object.rotationQuaternion.x,
							y: t.object.rotationQuaternion.y,
							z: t.object.rotationQuaternion.z,
							s: t.object.rotationQuaternion.w
						}),
						h = n.getObjectExtendSize();
					if (n === t) {
						var c = t.getObjectCenter();
						t.object.position.subtractToRef(c, i._tmpPositionVector), r.pos.push(c.x), r.pos.push(c.y), r.pos.push(c.z), r.rot.push(a.x / (OIMO.degtorad || OIMO.TO_RAD)), r.rot.push(a.y / (OIMO.degtorad || OIMO.TO_RAD)), r.rot.push(a.z / (OIMO.degtorad || OIMO.TO_RAD))
					} else r.pos.push(n.object.position.x), r.pos.push(n.object.position.y), r.pos.push(n.object.position.z), r.rot.push(0), r.rot.push(0), r.rot.push(0);
					switch (n.type) {
						case e.PhysicsImpostor.ParticleImpostor:
							e.Tools.Warn("No Particle support in Oimo.js. using SphereImpostor instead");
						case e.PhysicsImpostor.SphereImpostor:
							var l = h.x,
								u = h.y,
								d = h.z,
								f = Math.max(s(l), s(u), s(d)) / 2;
							r.type.push("sphere"), r.size.push(f), r.size.push(f), r.size.push(f);
							break;
						case e.PhysicsImpostor.CylinderImpostor:
							var p = s(h.x) / 2,
								m = s(h.y);
							r.type.push("cylinder"), r.size.push(p), r.size.push(m), r.size.push(m);
							break;
						case e.PhysicsImpostor.PlaneImpostor:
						case e.PhysicsImpostor.BoxImpostor:
						default:
							var p = s(h.x),
								m = s(h.y),
								_ = s(h.z);
							r.type.push("box"), r.size.push(p), r.size.push(m), r.size.push(_)
					}
					n.object.rotationQuaternion = o
				})), t.physicsBody = new OIMO.Body(r).body
			} else this._tmpPositionVector.copyFromFloats(0, 0, 0);
			t.setDeltaPosition(this._tmpPositionVector)
		}, t.prototype.removePhysicsBody = function(e) {
			this.world.removeRigidBody(e.physicsBody)
		}, t.prototype.generateJoint = function(t) {
			var i = t.mainImpostor.physicsBody,
				r = t.connectedImpostor.physicsBody;
			if (i && r) {
				var n, o = t.joint.jointData,
					s = o.nativeParams || {},
					a = {
						body1: i,
						body2: r,
						axe1: s.axe1 || (o.mainAxis ? o.mainAxis.asArray() : null),
						axe2: s.axe2 || (o.connectedAxis ? o.connectedAxis.asArray() : null),
						pos1: s.pos1 || (o.mainPivot ? o.mainPivot.asArray() : null),
						pos2: s.pos2 || (o.connectedPivot ? o.connectedPivot.asArray() : null),
						min: s.min,
						max: s.max,
						collision: s.collision || o.collision,
						spring: s.spring,
						world: this.world
					};
				switch (t.joint.type) {
					case e.PhysicsJoint.BallAndSocketJoint:
						n = "jointBall";
						break;
					case e.PhysicsJoint.SpringJoint:
						e.Tools.Warn("Oimo.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");
						var h = o;
						a.min = h.length || a.min, a.max = Math.max(a.min, a.max);
					case e.PhysicsJoint.DistanceJoint:
						n = "jointDistance", a.max = o.maxDistance;
						break;
					case e.PhysicsJoint.PrismaticJoint:
						n = "jointPrisme";
						break;
					case e.PhysicsJoint.SliderJoint:
						n = "jointSlide";
						break;
					case e.PhysicsJoint.WheelJoint:
						n = "jointWheel";
						break;
					case e.PhysicsJoint.HingeJoint:
					default:
						n = "jointHinge"
				}
				a.type = n, t.joint.physicsJoint = new OIMO.Link(a).joint
			}
		}, t.prototype.removeJoint = function(t) {
			try {
				this.world.removeJoint(t.joint.physicsJoint)
			} catch (i) {
				e.Tools.Warn(i)
			}
		}, t.prototype.isSupported = function() {
			return void 0 !== OIMO
		}, t.prototype.setTransformationFromPhysicsBody = function(e) {
			if (!e.physicsBody.sleeping) {
				if (e.physicsBody.shapes.next) {
					var t = this._getLastShape(e.physicsBody);
					e.object.position.x = t.position.x * OIMO.WORLD_SCALE, e.object.position.y = t.position.y * OIMO.WORLD_SCALE, e.object.position.z = t.position.z * OIMO.WORLD_SCALE
				} else e.object.position.copyFrom(e.physicsBody.getPosition());
				e.object.rotationQuaternion.copyFrom(e.physicsBody.getQuaternion()), e.object.rotationQuaternion.normalize()
			}
		}, t.prototype.setPhysicsBodyTransformation = function(e, t, i) {
			var r = e.physicsBody;
			r.position.init(t.x * OIMO.INV_SCALE, t.y * OIMO.INV_SCALE, t.z * OIMO.INV_SCALE), r.orientation.init(i.w, i.x, i.y, i.z), r.syncShapes(), r.awake()
		}, t.prototype._getLastShape = function(e) {
			for (var t = e.shapes; t.next;) t = t.next;
			return t
		}, t.prototype.setLinearVelocity = function(e, t) {
			e.physicsBody.linearVelocity.init(t.x, t.y, t.z)
		}, t.prototype.setAngularVelocity = function(e, t) {
			e.physicsBody.angularVelocity.init(t.x, t.y, t.z)
		}, t.prototype.getLinearVelocity = function(t) {
			var i = t.physicsBody.linearVelocity;
			return i ? new e.Vector3(i.x, i.y, i.z) : null
		}, t.prototype.getAngularVelocity = function(t) {
			var i = t.physicsBody.angularVelocity;
			return i ? new e.Vector3(i.x, i.y, i.z) : null
		}, t.prototype.setBodyMass = function(e, t) {
			var i = 0 === t;
			e.physicsBody.shapes.density = i ? 1 : t, e.physicsBody.setupMass(i ? 2 : 1)
		}, t.prototype.sleepBody = function(e) {
			e.physicsBody.sleep()
		}, t.prototype.wakeUpBody = function(e) {
			e.physicsBody.awake()
		}, t.prototype.updateDistanceJoint = function(e, t, i) {
			e.physicsJoint.limitMotor.upperLimit = t, void 0 !== i && (e.physicsJoint.limitMotor.lowerLimit = i)
		}, t.prototype.setMotor = function(e, t, i, r) {
			var n = r ? e.physicsJoint.rotationalLimitMotor2 : e.physicsJoint.rotationalLimitMotor1 || e.physicsJoint.rotationalLimitMotor || e.physicsJoint.limitMotor;
			n && n.setMotor(t, i)
		}, t.prototype.setLimit = function(e, t, i, r) {
			var n = r ? e.physicsJoint.rotationalLimitMotor2 : e.physicsJoint.rotationalLimitMotor1 || e.physicsJoint.rotationalLimitMotor || e.physicsJoint.limitMotor;
			n && n.setLimit(t, void 0 === i ? -t : i)
		}, t.prototype.dispose = function() {
			this.world.clear()
		}, t
	})();
	e.OimoJSPlugin = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s) {
			e.call(this, t, "displayPass", ["passSampler"], ["passSampler"], i, r, n, o, s)
		}
		return __extends(t, e), t
	})(e.PostProcess);
	e.DisplayPassPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e, t, i) {
			this.quality = e, this.distance = t, this.optimizeMesh = i
		}
		return e
	})();
	e.SimplificationSettings = t;
	var i = (function() {
		function t() {
			this.running = !1, this._simplificationArray = []
		}
		return t.prototype.addTask = function(e) {
			this._simplificationArray.push(e)
		}, t.prototype.executeNext = function() {
			var e = this._simplificationArray.pop();
			e ? (this.running = !0, this.runSimplification(e)) : this.running = !1
		}, t.prototype.runSimplification = function(t) {
			var i = this;
			if (t.parallelProcessing) t.settings.forEach((function(e) {
				var r = i.getSimplifier(t);
				r.simplify(e, (function(r) {
					t.mesh.addLODLevel(e.distance, r), r.isVisible = !0, e.quality === t.settings[t.settings.length - 1].quality && t.successCallback && t.successCallback(), i.executeNext()
				}))
			}));
			else {
				var r = this.getSimplifier(t),
					n = function(e, i) {
						r.simplify(e, (function(r) {
							t.mesh.addLODLevel(e.distance, r), r.isVisible = !0, i()
						}))
					};
				e.AsyncLoop.Run(t.settings.length, (function(e) {
					n(t.settings[e.index], (function() {
						e.executeNext()
					}))
				}), (function() {
					t.successCallback && t.successCallback(), i.executeNext()
				}))
			}
		}, t.prototype.getSimplifier = function(e) {
			switch (e.simplificationType) {
				case r.QUADRATIC:
				default:
					return new h(e.mesh)
			}
		}, t
	})();
	e.SimplificationQueue = i, (function(e) {
		e[e.QUADRATIC = 0] = "QUADRATIC"
	})(e.SimplificationType || (e.SimplificationType = {}));
	var r = e.SimplificationType,
		n = (function() {
			function e(e) {
				this.vertices = e, this.error = new Array(4), this.deleted = !1, this.isDirty = !1, this.deletePending = !1, this.borderFactor = 0
			}
			return e
		})();
	e.DecimationTriangle = n;
	var o = (function() {
		function e(e, t) {
			this.position = e, this.id = t, this.isBorder = !0, this.q = new s, this.triangleCount = 0, this.triangleStart = 0, this.originalOffsets = []
		}
		return e.prototype.updatePosition = function(e) {
			this.position.copyFrom(e)
		}, e
	})();
	e.DecimationVertex = o;
	var s = (function() {
		function e(e) {
			this.data = new Array(10);
			for (var t = 0; t < 10; ++t) e && e[t] ? this.data[t] = e[t] : this.data[t] = 0
		}
		return e.prototype.det = function(e, t, i, r, n, o, s, a, h) {
			var c = this.data[e] * this.data[n] * this.data[h] + this.data[i] * this.data[r] * this.data[a] + this.data[t] * this.data[o] * this.data[s] - this.data[i] * this.data[n] * this.data[s] - this.data[e] * this.data[o] * this.data[a] - this.data[t] * this.data[r] * this.data[h];
			return c
		}, e.prototype.addInPlace = function(e) {
			for (var t = 0; t < 10; ++t) this.data[t] += e.data[t]
		}, e.prototype.addArrayInPlace = function(e) {
			for (var t = 0; t < 10; ++t) this.data[t] += e[t]
		}, e.prototype.add = function(t) {
			for (var i = new e, r = 0; r < 10; ++r) i.data[r] = this.data[r] + t.data[r];
			return i
		}, e.FromData = function(t, i, r, n) {
			return new e(e.DataFromNumbers(t, i, r, n))
		}, e.DataFromNumbers = function(e, t, i, r) {
			return [e * e, e * t, e * i, e * r, t * t, t * i, t * r, i * i, i * r, r * r]
		}, e
	})();
	e.QuadraticMatrix = s;
	var a = (function() {
		function e(e, t) {
			this.vertexId = e, this.triangleId = t
		}
		return e
	})();
	e.Reference = a;
	var h = (function() {
		function t(t) {
			this._mesh = t, this.initialized = !1, this.syncIterations = 5e3, this.aggressiveness = 7, this.decimationIterations = 100, this.boundingBoxEpsilon = e.Epsilon
		}
		return t.prototype.simplify = function(t, i) {
			var r = this;
			this.initDecimatedMesh(), e.AsyncLoop.Run(this._mesh.subMeshes.length, (function(e) {
				r.initWithMesh(e.index, (function() {
					r.runDecimation(t, e.index, (function() {
						e.executeNext()
					}))
				}), t.optimizeMesh)
			}), (function() {
				setTimeout((function() {
					i(r._reconstructedMesh)
				}), 0)
			}))
		}, t.prototype.isTriangleOnBoundingBox = function(e) {
			var t = this,
				i = 0;
			return e.vertices.forEach((function(e) {
				var r = 0,
					n = e.position,
					o = t._mesh.getBoundingInfo().boundingBox;
				(o.maximum.x - n.x < t.boundingBoxEpsilon || n.x - o.minimum.x > t.boundingBoxEpsilon) && ++r, o.maximum.y !== n.y && n.y !== o.minimum.y || ++r, o.maximum.z !== n.z && n.z !== o.minimum.z || ++r, r > 1 && ++i
			})), i > 1 && console.log(e, i), i > 1
		}, t.prototype.runDecimation = function(t, i, r) {
			var n = this,
				o = ~~(this.triangles.length * t.quality),
				s = 0,
				a = this.triangles.length,
				h = function(t, i) {
					setTimeout((function() {
						t % 5 === 0 && n.updateMesh(0 === t);
						for (var r = 0; r < n.triangles.length; ++r) n.triangles[r].isDirty = !1;
						var h = 1e-9 * Math.pow(t + 3, n.aggressiveness),
							c = function(t) {
								var i = ~~((n.triangles.length / 2 + t) % n.triangles.length),
									r = n.triangles[i];
								if (r && !(r.error[3] > h || r.deleted || r.isDirty))
									for (var o = 0; o < 3; ++o)
										if (r.error[o] < h) {
											var a = [],
												c = [],
												l = r.vertices[o],
												u = r.vertices[(o + 1) % 3];
											if (l.isBorder || u.isBorder) continue;
											var d = e.Vector3.Zero(),
												f = e.Vector3.Zero(),
												p = e.Vector2.Zero(),
												m = new e.Color4(0, 0, 0, 1);
											n.calculateError(l, u, d, f, p, m);
											var _ = [];
											if (n.isFlipped(l, u, d, a, r.borderFactor, _)) continue;
											if (n.isFlipped(u, l, d, c, r.borderFactor, _)) continue;
											if (a.indexOf(!0) < 0 || c.indexOf(!0) < 0) continue;
											var g = [];
											if (_.forEach((function(e) {
													g.indexOf(e) === -1 && (e.deletePending = !0, g.push(e))
												})), g.length % 2 !== 0) continue;
											l.q = u.q.add(l.q), l.updatePosition(d);
											var v = n.references.length;
											s = n.updateTriangles(l, l, a, s), s = n.updateTriangles(l, u, c, s);
											var y = n.references.length - v;
											if (y <= l.triangleCount) {
												if (y)
													for (var x = 0; x < y; x++) n.references[l.triangleStart + x] = n.references[v + x]
											} else l.triangleStart = v;
											l.triangleCount = y;
											break
										}
							};
						e.AsyncLoop.SyncAsyncForLoop(n.triangles.length, n.syncIterations, c, i, (function() {
							return a - s <= o
						}))
					}), 0)
				};
			e.AsyncLoop.Run(this.decimationIterations, (function(e) {
				a - s <= o ? e.breakLoop() : h(e.index, (function() {
					e.executeNext()
				}))
			}), (function() {
				setTimeout((function() {
					n.reconstructMesh(i), r()
				}), 0)
			}))
		}, t.prototype.initWithMesh = function(t, i, r) {
			var s = this;
			this.vertices = [], this.triangles = [];
			var a = this._mesh.getVerticesData(e.VertexBuffer.PositionKind),
				h = this._mesh.getIndices(),
				c = this._mesh.subMeshes[t],
				l = function(e) {
					if (r)
						for (var t = 0; t < s.vertices.length; ++t)
							if (s.vertices[t].position.equals(e)) return s.vertices[t];
					return null
				},
				u = [],
				d = function(t) {
					var i = t + c.verticesStart,
						r = e.Vector3.FromArray(a, 3 * i),
						n = l(r) || new o(r, s.vertices.length);
					n.originalOffsets.push(i), n.id === s.vertices.length && s.vertices.push(n), u.push(n.id)
				},
				f = c.verticesCount;
			e.AsyncLoop.SyncAsyncForLoop(f, this.syncIterations / 4 >> 0, d, (function() {
				var t = function(e) {
					var t = c.indexStart / 3 + e,
						i = 3 * t,
						r = h[i + 0],
						o = h[i + 1],
						a = h[i + 2],
						l = s.vertices[u[r - c.verticesStart]],
						d = s.vertices[u[o - c.verticesStart]],
						f = s.vertices[u[a - c.verticesStart]],
						p = new n([l, d, f]);
					p.originalOffset = i, s.triangles.push(p)
				};
				e.AsyncLoop.SyncAsyncForLoop(c.indexCount / 3, s.syncIterations, t, (function() {
					s.init(i)
				}))
			}))
		}, t.prototype.init = function(t) {
			var i = this,
				r = function(t) {
					var r = i.triangles[t];
					r.normal = e.Vector3.Cross(r.vertices[1].position.subtract(r.vertices[0].position), r.vertices[2].position.subtract(r.vertices[0].position)).normalize();
					for (var n = 0; n < 3; n++) r.vertices[n].q.addArrayInPlace(s.DataFromNumbers(r.normal.x, r.normal.y, r.normal.z, -e.Vector3.Dot(r.normal, r.vertices[0].position)))
				};
			e.AsyncLoop.SyncAsyncForLoop(this.triangles.length, this.syncIterations, r, (function() {
				var r = function(e) {
					for (var t = i.triangles[e], r = 0; r < 3; ++r) t.error[r] = i.calculateError(t.vertices[r], t.vertices[(r + 1) % 3]);
					t.error[3] = Math.min(t.error[0], t.error[1], t.error[2])
				};
				e.AsyncLoop.SyncAsyncForLoop(i.triangles.length, i.syncIterations, r, (function() {
					i.initialized = !0, t()
				}))
			}))
		}, t.prototype.reconstructMesh = function(t) {
			var i, r = [];
			for (i = 0; i < this.vertices.length; ++i) this.vertices[i].triangleCount = 0;
			var n, o;
			for (i = 0; i < this.triangles.length; ++i)
				if (!this.triangles[i].deleted) {
					for (n = this.triangles[i], o = 0; o < 3; ++o) n.vertices[o].triangleCount = 1;
					r.push(n)
				}
			var s = this._reconstructedMesh.getVerticesData(e.VertexBuffer.PositionKind) || [],
				a = this._reconstructedMesh.getVerticesData(e.VertexBuffer.NormalKind) || [],
				h = this._reconstructedMesh.getVerticesData(e.VertexBuffer.UVKind) || [],
				c = this._reconstructedMesh.getVerticesData(e.VertexBuffer.ColorKind) || [],
				l = this._mesh.getVerticesData(e.VertexBuffer.NormalKind),
				u = this._mesh.getVerticesData(e.VertexBuffer.UVKind),
				d = this._mesh.getVerticesData(e.VertexBuffer.ColorKind),
				f = 0;
			for (i = 0; i < this.vertices.length; ++i) {
				var p = this.vertices[i];
				p.id = f, p.triangleCount && p.originalOffsets.forEach((function(e) {
					s.push(p.position.x), s.push(p.position.y), s.push(p.position.z), a.push(l[3 * e]), a.push(l[3 * e + 1]), a.push(l[3 * e + 2]), u && u.length ? (h.push(u[2 * e]), h.push(u[2 * e + 1])) : d && d.length && (c.push(d[4 * e]), c.push(d[4 * e + 1]), c.push(d[4 * e + 2]), c.push(d[4 * e + 3])), ++f
				}))
			}
			var m = this._reconstructedMesh.getTotalIndices(),
				_ = this._reconstructedMesh.getTotalVertices(),
				g = this._reconstructedMesh.subMeshes;
			this._reconstructedMesh.subMeshes = [];
			var v = this._reconstructedMesh.getIndices(),
				y = this._mesh.getIndices();
			for (i = 0; i < r.length; ++i) n = r[i], [0, 1, 2].forEach((function(e) {
				var t = y[n.originalOffset + e],
					i = n.vertices[e].originalOffsets.indexOf(t);
				i < 0 && (i = 0), v.push(n.vertices[e].id + i + _)
			}));
			this._reconstructedMesh.setIndices(v), this._reconstructedMesh.setVerticesData(e.VertexBuffer.PositionKind, s), this._reconstructedMesh.setVerticesData(e.VertexBuffer.NormalKind, a), h.length > 0 && this._reconstructedMesh.setVerticesData(e.VertexBuffer.UVKind, h), c.length > 0 && this._reconstructedMesh.setVerticesData(e.VertexBuffer.ColorKind, c);
			var x = this._mesh.subMeshes[t];
			if (t > 0) {
				this._reconstructedMesh.subMeshes = [], g.forEach((function(t) {
					new e.SubMesh(t.materialIndex, t.verticesStart, t.verticesCount, t.indexStart, t.indexCount, t.getMesh())
				}));
				new e.SubMesh(x.materialIndex, _, f, m, 3 * r.length, this._reconstructedMesh)
			}
		}, t.prototype.initDecimatedMesh = function() {
			this._reconstructedMesh = new e.Mesh(this._mesh.name + "Decimated", this._mesh.getScene()), this._reconstructedMesh.material = this._mesh.material, this._reconstructedMesh.parent = this._mesh.parent, this._reconstructedMesh.isVisible = !1, this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId
		}, t.prototype.isFlipped = function(t, i, r, n, o, s) {
			for (var a = 0; a < t.triangleCount; ++a) {
				var h = this.triangles[this.references[t.triangleStart + a].triangleId];
				if (!h.deleted) {
					var c = this.references[t.triangleStart + a].vertexId,
						l = h.vertices[(c + 1) % 3],
						u = h.vertices[(c + 2) % 3];
					if (l !== i && u !== i) {
						var d = l.position.subtract(r);
						d = d.normalize();
						var f = u.position.subtract(r);
						if (f = f.normalize(), Math.abs(e.Vector3.Dot(d, f)) > .999) return !0;
						var p = e.Vector3.Cross(d, f).normalize();
						if (n[a] = !1, e.Vector3.Dot(p, h.normal) < .2) return !0
					} else n[a] = !0, s.push(h)
				}
			}
			return !1
		}, t.prototype.updateTriangles = function(e, t, i, r) {
			for (var n = r, o = 0; o < t.triangleCount; ++o) {
				var s = this.references[t.triangleStart + o],
					a = this.triangles[s.triangleId];
				a.deleted || (i[o] && a.deletePending ? (a.deleted = !0, n++) : (a.vertices[s.vertexId] = e, a.isDirty = !0, a.error[0] = this.calculateError(a.vertices[0], a.vertices[1]) + a.borderFactor / 2, a.error[1] = this.calculateError(a.vertices[1], a.vertices[2]) + a.borderFactor / 2, a.error[2] = this.calculateError(a.vertices[2], a.vertices[0]) + a.borderFactor / 2, a.error[3] = Math.min(a.error[0], a.error[1], a.error[2]), this.references.push(s)))
			}
			return n
		}, t.prototype.identifyBorder = function() {
			for (var e = 0; e < this.vertices.length; ++e) {
				var t, i = [],
					r = [],
					n = this.vertices[e];
				for (t = 0; t < n.triangleCount; ++t)
					for (var o = this.triangles[this.references[n.triangleStart + t].triangleId], s = 0; s < 3; s++) {
						for (var a = 0, h = o.vertices[s]; a < i.length && r[a] !== h.id;) ++a;
						a === i.length ? (i.push(1), r.push(h.id)) : i[a]++
					}
				for (t = 0; t < i.length; ++t) 1 === i[t] ? this.vertices[r[t]].isBorder = !0 : this.vertices[r[t]].isBorder = !1
			}
		}, t.prototype.updateMesh = function(e) {
			void 0 === e && (e = !1);
			var t;
			if (!e) {
				var i = [];
				for (t = 0; t < this.triangles.length; ++t) this.triangles[t].deleted || i.push(this.triangles[t]);
				this.triangles = i
			}
			for (t = 0; t < this.vertices.length; ++t) this.vertices[t].triangleCount = 0, this.vertices[t].triangleStart = 0;
			var r, n, o;
			for (t = 0; t < this.triangles.length; ++t)
				for (r = this.triangles[t], n = 0; n < 3; ++n) o = r.vertices[n], o.triangleCount++;
			var s = 0;
			for (t = 0; t < this.vertices.length; ++t) this.vertices[t].triangleStart = s, s += this.vertices[t].triangleCount, this.vertices[t].triangleCount = 0;
			var h = new Array(3 * this.triangles.length);
			for (t = 0; t < this.triangles.length; ++t)
				for (r = this.triangles[t], n = 0; n < 3; ++n) o = r.vertices[n], h[o.triangleStart + o.triangleCount] = new a(n, t), o.triangleCount++;
			this.references = h, e && this.identifyBorder()
		}, t.prototype.vertexError = function(e, t) {
			var i = t.x,
				r = t.y,
				n = t.z;
			return e.data[0] * i * i + 2 * e.data[1] * i * r + 2 * e.data[2] * i * n + 2 * e.data[3] * i + e.data[4] * r * r + 2 * e.data[5] * r * n + 2 * e.data[6] * r + e.data[7] * n * n + 2 * e.data[8] * n + e.data[9]
		}, t.prototype.calculateError = function(t, i, r, n, o, s) {
			var a = t.q.add(i.q),
				h = t.isBorder && i.isBorder,
				c = 0,
				l = a.det(0, 1, 2, 1, 4, 5, 2, 5, 7);
			if (0 === l || h) {
				var u = t.position.add(i.position).divide(new e.Vector3(2, 2, 2)),
					d = this.vertexError(a, t.position),
					f = this.vertexError(a, i.position),
					p = this.vertexError(a, u);
				c = Math.min(d, f, p), c === d ? r && r.copyFrom(t.position) : c === f ? r && r.copyFrom(i.position) : r && r.copyFrom(u)
			} else r || (r = e.Vector3.Zero()), r.x = -1 / l * a.det(1, 2, 3, 4, 5, 6, 5, 7, 8), r.y = 1 / l * a.det(0, 2, 3, 1, 5, 6, 2, 7, 8), r.z = -1 / l * a.det(0, 1, 3, 1, 4, 6, 2, 5, 8), c = this.vertexError(a, r);
			return c
		}, t
	})();
	e.QuadraticErrorSimplification = h
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = [],
		i = function(i, r) {
			if (!t[i.id] && !i.doNotSerialize) {
				if (i instanceof e.Geometry.Primitives.Box) r.boxes.push(i.serialize());
				else if (i instanceof e.Geometry.Primitives.Sphere) r.spheres.push(i.serialize());
				else if (i instanceof e.Geometry.Primitives.Cylinder) r.cylinders.push(i.serialize());
				else if (i instanceof e.Geometry.Primitives.Torus) r.toruses.push(i.serialize());
				else if (i instanceof e.Geometry.Primitives.Ground) r.grounds.push(i.serialize());
				else if (i instanceof e.Geometry.Primitives.Plane) r.planes.push(i.serialize());
				else if (i instanceof e.Geometry.Primitives.TorusKnot) r.torusKnots.push(i.serialize());
				else {
					if (i instanceof e.Geometry.Primitives._Primitive) throw new Error("Unknown primitive type");
					r.vertexData.push(i.serializeVerticeData())
				}
				t[i.id] = !0
			}
		},
		r = function(t, r) {
			var n = {};
			n.name = t.name, n.id = t.id, e.Tags.HasTags(t) && (n.tags = e.Tags.GetTags(t)), n.position = t.position.asArray(), t.rotationQuaternion ? n.rotationQuaternion = t.rotationQuaternion.asArray() : t.rotation && (n.rotation = t.rotation.asArray()), n.scaling = t.scaling.asArray(), n.localMatrix = t.getPivotMatrix().asArray(), n.isEnabled = t.isEnabled(), n.isVisible = t.isVisible, n.infiniteDistance = t.infiniteDistance, n.pickable = t.isPickable, n.receiveShadows = t.receiveShadows, n.billboardMode = t.billboardMode, n.visibility = t.visibility, n.checkCollisions = t.checkCollisions, n.isBlocker = t.isBlocker, t.parent && (n.parentId = t.parent.id);
			var o = t._geometry;
			if (o) {
				var s = o.id;
				n.geometryId = s, t.getScene().getGeometryByID(s) || i(o, r.geometries), n.subMeshes = [];
				for (var a = 0; a < t.subMeshes.length; a++) {
					var h = t.subMeshes[a];
					n.subMeshes.push({
						materialIndex: h.materialIndex,
						verticesStart: h.verticesStart,
						verticesCount: h.verticesCount,
						indexStart: h.indexStart,
						indexCount: h.indexCount
					})
				}
			}
			t.material ? n.materialId = t.material.id : t.material = null, t.skeleton && (n.skeletonId = t.skeleton.id), t.getPhysicsImpostor() && (n.physicsMass = t.getPhysicsMass(), n.physicsFriction = t.getPhysicsFriction(), n.physicsRestitution = t.getPhysicsRestitution(), n.physicsImpostor = t.getPhysicsImpostor().type), t.metadata && (n.metadata = t.metadata), n.instances = [];
			for (var c = 0; c < t.instances.length; c++) {
				var l = t.instances[c],
					u = {
						name: l.name,
						position: l.position.asArray(),
						scaling: l.scaling.asArray()
					};
				l.rotationQuaternion ? u.rotationQuaternion = l.rotationQuaternion.asArray() : l.rotation && (u.rotation = l.rotation.asArray()), n.instances.push(u), e.Animation.AppendSerializedAnimations(l, u), u.ranges = l.serializeAnimationRanges()
			}
			return e.Animation.AppendSerializedAnimations(t, n), n.ranges = t.serializeAnimationRanges(), n.layerMask = t.layerMask, n.alphaIndex = t.alphaIndex, n.hasVertexAlpha = t.hasVertexAlpha, n.overlayAlpha = t.overlayAlpha, n.overlayColor = t.overlayColor.asArray(), n.renderOverlay = t.renderOverlay, n.applyFog = t.applyFog, t.actionManager && (n.actions = t.actionManager.serialize(t.name)), n
		},
		n = function(t, n) {
			if (t.delayLoadState === e.Engine.DELAYLOADSTATE_LOADED || t.delayLoadState === e.Engine.DELAYLOADSTATE_NONE) {
				t.material && (t.material instanceof e.StandardMaterial ? (n.materials = n.materials || [], n.materials.some((function(e) {
					return e.id === t.material.id
				})) || n.materials.push(t.material.serialize())) : t.material instanceof e.MultiMaterial && (n.multiMaterials = n.multiMaterials || [], n.multiMaterials.some((function(e) {
					return e.id === t.material.id
				})) || n.multiMaterials.push(t.material.serialize())));
				var o = t._geometry;
				o && (n.geometries || (n.geometries = {}, n.geometries.boxes = [], n.geometries.spheres = [], n.geometries.cylinders = [], n.geometries.toruses = [], n.geometries.grounds = [], n.geometries.planes = [], n.geometries.torusKnots = [], n.geometries.vertexData = []), i(o, n.geometries)), t.skeleton && (n.skeletons = n.skeletons || [], n.skeletons.push(t.skeleton.serialize())), n.meshes = n.meshes || [], n.meshes.push(r(t, n))
			}
		},
		o = (function() {
			function o() {}
			return o.ClearCache = function() {
				t = []
			}, o.Serialize = function(n) {
				var o = {};
				o.useDelayedTextureLoading = n.useDelayedTextureLoading, o.autoClear = n.autoClear, o.clearColor = n.clearColor.asArray(), o.ambientColor = n.ambientColor.asArray(), o.gravity = n.gravity.asArray(), o.collisionsEnabled = n.collisionsEnabled, o.workerCollisions = n.workerCollisions, n.fogMode && 0 !== n.fogMode && (o.fogMode = n.fogMode, o.fogColor = n.fogColor.asArray(), o.fogStart = n.fogStart, o.fogEnd = n.fogEnd, o.fogDensity = n.fogDensity), n.isPhysicsEnabled() && (o.physicsEnabled = !0, o.physicsGravity = n.getPhysicsEngine().gravity.asArray(), o.physicsEngine = n.getPhysicsEngine().getPhysicsPluginName()), n.metadata && (o.metadata = n.metadata), o.lights = [];
				var s, a;
				for (s = 0; s < n.lights.length; s++) a = n.lights[s], a.doNotSerialize || o.lights.push(a.serialize());
				for (o.cameras = [], s = 0; s < n.cameras.length; s++) {
					var h = n.cameras[s];
					h.doNotSerialize || o.cameras.push(h.serialize())
				}
				n.activeCamera && (o.activeCameraID = n.activeCamera.id), e.Animation.AppendSerializedAnimations(n, o), o.materials = [], o.multiMaterials = [];
				var c;
				for (s = 0; s < n.materials.length; s++) c = n.materials[s], c.doNotSerialize || o.materials.push(c.serialize());
				for (o.multiMaterials = [], s = 0; s < n.multiMaterials.length; s++) {
					var l = n.multiMaterials[s];
					o.multiMaterials.push(l.serialize())
				}
				for (o.skeletons = [], s = 0; s < n.skeletons.length; s++) o.skeletons.push(n.skeletons[s].serialize());
				o.geometries = {}, o.geometries.boxes = [], o.geometries.spheres = [], o.geometries.cylinders = [], o.geometries.toruses = [], o.geometries.grounds = [], o.geometries.planes = [], o.geometries.torusKnots = [], o.geometries.vertexData = [], t = [];
				var u = n.getGeometries();
				for (s = 0; s < u.length; s++) {
					var d = u[s];
					d.isReady() && i(d, o.geometries)
				}
				for (o.meshes = [], s = 0; s < n.meshes.length; s++) {
					var f = n.meshes[s];
					if (f instanceof e.Mesh) {
						var p = f;
						p.doNotSerialize || p.delayLoadState !== e.Engine.DELAYLOADSTATE_LOADED && p.delayLoadState !== e.Engine.DELAYLOADSTATE_NONE || o.meshes.push(r(p, o))
					}
				}
				for (o.particleSystems = [], s = 0; s < n.particleSystems.length; s++) o.particleSystems.push(n.particleSystems[s].serialize());
				for (o.lensFlareSystems = [], s = 0; s < n.lensFlareSystems.length; s++) o.lensFlareSystems.push(n.lensFlareSystems[s].serialize());
				for (o.shadowGenerators = [], s = 0; s < n.lights.length; s++) {
					a = n.lights[s];
					var m = a.getShadowGenerator();
					m && m instanceof e.ShadowGenerator && o.shadowGenerators.push(m.serialize())
				}
				for (n.actionManager && (o.actions = n.actionManager.serialize("scene")), o.sounds = [], s = 0; s < n.soundTracks.length; s++)
					for (var _ = n.soundTracks[s], g = 0; g < _.soundCollection.length; g++) o.sounds.push(_.soundCollection[g].serialize());
				return o
			}, o.SerializeMesh = function(t, i, r) {
				void 0 === i && (i = !1), void 0 === r && (r = !1);
				var o = {};
				if (t = t instanceof Array ? t : [t], i || r)
					for (var s = 0; s < t.length; ++s) r && t[s].getDescendants().forEach((function(i) {
						i instanceof e.Mesh && t.indexOf(i) < 0 && t.push(i)
					})), i && t[s].parent && t.indexOf(t[s].parent) < 0 && t.push(t[s].parent);
				return t.forEach((function(e) {
					n(e, o)
				})), o
			}, o
		})();
	e.SceneSerializer = o
})(BABYLON || (BABYLON = {}));
var Earcut;
!(function(e) {
	function t(e, t, r) {
		r = r || 2;
		var o = t && t.length,
			s = o ? t[0] * r : e.length,
			a = i(e, 0, s, r, !0),
			h = [];
		if (!a) return h;
		var l, u, d, f, p, m, _;
		if (o && (a = c(e, t, a, r)), e.length > 80 * r) {
			l = d = e[0], u = f = e[1];
			for (var g = r; g < s; g += r) p = e[g], m = e[g + 1], p < l && (l = p), m < u && (u = m), p > d && (d = p), m > f && (f = m);
			_ = Math.max(d - l, f - u)
		}
		return n(a, h, r, l, u, _, void 0), h
	}

	function i(e, t, i, r, n) {
		var o, s;
		if (n === O(e, t, i, r) > 0)
			for (o = t; o < i; o += r) s = M(o, e[o], e[o + 1], s);
		else
			for (o = i - r; o >= t; o -= r) s = M(o, e[o], e[o + 1], s);
		return s && x(s, s.next) && (S(s), s = s.next), s
	}

	function r(e, t) {
		if (!e) return e;
		t || (t = e);
		var i, r = e;
		do
			if (i = !1, r.steiner || !x(r, r.next) && 0 !== y(r.prev, r, r.next)) r = r.next;
			else {
				if (S(r), r = t = r.prev, r === r.next) return null;
				i = !0
			}
		while (i || r !== t);
		return t
	}

	function n(e, t, i, c, l, u, d) {
		if (e) {
			!d && u && f(e, c, l, u);
			for (var p, m, _ = e; e.prev !== e.next;)
				if (p = e.prev, m = e.next, u ? s(e, c, l, u) : o(e)) t.push(p.i / i), t.push(e.i / i), t.push(m.i / i), S(e), e = m.next, _ = m.next;
				else if (e = m, e === _) {
				d ? 1 === d ? (e = a(e, t, i), n(e, t, i, c, l, u, 2)) : 2 === d && h(e, t, i, c, l, u) : n(r(e, void 0), t, i, c, l, u, 1);
				break
			}
		}
	}

	function o(e) {
		var t = e.prev,
			i = e,
			r = e.next;
		if (y(t, i, r) >= 0) return !1;
		for (var n = e.next.next; n !== e.prev;) {
			if (g(t.x, t.y, i.x, i.y, r.x, r.y, n.x, n.y) && y(n.prev, n, n.next) >= 0) return !1;
			n = n.next
		}
		return !0
	}

	function s(e, t, i, r) {
		var n = e.prev,
			o = e,
			s = e.next;
		if (y(n, o, s) >= 0) return !1;
		for (var a = n.x < o.x ? n.x < s.x ? n.x : s.x : o.x < s.x ? o.x : s.x, h = n.y < o.y ? n.y < s.y ? n.y : s.y : o.y < s.y ? o.y : s.y, c = n.x > o.x ? n.x > s.x ? n.x : s.x : o.x > s.x ? o.x : s.x, l = n.y > o.y ? n.y > s.y ? n.y : s.y : o.y > s.y ? o.y : s.y, u = m(a, h, t, i, r), d = m(c, l, t, i, r), f = e.nextZ; f && f.z <= d;) {
			if (f !== e.prev && f !== e.next && g(n.x, n.y, o.x, o.y, s.x, s.y, f.x, f.y) && y(f.prev, f, f.next) >= 0) return !1;
			f = f.nextZ
		}
		for (f = e.prevZ; f && f.z >= u;) {
			if (f !== e.prev && f !== e.next && g(n.x, n.y, o.x, o.y, s.x, s.y, f.x, f.y) && y(f.prev, f, f.next) >= 0) return !1;
			f = f.prevZ
		}
		return !0
	}

	function a(e, t, i) {
		var r = e;
		do {
			var n = r.prev,
				o = r.next.next;
			!x(n, o) && b(n, r, r.next, o) && A(n, o) && A(o, n) && (t.push(n.i / i), t.push(r.i / i), t.push(o.i / i), S(r), S(r.next), r = e = o), r = r.next
		} while (r !== e);
		return r
	}

	function h(e, t, i, o, s, a) {
		var h = e;
		do {
			for (var c = h.next.next; c !== h.prev;) {
				if (h.i !== c.i && v(h, c)) {
					var l = P(h, c);
					return h = r(h, h.next), l = r(l, l.next), n(h, t, i, o, s, a, void 0), void n(l, t, i, o, s, a, void 0)
				}
				c = c.next
			}
			h = h.next
		} while (h !== e)
	}

	function c(e, t, n, o) {
		var s, a, h, c, d, f = [];
		for (s = 0, a = t.length; s < a; s++) h = t[s] * o, c = s < a - 1 ? t[s + 1] * o : e.length, d = i(e, h, c, o, !1), d === d.next && (d.steiner = !0), f.push(_(d));
		for (f.sort(l), s = 0; s < f.length; s++) u(f[s], n), n = r(n, n.next);
		return n
	}

	function l(e, t) {
		return e.x - t.x
	}

	function u(e, t) {
		if (t = d(e, t)) {
			var i = P(t, e);
			r(i, i.next)
		}
	}

	function d(e, t) {
		var i, r = t,
			n = e.x,
			o = e.y,
			s = -(1 / 0);
		do {
			if (o <= r.y && o >= r.next.y) {
				var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
				if (a <= n && a > s) {
					if (s = a, a === n) {
						if (o === r.y) return r;
						if (o === r.next.y) return r.next
					}
					i = r.x < r.next.x ? r : r.next
				}
			}
			r = r.next
		} while (r !== t);
		if (!i) return null;
		if (n === s) return i.prev;
		var h, c = i,
			l = i.x,
			u = i.y,
			d = 1 / 0;
		for (r = i.next; r !== c;) n >= r.x && r.x >= l && g(o < u ? n : s, o, l, u, o < u ? s : n, o, r.x, r.y) && (h = Math.abs(o - r.y) / (n - r.x), (h < d || h === d && r.x > i.x) && A(r, e) && (i = r, d = h)), r = r.next;
		return i
	}

	function f(e, t, i, r) {
		var n = e;
		do null === n.z && (n.z = m(n.x, n.y, t, i, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next; while (n !== e);
		n.prevZ.nextZ = null, n.prevZ = null, p(n)
	}

	function p(e) {
		var t, i, r, n, o, s, a, h, c = 1;
		do {
			for (i = e, e = null, o = null, s = 0; i;) {
				for (s++, r = i, a = 0, t = 0; t < c && (a++, r = r.nextZ, r); t++);
				for (h = c; a > 0 || h > 0 && r;) 0 === a ? (n = r, r = r.nextZ, h--) : 0 !== h && r ? i.z <= r.z ? (n = i, i = i.nextZ, a--) : (n = r, r = r.nextZ, h--) : (n = i, i = i.nextZ, a--), o ? o.nextZ = n : e = n, n.prevZ = o, o = n;
				i = r
			}
			o.nextZ = null, c *= 2
		} while (s > 1);
		return e
	}

	function m(e, t, i, r, n) {
		return e = 32767 * (e - i) / n, t = 32767 * (t - r) / n, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e | t << 1
	}

	function _(e) {
		var t = e,
			i = e;
		do t.x < i.x && (i = t), t = t.next; while (t !== e);
		return i
	}

	function g(e, t, i, r, n, o, s, a) {
		return (n - s) * (t - a) - (e - s) * (o - a) >= 0 && (e - s) * (r - a) - (i - s) * (t - a) >= 0 && (i - s) * (o - a) - (n - s) * (r - a) >= 0
	}

	function v(e, t) {
		return e.next.i !== t.i && e.prev.i !== t.i && !T(e, t) && A(e, t) && A(t, e) && E(e, t)
	}

	function y(e, t, i) {
		return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
	}

	function x(e, t) {
		return e.x === t.x && e.y === t.y
	}

	function b(e, t, i, r) {
		return !!(x(e, t) && x(i, r) || x(e, r) && x(i, t)) || y(e, t, i) > 0 != y(e, t, r) > 0 && y(i, r, e) > 0 != y(i, r, t) > 0
	}

	function T(e, t) {
		var i = e;
		do {
			if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && b(i, i.next, e, t)) return !0;
			i = i.next
		} while (i !== e);
		return !1
	}

	function A(e, t) {
		return y(e.prev, e, e.next) < 0 ? y(e, t, e.next) >= 0 && y(e, e.prev, t) >= 0 : y(e, t, e.prev) < 0 || y(e, e.next, t) < 0
	}

	function E(e, t) {
		var i = e,
			r = !1,
			n = (e.x + t.x) / 2,
			o = (e.y + t.y) / 2;
		do i.y > o != i.next.y > o && n < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (r = !r), i = i.next; while (i !== e);
		return r
	}

	function P(e, t) {
		var i = new C(e.i, e.x, e.y),
			r = new C(t.i, t.x, t.y),
			n = e.next,
			o = t.prev;
		return e.next = t, t.prev = e, i.next = n, n.prev = i, r.next = i, i.prev = r, o.next = r, r.prev = o, r
	}

	function M(e, t, i, r) {
		var n = new C(e, t, i);
		return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n
	}

	function S(e) {
		e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
	}

	function C(e, t, i) {
		this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
	}

	function R(e, t, i, r) {
		var n = t && t.length,
			o = n ? t[0] * i : e.length,
			s = Math.abs(O(e, 0, o, i));
		if (n)
			for (var a = 0, h = t.length; a < h; a++) {
				var c = t[a] * i,
					l = a < h - 1 ? t[a + 1] * i : e.length;
				s -= Math.abs(O(e, c, l, i))
			}
		var u = 0;
		for (a = 0; a < r.length; a += 3) {
			var d = r[a] * i,
				f = r[a + 1] * i,
				p = r[a + 2] * i;
			u += Math.abs((e[d] - e[p]) * (e[f + 1] - e[d + 1]) - (e[d] - e[f]) * (e[p + 1] - e[d + 1]))
		}
		return 0 === s && 0 === u ? 0 : Math.abs((u - s) / s)
	}

	function O(e, t, i, r) {
		for (var n = 0, o = t, s = i - r; o < i; o += r) n += (e[s] - e[o]) * (e[o + 1] + e[s + 1]), s = o;
		return n
	}

	function D(e) {
		for (var t = e[0][0].length, i = {
				vertices: [],
				holes: [],
				dimensions: t
			}, r = 0, n = 0; n < e.length; n++) {
			for (var o = 0; o < e[n].length; o++)
				for (var s = 0; s < t; s++) i.vertices.push(e[n][o][s]);
			n > 0 && (r += e[n - 1].length, i.holes.push(r))
		}
		return i
	}
	e.earcut = t, e.deviation = R, e.flatten = D
})(Earcut || (Earcut = {}));
var BABYLON;
!(function(e) {
	var t = 0,
		i = (function() {
			function t(e, t, i) {
				this.pos = e, this.normal = t, this.uv = i
			}
			return t.prototype.clone = function() {
				return new t(this.pos.clone(), this.normal.clone(), this.uv.clone())
			}, t.prototype.flip = function() {
				this.normal = this.normal.scale(-1)
			}, t.prototype.interpolate = function(i, r) {
				return new t(e.Vector3.Lerp(this.pos, i.pos, r), e.Vector3.Lerp(this.normal, i.normal, r), e.Vector2.Lerp(this.uv, i.uv, r))
			}, t
		})(),
		r = (function() {
			function t(e, t) {
				this.normal = e, this.w = t
			}
			return t.FromPoints = function(i, r, n) {
				var o = n.subtract(i),
					s = r.subtract(i);
				if (0 === o.lengthSquared() || 0 === s.lengthSquared()) return null;
				var a = e.Vector3.Normalize(e.Vector3.Cross(o, s));
				return new t(a, e.Vector3.Dot(a, i))
			}, t.prototype.clone = function() {
				return new t(this.normal.clone(), this.w)
			}, t.prototype.flip = function() {
				this.normal.scaleInPlace(-1), this.w = -this.w
			}, t.prototype.splitPolygon = function(i, r, o, s, a) {
				var h, c, l = 0,
					u = 1,
					d = 2,
					f = 3,
					p = 0,
					m = [];
				for (h = 0; h < i.vertices.length; h++) {
					c = e.Vector3.Dot(this.normal, i.vertices[h].pos) - this.w;
					var _ = c < -t.EPSILON ? d : c > t.EPSILON ? u : l;
					p |= _, m.push(_)
				}
				switch (p) {
					case l:
						(e.Vector3.Dot(this.normal, i.plane.normal) > 0 ? r : o).push(i);
						break;
					case u:
						s.push(i);
						break;
					case d:
						a.push(i);
						break;
					case f:
						var g = [],
							v = [];
						for (h = 0; h < i.vertices.length; h++) {
							var y = (h + 1) % i.vertices.length,
								x = m[h],
								b = m[y],
								T = i.vertices[h],
								A = i.vertices[y];
							if (x !== d && g.push(T), x !== u && v.push(x !== d ? T.clone() : T), (x | b) === f) {
								c = (this.w - e.Vector3.Dot(this.normal, T.pos)) / e.Vector3.Dot(this.normal, A.pos.subtract(T.pos));
								var E = T.interpolate(A, c);
								g.push(E), v.push(E.clone())
							}
						}
						var P;
						g.length >= 3 && (P = new n(g, i.shared), P.plane && s.push(P)), v.length >= 3 && (P = new n(v, i.shared), P.plane && a.push(P))
				}
			}, t.EPSILON = 1e-5, t
		})(),
		n = (function() {
			function e(e, t) {
				this.vertices = e, this.shared = t, this.plane = r.FromPoints(e[0].pos, e[1].pos, e[2].pos)
			}
			return e.prototype.clone = function() {
				var t = this.vertices.map((function(e) {
					return e.clone()
				}));
				return new e(t, this.shared)
			}, e.prototype.flip = function() {
				this.vertices.reverse().map((function(e) {
					e.flip()
				})), this.plane.flip()
			}, e
		})(),
		o = (function() {
			function e(e) {
				this.plane = null, this.front = null, this.back = null, this.polygons = [], e && this.build(e)
			}
			return e.prototype.clone = function() {
				var t = new e;
				return t.plane = this.plane && this.plane.clone(), t.front = this.front && this.front.clone(), t.back = this.back && this.back.clone(), t.polygons = this.polygons.map((function(e) {
					return e.clone()
				})), t
			}, e.prototype.invert = function() {
				for (var e = 0; e < this.polygons.length; e++) this.polygons[e].flip();
				this.plane && this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert();
				var t = this.front;
				this.front = this.back, this.back = t
			}, e.prototype.clipPolygons = function(e) {
				if (!this.plane) return e.slice();
				for (var t = [], i = [], r = 0; r < e.length; r++) this.plane.splitPolygon(e[r], t, i, t, i);
				return this.front && (t = this.front.clipPolygons(t)), i = this.back ? this.back.clipPolygons(i) : [], t.concat(i)
			}, e.prototype.clipTo = function(e) {
				this.polygons = e.clipPolygons(this.polygons), this.front && this.front.clipTo(e), this.back && this.back.clipTo(e)
			}, e.prototype.allPolygons = function() {
				var e = this.polygons.slice();
				return this.front && (e = e.concat(this.front.allPolygons())), this.back && (e = e.concat(this.back.allPolygons())), e
			}, e.prototype.build = function(t) {
				if (t.length) {
					this.plane || (this.plane = t[0].plane.clone());
					for (var i = [], r = [], n = 0; n < t.length; n++) this.plane.splitPolygon(t[n], this.polygons, this.polygons, i, r);
					i.length && (this.front || (this.front = new e), this.front.build(i)), r.length && (this.back || (this.back = new e), this.back.build(r))
				}
			}, e
		})(),
		s = (function() {
			function r() {
				this.polygons = new Array
			}
			return r.FromMesh = function(o) {
				var s, a, h, c, l, u, d, f, p, m, _, g = new Array;
				if (!(o instanceof e.Mesh)) throw "BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh";
				o.computeWorldMatrix(!0), d = o.getWorldMatrix(), f = o.position.clone(), p = o.rotation.clone(), o.rotationQuaternion && (m = o.rotationQuaternion.clone()), _ = o.scaling.clone();
				for (var v = o.getIndices(), y = o.getVerticesData(e.VertexBuffer.PositionKind), x = o.getVerticesData(e.VertexBuffer.NormalKind), b = o.getVerticesData(e.VertexBuffer.UVKind), T = o.subMeshes, A = 0, E = T.length; A < E; A++)
					for (var P = T[A].indexStart, M = T[A].indexCount + T[A].indexStart; P < M; P += 3) {
						u = [];
						for (var S = 0; S < 3; S++) {
							var C = new e.Vector3(x[3 * v[P + S]], x[3 * v[P + S] + 1], x[3 * v[P + S] + 2]);
							h = new e.Vector2(b[2 * v[P + S]], b[2 * v[P + S] + 1]);
							var R = new e.Vector3(y[3 * v[P + S]], y[3 * v[P + S] + 1], y[3 * v[P + S] + 2]);
							c = e.Vector3.TransformCoordinates(R, d), a = e.Vector3.TransformNormal(C, d), s = new i(c, a, h), u.push(s)
						}
						l = new n(u, {
							subMeshId: A,
							meshId: t,
							materialIndex: T[A].materialIndex
						}), l.plane && g.push(l)
					}
				var O = r.FromPolygons(g);
				return O.matrix = d, O.position = f, O.rotation = p, O.scaling = _, O.rotationQuaternion = m, t++, O
			}, r.FromPolygons = function(e) {
				var t = new r;
				return t.polygons = e, t
			}, r.prototype.clone = function() {
				var e = new r;
				return e.polygons = this.polygons.map((function(e) {
					return e.clone()
				})), e.copyTransformAttributes(this), e
			}, r.prototype.toPolygons = function() {
				return this.polygons
			}, r.prototype.union = function(e) {
				var t = new o(this.clone().polygons),
					i = new o(e.clone().polygons);
				return t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), r.FromPolygons(t.allPolygons()).copyTransformAttributes(this)
			}, r.prototype.unionInPlace = function(e) {
				var t = new o(this.polygons),
					i = new o(e.polygons);
				t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), this.polygons = t.allPolygons()
			}, r.prototype.subtract = function(e) {
				var t = new o(this.clone().polygons),
					i = new o(e.clone().polygons);
				return t.invert(), t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), t.invert(), r.FromPolygons(t.allPolygons()).copyTransformAttributes(this)
			}, r.prototype.subtractInPlace = function(e) {
				var t = new o(this.polygons),
					i = new o(e.polygons);
				t.invert(), t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), t.invert(), this.polygons = t.allPolygons()
			}, r.prototype.intersect = function(e) {
				var t = new o(this.clone().polygons),
					i = new o(e.clone().polygons);
				return t.invert(), i.clipTo(t), i.invert(), t.clipTo(i), i.clipTo(t), t.build(i.allPolygons()), t.invert(), r.FromPolygons(t.allPolygons()).copyTransformAttributes(this)
			}, r.prototype.intersectInPlace = function(e) {
				var t = new o(this.polygons),
					i = new o(e.polygons);
				t.invert(), i.clipTo(t), i.invert(), t.clipTo(i), i.clipTo(t), t.build(i.allPolygons()), t.invert(), this.polygons = t.allPolygons()
			}, r.prototype.inverse = function() {
				var e = this.clone();
				return e.inverseInPlace(), e
			}, r.prototype.inverseInPlace = function() {
				this.polygons.map((function(e) {
					e.flip()
				}))
			}, r.prototype.copyTransformAttributes = function(e) {
				return this.matrix = e.matrix, this.position = e.position, this.rotation = e.rotation, this.scaling = e.scaling, this.rotationQuaternion = e.rotationQuaternion, this
			}, r.prototype.buildMeshGeometry = function(t, i, r) {
				var n = this.matrix.clone();
				n.invert();
				var o, s, a, h = new e.Mesh(t, i),
					c = [],
					l = [],
					u = [],
					d = [],
					f = e.Vector3.Zero(),
					p = e.Vector3.Zero(),
					m = e.Vector2.Zero(),
					_ = this.polygons,
					g = [0, 0, 0],
					v = {},
					y = 0,
					x = {};
				r && _.sort((function(e, t) {
					return e.shared.meshId === t.shared.meshId ? e.shared.subMeshId - t.shared.subMeshId : e.shared.meshId - t.shared.meshId
				}));
				for (var b = 0, T = _.length; b < T; b++) {
					o = _[b], x[o.shared.meshId] || (x[o.shared.meshId] = {}), x[o.shared.meshId][o.shared.subMeshId] || (x[o.shared.meshId][o.shared.subMeshId] = {
						indexStart: +(1 / 0),
						indexEnd: -(1 / 0),
						materialIndex: o.shared.materialIndex
					}), a = x[o.shared.meshId][o.shared.subMeshId];
					for (var A = 2, E = o.vertices.length; A < E; A++) {
						g[0] = 0, g[1] = A - 1, g[2] = A;
						for (var P = 0; P < 3; P++) {
							f.copyFrom(o.vertices[g[P]].pos), p.copyFrom(o.vertices[g[P]].normal), m.copyFrom(o.vertices[g[P]].uv);
							var M = e.Vector3.TransformCoordinates(f, n),
								S = e.Vector3.TransformNormal(p, n);
							s = v[M.x + "," + M.y + "," + M.z], "undefined" != typeof s && u[3 * s] === S.x && u[3 * s + 1] === S.y && u[3 * s + 2] === S.z && d[2 * s] === m.x && d[2 * s + 1] === m.y || (c.push(M.x, M.y, M.z), d.push(m.x, m.y), u.push(p.x, p.y, p.z), s = v[M.x + "," + M.y + "," + M.z] = c.length / 3 - 1), l.push(s), a.indexStart = Math.min(y, a.indexStart), a.indexEnd = Math.max(y, a.indexEnd), y++
						}
					}
				}
				if (h.setVerticesData(e.VertexBuffer.PositionKind, c), h.setVerticesData(e.VertexBuffer.NormalKind, u), h.setVerticesData(e.VertexBuffer.UVKind, d), h.setIndices(l), r) {
					var C, R = 0;
					h.subMeshes = new Array;
					for (var O in x) {
						C = -1;
						for (var D in x[O]) a = x[O][D], e.SubMesh.CreateFromIndices(a.materialIndex + R, a.indexStart, a.indexEnd - a.indexStart + 1, h), C = Math.max(a.materialIndex, C);
						R += ++C
					}
				}
				return h
			}, r.prototype.toMesh = function(e, t, i, r) {
				var n = this.buildMeshGeometry(e, i, r);
				return n.material = t, n.position.copyFrom(this.position), n.rotation.copyFrom(this.rotation), this.rotationQuaternion && (n.rotationQuaternion = this.rotationQuaternion.clone()), n.scaling.copyFrom(this.scaling), n.computeWorldMatrix(!0), n
			}, r
		})();
	e.CSG = s
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o) {
			var s = this;
			t.call(this, i, "vrDistortionCorrection", ["LensCenter", "Scale", "ScaleIn", "HmdWarpParam"], null, o.postProcessScaleFactor, r, e.Texture.BILINEAR_SAMPLINGMODE, null, null), this._isRightEye = n, this._distortionFactors = o.distortionK, this._postProcessScaleFactor = o.postProcessScaleFactor, this._lensCenterOffset = o.lensCenterOffset, this.onSizeChangedObservable.add((function() {
				s.aspectRatio = .5 * s.width / s.height, s._scaleIn = new e.Vector2(2, 2 / s.aspectRatio), s._scaleFactor = new e.Vector2(.5 * (1 / s._postProcessScaleFactor), .5 * (1 / s._postProcessScaleFactor) * s.aspectRatio), s._lensCenter = new e.Vector2(s._isRightEye ? .5 - .5 * s._lensCenterOffset : .5 + .5 * s._lensCenterOffset, .5)
			})), this.onApplyObservable.add((function(e) {
				e.setFloat2("LensCenter", s._lensCenter.x, s._lensCenter.y), e.setFloat2("Scale", s._scaleFactor.x, s._scaleFactor.y), e.setFloat2("ScaleIn", s._scaleIn.x, s._scaleIn.y), e.setFloat4("HmdWarpParam", s._distortionFactors[0], s._distortionFactors[1], s._distortionFactors[2], s._distortionFactors[3])
			}))
		}
		return __extends(i, t), i
	})(e.PostProcess);
	e.VRDistortionCorrectionPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	!(function(e) {
		e[e.X = 0] = "X", e[e.Y = 1] = "Y", e[e.Z = 2] = "Z"
	})(e.JoystickAxis || (e.JoystickAxis = {}));
	var t = e.JoystickAxis,
		i = (function() {
			function i(r) {
				var n = this;
				r ? this._leftJoystick = !0 : this._leftJoystick = !1, this._joystickIndex = i._globalJoystickIndex, i._globalJoystickIndex++, this._axisTargetedByLeftAndRight = t.X, this._axisTargetedByUpAndDown = t.Y, this.reverseLeftRight = !1, this.reverseUpDown = !1, this._touches = new e.StringDictionary, this.deltaPosition = e.Vector3.Zero(), this._joystickSensibility = 25, this._inversedSensibility = 1 / (this._joystickSensibility / 1e3), this._rotationSpeed = 25, this._inverseRotationSpeed = 1 / (this._rotationSpeed / 1e3), this._rotateOnAxisRelativeToMesh = !1, this._onResize = function(e) {
					i.vjCanvasWidth = window.innerWidth, i.vjCanvasHeight = window.innerHeight, i.vjCanvas.width = i.vjCanvasWidth, i.vjCanvas.height = i.vjCanvasHeight, i.halfWidth = i.vjCanvasWidth / 2, i.halfHeight = i.vjCanvasHeight / 2
				}, i.vjCanvas || (window.addEventListener("resize", this._onResize, !1), i.vjCanvas = document.createElement("canvas"), i.vjCanvasWidth = window.innerWidth, i.vjCanvasHeight = window.innerHeight, i.vjCanvas.width = window.innerWidth, i.vjCanvas.height = window.innerHeight, i.vjCanvas.style.width = "100%", i.vjCanvas.style.height = "100%", i.vjCanvas.style.position = "absolute", i.vjCanvas.style.backgroundColor = "transparent", i.vjCanvas.style.top = "0px", i.vjCanvas.style.left = "0px", i.vjCanvas.style.zIndex = "5", i.vjCanvas.style.msTouchAction = "none", i.vjCanvas.setAttribute("touch-action", "none"), i.vjCanvasContext = i.vjCanvas.getContext("2d"), i.vjCanvasContext.strokeStyle = "#ffffff", i.vjCanvasContext.lineWidth = 2, document.body.appendChild(i.vjCanvas)), i.halfWidth = i.vjCanvas.width / 2, i.halfHeight = i.vjCanvas.height / 2, this.pressed = !1, this._joystickColor = "cyan", this._joystickPointerID = -1, this._joystickPointerPos = new e.Vector2(0, 0), this._joystickPreviousPointerPos = new e.Vector2(0, 0), this._joystickPointerStartPos = new e.Vector2(0, 0), this._deltaJoystickVector = new e.Vector2(0, 0), this._onPointerDownHandlerRef = function(e) {
					n._onPointerDown(e)
				}, this._onPointerMoveHandlerRef = function(e) {
					n._onPointerMove(e)
				}, this._onPointerOutHandlerRef = function(e) {
					n._onPointerUp(e)
				}, this._onPointerUpHandlerRef = function(e) {
					n._onPointerUp(e)
				}, i.vjCanvas.addEventListener("pointerdown", this._onPointerDownHandlerRef, !1), i.vjCanvas.addEventListener("pointermove", this._onPointerMoveHandlerRef, !1), i.vjCanvas.addEventListener("pointerup", this._onPointerUpHandlerRef, !1), i.vjCanvas.addEventListener("pointerout", this._onPointerUpHandlerRef, !1), i.vjCanvas.addEventListener("contextmenu", (function(e) {
					e.preventDefault()
				}), !1), requestAnimationFrame((function() {
					n._drawVirtualJoystick()
				}))
			}
			return i.prototype.setJoystickSensibility = function(e) {
				this._joystickSensibility = e, this._inversedSensibility = 1 / (this._joystickSensibility / 1e3)
			}, i.prototype._onPointerDown = function(e) {
				var t;
				e.preventDefault(), t = this._leftJoystick === !0 ? e.clientX < i.halfWidth : e.clientX > i.halfWidth, t && this._joystickPointerID < 0 ? (this._joystickPointerID = e.pointerId, this._joystickPointerStartPos.x = e.clientX, this._joystickPointerStartPos.y = e.clientY, this._joystickPointerPos = this._joystickPointerStartPos.clone(), this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone(), this._deltaJoystickVector.x = 0, this._deltaJoystickVector.y = 0, this.pressed = !0, this._touches.add(e.pointerId.toString(), e)) : i._globalJoystickIndex < 2 && this._action && (this._action(), this._touches.add(e.pointerId.toString(), {
					x: e.clientX,
					y: e.clientY,
					prevX: e.clientX,
					prevY: e.clientY
				}))
			}, i.prototype._onPointerMove = function(e) {
				if (this._joystickPointerID == e.pointerId) {
					this._joystickPointerPos.x = e.clientX, this._joystickPointerPos.y = e.clientY, this._deltaJoystickVector = this._joystickPointerPos.clone(), this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);
					var i = this.reverseLeftRight ? -1 : 1,
						r = i * this._deltaJoystickVector.x / this._inversedSensibility;
					switch (this._axisTargetedByLeftAndRight) {
						case t.X:
							this.deltaPosition.x = Math.min(1, Math.max(-1, r));
							break;
						case t.Y:
							this.deltaPosition.y = Math.min(1, Math.max(-1, r));
							break;
						case t.Z:
							this.deltaPosition.z = Math.min(1, Math.max(-1, r))
					}
					var n = this.reverseUpDown ? 1 : -1,
						o = n * this._deltaJoystickVector.y / this._inversedSensibility;
					switch (this._axisTargetedByUpAndDown) {
						case t.X:
							this.deltaPosition.x = Math.min(1, Math.max(-1, o));
							break;
						case t.Y:
							this.deltaPosition.y = Math.min(1, Math.max(-1, o));
							break;
						case t.Z:
							this.deltaPosition.z = Math.min(1, Math.max(-1, o))
					}
				} else {
					var s = this._touches.get(e.pointerId.toString());
					s && (s.x = e.clientX, s.y = e.clientY)
				}
			}, i.prototype._onPointerUp = function(e) {
				if (this._joystickPointerID == e.pointerId) i.vjCanvasContext.clearRect(this._joystickPointerStartPos.x - 63, this._joystickPointerStartPos.y - 63, 126, 126), i.vjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - 41, this._joystickPreviousPointerPos.y - 41, 82, 82), this._joystickPointerID = -1, this.pressed = !1;
				else {
					var t = this._touches.get(e.pointerId.toString());
					t && i.vjCanvasContext.clearRect(t.prevX - 43, t.prevY - 43, 86, 86)
				}
				this._deltaJoystickVector.x = 0, this._deltaJoystickVector.y = 0, this._touches.remove(e.pointerId.toString())
			}, i.prototype.setJoystickColor = function(e) {
				this._joystickColor = e
			}, i.prototype.setActionOnTouch = function(e) {
				this._action = e
			}, i.prototype.setAxisForLeftRight = function(e) {
				switch (e) {
					case t.X:
					case t.Y:
					case t.Z:
						this._axisTargetedByLeftAndRight = e;
						break;
					default:
						this._axisTargetedByLeftAndRight = t.X
				}
			}, i.prototype.setAxisForUpDown = function(e) {
				switch (e) {
					case t.X:
					case t.Y:
					case t.Z:
						this._axisTargetedByUpAndDown = e;
						break;
					default:
						this._axisTargetedByUpAndDown = t.Y
				}
			}, i.prototype._clearCanvas = function() {
				this._leftJoystick ? i.vjCanvasContext.clearRect(0, 0, i.vjCanvasWidth / 2, i.vjCanvasHeight) : i.vjCanvasContext.clearRect(i.vjCanvasWidth / 2, 0, i.vjCanvasWidth, i.vjCanvasHeight)
			}, i.prototype._drawVirtualJoystick = function() {
				var e = this;
				this.pressed && this._touches.forEach((function(t) {
					t.pointerId === e._joystickPointerID ? (i.vjCanvasContext.clearRect(e._joystickPointerStartPos.x - 63, e._joystickPointerStartPos.y - 63, 126, 126), i.vjCanvasContext.clearRect(e._joystickPreviousPointerPos.x - 41, e._joystickPreviousPointerPos.y - 41, 82, 82), i.vjCanvasContext.beginPath(), i.vjCanvasContext.lineWidth = 6, i.vjCanvasContext.strokeStyle = e._joystickColor, i.vjCanvasContext.arc(e._joystickPointerStartPos.x, e._joystickPointerStartPos.y, 40, 0, 2 * Math.PI, !0), i.vjCanvasContext.stroke(), i.vjCanvasContext.closePath(), i.vjCanvasContext.beginPath(), i.vjCanvasContext.strokeStyle = e._joystickColor, i.vjCanvasContext.lineWidth = 2, i.vjCanvasContext.arc(e._joystickPointerStartPos.x, e._joystickPointerStartPos.y, 60, 0, 2 * Math.PI, !0), i.vjCanvasContext.stroke(), i.vjCanvasContext.closePath(), i.vjCanvasContext.beginPath(), i.vjCanvasContext.strokeStyle = e._joystickColor, i.vjCanvasContext.arc(e._joystickPointerPos.x, e._joystickPointerPos.y, 40, 0, 2 * Math.PI, !0), i.vjCanvasContext.stroke(), i.vjCanvasContext.closePath(), e._joystickPreviousPointerPos = e._joystickPointerPos.clone()) : (i.vjCanvasContext.clearRect(t.prevX - 43, t.prevY - 43, 86, 86), i.vjCanvasContext.beginPath(), i.vjCanvasContext.fillStyle = "white", i.vjCanvasContext.beginPath(), i.vjCanvasContext.strokeStyle = "red", i.vjCanvasContext.lineWidth = 6, i.vjCanvasContext.arc(t.x, t.y, 40, 0, 2 * Math.PI, !0), i.vjCanvasContext.stroke(), i.vjCanvasContext.closePath(), t.prevX = t.x, t.prevY = t.y)
				})), requestAnimationFrame((function() {
					e._drawVirtualJoystick()
				}))
			}, i.prototype.releaseCanvas = function() {
				i.vjCanvas && (i.vjCanvas.removeEventListener("pointerdown", this._onPointerDownHandlerRef), i.vjCanvas.removeEventListener("pointermove", this._onPointerMoveHandlerRef), i.vjCanvas.removeEventListener("pointerup", this._onPointerUpHandlerRef), i.vjCanvas.removeEventListener("pointerout", this._onPointerUpHandlerRef), window.removeEventListener("resize", this._onResize), document.body.removeChild(i.vjCanvas), i.vjCanvas = null)
			}, i._globalJoystickIndex = 0, i
		})();
	e.VirtualJoystick = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r) {
			e.call(this, t, i, r), this.inputs.addVirtualJoystick()
		}
		return __extends(t, e), t
	})(e.FreeCamera);
	e.VirtualJoysticksCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {}
		return t.prototype.getLeftJoystick = function() {
			return this._leftjoystick
		}, t.prototype.getRightJoystick = function() {
			return this._rightjoystick
		}, t.prototype.checkInputs = function() {
			if (this._leftjoystick) {
				var t = this.camera,
					i = 50 * t._computeLocalCameraSpeed(),
					r = e.Matrix.RotationYawPitchRoll(t.rotation.y, t.rotation.x, 0),
					n = e.Vector3.TransformCoordinates(new e.Vector3(this._leftjoystick.deltaPosition.x * i, this._leftjoystick.deltaPosition.y * i, this._leftjoystick.deltaPosition.z * i), r);
				t.cameraDirection = t.cameraDirection.add(n), t.cameraRotation = t.cameraRotation.addVector3(this._rightjoystick.deltaPosition), this._leftjoystick.pressed || (this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(.9)), this._rightjoystick.pressed || (this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(.9))
			}
		}, t.prototype.attachControl = function(t, i) {
			this._leftjoystick = new e.VirtualJoystick((!0)), this._leftjoystick.setAxisForUpDown(e.JoystickAxis.Z), this._leftjoystick.setAxisForLeftRight(e.JoystickAxis.X), this._leftjoystick.setJoystickSensibility(.15), this._rightjoystick = new e.VirtualJoystick((!1)), this._rightjoystick.setAxisForUpDown(e.JoystickAxis.X), this._rightjoystick.setAxisForLeftRight(e.JoystickAxis.Y), this._rightjoystick.reverseUpDown = !0, this._rightjoystick.setJoystickSensibility(.05), this._rightjoystick.setJoystickColor("yellow")
		}, t.prototype.detachControl = function(e) {
			this._leftjoystick.releaseCanvas(), this._rightjoystick.releaseCanvas()
		}, t.prototype.getTypeName = function() {
			return "FreeCameraVirtualJoystickInput"
		}, t.prototype.getSimpleName = function() {
			return "virtualJoystick"
		}, t
	})();
	e.FreeCameraVirtualJoystickInput = t, e.CameraInputTypes.FreeCameraVirtualJoystickInput = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s) {
			var a = this;
			e.call(this, t, "anaglyph", null, ["leftSampler"], i, r[1], n, o, s), this._passedProcess = r[0]._rigPostProcess, this.onApplyObservable.add((function(e) {
				e.setTextureFromPostProcess("leftSampler", a._passedProcess)
			}))
		}
		return __extends(t, e), t
	})(e.PostProcess);
	e.AnaglyphPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e) {
			this._scene = e
		}
		return t.prototype.render = function(t, i, r) {
			var n = this;
			void 0 === r && (r = !1);
			var o = this._scene,
				s = this._scene.getEngine(),
				a = null !== s.getCaps().instancedArrays && null !== i.visibleInstances[t._id] && void 0 !== i.visibleInstances[t._id];
			if (this.isReady(t, a)) {
				var h = t.getRenderingMesh(),
					c = t.getMaterial();
				if (s.enableEffect(this._effect), this._effect.setFloat("offset", r ? 0 : h.outlineWidth), this._effect.setColor4("color", r ? h.overlayColor : h.outlineColor, r ? h.overlayAlpha : 1), this._effect.setMatrix("viewProjection", o.getTransformMatrix()), h.useBones && h.computeBonesUsingShaders && this._effect.setMatrices("mBones", h.skeleton.getTransformMatrices(h)), h._bind(t, this._effect, e.Material.TriangleFillMode), c && c.needAlphaTesting()) {
					var l = c.getAlphaTestTexture();
					this._effect.setTexture("diffuseSampler", l), this._effect.setMatrix("diffuseMatrix", l.getTextureMatrix())
				}
				h._processRendering(t, this._effect, e.Material.TriangleFillMode, i, a, (function(e, t) {
					n._effect.setMatrix("world", t)
				}))
			}
		}, t.prototype.isReady = function(t, i) {
			var r = [],
				n = [e.VertexBuffer.PositionKind, e.VertexBuffer.NormalKind],
				o = t.getMesh(),
				s = t.getMaterial();
			s && s.needAlphaTesting() && (r.push("#define ALPHATEST"), o.isVerticesDataPresent(e.VertexBuffer.UVKind) && (n.push(e.VertexBuffer.UVKind), r.push("#define UV1")), o.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (n.push(e.VertexBuffer.UV2Kind), r.push("#define UV2"))), o.useBones && o.computeBonesUsingShaders ? (n.push(e.VertexBuffer.MatricesIndicesKind), n.push(e.VertexBuffer.MatricesWeightsKind), o.numBoneInfluencers > 4 && (n.push(e.VertexBuffer.MatricesIndicesExtraKind), n.push(e.VertexBuffer.MatricesWeightsExtraKind)), r.push("#define NUM_BONE_INFLUENCERS " + o.numBoneInfluencers), r.push("#define BonesPerMesh " + (o.skeleton.bones.length + 1))) : r.push("#define NUM_BONE_INFLUENCERS 0"), i && (r.push("#define INSTANCES"), n.push("world0"), n.push("world1"), n.push("world2"), n.push("world3"));
			var a = r.join("\n");
			return this._cachedDefines !== a && (this._cachedDefines = a, this._effect = this._scene.getEngine().createEffect("outline", n, ["world", "mBones", "viewProjection", "diffuseMatrix", "offset", "color"], ["diffuseSampler"], a)), this._effect.isReady()
		}, t
	})();
	e.OutlineRenderer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i, r) {
			this.name = e, this.meshesNames = t, this.rootUrl = i, this.sceneFilename = r, this.isCompleted = !1
		}
		return t.prototype.run = function(t, i, r) {
			var n = this;
			e.SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, t, (function(e, t, r) {
				n.loadedMeshes = e, n.loadedParticleSystems = t, n.loadedSkeletons = r, n.isCompleted = !0, n.onSuccess && n.onSuccess(n), i()
			}), null, (function() {
				n.onError && n.onError(n), r()
			}))
		}, t
	})();
	e.MeshAssetTask = t;
	var i = (function() {
		function t(e, t) {
			this.name = e, this.url = t, this.isCompleted = !1
		}
		return t.prototype.run = function(t, i, r) {
			var n = this;
			e.Tools.LoadFile(this.url, (function(e) {
				n.text = e, n.isCompleted = !0, n.onSuccess && n.onSuccess(n), i()
			}), null, t.database, !1, (function() {
				n.onError && n.onError(n), r()
			}))
		}, t
	})();
	e.TextFileAssetTask = i;
	var r = (function() {
		function t(e, t) {
			this.name = e, this.url = t, this.isCompleted = !1
		}
		return t.prototype.run = function(t, i, r) {
			var n = this;
			e.Tools.LoadFile(this.url, (function(e) {
				n.data = e, n.isCompleted = !0, n.onSuccess && n.onSuccess(n), i()
			}), null, t.database, !0, (function() {
				n.onError && n.onError(n), r()
			}))
		}, t
	})();
	e.BinaryFileAssetTask = r;
	var n = (function() {
		function t(e, t) {
			this.name = e, this.url = t, this.isCompleted = !1
		}
		return t.prototype.run = function(t, i, r) {
			var n = this,
				o = new Image;
			e.Tools.SetCorsBehavior(this.url, o), o.onload = function() {
				n.image = o, n.isCompleted = !0, n.onSuccess && n.onSuccess(n), i()
			}, o.onerror = function() {
				n.onError && n.onError(n), r()
			}, o.src = this.url
		}, t
	})();
	e.ImageAssetTask = n;
	var o = (function() {
		function t(t, i, r, n, o) {
			void 0 === o && (o = e.Texture.TRILINEAR_SAMPLINGMODE), this.name = t, this.url = i, this.noMipmap = r, this.invertY = n, this.samplingMode = o, this.isCompleted = !1
		}
		return t.prototype.run = function(t, i, r) {
			var n = this,
				o = function() {
					n.isCompleted = !0, n.onSuccess && n.onSuccess(n), i()
				},
				s = function() {
					n.onError && n.onError(n), r()
				};
			this.texture = new e.Texture(this.url, t, this.noMipmap, this.invertY, this.samplingMode, o, s)
		}, t
	})();
	e.TextureAssetTask = o;
	var s = (function() {
		function t(e, t, i, r, n) {
			this.name = e, this.url = t, this.extensions = i, this.noMipmap = r, this.files = n, this.isCompleted = !1
		}
		return t.prototype.run = function(t, i, r) {
			var n = this,
				o = function() {
					n.isCompleted = !0, n.onSuccess && n.onSuccess(n), i()
				},
				s = function() {
					n.onError && n.onError(n), r()
				};
			this.texture = new e.CubeTexture(this.url, t, this.extensions, this.noMipmap, this.files, o, s)
		}, t
	})();
	e.CubeTextureAssetTask = s;
	var a = (function() {
		function s(e) {
			this.tasks = new Array, this.waitingTasksCount = 0, this.useDefaultLoadingScreen = !0, this._scene = e
		}
		return s.prototype.addMeshTask = function(e, i, r, n) {
			var o = new t(e, i, r, n);
			return this.tasks.push(o), o
		}, s.prototype.addTextFileTask = function(e, t) {
			var r = new i(e, t);
			return this.tasks.push(r), r
		}, s.prototype.addBinaryFileTask = function(e, t) {
			var i = new r(e, t);
			return this.tasks.push(i), i
		}, s.prototype.addImageTask = function(e, t) {
			var i = new n(e, t);
			return this.tasks.push(i), i
		}, s.prototype.addTextureTask = function(t, i, r, n, s) {
			void 0 === s && (s = e.Texture.TRILINEAR_SAMPLINGMODE);
			var a = new o(t, i, r, n, s);
			return this.tasks.push(a), a
		}, s.prototype._decreaseWaitingTasksCount = function() {
			this.waitingTasksCount--, 0 === this.waitingTasksCount && (this.onFinish && this.onFinish(this.tasks), this._scene.getEngine().hideLoadingUI())
		}, s.prototype._runTask = function(e) {
			var t = this;
			e.run(this._scene, (function() {
				t.onTaskSuccess && t.onTaskSuccess(e), t._decreaseWaitingTasksCount()
			}), (function() {
				t.onTaskError && t.onTaskError(e), t._decreaseWaitingTasksCount()
			}))
		}, s.prototype.reset = function() {
			return this.tasks = new Array, this
		}, s.prototype.load = function() {
			if (this.waitingTasksCount = this.tasks.length, 0 === this.waitingTasksCount) return this.onFinish && this.onFinish(this.tasks), this;
			this.useDefaultLoadingScreen && this._scene.getEngine().displayLoadingUI();
			for (var e = 0; e < this.tasks.length; e++) {
				var t = this.tasks[e];
				this._runTask(t)
			}
			return this
		}, s
	})();
	e.AssetsManager = a
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this.compensateDistortion = !0
		}
		return Object.defineProperty(t.prototype, "aspectRatio", {
			get: function() {
				return this.hResolution / (2 * this.vResolution)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "aspectRatioFov", {
			get: function() {
				return 2 * Math.atan(this.postProcessScaleFactor * this.vScreenSize / (2 * this.eyeToScreenDistance))
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "leftHMatrix", {
			get: function() {
				var t = this.hScreenSize / 4 - this.lensSeparationDistance / 2,
					i = 4 * t / this.hScreenSize;
				return e.Matrix.Translation(i, 0, 0)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "rightHMatrix", {
			get: function() {
				var t = this.hScreenSize / 4 - this.lensSeparationDistance / 2,
					i = 4 * t / this.hScreenSize;
				return e.Matrix.Translation(-i, 0, 0)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "leftPreViewMatrix", {
			get: function() {
				return e.Matrix.Translation(.5 * this.interpupillaryDistance, 0, 0)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "rightPreViewMatrix", {
			get: function() {
				return e.Matrix.Translation(-.5 * this.interpupillaryDistance, 0, 0)
			},
			enumerable: !0,
			configurable: !0
		}), t.GetDefault = function() {
			var e = new t;
			return e.hResolution = 1280, e.vResolution = 800, e.hScreenSize = .149759993, e.vScreenSize = .0935999975, e.vScreenCenter = .0467999987, e.eyeToScreenDistance = .0410000011, e.lensSeparationDistance = .063500002, e.interpupillaryDistance = .064000003, e.distortionK = [1, .219999999, .239999995, 0], e.chromaAbCorrection = [.995999992, -.00400000019, 1.01400006, 0], e.postProcessScaleFactor = 1.714605507808412, e.lensCenterOffset = .151976421, e
		}, t
	})();
	e.VRCameraMetrics = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			var a = this;
			void 0 === o && (o = !1), void 0 === s && (s = {}), t.call(this, i, r, n), this.webVROptions = s, this._vrDevice = null, this._cacheState = null, this._vrEnabled = !1, this._attached = !1, this._positionOffset = r, this.getEngine().initWebVR(), this.getEngine().vrDisplaysPromise ? (this._frameData = new VRFrameData, this.getEngine().vrDisplaysPromise.then((function(t) {
				if (t.length > 0) {
					if (a._vrEnabled = !0, a.webVROptions.displayName) {
						var i = t.some((function(e) {
							return e.displayName === a.webVROptions.displayName && (a._vrDevice = e, !0)
						}));
						i || (a._vrDevice = t[0], e.Tools.Warn("Display " + a.webVROptions.displayName + " was not found. Using " + a._vrDevice.displayName))
					} else a._vrDevice = t[0];
					a.setCameraRigMode(e.Camera.RIG_MODE_WEBVR, {
						vrDisplay: a._vrDevice,
						frameData: a._frameData
					}), a._attached && a.getEngine().enableVR(a._vrDevice)
				} else e.Tools.Error("No WebVR devices found!")
			}))) : e.Tools.Error("WebVR is not enabled on your browser"), this.rotationQuaternion = new e.Quaternion, this._quaternionCache = new e.Quaternion
		}
		return __extends(i, t), i.prototype._checkInputs = function() {
			if (this._vrEnabled && this._vrDevice.getFrameData(this._frameData)) {
				var e = this._frameData.pose;
				e && e.orientation && (this._cacheState = e, this.rotationQuaternion.copyFromFloats(this._cacheState.orientation[0], this._cacheState.orientation[1], -this._cacheState.orientation[2], -this._cacheState.orientation[3]), this.webVROptions.trackPosition && this._cacheState.position && (this.position.copyFromFloats(this._cacheState.position[0], this._cacheState.position[1], -this._cacheState.position[2]), this.webVROptions.positionScale && this.position.scaleInPlace(this.webVROptions.positionScale), this.position.addInPlace(this._positionOffset)))
			}
			t.prototype._checkInputs.call(this)
		}, i.prototype.attachControl = function(i, r) {
			t.prototype.attachControl.call(this, i, r), this._attached = !0, r = !e.Camera.ForceAttachControlToAlwaysPreventDefault && r, this._vrEnabled && this.getEngine().enableVR(this._vrDevice)
		}, i.prototype.detachControl = function(e) {
			t.prototype.detachControl.call(this, e), this._vrEnabled = !1, this._attached = !1, this.getEngine().disableVR()
		}, i.prototype.requestVRFullscreen = function(t) {
			e.Tools.Warn("requestVRFullscreen is deprecated. call attachControl() to start sending frames to the VR display.")
		}, i.prototype.getTypeName = function() {
			return "WebVRFreeCamera"
		}, i.prototype.resetToCurrentRotation = function() {
			this._vrDevice.resetPose()
		}, i.prototype.setPositionOffset = function(e) {
			e ? this._positionOffset = e : this._positionOffset.copyFrom(this.position)
		}, i
	})(e.FreeCamera);
	e.WebVRFreeCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e) {
			void 0 === e && (e = 0), this.priority = e, this.apply = function(e) {
				return !0
			}
		}
		return e
	})();
	e.SceneOptimization = t;
	var i = (function(e) {
		function t(t, i) {
			var r = this;
			void 0 === t && (t = 0), void 0 === i && (i = 1024), e.call(this, t), this.priority = t, this.maximumSize = i, this.apply = function(e) {
				for (var t = !0, i = 0; i < e.textures.length; i++) {
					var n = e.textures[i];
					if (n.canRescale) {
						var o = n.getSize(),
							s = Math.max(o.width, o.height);
						s > r.maximumSize && (n.scale(.5), t = !1)
					}
				}
				return t
			}
		}
		return __extends(t, e), t
	})(t);
	e.TextureOptimization = i;
	var r = (function(e) {
		function t(t, i) {
			var r = this;
			void 0 === t && (t = 0), void 0 === i && (i = 2), e.call(this, t), this.priority = t, this.maximumScale = i, this._currentScale = 1, this.apply = function(e) {
				return r._currentScale++, e.getEngine().setHardwareScalingLevel(r._currentScale), r._currentScale >= r.maximumScale
			}
		}
		return __extends(t, e), t
	})(t);
	e.HardwareScalingOptimization = r;
	var n = (function(e) {
		function t() {
			e.apply(this, arguments), this.apply = function(e) {
				return e.shadowsEnabled = !1, !0
			}
		}
		return __extends(t, e), t
	})(t);
	e.ShadowsOptimization = n;
	var o = (function(e) {
		function t() {
			e.apply(this, arguments), this.apply = function(e) {
				return e.postProcessesEnabled = !1, !0
			}
		}
		return __extends(t, e), t
	})(t);
	e.PostProcessesOptimization = o;
	var s = (function(e) {
		function t() {
			e.apply(this, arguments), this.apply = function(e) {
				return e.lensFlaresEnabled = !1, !0
			}
		}
		return __extends(t, e), t
	})(t);
	e.LensFlaresOptimization = s;
	var a = (function(e) {
		function t() {
			e.apply(this, arguments), this.apply = function(e) {
				return e.particlesEnabled = !1, !0
			}
		}
		return __extends(t, e), t
	})(t);
	e.ParticlesOptimization = a;
	var h = (function(e) {
		function t() {
			e.apply(this, arguments), this.apply = function(e) {
				return e.renderTargetsEnabled = !1, !0
			}
		}
		return __extends(t, e), t
	})(t);
	e.RenderTargetsOptimization = h;
	var c = (function(t) {
		function i() {
			var r = this;
			t.apply(this, arguments), this._canBeMerged = function(t) {
				if (!(t instanceof e.Mesh)) return !1;
				var i = t;
				return !(!i.isVisible || !i.isEnabled()) && (!(i.instances.length > 0) && (!i.skeleton && !i.hasLODLevels && !i.parent))
			}, this.apply = function(t, n) {
				for (var o = t.meshes.slice(0), s = o.length, a = 0; a < s; a++) {
					var h = new Array,
						c = o[a];
					if (r._canBeMerged(c)) {
						h.push(c);
						for (var l = a + 1; l < s; l++) {
							var u = o[l];
							r._canBeMerged(u) && u.material === c.material && u.checkCollisions === c.checkCollisions && (h.push(u), s--, o.splice(l, 1), l--)
						}
						h.length < 2 || e.Mesh.MergeMeshes(h)
					}
				}
				return void 0 != n ? n && t.createOrUpdateSelectionOctree() : i.UpdateSelectionTree && t.createOrUpdateSelectionOctree(), !0
			}
		}
		return __extends(i, t), Object.defineProperty(i, "UpdateSelectionTree", {
			get: function() {
				return i._UpdateSelectionTree
			},
			set: function(e) {
				i._UpdateSelectionTree = e
			},
			enumerable: !0,
			configurable: !0
		}), i._UpdateSelectionTree = !1, i
	})(t);
	e.MergeMeshesOptimization = c;
	var l = (function() {
		function e(e, t) {
			void 0 === e && (e = 60), void 0 === t && (t = 2e3), this.targetFrameRate = e, this.trackerDuration = t, this.optimizations = new Array
		}
		return e.LowDegradationAllowed = function(t) {
			var r = new e(t),
				h = 0;
			return r.optimizations.push(new c(h)), r.optimizations.push(new n(h)), r.optimizations.push(new s(h)), h++, r.optimizations.push(new o(h)), r.optimizations.push(new a(h)), h++, r.optimizations.push(new i(h, 1024)), r
		}, e.ModerateDegradationAllowed = function(t) {
			var l = new e(t),
				u = 0;
			return l.optimizations.push(new c(u)), l.optimizations.push(new n(u)), l.optimizations.push(new s(u)), u++, l.optimizations.push(new o(u)), l.optimizations.push(new a(u)), u++, l.optimizations.push(new i(u, 512)), u++, l.optimizations.push(new h(u)), u++, l.optimizations.push(new r(u, 2)), l
		}, e.HighDegradationAllowed = function(t) {
			var l = new e(t),
				u = 0;
			return l.optimizations.push(new c(u)), l.optimizations.push(new n(u)), l.optimizations.push(new s(u)), u++, l.optimizations.push(new o(u)), l.optimizations.push(new a(u)), u++, l.optimizations.push(new i(u, 256)), u++, l.optimizations.push(new h(u)), u++, l.optimizations.push(new r(u, 4)), l
		}, e
	})();
	e.SceneOptimizerOptions = l;
	var u = (function() {
		function e() {}
		return e._CheckCurrentState = function(t, i, r, n, o) {
			if (t.getEngine().getFps() >= i.targetFrameRate) return void(n && n());
			for (var s = !0, a = !0, h = 0; h < i.optimizations.length; h++) {
				var c = i.optimizations[h];
				c.priority === r && (a = !1, s = s && c.apply(t))
			}
			return a ? void(o && o()) : (s && r++, void t.executeWhenReady((function() {
				setTimeout((function() {
					e._CheckCurrentState(t, i, r, n, o)
				}), i.trackerDuration)
			})))
		}, e.OptimizeAsync = function(t, i, r, n) {
			i || (i = l.ModerateDegradationAllowed()), t.executeWhenReady((function() {
				setTimeout((function() {
					e._CheckCurrentState(t, i, 0, r, n)
				}), i.trackerDuration)
			}))
		}, e
	})();
	e.SceneOptimizer = u
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(e) {
		var t = (function() {
			function e(e, t) {
				this.distance = e, this.mesh = t
			}
			return e
		})();
		e.MeshLODLevel = t
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h, c) {
			void 0 === a && (a = !0), void 0 === h && (h = !1), void 0 === c && (c = e.Texture.TRILINEAR_SAMPLINGMODE), t.call(this, null, s, !a, h), this.format = o, this._texture = s.getEngine().createRawTexture(i, r, n, o, a, h, c), this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE
		}
		return __extends(i, t), i.prototype.update = function(e) {
			this.getScene().getEngine().updateRawTexture(this._texture, e, this.format, this._invertY)
		}, i.CreateLuminanceTexture = function(t, r, n, o, s, a, h) {
			return void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === h && (h = e.Texture.TRILINEAR_SAMPLINGMODE), new i(t, r, n, e.Engine.TEXTUREFORMAT_LUMINANCE, o, s, a, h);
		}, i.CreateLuminanceAlphaTexture = function(t, r, n, o, s, a, h) {
			return void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === h && (h = e.Texture.TRILINEAR_SAMPLINGMODE), new i(t, r, n, e.Engine.TEXTUREFORMAT_LUMINANCE_ALPHA, o, s, a, h)
		}, i.CreateAlphaTexture = function(t, r, n, o, s, a, h) {
			return void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === h && (h = e.Texture.TRILINEAR_SAMPLINGMODE), new i(t, r, n, e.Engine.TEXTUREFORMAT_ALPHA, o, s, a, h)
		}, i.CreateRGBTexture = function(t, r, n, o, s, a, h) {
			return void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === h && (h = e.Texture.TRILINEAR_SAMPLINGMODE), new i(t, r, n, e.Engine.TEXTUREFORMAT_RGB, o, s, a, h)
		}, i.CreateRGBATexture = function(t, r, n, o, s, a, h) {
			return void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === h && (h = e.Texture.TRILINEAR_SAMPLINGMODE), new i(t, r, n, e.Engine.TEXTUREFORMAT_RGBA, o, s, a, h)
		}, i
	})(e.Texture);
	e.RawTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
			function t(t, i) {
				e.call(this, t.x, t.y), this.index = i
			}
			return __extends(t, e), t
		})(e.Vector2),
		i = (function() {
			function i() {
				this.elements = new Array
			}
			return i.prototype.add = function(e) {
				var i = this,
					r = new Array;
				return e.forEach((function(e) {
					if (0 === r.length || !e.equalsWithEpsilon(r[0])) {
						var n = new t(e, i.elements.length);
						r.push(n), i.elements.push(n)
					}
				})), r
			}, i.prototype.computeBounds = function() {
				var t = new e.Vector2(this.elements[0].x, this.elements[0].y),
					i = new e.Vector2(this.elements[0].x, this.elements[0].y);
				return this.elements.forEach((function(e) {
					e.x < t.x ? t.x = e.x : e.x > i.x && (i.x = e.x), e.y < t.y ? t.y = e.y : e.y > i.y && (i.y = e.y)
				})), {
					min: t,
					max: i,
					width: i.x - t.x,
					height: i.y - t.y
				}
			}, i
		})(),
		r = (function() {
			function t() {}
			return t.Rectangle = function(t, i, r, n) {
				return [new e.Vector2(t, i), new e.Vector2(r, i), new e.Vector2(r, n), new e.Vector2(t, n)]
			}, t.Circle = function(t, i, r, n) {
				void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === n && (n = 32);
				for (var o = new Array, s = 0, a = 2 * Math.PI / n, h = 0; h < n; h++) o.push(new e.Vector2(i + Math.cos(s) * t, r + Math.sin(s) * t)), s -= a;
				return o
			}, t.Parse = function(t) {
				var i, r = t.split(/[^-+eE\.\d]+/).map(parseFloat).filter((function(e) {
						return !isNaN(e)
					})),
					n = [];
				for (i = 0; i < (2147483646 & r.length); i += 2) n.push(new e.Vector2(r[i], r[i + 1]));
				return n
			}, t.StartingAt = function(t, i) {
				return e.Path2.StartingAt(t, i)
			}, t
		})();
	e.Polygon = r;
	var n = (function() {
		function t(t, r, n) {
			this._points = new i, this._outlinepoints = new i, this._holes = [], this._epoints = new Array, this._eholes = new Array, this._name = t, this._scene = n;
			var o;
			o = r instanceof e.Path2 ? r.getPoints() : r, this._addToepoint(o), this._points.add(o), this._outlinepoints.add(o)
		}
		return t.prototype._addToepoint = function(e) {
			for (var t = 0, i = e; t < i.length; t++) {
				var r = i[t];
				this._epoints.push(r.x, r.y)
			}
		}, t.prototype.addHole = function(e) {
			this._points.add(e);
			var t = new i;
			return t.add(e), this._holes.push(t), this._eholes.push(this._epoints.length / 2), this._addToepoint(e), this
		}, t.prototype.build = function(t, i) {
			var r = this;
			void 0 === t && (t = !1);
			var n = new e.Mesh(this._name, this._scene),
				o = [],
				s = [],
				a = [],
				h = this._points.computeBounds();
			this._points.elements.forEach((function(e) {
				o.push(0, 1, 0), s.push(e.x, 0, e.y), a.push((e.x - h.min.x) / h.width, (e.y - h.min.y) / h.height)
			}));
			for (var c = [], l = Earcut.earcut(this._epoints, this._eholes, 2), u = 0; u < l.length; u++) c.push(l[u]);
			if (i > 0) {
				var d = s.length / 3;
				this._points.elements.forEach((function(e) {
					o.push(0, -1, 0), s.push(e.x, -i, e.y), a.push(1 - (e.x - h.min.x) / h.width, 1 - (e.y - h.min.y) / h.height)
				}));
				for (var f = c.length, u = 0; u < f; u += 3) {
					var p = c[u + 0],
						m = c[u + 1],
						_ = c[u + 2];
					c.push(_ + d), c.push(m + d), c.push(p + d)
				}
				this.addSide(s, o, a, c, h, this._outlinepoints, i, !1), this._holes.forEach((function(e) {
					r.addSide(s, o, a, c, h, e, i, !0)
				}))
			}
			return n.setVerticesData(e.VertexBuffer.PositionKind, s, t), n.setVerticesData(e.VertexBuffer.NormalKind, o, t), n.setVerticesData(e.VertexBuffer.UVKind, a, t), n.setIndices(c), n
		}, t.prototype.addSide = function(t, i, r, n, o, s, a, h) {
			for (var c = t.length / 3, l = 0, u = 0; u < s.elements.length; u++) {
				var d, f = s.elements[u];
				d = u + 1 > s.elements.length - 1 ? s.elements[0] : s.elements[u + 1], t.push(f.x, 0, f.y), t.push(f.x, -a, f.y), t.push(d.x, 0, d.y), t.push(d.x, -a, d.y);
				var p = new e.Vector3(f.x, 0, f.y),
					m = new e.Vector3(d.x, 0, d.y),
					_ = m.subtract(p),
					g = new e.Vector3(0, 1, 0),
					v = e.Vector3.Cross(_, g);
				v = v.normalize(), r.push(l / o.width, 0), r.push(l / o.width, 1), l += _.length(), r.push(l / o.width, 0), r.push(l / o.width, 1), h ? (i.push(v.x, v.y, v.z), i.push(v.x, v.y, v.z), i.push(v.x, v.y, v.z), i.push(v.x, v.y, v.z), n.push(c), n.push(c + 2), n.push(c + 1), n.push(c + 1), n.push(c + 2), n.push(c + 3)) : (i.push(-v.x, -v.y, -v.z), i.push(-v.x, -v.y, -v.z), i.push(-v.x, -v.y, -v.z), i.push(-v.x, -v.y, -v.z), n.push(c), n.push(c + 1), n.push(c + 2), n.push(c + 1), n.push(c + 3), n.push(c + 2)), c += 4
			}
		}, t
	})();
	e.PolygonMeshBuilder = n
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r) {
			void 0 === r && (r = 2), this.maxDepth = r, this.dynamicContent = new Array, this._maxBlockCapacity = i || 64, this._selectionContent = new e.SmartArray(1024), this._creationFunc = t
		}
		return t.prototype.update = function(e, i, r) {
			t._CreateBlocks(e, i, r, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc)
		}, t.prototype.addMesh = function(e) {
			for (var t = 0; t < this.blocks.length; t++) {
				var i = this.blocks[t];
				i.addEntry(e)
			}
		}, t.prototype.select = function(e, t) {
			this._selectionContent.reset();
			for (var i = 0; i < this.blocks.length; i++) {
				var r = this.blocks[i];
				r.select(e, this._selectionContent, t)
			}
			return t ? this._selectionContent.concat(this.dynamicContent) : this._selectionContent.concatWithNoDuplicate(this.dynamicContent), this._selectionContent
		}, t.prototype.intersects = function(e, t, i) {
			this._selectionContent.reset();
			for (var r = 0; r < this.blocks.length; r++) {
				var n = this.blocks[r];
				n.intersects(e, t, this._selectionContent, i)
			}
			return i ? this._selectionContent.concat(this.dynamicContent) : this._selectionContent.concatWithNoDuplicate(this.dynamicContent), this._selectionContent
		}, t.prototype.intersectsRay = function(e) {
			this._selectionContent.reset();
			for (var t = 0; t < this.blocks.length; t++) {
				var i = this.blocks[t];
				i.intersectsRay(e, this._selectionContent)
			}
			return this._selectionContent.concatWithNoDuplicate(this.dynamicContent), this._selectionContent
		}, t._CreateBlocks = function(t, i, r, n, o, s, a, h) {
			a.blocks = new Array;
			for (var c = new e.Vector3((i.x - t.x) / 2, (i.y - t.y) / 2, (i.z - t.z) / 2), l = 0; l < 2; l++)
				for (var u = 0; u < 2; u++)
					for (var d = 0; d < 2; d++) {
						var f = t.add(c.multiplyByFloats(l, u, d)),
							p = t.add(c.multiplyByFloats(l + 1, u + 1, d + 1)),
							m = new e.OctreeBlock(f, p, n, o + 1, s, h);
						m.addEntries(r), a.blocks.push(m)
					}
		}, t.CreationFuncForMeshes = function(e, t) {
			!e.isBlocked && e.getBoundingInfo().boundingBox.intersectsMinMax(t.minPoint, t.maxPoint) && t.entries.push(e)
		}, t.CreationFuncForSubMeshes = function(e, t) {
			e.getBoundingInfo().boundingBox.intersectsMinMax(t.minPoint, t.maxPoint) && t.entries.push(e)
		}, t
	})();
	e.Octree = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(e, t, i, r, n, o) {
			this.entries = new Array, this._boundingVectors = new Array, this._capacity = i, this._depth = r, this._maxDepth = n, this._creationFunc = o, this._minPoint = e, this._maxPoint = t, this._boundingVectors.push(e.clone()), this._boundingVectors.push(t.clone()), this._boundingVectors.push(e.clone()), this._boundingVectors[2].x = t.x, this._boundingVectors.push(e.clone()), this._boundingVectors[3].y = t.y, this._boundingVectors.push(e.clone()), this._boundingVectors[4].z = t.z, this._boundingVectors.push(t.clone()), this._boundingVectors[5].z = e.z, this._boundingVectors.push(t.clone()), this._boundingVectors[6].x = e.x, this._boundingVectors.push(t.clone()), this._boundingVectors[7].y = e.y
		}
		return Object.defineProperty(t.prototype, "capacity", {
			get: function() {
				return this._capacity
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "minPoint", {
			get: function() {
				return this._minPoint
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "maxPoint", {
			get: function() {
				return this._maxPoint
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.addEntry = function(e) {
			if (this.blocks)
				for (var t = 0; t < this.blocks.length; t++) {
					var i = this.blocks[t];
					i.addEntry(e)
				} else this._creationFunc(e, this), this.entries.length > this.capacity && this._depth < this._maxDepth && this.createInnerBlocks()
		}, t.prototype.addEntries = function(e) {
			for (var t = 0; t < e.length; t++) {
				var i = e[t];
				this.addEntry(i)
			}
		}, t.prototype.select = function(t, i, r) {
			if (e.BoundingBox.IsInFrustum(this._boundingVectors, t)) {
				if (this.blocks) {
					for (var n = 0; n < this.blocks.length; n++) {
						var o = this.blocks[n];
						o.select(t, i, r)
					}
					return
				}
				r ? i.concat(this.entries) : i.concatWithNoDuplicate(this.entries)
			}
		}, t.prototype.intersects = function(t, i, r, n) {
			if (e.BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, t, i)) {
				if (this.blocks) {
					for (var o = 0; o < this.blocks.length; o++) {
						var s = this.blocks[o];
						s.intersects(t, i, r, n)
					}
					return
				}
				n ? r.concat(this.entries) : r.concatWithNoDuplicate(this.entries)
			}
		}, t.prototype.intersectsRay = function(e, t) {
			if (e.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {
				if (this.blocks) {
					for (var i = 0; i < this.blocks.length; i++) {
						var r = this.blocks[i];
						r.intersectsRay(e, t)
					}
					return
				}
				t.concatWithNoDuplicate(this.entries)
			}
		}, t.prototype.createInnerBlocks = function() {
			e.Octree._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc)
		}, t
	})();
	e.OctreeBlock = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h, c) {
			var l = this;
			void 0 === a && (a = e.Texture.BILINEAR_SAMPLINGMODE), t.call(this, i, "blur", ["screenSize", "direction", "blurWidth"], null, o, s, a, h, c), this.direction = r, this.blurWidth = n, this.onApplyObservable.add((function(e) {
				e.setFloat2("screenSize", l.width, l.height), e.setVector2("direction", l.direction), e.setFloat("blurWidth", l.blurWidth)
			}))
		}
		return __extends(i, t), i
	})(e.PostProcess);
	e.BlurPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h, c, l, u) {
			var d = this;
			t.call(this, i, "refraction", ["baseColor", "depth", "colorLevel"], ["refractionSampler"], a, h, c, l, u), this.color = n, this.depth = o, this.colorLevel = s, this.onActivateObservable.add((function(t) {
				d._refRexture = d._refRexture || new e.Texture(r, t.getScene())
			})), this.onApplyObservable.add((function(e) {
				e.setColor3("baseColor", d.color), e.setFloat("depth", d.depth), e.setFloat("colorLevel", d.colorLevel), e.setTexture("refractionSampler", d._refRexture)
			}))
		}
		return __extends(i, t), i.prototype.dispose = function(e) {
			this._refRexture && this._refRexture.dispose(), t.prototype.dispose.call(this, e)
		}, i
	})(e.PostProcess);
	e.RefractionPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s) {
			e.call(this, t, "blackAndWhite", null, null, i, r, n, o, s)
		}
		return __extends(t, e), t
	})(e.PostProcess);
	e.BlackAndWhitePostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s, a) {
			var h = this;
			e.call(this, t, "convolution", ["kernel", "screenSize"], null, r, n, o, s, a), this.kernel = i, this.onApply = function(e) {
				e.setFloat2("screenSize", h.width, h.height), e.setArray("kernel", h.kernel)
			}
		}
		return __extends(t, e), t.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1], t.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0], t.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1], t.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0], t.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2], t.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0], t
	})(e.PostProcess);
	e.ConvolutionPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s, a) {
			var h = this;
			e.call(this, t, "filter", ["kernelMatrix"], null, r, n, o, s, a), this.kernelMatrix = i, this.onApply = function(e) {
				e.setMatrix("kernelMatrix", h.kernelMatrix)
			}
		}
		return __extends(t, e), t
	})(e.PostProcess);
	e.FilterPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r, n, o, s) {
			var a = this;
			e.call(this, t, "fxaa", ["texelSize"], null, i, r, n, o, s), this.onSizeChangedObservable.add((function() {
				a.texelWidth = 1 / a.width, a.texelHeight = 1 / a.height
			})), this.onApplyObservable.add((function(e) {
				e.setFloat2("texelSize", a.texelWidth, a.texelHeight)
			}))
		}
		return __extends(t, e), t
	})(e.PostProcess);
	e.FxaaPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a) {
			var h = this;
			t.call(this, i, "stereoscopicInterlace", ["stepSize"], ["camASampler"], 1, r[1], o, s, a, n ? "#define IS_STEREOSCOPIC_HORIZ 1" : void 0), this._passedProcess = r[0]._rigPostProcess, this._stepSize = new e.Vector2(1 / this.width, 1 / this.height), this.onSizeChangedObservable.add((function() {
				h._stepSize = new e.Vector2(1 / h.width, 1 / h.height)
			})), this.onApplyObservable.add((function(e) {
				e.setTextureFromPostProcess("camASampler", h._passedProcess), e.setFloat2("stepSize", h._stepSize.x, h._stepSize.y)
			}))
		}
		return __extends(i, t), i
	})(e.PostProcess);
	e.StereoscopicInterlacePostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o) {
			this.size = t, this.position = i, this.alphaMode = e.Engine.ALPHA_ONEONE, this.dispose = function() {
				this.texture && this.texture.dispose();
				var e = this._system.lensFlares.indexOf(this);
				this._system.lensFlares.splice(e, 1)
			}, this.color = r || new e.Color3(1, 1, 1), this.texture = n ? new e.Texture(n, o.getScene(), (!0)) : null, this._system = o, o.lensFlares.push(this)
		}
		return t
	})();
	e.LensFlare = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r) {
			this.name = t, this.lensFlares = new Array, this.borderLimit = 300, this.viewportBorder = 0, this.layerMask = 268435455, this._vertexBuffers = {}, this._isEnabled = !0, this._scene = r, this._emitter = i, this.id = t, r.lensFlareSystems.push(this), this.meshesSelectionPredicate = function(e) {
				return e.material && e.isVisible && e.isEnabled() && e.isBlocker && 0 != (e.layerMask & r.activeCamera.layerMask)
			};
			var n = r.getEngine(),
				o = [];
			o.push(1, 1), o.push(-1, 1), o.push(-1, -1), o.push(1, -1), this._vertexBuffers[e.VertexBuffer.PositionKind] = new e.VertexBuffer(n, o, e.VertexBuffer.PositionKind, (!1), (!1), 2);
			var s = [];
			s.push(0), s.push(1), s.push(2), s.push(0), s.push(2), s.push(3), this._indexBuffer = n.createIndexBuffer(s), this._effect = n.createEffect("lensFlare", [e.VertexBuffer.PositionKind], ["color", "viewportMatrix"], ["textureSampler"], "")
		}
		return Object.defineProperty(t.prototype, "isEnabled", {
			get: function() {
				return this._isEnabled
			},
			set: function(e) {
				this._isEnabled = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getScene = function() {
			return this._scene
		}, t.prototype.getEmitter = function() {
			return this._emitter
		}, t.prototype.setEmitter = function(e) {
			this._emitter = e
		}, t.prototype.getEmitterPosition = function() {
			return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position
		}, t.prototype.computeEffectivePosition = function(t) {
			var i = this.getEmitterPosition();
			return i = e.Vector3.Project(i, e.Matrix.Identity(), this._scene.getTransformMatrix(), t), this._positionX = i.x, this._positionY = i.y, i = e.Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix()), this.viewportBorder > 0 && (t.x -= this.viewportBorder, t.y -= this.viewportBorder, t.width += 2 * this.viewportBorder, t.height += 2 * this.viewportBorder, i.x += this.viewportBorder, i.y += this.viewportBorder, this._positionX += this.viewportBorder, this._positionY += this.viewportBorder), i.z > 0 && (this._positionX > t.x && this._positionX < t.x + t.width && this._positionY > t.y && this._positionY < t.y + t.height, !0)
		}, t.prototype._isVisible = function() {
			if (!this._isEnabled) return !1;
			var t = this.getEmitterPosition(),
				i = t.subtract(this._scene.activeCamera.globalPosition),
				r = i.length();
			i.normalize();
			var n = new e.Ray(this._scene.activeCamera.globalPosition, i),
				o = this._scene.pickWithRay(n, this.meshesSelectionPredicate, !0);
			return !o.hit || o.distance > r
		}, t.prototype.render = function() {
			if (!this._effect.isReady()) return !1;
			var t = this._scene.getEngine(),
				i = this._scene.activeCamera.viewport,
				r = i.toGlobal(t.getRenderWidth(!0), t.getRenderHeight(!0));
			if (!this.computeEffectivePosition(r)) return !1;
			if (!this._isVisible()) return !1;
			var n, o;
			n = this._positionX < this.borderLimit + r.x ? this.borderLimit + r.x - this._positionX : this._positionX > r.x + r.width - this.borderLimit ? this._positionX - r.x - r.width + this.borderLimit : 0, o = this._positionY < this.borderLimit + r.y ? this.borderLimit + r.y - this._positionY : this._positionY > r.y + r.height - this.borderLimit ? this._positionY - r.y - r.height + this.borderLimit : 0;
			var s = n > o ? n : o;
			s -= this.viewportBorder, s > this.borderLimit && (s = this.borderLimit);
			var a = 1 - s / this.borderLimit;
			if (a < 0) return !1;
			a > 1 && (a = 1), this.viewportBorder > 0 && (r.x += this.viewportBorder, r.y += this.viewportBorder, r.width -= 2 * this.viewportBorder, r.height -= 2 * this.viewportBorder, this._positionX -= this.viewportBorder, this._positionY -= this.viewportBorder);
			var h = r.x + r.width / 2,
				c = r.y + r.height / 2,
				l = h - this._positionX,
				u = c - this._positionY;
			t.enableEffect(this._effect), t.setState(!1), t.setDepthBuffer(!1), t.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);
			for (var d = 0; d < this.lensFlares.length; d++) {
				var f = this.lensFlares[d];
				t.setAlphaMode(f.alphaMode);
				var p = h - l * f.position,
					m = c - u * f.position,
					_ = f.size,
					g = f.size * t.getAspectRatio(this._scene.activeCamera, !0),
					v = 2 * (p / (r.width + 2 * r.x)) - 1,
					y = 1 - 2 * (m / (r.height + 2 * r.y)),
					x = e.Matrix.FromValues(_ / 2, 0, 0, 0, 0, g / 2, 0, 0, 0, 0, 1, 0, v, y, 0, 1);
				this._effect.setMatrix("viewportMatrix", x), this._effect.setTexture("textureSampler", f.texture), this._effect.setFloat4("color", f.color.r * a, f.color.g * a, f.color.b * a, 1), t.draw(!0, 0, 6)
			}
			return t.setDepthBuffer(!0), t.setAlphaMode(e.Engine.ALPHA_DISABLE), !0
		}, t.prototype.dispose = function() {
			var t = this._vertexBuffers[e.VertexBuffer.PositionKind];
			for (t && (t.dispose(), this._vertexBuffers[e.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null); this.lensFlares.length;) this.lensFlares[0].dispose();
			var i = this._scene.lensFlareSystems.indexOf(this);
			this._scene.lensFlareSystems.splice(i, 1)
		}, t.Parse = function(i, r, n) {
			var o = r.getLastEntryByID(i.emitterId),
				s = i.name || "lensFlareSystem#" + i.emitterId,
				a = new t(s, o, r);
			a.id = i.id || s, a.borderLimit = i.borderLimit;
			for (var h = 0; h < i.flares.length; h++) {
				var c = i.flares[h];
				new e.LensFlare(c.size, c.position, e.Color3.FromArray(c.color), n + c.textureName, a)
			}
			return a
		}, t.prototype.serialize = function() {
			var t = {};
			t.id = this.id, t.name = this.name, t.emitterId = this.getEmitter().id, t.borderLimit = this.borderLimit, t.flares = [];
			for (var i = 0; i < this.lensFlares.length; i++) {
				var r = this.lensFlares[i];
				t.flares.push({
					size: r.size,
					position: r.position,
					color: r.color.asArray(),
					textureName: e.Tools.GetFilename(r.texture.name)
				})
			}
			return t
		}, t
	})();
	e.LensFlareSystem = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n) {
			t.call(this, i, r, n), this._quaternionCache = new e.Quaternion, this.inputs.addDeviceOrientation()
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "DeviceOrientationCamera"
		}, i.prototype._checkInputs = function() {
			t.prototype._checkInputs.call(this), this._quaternionCache.copyFrom(this.rotationQuaternion), this._initialQuaternion && this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion)
		}, i.prototype.resetToCurrentRotation = function(t) {
			var i = this;
			void 0 === t && (t = e.Axis.Y), this.rotationQuaternion && (this._initialQuaternion || (this._initialQuaternion = new e.Quaternion), this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion), ["x", "y", "z"].forEach((function(e) {
				t[e] ? i._initialQuaternion[e] *= -1 : i._initialQuaternion[e] = 0
			})), this._initialQuaternion.normalize(), this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion))
		}, i
	})(e.FreeCamera);
	e.DeviceOrientationCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			void 0 === o && (o = !0), void 0 === s && (s = e.VRCameraMetrics.GetDefault()), t.call(this, i, r, n), s.compensateDistortion = o, this.setCameraRigMode(e.Camera.RIG_MODE_VR, {
				vrCameraMetrics: s
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "VRDeviceOrientationFreeCamera"
		}, i
	})(e.DeviceOrientationCamera);
	e.VRDeviceOrientationFreeCamera = t;
	var i = (function(t) {
		function i(i, r, n, o, s, a, h, c) {
			void 0 === h && (h = !0), void 0 === c && (c = e.VRCameraMetrics.GetDefault()), t.call(this, i, r, n, o, s, a), c.compensateDistortion = h, this.setCameraRigMode(e.Camera.RIG_MODE_VR, {
				vrCameraMetrics: c
			}), this.inputs.addVRDeviceOrientation()
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "VRDeviceOrientationArcRotateCamera"
		}, i
	})(e.ArcRotateCamera);
	e.VRDeviceOrientationArcRotateCamera = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
		function t(t, i, r) {
			e.call(this, t, i, r), this.inputs.addGamepad()
		}
		return __extends(t, e), Object.defineProperty(t.prototype, "gamepadAngularSensibility", {
			get: function() {
				var e = this.inputs.attached.gamepad;
				if (e) return e.gamepadAngularSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.gamepad;
				t && (t.gamepadAngularSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "gamepadMoveSensibility", {
			get: function() {
				var e = this.inputs.attached.gamepad;
				if (e) return e.gamepadMoveSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.gamepad;
				t && (t.gamepadMoveSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getTypeName = function() {
			return "UniversalCamera"
		}, t
	})(e.TouchCamera);
	e.UniversalCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function e(e) {
			var t = this;
			this.babylonGamepads = [], this.oneGamepadConnected = !1, this.isMonitoring = !1, this.gamepadEventSupported = "GamepadEvent" in window, this.gamepadSupportAvailable = navigator.getGamepads || !!navigator.webkitGetGamepads || !!navigator.msGetGamepads || !!navigator.webkitGamepads, this._callbackGamepadConnected = e, this.gamepadSupportAvailable && (this.gamepadEventSupported ? (this._onGamepadConnectedEvent = function(e) {
				t._onGamepadConnected(e)
			}, this._onGamepadDisonnectedEvent = function(e) {
				t._onGamepadDisconnected(e)
			}, window.addEventListener("gamepadconnected", this._onGamepadConnectedEvent, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisonnectedEvent, !1)) : this._startMonitoringGamepads())
		}
		return e.prototype.dispose = function() {
			e.gamepadDOMInfo && document.body.removeChild(e.gamepadDOMInfo), this._onGamepadConnectedEvent && (window.removeEventListener("gamepadconnected", this._onGamepadConnectedEvent, !1), window.removeEventListener("gamepaddisconnected", this._onGamepadDisonnectedEvent, !1), this._onGamepadConnectedEvent = null, this._onGamepadDisonnectedEvent = null)
		}, e.prototype._onGamepadConnected = function(e) {
			var t = this._addNewGamepad(e.gamepad);
			this._callbackGamepadConnected && this._callbackGamepadConnected(t), this._startMonitoringGamepads()
		}, e.prototype._addNewGamepad = function(t) {
			this.oneGamepadConnected || (this.oneGamepadConnected = !0, e.gamepadDOMInfo && (document.body.removeChild(e.gamepadDOMInfo), e.gamepadDOMInfo = null));
			var i, r = t.id.search("Xbox One") !== -1;
			return i = r || t.id.search("Xbox 360") !== -1 || t.id.search("xinput") !== -1 ? new a(t.id, t.index, t, r) : new n(t.id, t.index, t), this.babylonGamepads.push(i), i
		}, e.prototype._onGamepadDisconnected = function(e) {
			for (var t in this.babylonGamepads)
				if (this.babylonGamepads[t].index == e.gamepad.index) {
					this.babylonGamepads.splice(+t, 1);
					break
				}
			0 == this.babylonGamepads.length && this._stopMonitoringGamepads()
		}, e.prototype._startMonitoringGamepads = function() {
			this.isMonitoring || (this.isMonitoring = !0, this._checkGamepadsStatus())
		}, e.prototype._stopMonitoringGamepads = function() {
			this.isMonitoring = !1
		}, e.prototype._checkGamepadsStatus = function() {
			var e = this;
			this._updateGamepadObjects();
			for (var t in this.babylonGamepads) this.babylonGamepads[t].update();
			this.isMonitoring && (window.requestAnimationFrame ? window.requestAnimationFrame((function() {
				e._checkGamepadsStatus()
			})) : window.mozRequestAnimationFrame ? window.mozRequestAnimationFrame((function() {
				e._checkGamepadsStatus()
			})) : window.webkitRequestAnimationFrame && window.webkitRequestAnimationFrame((function() {
				e._checkGamepadsStatus()
			})))
		}, e.prototype._updateGamepadObjects = function() {
			for (var e = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [], t = 0; t < e.length; t++)
				if (e[t])
					if (e[t].index in this.babylonGamepads) this.babylonGamepads[t].browserGamepad = e[t];
					else {
						var i = this._addNewGamepad(e[t]);
						this._callbackGamepadConnected && this._callbackGamepadConnected(i)
					}
		}, e
	})();
	e.Gamepads = t;
	var i = (function() {
		function e(e, t) {
			this.x = e, this.y = t
		}
		return e
	})();
	e.StickValues = i;
	var r = (function() {
		function e(e, t, i, r, n, o, s) {
			void 0 === r && (r = 0), void 0 === n && (n = 1), void 0 === o && (o = 2), void 0 === s && (s = 3), this.id = e, this.index = t, this.browserGamepad = i, this._leftStickAxisX = r, this._leftStickAxisY = n, this._rightStickAxisX = o, this._rightStickAxisY = s, this.browserGamepad.axes.length >= 2 && (this._leftStick = {
				x: this.browserGamepad.axes[this._leftStickAxisX],
				y: this.browserGamepad.axes[this._leftStickAxisY]
			}), this.browserGamepad.axes.length >= 4 && (this._rightStick = {
				x: this.browserGamepad.axes[this._rightStickAxisX],
				y: this.browserGamepad.axes[this._rightStickAxisY]
			})
		}
		return e.prototype.onleftstickchanged = function(e) {
			this._onleftstickchanged = e
		}, e.prototype.onrightstickchanged = function(e) {
			this._onrightstickchanged = e
		}, Object.defineProperty(e.prototype, "leftStick", {
			get: function() {
				return this._leftStick
			},
			set: function(e) {
				!this._onleftstickchanged || this._leftStick.x === e.x && this._leftStick.y === e.y || this._onleftstickchanged(e), this._leftStick = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(e.prototype, "rightStick", {
			get: function() {
				return this._rightStick
			},
			set: function(e) {
				!this._onrightstickchanged || this._rightStick.x === e.x && this._rightStick.y === e.y || this._onrightstickchanged(e), this._rightStick = e
			},
			enumerable: !0,
			configurable: !0
		}), e.prototype.update = function() {
			this._leftStick && (this.leftStick = {
				x: this.browserGamepad.axes[this._leftStickAxisX],
				y: this.browserGamepad.axes[this._leftStickAxisY]
			}), this._rightStick && (this.rightStick = {
				x: this.browserGamepad.axes[this._rightStickAxisX],
				y: this.browserGamepad.axes[this._rightStickAxisY]
			})
		}, e
	})();
	e.Gamepad = r;
	var n = (function(e) {
		function t(t, i, r) {
			e.call(this, t, i, r), this.id = t, this.index = i, this.gamepad = r, this._buttons = new Array(r.buttons.length)
		}
		return __extends(t, e), t.prototype.onbuttondown = function(e) {
			this._onbuttondown = e
		}, t.prototype.onbuttonup = function(e) {
			this._onbuttonup = e
		}, t.prototype._setButtonValue = function(e, t, i) {
			return e !== t && (this._onbuttondown && 1 === e && this._onbuttondown(i), this._onbuttonup && 0 === e && this._onbuttonup(i)), e
		}, t.prototype.update = function() {
			e.prototype.update.call(this);
			for (var t = 0; t < this._buttons.length; t++) this._buttons[t] = this._setButtonValue(this.gamepad.buttons[t].value, this._buttons[t], t)
		}, t
	})(r);
	e.GenericPad = n, (function(e) {
		e[e.A = 0] = "A", e[e.B = 1] = "B", e[e.X = 2] = "X", e[e.Y = 3] = "Y", e[e.Start = 4] = "Start", e[e.Back = 5] = "Back", e[e.LB = 6] = "LB", e[e.RB = 7] = "RB", e[e.LeftStick = 8] = "LeftStick", e[e.RightStick = 9] = "RightStick"
	})(e.Xbox360Button || (e.Xbox360Button = {}));
	var o = e.Xbox360Button;
	!(function(e) {
		e[e.Up = 0] = "Up", e[e.Down = 1] = "Down", e[e.Left = 2] = "Left", e[e.Right = 3] = "Right"
	})(e.Xbox360Dpad || (e.Xbox360Dpad = {}));
	var s = e.Xbox360Dpad,
		a = (function(e) {
			function t(t, i, r, n) {
				void 0 === n && (n = !1), e.call(this, t, i, r, 0, 1, n ? 3 : 2, n ? 4 : 3), this._leftTrigger = 0, this._rightTrigger = 0, this._buttonA = 0, this._buttonB = 0, this._buttonX = 0, this._buttonY = 0, this._buttonBack = 0, this._buttonStart = 0, this._buttonLB = 0, this._buttonRB = 0, this._buttonLeftStick = 0, this._buttonRightStick = 0, this._dPadUp = 0, this._dPadDown = 0, this._dPadLeft = 0, this._dPadRight = 0, this._isXboxOnePad = !1, this._isXboxOnePad = n
			}
			return __extends(t, e), t.prototype.onlefttriggerchanged = function(e) {
				this._onlefttriggerchanged = e
			}, t.prototype.onrighttriggerchanged = function(e) {
				this._onrighttriggerchanged = e
			}, Object.defineProperty(t.prototype, "leftTrigger", {
				get: function() {
					return this._leftTrigger
				},
				set: function(e) {
					this._onlefttriggerchanged && this._leftTrigger !== e && this._onlefttriggerchanged(e), this._leftTrigger = e
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "rightTrigger", {
				get: function() {
					return this._rightTrigger
				},
				set: function(e) {
					this._onrighttriggerchanged && this._rightTrigger !== e && this._onrighttriggerchanged(e), this._rightTrigger = e
				},
				enumerable: !0,
				configurable: !0
			}), t.prototype.onbuttondown = function(e) {
				this._onbuttondown = e
			}, t.prototype.onbuttonup = function(e) {
				this._onbuttonup = e
			}, t.prototype.ondpaddown = function(e) {
				this._ondpaddown = e
			}, t.prototype.ondpadup = function(e) {
				this._ondpadup = e
			}, t.prototype._setButtonValue = function(e, t, i) {
				return e !== t && (this._onbuttondown && 1 === e && this._onbuttondown(i), this._onbuttonup && 0 === e && this._onbuttonup(i)), e
			}, t.prototype._setDPadValue = function(e, t, i) {
				return e !== t && (this._ondpaddown && 1 === e && this._ondpaddown(i), this._ondpadup && 0 === e && this._ondpadup(i)), e
			}, Object.defineProperty(t.prototype, "buttonA", {
				get: function() {
					return this._buttonA
				},
				set: function(e) {
					this._buttonA = this._setButtonValue(e, this._buttonA, o.A)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonB", {
				get: function() {
					return this._buttonB
				},
				set: function(e) {
					this._buttonB = this._setButtonValue(e, this._buttonB, o.B)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonX", {
				get: function() {
					return this._buttonX
				},
				set: function(e) {
					this._buttonX = this._setButtonValue(e, this._buttonX, o.X)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonY", {
				get: function() {
					return this._buttonY
				},
				set: function(e) {
					this._buttonY = this._setButtonValue(e, this._buttonY, o.Y)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonStart", {
				get: function() {
					return this._buttonStart
				},
				set: function(e) {
					this._buttonStart = this._setButtonValue(e, this._buttonStart, o.Start)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonBack", {
				get: function() {
					return this._buttonBack
				},
				set: function(e) {
					this._buttonBack = this._setButtonValue(e, this._buttonBack, o.Back)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonLB", {
				get: function() {
					return this._buttonLB
				},
				set: function(e) {
					this._buttonLB = this._setButtonValue(e, this._buttonLB, o.LB)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonRB", {
				get: function() {
					return this._buttonRB
				},
				set: function(e) {
					this._buttonRB = this._setButtonValue(e, this._buttonRB, o.RB)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonLeftStick", {
				get: function() {
					return this._buttonLeftStick
				},
				set: function(e) {
					this._buttonLeftStick = this._setButtonValue(e, this._buttonLeftStick, o.LeftStick)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "buttonRightStick", {
				get: function() {
					return this._buttonRightStick
				},
				set: function(e) {
					this._buttonRightStick = this._setButtonValue(e, this._buttonRightStick, o.RightStick)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "dPadUp", {
				get: function() {
					return this._dPadUp
				},
				set: function(e) {
					this._dPadUp = this._setDPadValue(e, this._dPadUp, s.Up)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "dPadDown", {
				get: function() {
					return this._dPadDown
				},
				set: function(e) {
					this._dPadDown = this._setDPadValue(e, this._dPadDown, s.Down)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "dPadLeft", {
				get: function() {
					return this._dPadLeft
				},
				set: function(e) {
					this._dPadLeft = this._setDPadValue(e, this._dPadLeft, s.Left)
				},
				enumerable: !0,
				configurable: !0
			}), Object.defineProperty(t.prototype, "dPadRight", {
				get: function() {
					return this._dPadRight
				},
				set: function(e) {
					this._dPadRight = this._setDPadValue(e, this._dPadRight, s.Right)
				},
				enumerable: !0,
				configurable: !0
			}), t.prototype.update = function() {
				e.prototype.update.call(this), this._isXboxOnePad ? (this.buttonA = this.browserGamepad.buttons[0].value, this.buttonB = this.browserGamepad.buttons[1].value, this.buttonX = this.browserGamepad.buttons[2].value, this.buttonY = this.browserGamepad.buttons[3].value, this.buttonLB = this.browserGamepad.buttons[4].value, this.buttonRB = this.browserGamepad.buttons[5].value, this.leftTrigger = this.browserGamepad.axes[2], this.rightTrigger = this.browserGamepad.axes[5], this.buttonBack = this.browserGamepad.buttons[9].value, this.buttonStart = this.browserGamepad.buttons[8].value, this.buttonLeftStick = this.browserGamepad.buttons[6].value, this.buttonRightStick = this.browserGamepad.buttons[7].value, this.dPadUp = this.browserGamepad.buttons[11].value, this.dPadDown = this.browserGamepad.buttons[12].value, this.dPadLeft = this.browserGamepad.buttons[13].value, this.dPadRight = this.browserGamepad.buttons[14].value) : (this.buttonA = this.browserGamepad.buttons[0].value, this.buttonB = this.browserGamepad.buttons[1].value, this.buttonX = this.browserGamepad.buttons[2].value, this.buttonY = this.browserGamepad.buttons[3].value, this.buttonLB = this.browserGamepad.buttons[4].value, this.buttonRB = this.browserGamepad.buttons[5].value, this.leftTrigger = this.browserGamepad.buttons[6].value, this.rightTrigger = this.browserGamepad.buttons[7].value, this.buttonBack = this.browserGamepad.buttons[8].value, this.buttonStart = this.browserGamepad.buttons[9].value, this.buttonLeftStick = this.browserGamepad.buttons[10].value, this.buttonRightStick = this.browserGamepad.buttons[11].value,
					this.dPadUp = this.browserGamepad.buttons[12].value, this.dPadDown = this.browserGamepad.buttons[13].value, this.dPadLeft = this.browserGamepad.buttons[14].value, this.dPadRight = this.browserGamepad.buttons[15].value)
			}, t
		})(r);
	e.Xbox360Pad = a
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n) {
			e.Tools.Warn("Deprecated. Please use Universal Camera instead."), t.call(this, i, r, n)
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "gamepadAngularSensibility", {
			get: function() {
				var e = this.inputs.attached.gamepad;
				if (e) return e.gamepadAngularSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.gamepad;
				t && (t.gamepadAngularSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "gamepadMoveSensibility", {
			get: function() {
				var e = this.inputs.attached.gamepad;
				if (e) return e.gamepadMoveSensibility
			},
			set: function(e) {
				var t = this.inputs.attached.gamepad;
				t && (t.gamepadMoveSensibility = e)
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.getTypeName = function() {
			return "GamepadCamera"
		}, i
	})(e.UniversalCamera);
	e.GamepadCamera = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t) {
			this.SMOOTHING = .75, this.FFT_SIZE = 512, this.BARGRAPHAMPLITUDE = 256, this.DEBUGCANVASPOS = {
				x: 20,
				y: 20
			}, this.DEBUGCANVASSIZE = {
				width: 320,
				height: 200
			}, this._scene = t, this._audioEngine = e.Engine.audioEngine, this._audioEngine.canUseWebAudio && (this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser(), this._webAudioAnalyser.minDecibels = -140, this._webAudioAnalyser.maxDecibels = 0, this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount), this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount), this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount))
		}
		return t.prototype.getFrequencyBinCount = function() {
			return this._audioEngine.canUseWebAudio ? this._webAudioAnalyser.frequencyBinCount : 0
		}, t.prototype.getByteFrequencyData = function() {
			return this._audioEngine.canUseWebAudio && (this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING, this._webAudioAnalyser.fftSize = this.FFT_SIZE, this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs)), this._byteFreqs
		}, t.prototype.getByteTimeDomainData = function() {
			return this._audioEngine.canUseWebAudio && (this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING, this._webAudioAnalyser.fftSize = this.FFT_SIZE, this._webAudioAnalyser.getByteTimeDomainData(this._byteTime)), this._byteTime
		}, t.prototype.getFloatFrequencyData = function() {
			return this._audioEngine.canUseWebAudio && (this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING, this._webAudioAnalyser.fftSize = this.FFT_SIZE, this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs)), this._floatFreqs
		}, t.prototype.drawDebugCanvas = function() {
			var e = this;
			if (this._audioEngine.canUseWebAudio && (this._debugCanvas || (this._debugCanvas = document.createElement("canvas"), this._debugCanvas.width = this.DEBUGCANVASSIZE.width, this._debugCanvas.height = this.DEBUGCANVASSIZE.height, this._debugCanvas.style.position = "absolute", this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + "px", this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + "px", this._debugCanvasContext = this._debugCanvas.getContext("2d"), document.body.appendChild(this._debugCanvas), this._registerFunc = function() {
					e.drawDebugCanvas()
				}, this._scene.registerBeforeRender(this._registerFunc)), this._registerFunc)) {
				var t = this.getByteFrequencyData();
				this._debugCanvasContext.fillStyle = "rgb(0, 0, 0)", this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);
				for (var i = 0; i < this.getFrequencyBinCount(); i++) {
					var r = t[i],
						n = r / this.BARGRAPHAMPLITUDE,
						o = this.DEBUGCANVASSIZE.height * n,
						s = this.DEBUGCANVASSIZE.height - o - 1,
						a = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount(),
						h = i / this.getFrequencyBinCount() * 360;
					this._debugCanvasContext.fillStyle = "hsl(" + h + ", 100%, 50%)", this._debugCanvasContext.fillRect(i * a, s, a, o)
				}
			}
		}, t.prototype.stopDebugCanvas = function() {
			this._debugCanvas && (this._scene.unregisterBeforeRender(this._registerFunc), this._registerFunc = null, document.body.removeChild(this._debugCanvas), this._debugCanvas = null, this._debugCanvasContext = null)
		}, t.prototype.connectAudioNodes = function(e, t) {
			this._audioEngine.canUseWebAudio && (e.connect(this._webAudioAnalyser), this._webAudioAnalyser.connect(t))
		}, t.prototype.dispose = function() {
			this._audioEngine.canUseWebAudio && this._webAudioAnalyser.disconnect()
		}, t
	})();
	e.Analyser = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i) {
			var r = this;
			void 0 === i && (i = e.Engine.TEXTURETYPE_FLOAT), this._viewMatrix = e.Matrix.Zero(), this._projectionMatrix = e.Matrix.Zero(), this._transformMatrix = e.Matrix.Zero(), this._worldViewProjection = e.Matrix.Zero(), this._scene = t;
			var n = t.getEngine();
			this._depthMap = new e.RenderTargetTexture("depthMap", {
				width: n.getRenderWidth(),
				height: n.getRenderHeight()
			}, this._scene, (!1), (!0), i), this._depthMap.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._depthMap.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._depthMap.refreshRate = 1, this._depthMap.renderParticles = !1, this._depthMap.renderList = null, this._depthMap.onClearObservable.add((function(t) {
				t.clear(new e.Color4(1, 1, 1, 1), !0, !0, !0)
			}));
			var o = function(t) {
				var i = t.getRenderingMesh(),
					n = r._scene,
					o = n.getEngine();
				o.setState(t.getMaterial().backFaceCulling);
				var s = i._getInstancesRenderList(t._id);
				if (!s.mustReturn) {
					var a = null !== o.getCaps().instancedArrays && null !== s.visibleInstances[t._id];
					if (r.isReady(t, a)) {
						o.enableEffect(r._effect), i._bind(t, r._effect, e.Material.TriangleFillMode);
						var h = t.getMaterial();
						if (r._effect.setMatrix("viewProjection", n.getTransformMatrix()), r._effect.setFloat("far", n.activeCamera.maxZ), h && h.needAlphaTesting()) {
							var c = h.getAlphaTestTexture();
							r._effect.setTexture("diffuseSampler", c), r._effect.setMatrix("diffuseMatrix", c.getTextureMatrix())
						}
						i.useBones && i.computeBonesUsingShaders && r._effect.setMatrices("mBones", i.skeleton.getTransformMatrices(i)), i._processRendering(t, r._effect, e.Material.TriangleFillMode, s, a, (function(e, t) {
							return r._effect.setMatrix("world", t)
						}))
					}
				}
			};
			this._depthMap.customRenderFunction = function(e, t) {
				var i;
				for (i = 0; i < e.length; i++) o(e.data[i]);
				for (i = 0; i < t.length; i++) o(t.data[i])
			}
		}
		return t.prototype.isReady = function(t, i) {
			var r = t.getMaterial();
			if (r.disableDepthWrite) return !1;
			var n = [],
				o = [e.VertexBuffer.PositionKind],
				s = t.getMesh();
			s.getScene();
			r && r.needAlphaTesting() && (n.push("#define ALPHATEST"), s.isVerticesDataPresent(e.VertexBuffer.UVKind) && (o.push(e.VertexBuffer.UVKind), n.push("#define UV1")), s.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (o.push(e.VertexBuffer.UV2Kind), n.push("#define UV2"))), s.useBones && s.computeBonesUsingShaders ? (o.push(e.VertexBuffer.MatricesIndicesKind), o.push(e.VertexBuffer.MatricesWeightsKind), s.numBoneInfluencers > 4 && (o.push(e.VertexBuffer.MatricesIndicesExtraKind), o.push(e.VertexBuffer.MatricesWeightsExtraKind)), n.push("#define NUM_BONE_INFLUENCERS " + s.numBoneInfluencers), n.push("#define BonesPerMesh " + (s.skeleton.bones.length + 1))) : n.push("#define NUM_BONE_INFLUENCERS 0"), i && (n.push("#define INSTANCES"), o.push("world0"), o.push("world1"), o.push("world2"), o.push("world3"));
			var a = n.join("\n");
			return this._cachedDefines !== a && (this._cachedDefines = a, this._effect = this._scene.getEngine().createEffect("depth", o, ["world", "mBones", "viewProjection", "diffuseMatrix", "far"], ["diffuseSampler"], a)), this._effect.isReady()
		}, t.prototype.getDepthMap = function() {
			return this._depthMap
		}, t.prototype.dispose = function() {
			this._depthMap.dispose()
		}, t
	})();
	e.DepthRenderer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o) {
			var s = this;
			t.call(this, r.getEngine(), i), this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect", this.SSAORenderEffect = "SSAORenderEffect", this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect", this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect", this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect", this.totalStrength = 1, this.radius = 1e-4, this.area = .0075, this.fallOff = 1e-6, this.base = .5, this._firstUpdate = !0, this._scene = r, this._createRandomTexture(), this._depthTexture = r.enableDepthRenderer().getDepthMap();
			var a = n.ssaoRatio || n,
				h = n.combineRatio || n;
			this._ratio = {
				ssaoRatio: a,
				combineRatio: h
			}, this._originalColorPostProcess = new e.PassPostProcess("SSAOOriginalSceneColor", h, null, e.Texture.BILINEAR_SAMPLINGMODE, r.getEngine(), (!1)), this._createSSAOPostProcess(a), this._createBlurPostProcess(a), this._createSSAOCombinePostProcess(h), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), this.SSAOOriginalSceneColorEffect, function() {
				return s._originalColorPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), this.SSAORenderEffect, function() {
				return s._ssaoPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), this.SSAOBlurHRenderEffect, function() {
				return s._blurHPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), this.SSAOBlurVRenderEffect, function() {
				return s._blurVPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), this.SSAOCombineRenderEffect, function() {
				return s._ssaoCombinePostProcess
			}, (!0))), r.postProcessRenderPipelineManager.addPipeline(this), o && r.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(i, o)
		}
		return __extends(i, t), i.prototype.getBlurHPostProcess = function() {
			return e.Tools.Error("SSAORenderinPipeline.getBlurHPostProcess() is deprecated, no more blur post-process exists"), null
		}, i.prototype.getBlurVPostProcess = function() {
			return e.Tools.Error("SSAORenderinPipeline.getBlurVPostProcess() is deprecated, no more blur post-process exists"), null
		}, i.prototype.dispose = function(e) {
			void 0 === e && (e = !1);
			for (var t = 0; t < this._scene.cameras.length; t++) {
				var i = this._scene.cameras[t];
				this._originalColorPostProcess.dispose(i), this._ssaoPostProcess.dispose(i), this._blurHPostProcess.dispose(i), this._blurVPostProcess.dispose(i), this._ssaoCombinePostProcess.dispose(i)
			}
			this._randomTexture.dispose(), e && this._scene.disableDepthRenderer(), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras)
		}, i.prototype._createBlurPostProcess = function(t) {
			for (var i = this, r = [], n = -8; n < 8; n++) r.push(2 * n);
			this._blurHPostProcess = new e.PostProcess("BlurH", "ssao", ["outSize", "samplerOffsets"], ["depthSampler"], t, null, e.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1), "#define BILATERAL_BLUR\n#define BILATERAL_BLUR_H\n#define SAMPLES 16"), this._blurHPostProcess.onApply = function(e) {
				e.setFloat("outSize", i._ssaoCombinePostProcess.width), e.setTexture("depthSampler", i._depthTexture), i._firstUpdate && e.setArray("samplerOffsets", r)
			}, this._blurVPostProcess = new e.PostProcess("BlurV", "ssao", ["outSize", "samplerOffsets"], ["depthSampler"], t, null, e.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1), "#define BILATERAL_BLUR\n#define SAMPLES 16"), this._blurVPostProcess.onApply = function(e) {
				e.setFloat("outSize", i._ssaoCombinePostProcess.height), e.setTexture("depthSampler", i._depthTexture), i._firstUpdate && (e.setArray("samplerOffsets", r), i._firstUpdate = !1)
			}
		}, i.prototype._createSSAOPostProcess = function(t) {
			var i = this,
				r = 16,
				n = [.5381, .1856, -.4319, .1379, .2486, .443, .3371, .5679, -.0057, -.6999, -.0451, -.0019, .0689, -.1598, -.8547, .056, .0069, -.1843, -.0146, .1402, .0762, .01, -.1924, -.0344, -.3577, -.5301, -.4358, -.3169, .1063, .0158, .0103, -.5869, .0046, -.0897, -.494, .3287, .7119, -.0154, -.0918, -.0533, .0596, -.5411, .0352, -.0631, .546, -.4776, .2847, -.0271],
				o = 1 / r;
			this._ssaoPostProcess = new e.PostProcess("ssao", "ssao", ["sampleSphere", "samplesFactor", "randTextureTiles", "totalStrength", "radius", "area", "fallOff", "base", "range", "viewport"], ["randomSampler"], t, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1), "#define SAMPLES " + r + "\n#define SSAO");
			new e.Vector2(0, 0);
			this._ssaoPostProcess.onApply = function(e) {
				i._firstUpdate && (e.setArray3("sampleSphere", n), e.setFloat("samplesFactor", o), e.setFloat("randTextureTiles", 4)), e.setFloat("totalStrength", i.totalStrength), e.setFloat("radius", i.radius), e.setFloat("area", i.area), e.setFloat("fallOff", i.fallOff), e.setFloat("base", i.base), e.setTexture("textureSampler", i._depthTexture), e.setTexture("randomSampler", i._randomTexture)
			}
		}, i.prototype._createSSAOCombinePostProcess = function(t) {
			var i = this;
			this._ssaoCombinePostProcess = new e.PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor"], t, null, e.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1)), this._ssaoCombinePostProcess.onApply = function(e) {
				e.setTextureFromPostProcess("originalColor", i._originalColorPostProcess)
			}
		}, i.prototype._createRandomTexture = function() {
			var t = 512;
			this._randomTexture = new e.DynamicTexture("SSAORandomTexture", t, this._scene, (!1), e.Texture.TRILINEAR_SAMPLINGMODE), this._randomTexture.wrapU = e.Texture.WRAP_ADDRESSMODE, this._randomTexture.wrapV = e.Texture.WRAP_ADDRESSMODE;
			for (var i = this._randomTexture.getContext(), r = function(e, t) {
					return Math.random() * (t - e) + e
				}, n = e.Vector3.Zero(), o = 0; o < t; o++)
				for (var s = 0; s < t; s++) n.x = Math.floor(255 * r(-1, 1)), n.y = Math.floor(255 * r(-1, 1)), n.z = Math.floor(255 * r(-1, 1)), i.fillStyle = "rgb(" + n.x + ", " + n.y + ", " + n.z + ")", i.fillRect(o, s, 1, 1);
			this._randomTexture.update(!1)
		}, __decorate([e.serialize()], i.prototype, "totalStrength", void 0), __decorate([e.serialize()], i.prototype, "radius", void 0), __decorate([e.serialize()], i.prototype, "area", void 0), __decorate([e.serialize()], i.prototype, "fallOff", void 0), __decorate([e.serialize()], i.prototype, "base", void 0), __decorate([e.serialize()], i.prototype, "_ratio", void 0), i
	})(e.PostProcessRenderPipeline);
	e.SSAORenderingPipeline = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(r, n, o, s, a, h, c, l, u) {
			var d = this;
			void 0 === a && (a = 100), void 0 === h && (h = e.Texture.BILINEAR_SAMPLINGMODE), t.call(this, r, "volumetricLightScattering", ["decay", "exposure", "weight", "meshPositionOnScreen", "density"], ["lightScatteringSampler"], n.postProcessRatio || n, o, h, c, l, "#define NUM_SAMPLES " + a), this._screenCoordinates = e.Vector2.Zero(), this.customMeshPosition = e.Vector3.Zero(), this.useCustomMeshPosition = !1, this.invert = !0, this.excludedMeshes = new Array, this.exposure = .3, this.decay = .96815, this.weight = .58767, this.density = .926, u = null === o ? u : o.getScene();
			var c = u.getEngine();
			this._viewPort = new e.Viewport(0, 0, 1, 1).toGlobal(c.getRenderWidth(), c.getRenderHeight()), this.mesh = null !== s ? s : i.CreateDefaultMesh("VolumetricLightScatteringMesh", u), this._createPass(u, n.passRatio || n), this.onActivate = function(e) {
				d.isSupported || d.dispose(e), d.onActivate = null
			}, this.onApplyObservable.add((function(e) {
				d._updateMeshScreenCoordinates(u), e.setTexture("lightScatteringSampler", d._volumetricLightScatteringRTT), e.setFloat("exposure", d.exposure), e.setFloat("decay", d.decay), e.setFloat("weight", d.weight), e.setFloat("density", d.density), e.setVector2("meshPositionOnScreen", d._screenCoordinates)
			}))
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "useDiffuseColor", {
			get: function() {
				return e.Tools.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead"), !1
			},
			set: function(t) {
				e.Tools.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead")
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype.isReady = function(t, i) {
			var r = t.getMesh();
			if (r === this.mesh) return r.material.isReady(r);
			var n = [],
				o = [e.VertexBuffer.PositionKind],
				s = t.getMaterial();
			s && (s.needAlphaTesting() && n.push("#define ALPHATEST"), r.isVerticesDataPresent(e.VertexBuffer.UVKind) && (o.push(e.VertexBuffer.UVKind), n.push("#define UV1")), r.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (o.push(e.VertexBuffer.UV2Kind), n.push("#define UV2"))), r.useBones && r.computeBonesUsingShaders ? (o.push(e.VertexBuffer.MatricesIndicesKind), o.push(e.VertexBuffer.MatricesWeightsKind), n.push("#define NUM_BONE_INFLUENCERS " + r.numBoneInfluencers), n.push("#define BonesPerMesh " + (r.skeleton.bones.length + 1))) : n.push("#define NUM_BONE_INFLUENCERS 0"), i && (n.push("#define INSTANCES"), o.push("world0"), o.push("world1"), o.push("world2"), o.push("world3"));
			var a = n.join("\n");
			return this._cachedDefines !== a && (this._cachedDefines = a, this._volumetricLightScatteringPass = r.getScene().getEngine().createEffect({
				vertexElement: "depth",
				fragmentElement: "volumetricLightScatteringPass"
			}, o, ["world", "mBones", "viewProjection", "diffuseMatrix"], ["diffuseSampler"], a)), this._volumetricLightScatteringPass.isReady()
		}, i.prototype.setCustomMeshPosition = function(e) {
			this.customMeshPosition = e
		}, i.prototype.getCustomMeshPosition = function() {
			return this.customMeshPosition
		}, i.prototype.dispose = function(e) {
			var i = e.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);
			i !== -1 && e.getScene().customRenderTargets.splice(i, 1), this._volumetricLightScatteringRTT.dispose(), t.prototype.dispose.call(this, e)
		}, i.prototype.getPass = function() {
			return this._volumetricLightScatteringRTT
		}, i.prototype._meshExcluded = function(e) {
			return this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(e) !== -1
		}, i.prototype._createPass = function(t, i) {
			var r = this,
				n = t.getEngine();
			this._volumetricLightScatteringRTT = new e.RenderTargetTexture("volumetricLightScatteringMap", {
				width: n.getRenderWidth() * i,
				height: n.getRenderHeight() * i
			}, t, (!1), (!0), e.Engine.TEXTURETYPE_UNSIGNED_INT), this._volumetricLightScatteringRTT.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._volumetricLightScatteringRTT.wrapV = e.Texture.CLAMP_ADDRESSMODE, this._volumetricLightScatteringRTT.renderList = null, this._volumetricLightScatteringRTT.renderParticles = !1, t.customRenderTargets.push(this._volumetricLightScatteringRTT);
			var o, s = function(t) {
					var i = t.getRenderingMesh();
					if (!r._meshExcluded(i)) {
						var n = i.getScene(),
							o = n.getEngine();
						o.setState(t.getMaterial().backFaceCulling);
						var s = i._getInstancesRenderList(t._id);
						if (!s.mustReturn) {
							var a = null !== o.getCaps().instancedArrays && null !== s.visibleInstances[t._id];
							if (r.isReady(t, a)) {
								var h = r._volumetricLightScatteringPass;
								if (i === r.mesh && (h = t.getMaterial().getEffect()), o.enableEffect(h), i._bind(t, h, e.Material.TriangleFillMode), i === r.mesh) t.getMaterial().bind(i.getWorldMatrix(), i);
								else {
									var c = t.getMaterial();
									if (r._volumetricLightScatteringPass.setMatrix("viewProjection", n.getTransformMatrix()), c && c.needAlphaTesting()) {
										var l = c.getAlphaTestTexture();
										r._volumetricLightScatteringPass.setTexture("diffuseSampler", l), l && r._volumetricLightScatteringPass.setMatrix("diffuseMatrix", l.getTextureMatrix())
									}
									i.useBones && i.computeBonesUsingShaders && r._volumetricLightScatteringPass.setMatrices("mBones", i.skeleton.getTransformMatrices(i))
								}
								i._processRendering(t, r._volumetricLightScatteringPass, e.Material.TriangleFillMode, s, a, (function(e, t) {
									return h.setMatrix("world", t)
								}))
							}
						}
					}
				},
				a = new e.Color4(0, 0, 0, 1);
			this._volumetricLightScatteringRTT.onBeforeRenderObservable.add((function() {
				o = t.clearColor, t.clearColor = a
			})), this._volumetricLightScatteringRTT.onAfterRenderObservable.add((function() {
				t.clearColor = o
			})), this._volumetricLightScatteringRTT.customRenderFunction = function(i, r, n) {
				var o, a = t.getEngine();
				for (o = 0; o < i.length; o++) s(i.data[o]);
				for (a.setAlphaTesting(!0), o = 0; o < r.length; o++) s(r.data[o]);
				if (a.setAlphaTesting(!1), n.length) {
					for (o = 0; o < n.length; o++) {
						var h = n.data[o];
						h._alphaIndex = h.getMesh().alphaIndex, h._distanceToCamera = h.getBoundingInfo().boundingSphere.centerWorld.subtract(t.activeCamera.position).length()
					}
					var c = n.data.slice(0, n.length);
					for (c.sort((function(e, t) {
							return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0
						})), a.setAlphaMode(e.Engine.ALPHA_COMBINE), o = 0; o < c.length; o++) s(c[o]);
					a.setAlphaMode(e.Engine.ALPHA_DISABLE)
				}
			}
		}, i.prototype._updateMeshScreenCoordinates = function(t) {
			var i, r = t.getTransformMatrix();
			i = this.useCustomMeshPosition ? this.customMeshPosition : this.attachedNode ? this.attachedNode.position : this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;
			var n = e.Vector3.Project(i, e.Matrix.Identity(), r, this._viewPort);
			this._screenCoordinates.x = n.x / this._viewPort.width, this._screenCoordinates.y = n.y / this._viewPort.height, this.invert && (this._screenCoordinates.y = 1 - this._screenCoordinates.y)
		}, i.CreateDefaultMesh = function(t, i) {
			var r = e.Mesh.CreatePlane(t, 1, i);
			r.billboardMode = e.AbstractMesh.BILLBOARDMODE_ALL;
			var n = new e.StandardMaterial(t + "Material", i);
			return n.emissiveColor = new e.Color3(1, 1, 1), r.material = n, r
		}, __decorate([e.serializeAsVector3()], i.prototype, "customMeshPosition", void 0), __decorate([e.serialize()], i.prototype, "useCustomMeshPosition", void 0), __decorate([e.serialize()], i.prototype, "invert", void 0), __decorate([e.serializeAsMeshReference()], i.prototype, "mesh", void 0), __decorate([e.serialize()], i.prototype, "excludedMeshes", void 0), __decorate([e.serialize()], i.prototype, "exposure", void 0), __decorate([e.serialize()], i.prototype, "decay", void 0), __decorate([e.serialize()], i.prototype, "weight", void 0), __decorate([e.serialize()], i.prototype, "density", void 0), i
	})(e.PostProcess);
	e.VolumetricLightScatteringPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			var a = this;
			void 0 === o && (o = 1), t.call(this, n.getEngine(), i), this.LensChromaticAberrationEffect = "LensChromaticAberrationEffect", this.HighlightsEnhancingEffect = "HighlightsEnhancingEffect", this.LensDepthOfFieldEffect = "LensDepthOfFieldEffect", this._scene = n, this._depthTexture = n.enableDepthRenderer().getDepthMap(), r.grain_texture ? this._grainTexture = r.grain_texture : this._createGrainTexture(), this._edgeBlur = r.edge_blur ? r.edge_blur : 0, this._grainAmount = r.grain_amount ? r.grain_amount : 0, this._chromaticAberration = r.chromatic_aberration ? r.chromatic_aberration : 0, this._distortion = r.distortion ? r.distortion : 0, this._highlightsGain = void 0 !== r.dof_gain ? r.dof_gain : -1, this._highlightsThreshold = r.dof_threshold ? r.dof_threshold : 1, this._dofDistance = void 0 !== r.dof_focus_distance ? r.dof_focus_distance : -1, this._dofAperture = r.dof_aperture ? r.dof_aperture : 1, this._dofDarken = r.dof_darken ? r.dof_darken : 0, this._dofPentagon = void 0 === r.dof_pentagon || r.dof_pentagon, this._blurNoise = void 0 === r.blur_noise || r.blur_noise, this._createChromaticAberrationPostProcess(o), this._createHighlightsPostProcess(o), this._createDepthOfFieldPostProcess(o / 4), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), this.LensChromaticAberrationEffect, function() {
				return a._chromaticAberrationPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), this.HighlightsEnhancingEffect, function() {
				return a._highlightsPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), this.LensDepthOfFieldEffect, function() {
				return a._depthOfFieldPostProcess
			}, (!0))), this._highlightsGain === -1 && this._disableEffect(this.HighlightsEnhancingEffect, null), n.postProcessRenderPipelineManager.addPipeline(this), s && n.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(i, s)
		}
		return __extends(i, t), i.prototype.setEdgeBlur = function(e) {
			this._edgeBlur = e
		}, i.prototype.disableEdgeBlur = function() {
			this._edgeBlur = 0
		}, i.prototype.setGrainAmount = function(e) {
			this._grainAmount = e
		}, i.prototype.disableGrain = function() {
			this._grainAmount = 0
		}, i.prototype.setChromaticAberration = function(e) {
			this._chromaticAberration = e
		}, i.prototype.disableChromaticAberration = function() {
			this._chromaticAberration = 0
		}, i.prototype.setEdgeDistortion = function(e) {
			this._distortion = e
		}, i.prototype.disableEdgeDistortion = function() {
			this._distortion = 0
		}, i.prototype.setFocusDistance = function(e) {
			this._dofDistance = e
		}, i.prototype.disableDepthOfField = function() {
			this._dofDistance = -1
		}, i.prototype.setAperture = function(e) {
			this._dofAperture = e
		}, i.prototype.setDarkenOutOfFocus = function(e) {
			this._dofDarken = e
		}, i.prototype.enablePentagonBokeh = function() {
			this._highlightsPostProcess.updateEffect("#define PENTAGON\n")
		}, i.prototype.disablePentagonBokeh = function() {
			this._highlightsPostProcess.updateEffect()
		}, i.prototype.enableNoiseBlur = function() {
			this._blurNoise = !0
		}, i.prototype.disableNoiseBlur = function() {
			this._blurNoise = !1
		}, i.prototype.setHighlightsGain = function(e) {
			this._highlightsGain = e
		}, i.prototype.setHighlightsThreshold = function(e) {
			this._highlightsGain === -1 && (this._highlightsGain = 1), this._highlightsThreshold = e
		}, i.prototype.disableHighlights = function() {
			this._highlightsGain = -1
		}, i.prototype.dispose = function(e) {
			void 0 === e && (e = !1), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras), this._chromaticAberrationPostProcess = void 0, this._highlightsPostProcess = void 0, this._depthOfFieldPostProcess = void 0, this._grainTexture.dispose(), e && this._scene.disableDepthRenderer()
		}, i.prototype._createChromaticAberrationPostProcess = function(t) {
			var i = this;
			this._chromaticAberrationPostProcess = new e.PostProcess("LensChromaticAberration", "chromaticAberration", ["chromatic_aberration", "screen_width", "screen_height"], [], t, null, e.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1)), this._chromaticAberrationPostProcess.onApply = function(e) {
				e.setFloat("chromatic_aberration", i._chromaticAberration), e.setFloat("screen_width", i._scene.getEngine().getRenderingCanvas().width), e.setFloat("screen_height", i._scene.getEngine().getRenderingCanvas().height)
			}
		}, i.prototype._createHighlightsPostProcess = function(t) {
			var i = this;
			this._highlightsPostProcess = new e.PostProcess("LensHighlights", "lensHighlights", ["gain", "threshold", "screen_width", "screen_height"], [], t, null, e.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1), this._dofPentagon ? "#define PENTAGON\n" : ""), this._highlightsPostProcess.onApply = function(e) {
				e.setFloat("gain", i._highlightsGain), e.setFloat("threshold", i._highlightsThreshold), e.setTextureFromPostProcess("textureSampler", i._chromaticAberrationPostProcess), e.setFloat("screen_width", i._scene.getEngine().getRenderingCanvas().width), e.setFloat("screen_height", i._scene.getEngine().getRenderingCanvas().height)
			}
		}, i.prototype._createDepthOfFieldPostProcess = function(t) {
			var i = this;
			this._depthOfFieldPostProcess = new e.PostProcess("LensDepthOfField", "depthOfField", ["grain_amount", "blur_noise", "screen_width", "screen_height", "distortion", "dof_enabled", "screen_distance", "aperture", "darken", "edge_blur", "highlights", "near", "far"], ["depthSampler", "grainSampler", "highlightsSampler"], t, null, e.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), (!1)), this._depthOfFieldPostProcess.onApply = function(e) {
				e.setTexture("depthSampler", i._depthTexture), e.setTexture("grainSampler", i._grainTexture), e.setTextureFromPostProcess("textureSampler", i._highlightsPostProcess), e.setTextureFromPostProcess("highlightsSampler", i._depthOfFieldPostProcess), e.setFloat("grain_amount", i._grainAmount), e.setBool("blur_noise", i._blurNoise), e.setFloat("screen_width", i._scene.getEngine().getRenderingCanvas().width), e.setFloat("screen_height", i._scene.getEngine().getRenderingCanvas().height), e.setFloat("distortion", i._distortion), e.setBool("dof_enabled", i._dofDistance !== -1), e.setFloat("screen_distance", 1 / (.1 - 1 / i._dofDistance)), e.setFloat("aperture", i._dofAperture), e.setFloat("darken", i._dofDarken), e.setFloat("edge_blur", i._edgeBlur), e.setBool("highlights", i._highlightsGain !== -1), e.setFloat("near", i._scene.activeCamera.minZ), e.setFloat("far", i._scene.activeCamera.maxZ)
			}
		}, i.prototype._createGrainTexture = function() {
			var t = 512;
			this._grainTexture = new e.DynamicTexture("LensNoiseTexture", t, this._scene, (!1), e.Texture.BILINEAR_SAMPLINGMODE), this._grainTexture.wrapU = e.Texture.WRAP_ADDRESSMODE, this._grainTexture.wrapV = e.Texture.WRAP_ADDRESSMODE;
			for (var i, r = this._grainTexture.getContext(), n = function(e, t) {
					return Math.random() * (t - e) + e
				}, o = 0; o < t; o++)
				for (var s = 0; s < t; s++) i = Math.floor(255 * n(.42, .58)), r.fillStyle = "rgb(" + i + ", " + i + ", " + i + ")", r.fillRect(o, s, 1, 1);
			this._grainTexture.update(!1)
		}, i
	})(e.PostProcessRenderPipeline);
	e.LensRenderingPipeline = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h) {
			var c = this;
			t.call(this, i, "colorCorrection", null, ["colorTable"], n, o, s, a, h), this._colorTableTexture = new e.Texture(r, o.getScene(), (!0), (!1), e.Texture.TRILINEAR_SAMPLINGMODE), this._colorTableTexture.anisotropicFilteringLevel = 1, this._colorTableTexture.wrapU = e.Texture.CLAMP_ADDRESSMODE, this._colorTableTexture.wrapV = e.Texture.CLAMP_ADDRESSMODE, this.onApply = function(e) {
				e.setTexture("colorTable", c._colorTableTexture)
			}
		}
		return __extends(i, t), i
	})(e.PostProcess);
	e.ColorCorrectionPostProcess = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o) {
			t.call(this, i, r, o), this.interaxialDistance = n, this.setCameraRigMode(e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {
				interaxialDistance: n
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "AnaglyphFreeCamera"
		}, i
	})(e.FreeCamera);
	e.AnaglyphFreeCamera = t;
	var i = (function(t) {
		function i(i, r, n, o, s, a, h) {
			t.call(this, i, r, n, o, s, h), this.interaxialDistance = a, this.setCameraRigMode(e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {
				interaxialDistance: a
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "AnaglyphArcRotateCamera"
		}, i
	})(e.ArcRotateCamera);
	e.AnaglyphArcRotateCamera = i;
	var r = (function(t) {
		function i(i, r, n, o) {
			t.call(this, i, r, o), this.interaxialDistance = n, this.setCameraRigMode(e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {
				interaxialDistance: n
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "AnaglyphGamepadCamera"
		}, i
	})(e.GamepadCamera);
	e.AnaglyphGamepadCamera = r;
	var n = (function(t) {
		function i(i, r, n, o) {
			t.call(this, i, r, o), this.interaxialDistance = n, this.setCameraRigMode(e.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {
				interaxialDistance: n
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "AnaglyphUniversalCamera"
		}, i
	})(e.UniversalCamera);
	e.AnaglyphUniversalCamera = n;
	var o = (function(t) {
		function i(i, r, n, o, s) {
			t.call(this, i, r, s), this.interaxialDistance = n, this.isStereoscopicSideBySide = o, this.setCameraRigMode(o ? e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
				interaxialDistance: n
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "StereoscopicFreeCamera"
		}, i
	})(e.FreeCamera);
	e.StereoscopicFreeCamera = o;
	var s = (function(t) {
		function i(i, r, n, o, s, a, h, c) {
			t.call(this, i, r, n, o, s, c), this.interaxialDistance = a, this.isStereoscopicSideBySide = h, this.setCameraRigMode(h ? e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
				interaxialDistance: a
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "StereoscopicArcRotateCamera"
		}, i
	})(e.ArcRotateCamera);
	e.StereoscopicArcRotateCamera = s;
	var a = (function(t) {
		function i(i, r, n, o, s) {
			t.call(this, i, r, s), this.interaxialDistance = n, this.isStereoscopicSideBySide = o, this.setCameraRigMode(o ? e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
				interaxialDistance: n
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "StereoscopicGamepadCamera"
		}, i
	})(e.GamepadCamera);
	e.StereoscopicGamepadCamera = a;
	var h = (function(t) {
		function i(i, r, n, o, s) {
			t.call(this, i, r, s), this.interaxialDistance = n, this.isStereoscopicSideBySide = o, this.setCameraRigMode(o ? e.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : e.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {
				interaxialDistance: n
			})
		}
		return __extends(i, t), i.prototype.getTypeName = function() {
			return "StereoscopicUniversalCamera"
		}, i
	})(e.UniversalCamera);
	e.StereoscopicUniversalCamera = h
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(r, n, o, s, a) {
			var h = this;
			void 0 === s && (s = null), t.call(this, n.getEngine(), r), this.gaussCoeff = .3, this.gaussMean = 1, this.gaussStandDev = .8, this.gaussMultiplier = 4, this.exposure = 1, this.minimumLuminance = 1, this.maximumLuminance = 1e20, this.luminanceIncreaserate = .5, this.luminanceDecreaseRate = .5, this.brightThreshold = .8, this._needUpdate = !0, this._scene = n, this._createBrightPassPostProcess(n, o), this._createDownSampleX4PostProcess(n, o), this._createGaussianBlurPostProcess(n, o), this._createTextureAdderPostProcess(n, o), this._createLuminanceGeneratorPostProcess(n), this._createHDRPostProcess(n, o), null === s ? this._originalPostProcess = new e.PassPostProcess("hdr", o, null, e.Texture.BILINEAR_SAMPLINGMODE, n.getEngine(), (!1)) : this._originalPostProcess = s, this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRPassPostProcess", function() {
				return h._originalPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRBrightPass", function() {
				return h._brightPassPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRDownSampleX4", function() {
				return h._downSampleX4PostProcess;
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRGaussianBlurH", function() {
				return h._guassianBlurHPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRGaussianBlurV", function() {
				return h._guassianBlurVPostProcess
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRTextureAdder", function() {
				return h._textureAdderPostProcess
			}, (!0)));
			for (var c = function(t) {
					h.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDRDownSampler" + t, function() {
						return h._downSamplePostProcesses[t]
					}, (!0)))
				}, l = i.LUM_STEPS - 1; l >= 0; l--) c(l);
			this.addEffect(new e.PostProcessRenderEffect(n.getEngine(), "HDR", function() {
				return h._hdrPostProcess
			}, (!0))), n.postProcessRenderPipelineManager.addPipeline(this), null !== a && n.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(r, a), this.update()
		}
		return __extends(i, t), i.prototype.update = function() {
			this._needUpdate = !0
		}, i.prototype.getCurrentLuminance = function() {
			return this._hdrCurrentLuminance
		}, i.prototype.getOutputLuminance = function() {
			return this._hdrOutputLuminance
		}, i.prototype.dispose = function() {
			this._originalPostProcess = void 0, this._brightPassPostProcess = void 0, this._downSampleX4PostProcess = void 0, this._guassianBlurHPostProcess = void 0, this._guassianBlurVPostProcess = void 0, this._textureAdderPostProcess = void 0;
			for (var e = i.LUM_STEPS - 1; e >= 0; e--) this._downSamplePostProcesses[e] = void 0;
			this._hdrPostProcess = void 0, this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras)
		}, i.prototype._createHDRPostProcess = function(t, i) {
			var r = this,
				n = 0;
			this._hdrOutputLuminance = -1, this._hdrCurrentLuminance = 1, this._hdrPostProcess = new e.PostProcess("hdr", "hdr", ["exposure", "avgLuminance"], ["otherSampler"], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define HDR"), this._hdrPostProcess.onApply = function(i) {
				if (r._hdrOutputLuminance < 0) r._hdrOutputLuminance = r._hdrCurrentLuminance;
				else {
					var o = (n - (n + t.getEngine().getDeltaTime())) / 1e3;
					r._hdrCurrentLuminance < r._hdrOutputLuminance + r.luminanceDecreaseRate * o ? r._hdrOutputLuminance += r.luminanceDecreaseRate * o : r._hdrCurrentLuminance > r._hdrOutputLuminance - r.luminanceIncreaserate * o ? r._hdrOutputLuminance -= r.luminanceIncreaserate * o : r._hdrOutputLuminance = r._hdrCurrentLuminance
				}
				r._hdrOutputLuminance = e.MathTools.Clamp(r._hdrOutputLuminance, r.minimumLuminance, r.maximumLuminance), n += t.getEngine().getDeltaTime(), i.setTextureFromPostProcess("textureSampler", r._textureAdderPostProcess), i.setTextureFromPostProcess("otherSampler", r._originalPostProcess), i.setFloat("exposure", r.exposure), i.setFloat("avgLuminance", r._hdrOutputLuminance), r._needUpdate = !1
			}
		}, i.prototype._createTextureAdderPostProcess = function(t, i) {
			var r = this;
			this._textureAdderPostProcess = new e.PostProcess("hdr", "hdr", [], ["otherSampler"], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define TEXTURE_ADDER"), this._textureAdderPostProcess.onApply = function(e) {
				e.setTextureFromPostProcess("otherSampler", r._originalPostProcess)
			}
		}, i.prototype._createDownSampleX4PostProcess = function(t, i) {
			var r = this,
				n = new Array(32);
			this._downSampleX4PostProcess = new e.PostProcess("hdr", "hdr", ["dsOffsets"], [], i / 4, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define DOWN_SAMPLE_X4"), this._downSampleX4PostProcess.onApply = function(e) {
				if (r._needUpdate)
					for (var t = 0, i = -2; i < 2; i++)
						for (var o = -2; o < 2; o++) n[t] = (i + .5) * (1 / r._downSampleX4PostProcess.width), n[t + 1] = (o + .5) * (1 / r._downSampleX4PostProcess.height), t += 2;
				e.setArray2("dsOffsets", n)
			}
		}, i.prototype._createBrightPassPostProcess = function(t, i) {
			var r = this,
				n = new Array(8),
				o = function(e) {
					if (r._needUpdate) {
						var t = 1 / r._brightPassPostProcess.width,
							i = 1 / r._brightPassPostProcess.height;
						n[0] = -.5 * t, n[1] = .5 * i, n[2] = .5 * t, n[3] = .5 * i, n[4] = -.5 * t, n[5] = -.5 * i, n[6] = .5 * t, n[7] = -.5 * i
					}
					e.setArray2("dsOffsets", n), e.setFloat("brightThreshold", r.brightThreshold)
				};
			this._brightPassPostProcess = new e.PostProcess("hdr", "hdr", ["dsOffsets", "brightThreshold"], [], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define BRIGHT_PASS"), this._brightPassPostProcess.onApply = o
		}, i.prototype._createLuminanceGeneratorPostProcess = function(t) {
			var r, n = this,
				o = i.LUM_STEPS,
				s = new Array(8),
				a = new Array(18);
			this._downSamplePostProcesses = new Array(o);
			var h = function(e, t) {
					var i = 1 / e,
						r = 1 / t;
					s[0] = -.5 * i, s[1] = .5 * r, s[2] = .5 * i, s[3] = .5 * r, s[4] = -.5 * i, s[5] = -.5 * r, s[6] = .5 * i, s[7] = -.5 * r
				},
				c = function(e, t) {
					for (var i = 0, r = -1; r < 2; r++)
						for (var n = -1; n < 2; n++) a[i] = r / e, a[i + 1] = n / t, i += 2
				},
				l = function(e) {
					n._needUpdate && h(n._textureAdderPostProcess.width, n._textureAdderPostProcess.height), e.setTextureFromPostProcess("textureSampler", n._textureAdderPostProcess), e.setArray2("lumOffsets", s)
				},
				u = function(e) {
					var t = e;
					return function(e) {
						h(n._downSamplePostProcesses[t].width, n._downSamplePostProcesses[t].height), c(n._downSamplePostProcesses[t].width, n._downSamplePostProcesses[t].height), r = .5 / n._downSamplePostProcesses[t].width, e.setTextureFromPostProcess("textureSampler", n._downSamplePostProcesses[t + 1]), e.setFloat("halfDestPixelSize", r), e.setArray2("dsOffsets", a)
					}
				},
				d = function(i) {
					var r = t.getEngine().readPixels(0, 0, 1, 1),
						o = new e.Vector4(1 / 16581375, 1 / 65025, 1 / 255, 1);
					n._hdrCurrentLuminance = (r[0] * o.x + r[1] * o.y + r[2] * o.z + r[3] * o.w) / 100
				},
				f = {
					width: Math.pow(3, o - 1),
					height: Math.pow(3, o - 1)
				};
			this._downSamplePostProcesses[o - 1] = new e.PostProcess("hdr", "hdr", ["lumOffsets"], [], f, null, e.Texture.NEAREST_SAMPLINGMODE, t.getEngine(), (!1), "#define LUMINANCE_GENERATOR", e.Engine.TEXTURETYPE_FLOAT), this._downSamplePostProcesses[o - 1].onApply = l;
			for (var p = o - 2; p >= 0; p--) {
				var m = Math.pow(3, p);
				f = {
					width: m,
					height: m
				};
				var _ = "#define DOWN_SAMPLE\n";
				0 === p && (_ += "#define FINAL_DOWN_SAMPLE\n"), this._downSamplePostProcesses[p] = new e.PostProcess("hdr", "hdr", ["dsOffsets", "halfDestPixelSize"], [], f, null, e.Texture.NEAREST_SAMPLINGMODE, t.getEngine(), (!1), _, e.Engine.TEXTURETYPE_FLOAT), this._downSamplePostProcesses[p].onApply = u(p), 0 === p && (this._downSamplePostProcesses[p].onAfterRender = d)
			}
		}, i.prototype._createGaussianBlurPostProcess = function(t, i) {
			var r = this,
				n = new Array(9),
				o = new Array(9),
				s = new Array(9),
				a = ["blurOffsets", "blurWeights", "multiplier"],
				h = function(e) {
					for (var i = {
							width: t.getEngine().getRenderWidth(),
							height: t.getEngine().getRenderHeight()
						}, r = 0; r < 9; r++) {
						var s = (r - 4) * (1 / (e === !0 ? i.height : i.width));
						e ? o[r] = s : n[r] = s
					}
				},
				c = function() {
					for (var e = 0, t = 0; t < 9; t++) e = (t - 4) / 4, s[t] = r.gaussCoeff * (1 / Math.sqrt(2 * Math.PI * r.gaussStandDev)) * Math.exp(-((e - r.gaussMean) * (e - r.gaussMean)) / (2 * r.gaussStandDev * r.gaussStandDev))
				},
				l = function(e) {
					return function(t) {
						r._needUpdate && (c(), h(e)), t.setArray("blurOffsets", e ? o : n), t.setArray("blurWeights", s), t.setFloat("multiplier", r.gaussMultiplier)
					}
				};
			this._guassianBlurHPostProcess = new e.PostProcess("hdr", "hdr", a, [], i / 4, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define GAUSSIAN_BLUR_H"), this._guassianBlurHPostProcess.onApply = l(!1), this._guassianBlurVPostProcess = new e.PostProcess("hdr", "hdr", a, [], i / 4, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define GAUSSIAN_BLUR_V"), this._guassianBlurVPostProcess.onApply = l(!0)
		}, i.LUM_STEPS = 6, i
	})(e.PostProcessRenderPipeline);
	e.HDRRenderingPipeline = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
			function e() {
				this.edges = new Array, this.edgesConnectedCount = 0
			}
			return e
		})(),
		i = (function() {
			function i(e, t, i) {
				void 0 === t && (t = .95), void 0 === i && (i = !1), this.edgesWidthScalerForOrthographic = 1e3, this.edgesWidthScalerForPerspective = 50, this._linesPositions = new Array, this._linesNormals = new Array, this._linesIndices = new Array, this._buffers = {}, this._checkVerticesInsteadOfIndices = !1, this._source = e, this._checkVerticesInsteadOfIndices = i, this._epsilon = t, this._prepareRessources(), this._generateEdgesLines()
			}
			return i.prototype._prepareRessources = function() {
				this._lineShader || (this._lineShader = new e.ShaderMaterial("lineShader", this._source.getScene(), "line", {
					attributes: ["position", "normal"],
					uniforms: ["worldViewProjection", "color", "width", "aspectRatio"]
				}), this._lineShader.disableDepthWrite = !0, this._lineShader.backFaceCulling = !1)
			}, i.prototype.dispose = function() {
				var t = this._buffers[e.VertexBuffer.PositionKind];
				t && (t.dispose(), this._buffers[e.VertexBuffer.PositionKind] = null), t = this._buffers[e.VertexBuffer.NormalKind], t && (t.dispose(), this._buffers[e.VertexBuffer.NormalKind] = null), this._source.getScene().getEngine()._releaseBuffer(this._ib), this._lineShader.dispose()
			}, i.prototype._processEdgeForAdjacencies = function(e, t, i, r, n) {
				return e === i && t === r || e === r && t === i ? 0 : e === r && t === n || e === n && t === r ? 1 : e === n && t === i || e === i && t === n ? 2 : -1
			}, i.prototype._processEdgeForAdjacenciesWithVertices = function(e, t, i, r, n) {
				return e.equalsWithEpsilon(i) && t.equalsWithEpsilon(r) || e.equalsWithEpsilon(r) && t.equalsWithEpsilon(i) ? 0 : e.equalsWithEpsilon(r) && t.equalsWithEpsilon(n) || e.equalsWithEpsilon(n) && t.equalsWithEpsilon(r) ? 1 : e.equalsWithEpsilon(n) && t.equalsWithEpsilon(i) || e.equalsWithEpsilon(i) && t.equalsWithEpsilon(n) ? 2 : -1
			}, i.prototype._checkEdge = function(t, i, r, n, o) {
				var s;
				if (void 0 === i) s = !0;
				else {
					var a = e.Vector3.Dot(r[t], r[i]);
					s = a < this._epsilon
				}
				if (s) {
					var h = this._linesPositions.length / 3,
						c = n.subtract(o);
					c.normalize(), this._linesPositions.push(n.x), this._linesPositions.push(n.y), this._linesPositions.push(n.z), this._linesPositions.push(n.x), this._linesPositions.push(n.y), this._linesPositions.push(n.z), this._linesPositions.push(o.x), this._linesPositions.push(o.y), this._linesPositions.push(o.z), this._linesPositions.push(o.x), this._linesPositions.push(o.y), this._linesPositions.push(o.z), this._linesNormals.push(o.x), this._linesNormals.push(o.y), this._linesNormals.push(o.z), this._linesNormals.push(-1), this._linesNormals.push(o.x), this._linesNormals.push(o.y), this._linesNormals.push(o.z), this._linesNormals.push(1), this._linesNormals.push(n.x), this._linesNormals.push(n.y), this._linesNormals.push(n.z), this._linesNormals.push(-1), this._linesNormals.push(n.x), this._linesNormals.push(n.y), this._linesNormals.push(n.z), this._linesNormals.push(1), this._linesIndices.push(h), this._linesIndices.push(h + 1), this._linesIndices.push(h + 2), this._linesIndices.push(h), this._linesIndices.push(h + 2), this._linesIndices.push(h + 3)
				}
			}, i.prototype._generateEdgesLines = function() {
				var i, r, n = this._source.getVerticesData(e.VertexBuffer.PositionKind),
					o = this._source.getIndices(),
					s = new Array,
					a = new Array;
				for (i = 0; i < o.length; i += 3) {
					r = new t;
					var h = o[i],
						c = o[i + 1],
						l = o[i + 2];
					r.p0 = new e.Vector3(n[3 * h], n[3 * h + 1], n[3 * h + 2]), r.p1 = new e.Vector3(n[3 * c], n[3 * c + 1], n[3 * c + 2]), r.p2 = new e.Vector3(n[3 * l], n[3 * l + 1], n[3 * l + 2]);
					var u = e.Vector3.Cross(r.p1.subtract(r.p0), r.p2.subtract(r.p1));
					u.normalize(), a.push(u), s.push(r)
				}
				for (i = 0; i < s.length; i++) {
					r = s[i];
					for (var d = i + 1; d < s.length; d++) {
						var f = s[d];
						if (3 === r.edgesConnectedCount) break;
						if (3 !== f.edgesConnectedCount)
							for (var p = o[3 * d], m = o[3 * d + 1], _ = o[3 * d + 2], g = 0; g < 3; g++) {
								var v;
								if (void 0 === r.edges[g]) {
									switch (g) {
										case 0:
											v = this._checkVerticesInsteadOfIndices ? this._processEdgeForAdjacenciesWithVertices(r.p0, r.p1, f.p0, f.p1, f.p2) : this._processEdgeForAdjacencies(o[3 * i], o[3 * i + 1], p, m, _);
											break;
										case 1:
											v = this._checkVerticesInsteadOfIndices ? this._processEdgeForAdjacenciesWithVertices(r.p1, r.p2, f.p0, f.p1, f.p2) : this._processEdgeForAdjacencies(o[3 * i + 1], o[3 * i + 2], p, m, _);
											break;
										case 2:
											v = this._checkVerticesInsteadOfIndices ? this._processEdgeForAdjacenciesWithVertices(r.p2, r.p0, f.p0, f.p1, f.p2) : this._processEdgeForAdjacencies(o[3 * i + 2], o[3 * i], p, m, _)
									}
									if (v !== -1 && (r.edges[g] = d, f.edges[v] = i, r.edgesConnectedCount++, f.edgesConnectedCount++, 3 === r.edgesConnectedCount)) break
								}
							}
					}
				}
				for (i = 0; i < s.length; i++) {
					var y = s[i];
					this._checkEdge(i, y.edges[0], a, y.p0, y.p1), this._checkEdge(i, y.edges[1], a, y.p1, y.p2), this._checkEdge(i, y.edges[2], a, y.p2, y.p0)
				}
				var x = this._source.getScene().getEngine();
				this._buffers[e.VertexBuffer.PositionKind] = new e.VertexBuffer(x, this._linesPositions, e.VertexBuffer.PositionKind, (!1)), this._buffers[e.VertexBuffer.NormalKind] = new e.VertexBuffer(x, this._linesNormals, e.VertexBuffer.NormalKind, (!1), (!1), 4), this._ib = x.createIndexBuffer(this._linesIndices), this._indicesCount = this._linesIndices.length
			}, i.prototype.render = function() {
				if (this._lineShader.isReady()) {
					var t = this._source.getScene(),
						i = t.getEngine();
					this._lineShader._preBind(), i.bindBuffers(this._buffers, this._ib, this._lineShader.getEffect()), t.resetCachedMaterial(), this._lineShader.setColor4("color", this._source.edgesColor), t.activeCamera.mode === e.Camera.ORTHOGRAPHIC_CAMERA ? this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForOrthographic) : this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForPerspective), this._lineShader.setFloat("aspectRatio", i.getAspectRatio(t.activeCamera)), this._lineShader.bind(this._source.getWorldMatrix()), i.draw(!0, 0, this._indicesCount), this._lineShader.unbind(), i.setDepthWrite(!0)
				}
			}, i
		})();
	e.EdgesRenderer = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	!(function(e) {
		e[e.Hable = 0] = "Hable", e[e.Reinhard = 1] = "Reinhard", e[e.HejiDawson = 2] = "HejiDawson", e[e.Photographic = 3] = "Photographic"
	})(e.TonemappingOperator || (e.TonemappingOperator = {}));
	var t = e.TonemappingOperator,
		i = (function(i) {
			function r(r, n, o, s, a, h, c) {
				var l = this;
				void 0 === a && (a = e.Texture.BILINEAR_SAMPLINGMODE), void 0 === c && (c = e.Engine.TEXTURETYPE_UNSIGNED_INT), i.call(this, r, "tonemap", ["_ExposureAdjustment"], null, 1, s, a, h, !0, u, c), this._operator = n, this.exposureAdjustment = o;
				var u = "#define ";
				this._operator === t.Hable ? u += "HABLE_TONEMAPPING" : this._operator === t.Reinhard ? u += "REINHARD_TONEMAPPING" : this._operator === t.HejiDawson ? u += "OPTIMIZED_HEJIDAWSON_TONEMAPPING" : this._operator === t.Photographic && (u += "PHOTOGRAPHIC_TONEMAPPING"), this.updateEffect(u), this.onApply = function(e) {
					e.setFloat("_ExposureAdjustment", l.exposureAdjustment)
				}
			}
			return __extends(r, i), r
		})(e.PostProcess);
	e.TonemapPostProcess = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n) {
			var o = this;
			void 0 === n && (n = !0), this.name = t, this._viewMatrix = e.Matrix.Identity(), this._target = e.Vector3.Zero(), this._add = e.Vector3.Zero(), this.invertYAxis = !1, this.position = e.Vector3.Zero(), this._scene = r, this._scene.reflectionProbes.push(this), this._renderTargetTexture = new e.RenderTargetTexture(t, i, r, n, (!0), e.Engine.TEXTURETYPE_UNSIGNED_INT, (!0)), this._renderTargetTexture.onBeforeRenderObservable.add((function(t) {
				switch (t) {
					case 0:
						o._add.copyFromFloats(1, 0, 0);
						break;
					case 1:
						o._add.copyFromFloats(-1, 0, 0);
						break;
					case 2:
						o._add.copyFromFloats(0, o.invertYAxis ? 1 : -1, 0);
						break;
					case 3:
						o._add.copyFromFloats(0, o.invertYAxis ? -1 : 1, 0);
						break;
					case 4:
						o._add.copyFromFloats(0, 0, 1);
						break;
					case 5:
						o._add.copyFromFloats(0, 0, -1)
				}
				o._attachedMesh && o.position.copyFrom(o._attachedMesh.getAbsolutePosition()), o.position.addToRef(o._add, o._target), e.Matrix.LookAtLHToRef(o.position, o._target, e.Vector3.Up(), o._viewMatrix), r.setTransformMatrix(o._viewMatrix, o._projectionMatrix)
			})), this._renderTargetTexture.onAfterUnbindObservable.add((function() {
				r.updateTransformMatrix(!0)
			})), this._projectionMatrix = e.Matrix.PerspectiveFovLH(Math.PI / 2, 1, r.activeCamera.minZ, r.activeCamera.maxZ)
		}
		return Object.defineProperty(t.prototype, "refreshRate", {
			get: function() {
				return this._renderTargetTexture.refreshRate
			},
			set: function(e) {
				this._renderTargetTexture.refreshRate = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.getScene = function() {
			return this._scene
		}, Object.defineProperty(t.prototype, "cubeTexture", {
			get: function() {
				return this._renderTargetTexture
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "renderList", {
			get: function() {
				return this._renderTargetTexture.renderList
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.attachToMesh = function(e) {
			this._attachedMesh = e
		}, t.prototype.dispose = function() {
			var e = this._scene.reflectionProbes.indexOf(this);
			e !== -1 && this._scene.reflectionProbes.splice(e, 1), this._renderTargetTexture && (this._renderTargetTexture.dispose(), this._renderTargetTexture = null)
		}, t
	})();
	e.ReflectionProbe = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r, n, o, s, a) {
			this.idx = 0, this.color = new e.Color4(1, 1, 1, 1), this.position = e.Vector3.Zero(), this.rotation = e.Vector3.Zero(), this.scaling = new e.Vector3(1, 1, 1), this.uvs = new e.Vector4(0, 0, 1, 1), this.velocity = e.Vector3.Zero(), this.alive = !0, this.isVisible = !0, this._pos = 0, this.shapeId = 0, this.idxInShape = 0, this.idx = t, this._pos = i, this._model = r, this.shapeId = n, this.idxInShape = o, this._sps = s, a && (this._modelBoundingInfo = a, this._boundingInfo = new e.BoundingInfo(a.minimum, a.maximum))
		}
		return Object.defineProperty(t.prototype, "scale", {
			get: function() {
				return this.scaling
			},
			set: function(e) {
				this.scaling = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "quaternion", {
			get: function() {
				return this.rotationQuaternion
			},
			set: function(e) {
				this.rotationQuaternion = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.intersectsMesh = function(t) {
			return !(!this._boundingInfo || !t._boundingInfo) && (this._sps._bSphereOnly ? e.BoundingSphere.Intersects(this._boundingInfo.boundingSphere, t._boundingInfo.boundingSphere) : this._boundingInfo.intersects(t._boundingInfo, !1))
		}, t
	})();
	e.SolidParticle = t;
	var i = (function() {
		function e(e, t, i, r, n) {
			this.shapeID = e, this._shape = t, this._shapeUV = i, this._positionFunction = r, this._vertexFunction = n
		}
		return e
	})();
	e.ModelShape = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t, i, r) {
			this.particles = new Array, this.nbParticles = 0, this.billboard = !1, this.recomputeNormals = !0, this.counter = 0, this.vars = {}, this._positions = new Array, this._indices = new Array, this._normals = new Array, this._colors = new Array, this._uvs = new Array, this._index = 0, this._updatable = !0, this._pickable = !1, this._isVisibilityBoxLocked = !1, this._alwaysVisible = !1, this._shapeCounter = 0, this._copy = new e.SolidParticle(null, null, null, null, null, null), this._color = new e.Color4(0, 0, 0, 0), this._computeParticleColor = !0, this._computeParticleTexture = !0, this._computeParticleRotation = !0, this._computeParticleVertex = !1, this._computeBoundingBox = !1, this._cam_axisZ = e.Vector3.Zero(), this._cam_axisY = e.Vector3.Zero(), this._cam_axisX = e.Vector3.Zero(), this._axisX = e.Axis.X, this._axisY = e.Axis.Y, this._axisZ = e.Axis.Z, this._camDir = e.Vector3.Zero(), this._rotMatrix = new e.Matrix, this._invertMatrix = new e.Matrix, this._rotated = e.Vector3.Zero(), this._quaternion = new e.Quaternion, this._vertex = e.Vector3.Zero(), this._normal = e.Vector3.Zero(), this._yaw = 0, this._pitch = 0, this._roll = 0, this._halfroll = 0, this._halfpitch = 0, this._halfyaw = 0, this._sinRoll = 0, this._cosRoll = 0, this._sinPitch = 0, this._cosPitch = 0, this._sinYaw = 0, this._cosYaw = 0, this._w = 0, this._minimum = e.Tmp.Vector3[0], this._maximum = e.Tmp.Vector3[1], this._scale = e.Tmp.Vector3[2], this._translation = e.Tmp.Vector3[3], this._minBbox = e.Tmp.Vector3[4], this._maxBbox = e.Tmp.Vector3[5], this._particlesIntersect = !1, this._bSphereOnly = !1, this._bSphereRadiusFactor = 1, this.name = t, this._scene = i, this._camera = i.activeCamera, this._pickable = !!r && r.isPickable, this._particlesIntersect = !!r && r.particleIntersection, this._bSphereOnly = !!r && r.boundingSphereOnly, this._bSphereRadiusFactor = r && r.bSphereRadiusFactor ? r.bSphereRadiusFactor : 1, r && r.updatable ? this._updatable = r.updatable : this._updatable = !0, this._pickable && (this.pickedParticles = [])
		}
		return t.prototype.buildMesh = function() {
			if (0 === this.nbParticles) {
				var t = e.MeshBuilder.CreateDisc("", {
					radius: 1,
					tessellation: 3
				}, this._scene);
				this.addShape(t, 1), t.dispose()
			}
			this._positions32 = new Float32Array(this._positions), this._uvs32 = new Float32Array(this._uvs), this._colors32 = new Float32Array(this._colors), this.recomputeNormals && e.VertexData.ComputeNormals(this._positions32, this._indices, this._normals), this._normals32 = new Float32Array(this._normals), this._fixedNormal32 = new Float32Array(this._normals);
			var i = new e.VertexData;
			i.set(this._positions32, e.VertexBuffer.PositionKind), i.indices = this._indices, i.set(this._normals32, e.VertexBuffer.NormalKind), this._uvs32 && i.set(this._uvs32, e.VertexBuffer.UVKind), this._colors32 && i.set(this._colors32, e.VertexBuffer.ColorKind);
			var r = new e.Mesh(this.name, this._scene);
			return i.applyToMesh(r, this._updatable), this.mesh = r, this.mesh.isPickable = this._pickable, this._positions = null, this._normals = null, this._uvs = null, this._colors = null, this._updatable || (this.particles.length = 0), r
		}, t.prototype.digest = function(t, i) {
			var r = i && i.facetNb || 1,
				n = i && i.number,
				o = i && i.delta || 0,
				s = t.getVerticesData(e.VertexBuffer.PositionKind),
				a = t.getIndices(),
				h = t.getVerticesData(e.VertexBuffer.UVKind),
				c = t.getVerticesData(e.VertexBuffer.ColorKind),
				l = t.getVerticesData(e.VertexBuffer.NormalKind),
				u = 0,
				d = a.length / 3;
			n ? (n = n > d ? d : n, r = Math.round(d / n), o = 0) : r = r > d ? d : r;
			for (var f = [], p = [], m = [], _ = [], g = e.Tmp.Vector3[0], v = r; u < d;) {
				r = v + Math.floor((1 + o) * Math.random()), u > d - r && (r = d - u), f.length = 0, p.length = 0, m.length = 0, _.length = 0;
				for (var y = 0, x = 3 * u; x < 3 * (u + r); x++) {
					p.push(y);
					var b = a[x];
					f.push(s[3 * b], s[3 * b + 1], s[3 * b + 2]), h && m.push(h[2 * b], h[2 * b + 1]), c && _.push(c[4 * b], c[4 * b + 1], c[4 * b + 2], c[4 * b + 3]), y++
				}
				var T, A = this.nbParticles,
					E = this._posToShape(f),
					P = this._uvsToShapeUV(m);
				for (T = 0; T < E.length; T++) g.addInPlace(E[T]);
				for (g.scaleInPlace(1 / E.length), T = 0; T < E.length; T++) E[T].subtractInPlace(g);
				var M;
				this._particlesIntersect && (M = new e.BoundingInfo(g, g));
				var S = new e.ModelShape(this._shapeCounter, E, P, null, null);
				this._meshBuilder(this._index, E, this._positions, p, this._indices, m, this._uvs, _, this._colors, l, this._normals, A, 0, null), this._addParticle(A, this._positions.length, S, this._shapeCounter, 0, M), this.particles[this.nbParticles].position.addInPlace(g), this._index += E.length, A++, this.nbParticles++, this._shapeCounter++, u += r
			}
			return this
		}, t.prototype._resetCopy = function() {
			this._copy.position.x = 0, this._copy.position.y = 0, this._copy.position.z = 0, this._copy.rotation.x = 0, this._copy.rotation.y = 0, this._copy.rotation.z = 0, this._copy.rotationQuaternion = null, this._copy.scaling.x = 1, this._copy.scaling.y = 1, this._copy.scaling.z = 1, this._copy.uvs.x = 0, this._copy.uvs.y = 0, this._copy.uvs.z = 1, this._copy.uvs.w = 1, this._copy.color = null
		}, t.prototype._meshBuilder = function(t, i, r, n, o, s, a, h, c, l, u, d, f, p) {
			var m, _ = 0,
				g = 0,
				v = 0;
			for (this._resetCopy(), p && p.positionFunction && p.positionFunction(this._copy, d, f), this._copy.rotationQuaternion ? this._quaternion.copyFrom(this._copy.rotationQuaternion) : (this._yaw = this._copy.rotation.y, this._pitch = this._copy.rotation.x, this._roll = this._copy.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix(), m = 0; m < i.length; m++) this._vertex.x = i[m].x, this._vertex.y = i[m].y, this._vertex.z = i[m].z, p && p.vertexFunction && p.vertexFunction(this._copy, this._vertex, m), this._vertex.x *= this._copy.scaling.x, this._vertex.y *= this._copy.scaling.y, this._vertex.z *= this._copy.scaling.z, e.Vector3.TransformCoordinatesToRef(this._vertex, this._rotMatrix, this._rotated), r.push(this._copy.position.x + this._rotated.x, this._copy.position.y + this._rotated.y, this._copy.position.z + this._rotated.z), s && (a.push((this._copy.uvs.z - this._copy.uvs.x) * s[_] + this._copy.uvs.x, (this._copy.uvs.w - this._copy.uvs.y) * s[_ + 1] + this._copy.uvs.y), _ += 2), this._copy.color ? this._color = this._copy.color : h && void 0 !== h[g] ? (this._color.r = h[g], this._color.g = h[g + 1], this._color.b = h[g + 2], this._color.a = h[g + 3]) : (this._color.r = 1, this._color.g = 1, this._color.b = 1, this._color.a = 1), c.push(this._color.r, this._color.g, this._color.b, this._color.a), g += 4, !this.recomputeNormals && l && (this._normal.x = l[v], this._normal.y = l[v + 1], this._normal.z = l[v + 2], e.Vector3.TransformCoordinatesToRef(this._normal, this._rotMatrix, this._normal), u.push(this._normal.x, this._normal.y, this._normal.z), v += 3);
			for (m = 0; m < n.length; m++) o.push(t + n[m]);
			if (this._pickable) {
				var y = n.length / 3;
				for (m = 0; m < y; m++) this.pickedParticles.push({
					idx: d,
					faceId: m
				})
			}
		}, t.prototype._posToShape = function(t) {
			for (var i = [], r = 0; r < t.length; r += 3) i.push(new e.Vector3(t[r], t[r + 1], t[r + 2]));
			return i
		}, t.prototype._uvsToShapeUV = function(e) {
			var t = [];
			if (e)
				for (var i = 0; i < e.length; i++) t.push(e[i]);
			return t
		}, t.prototype._addParticle = function(t, i, r, n, o, s) {
			this.particles.push(new e.SolidParticle(t, i, r, n, o, this, s))
		}, t.prototype.addShape = function(t, i, r) {
			var n, o = t.getVerticesData(e.VertexBuffer.PositionKind),
				s = t.getIndices(),
				a = t.getVerticesData(e.VertexBuffer.UVKind),
				h = t.getVerticesData(e.VertexBuffer.ColorKind),
				c = t.getVerticesData(e.VertexBuffer.NormalKind);
			this._particlesIntersect && (n = t.getBoundingInfo());
			for (var l = this._posToShape(o), u = this._uvsToShapeUV(a), d = r ? r.positionFunction : null, f = r ? r.vertexFunction : null, p = new e.ModelShape(this._shapeCounter, l, u, d, f), m = this.nbParticles, _ = 0; _ < i; _++) this._meshBuilder(this._index, l, this._positions, s, this._indices, a, this._uvs, h, this._colors, c, this._normals, m, _, r), this._updatable && this._addParticle(m, this._positions.length, p, this._shapeCounter, _, n), this._index += l.length, m++;
			return this.nbParticles += i, this._shapeCounter++, this._shapeCounter - 1
		}, t.prototype._rebuildParticle = function(t) {
			this._resetCopy(), t._model._positionFunction && t._model._positionFunction(this._copy, t.idx, t.idxInShape), this._copy.rotationQuaternion ? this._quaternion.copyFrom(this._copy.rotationQuaternion) : (this._yaw = this._copy.rotation.y, this._pitch = this._copy.rotation.x, this._roll = this._copy.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix(), this._shape = t._model._shape;
			for (var i = 0; i < this._shape.length; i++) this._vertex.x = this._shape[i].x, this._vertex.y = this._shape[i].y, this._vertex.z = this._shape[i].z, t._model._vertexFunction && t._model._vertexFunction(this._copy, this._vertex, i), this._vertex.x *= this._copy.scaling.x, this._vertex.y *= this._copy.scaling.y, this._vertex.z *= this._copy.scaling.z, e.Vector3.TransformCoordinatesToRef(this._vertex, this._rotMatrix, this._rotated), this._positions32[t._pos + 3 * i] = this._copy.position.x + this._rotated.x, this._positions32[t._pos + 3 * i + 1] = this._copy.position.y + this._rotated.y, this._positions32[t._pos + 3 * i + 2] = this._copy.position.z + this._rotated.z;
			t.position.x = 0, t.position.y = 0, t.position.z = 0, t.rotation.x = 0, t.rotation.y = 0, t.rotation.z = 0, t.rotationQuaternion = null, t.scaling.x = 1, t.scaling.y = 1, t.scaling.z = 1
		}, t.prototype.rebuildMesh = function() {
			for (var t = 0; t < this.particles.length; t++) this._rebuildParticle(this.particles[t]);
			this.mesh.updateVerticesData(e.VertexBuffer.PositionKind, this._positions32, !1, !1)
		}, t.prototype.setParticles = function(t, i, r) {
			if (void 0 === t && (t = 0), void 0 === i && (i = this.nbParticles - 1), void 0 === r && (r = !0), this._updatable) {
				this.beforeUpdateParticles(t, i, r), this._cam_axisX.x = 1, this._cam_axisX.y = 0, this._cam_axisX.z = 0, this._cam_axisY.x = 0, this._cam_axisY.y = 1, this._cam_axisY.z = 0, this._cam_axisZ.x = 0, this._cam_axisZ.y = 0, this._cam_axisZ.z = 1, this.billboard && this.mesh._worldMatrix.decompose(this._scale, this._quaternion, this._translation) && (this._quaternionToRotationMatrix(), this._rotMatrix.invertToRef(this._invertMatrix), this._camera._currentTarget.subtractToRef(this._camera.globalPosition, this._camDir), e.Vector3.TransformCoordinatesToRef(this._camDir, this._invertMatrix, this._cam_axisZ), this._cam_axisZ.normalize(), e.Vector3.CrossToRef(this._cam_axisZ, this._axisX, this._cam_axisY), e.Vector3.CrossToRef(this._cam_axisY, this._cam_axisZ, this._cam_axisX), this._cam_axisY.normalize(), this._cam_axisX.normalize()), e.Matrix.IdentityToRef(this._rotMatrix);
				var n = 0,
					o = 0,
					s = 0,
					a = 0,
					h = 0,
					c = 0,
					l = 0;
				this._computeBoundingBox && (e.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this._minimum), e.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this._maximum)), i = i > this.nbParticles - 1 ? this.nbParticles - 1 : i;
				for (var u = t; u <= i; u++) {
					if (this._particle = this.particles[u], this._shape = this._particle._model._shape, this._shapeUV = this._particle._model._shapeUV, this.updateParticle(this._particle), this._particle.isVisible)
						for (this.billboard && (this._particle.rotation.x = 0, this._particle.rotation.y = 0), (this._computeParticleRotation || this.billboard) && (this._particle.rotationQuaternion ? this._quaternion.copyFrom(this._particle.rotationQuaternion) : (this._yaw = this._particle.rotation.y, this._pitch = this._particle.rotation.x, this._roll = this._particle.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix()), l = 0; l < this._shape.length; l++) n = o + 3 * l, s = a + 4 * l, h = c + 2 * l, this._vertex.x = this._shape[l].x, this._vertex.y = this._shape[l].y, this._vertex.z = this._shape[l].z, this._computeParticleVertex && this.updateParticleVertex(this._particle, this._vertex, l), this._vertex.x *= this._particle.scaling.x, this._vertex.y *= this._particle.scaling.y, this._vertex.z *= this._particle.scaling.z, this._w = this._vertex.x * this._rotMatrix.m[3] + this._vertex.y * this._rotMatrix.m[7] + this._vertex.z * this._rotMatrix.m[11] + this._rotMatrix.m[15], this._rotated.x = (this._vertex.x * this._rotMatrix.m[0] + this._vertex.y * this._rotMatrix.m[4] + this._vertex.z * this._rotMatrix.m[8] + this._rotMatrix.m[12]) / this._w, this._rotated.y = (this._vertex.x * this._rotMatrix.m[1] + this._vertex.y * this._rotMatrix.m[5] + this._vertex.z * this._rotMatrix.m[9] + this._rotMatrix.m[13]) / this._w, this._rotated.z = (this._vertex.x * this._rotMatrix.m[2] + this._vertex.y * this._rotMatrix.m[6] + this._vertex.z * this._rotMatrix.m[10] + this._rotMatrix.m[14]) / this._w, this._positions32[n] = this._particle.position.x + this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z, this._positions32[n + 1] = this._particle.position.y + this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z, this._positions32[n + 2] = this._particle.position.z + this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z, this._computeBoundingBox && (this._positions32[n] < this._minimum.x && (this._minimum.x = this._positions32[n]), this._positions32[n] > this._maximum.x && (this._maximum.x = this._positions32[n]), this._positions32[n + 1] < this._minimum.y && (this._minimum.y = this._positions32[n + 1]), this._positions32[n + 1] > this._maximum.y && (this._maximum.y = this._positions32[n + 1]), this._positions32[n + 2] < this._minimum.z && (this._minimum.z = this._positions32[n + 2]), this._positions32[n + 2] > this._maximum.z && (this._maximum.z = this._positions32[n + 2])), this._computeParticleVertex || (this._normal.x = this._fixedNormal32[n], this._normal.y = this._fixedNormal32[n + 1], this._normal.z = this._fixedNormal32[n + 2], this._w = this._normal.x * this._rotMatrix.m[3] + this._normal.y * this._rotMatrix.m[7] + this._normal.z * this._rotMatrix.m[11] + this._rotMatrix.m[15], this._rotated.x = (this._normal.x * this._rotMatrix.m[0] + this._normal.y * this._rotMatrix.m[4] + this._normal.z * this._rotMatrix.m[8] + this._rotMatrix.m[12]) / this._w, this._rotated.y = (this._normal.x * this._rotMatrix.m[1] + this._normal.y * this._rotMatrix.m[5] + this._normal.z * this._rotMatrix.m[9] + this._rotMatrix.m[13]) / this._w, this._rotated.z = (this._normal.x * this._rotMatrix.m[2] + this._normal.y * this._rotMatrix.m[6] + this._normal.z * this._rotMatrix.m[10] + this._rotMatrix.m[14]) / this._w, this._normals32[n] = this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z, this._normals32[n + 1] = this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z, this._normals32[n + 2] = this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z), this._computeParticleColor && (this._colors32[s] = this._particle.color.r, this._colors32[s + 1] = this._particle.color.g, this._colors32[s + 2] = this._particle.color.b, this._colors32[s + 3] = this._particle.color.a), this._computeParticleTexture && (this._uvs32[h] = this._shapeUV[2 * l] * (this._particle.uvs.z - this._particle.uvs.x) + this._particle.uvs.x, this._uvs32[h + 1] = this._shapeUV[2 * l + 1] * (this._particle.uvs.w - this._particle.uvs.y) + this._particle.uvs.y);
					else
						for (l = 0; l < this._shape.length; l++) n = o + 3 * l, s = a + 4 * l, h = c + 2 * l, this._positions32[n] = this._camera.position.x, this._positions32[n + 1] = this._camera.position.y, this._positions32[n + 2] = this._camera.position.z, this._normals32[n] = 0, this._normals32[n + 1] = 0, this._normals32[n + 2] = 0, this._computeParticleColor && (this._colors32[s] = this._particle.color.r, this._colors32[s + 1] = this._particle.color.g, this._colors32[s + 2] = this._particle.color.b, this._colors32[s + 3] = this._particle.color.a), this._computeParticleTexture && (this._uvs32[h] = this._shapeUV[2 * l] * (this._particle.uvs.z - this._particle.uvs.x) + this._particle.uvs.x, this._uvs32[h + 1] = this._shapeUV[2 * l + 1] * (this._particle.uvs.w - this._particle.uvs.y) + this._particle.uvs.y);
					if (this._particlesIntersect) {
						var d = this._particle._boundingInfo,
							f = d.boundingBox,
							p = d.boundingSphere;
						if (!this._bSphereOnly) {
							for (var m = 0; m < f.vectors.length; m++) this._vertex.x = this._particle._modelBoundingInfo.boundingBox.vectors[m].x * this._particle.scaling.x, this._vertex.y = this._particle._modelBoundingInfo.boundingBox.vectors[m].y * this._particle.scaling.y,
								this._vertex.z = this._particle._modelBoundingInfo.boundingBox.vectors[m].z * this._particle.scaling.z, this._w = this._vertex.x * this._rotMatrix.m[3] + this._vertex.y * this._rotMatrix.m[7] + this._vertex.z * this._rotMatrix.m[11] + this._rotMatrix.m[15], this._rotated.x = (this._vertex.x * this._rotMatrix.m[0] + this._vertex.y * this._rotMatrix.m[4] + this._vertex.z * this._rotMatrix.m[8] + this._rotMatrix.m[12]) / this._w, this._rotated.y = (this._vertex.x * this._rotMatrix.m[1] + this._vertex.y * this._rotMatrix.m[5] + this._vertex.z * this._rotMatrix.m[9] + this._rotMatrix.m[13]) / this._w, this._rotated.z = (this._vertex.x * this._rotMatrix.m[2] + this._vertex.y * this._rotMatrix.m[6] + this._vertex.z * this._rotMatrix.m[10] + this._rotMatrix.m[14]) / this._w, f.vectors[m].x = this._particle.position.x + this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z, f.vectors[m].y = this._particle.position.y + this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z, f.vectors[m].z = this._particle.position.z + this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z;
							f._update(this.mesh._worldMatrix)
						}
						this._minBbox.x = this._particle._modelBoundingInfo.minimum.x * this._particle.scaling.x, this._minBbox.y = this._particle._modelBoundingInfo.minimum.y * this._particle.scaling.y, this._minBbox.z = this._particle._modelBoundingInfo.minimum.z * this._particle.scaling.z, this._maxBbox.x = this._particle._modelBoundingInfo.maximum.x * this._particle.scaling.x, this._maxBbox.y = this._particle._modelBoundingInfo.maximum.y * this._particle.scaling.y, this._maxBbox.z = this._particle._modelBoundingInfo.maximum.z * this._particle.scaling.z, p.center.x = this._particle.position.x + .5 * (this._minBbox.x + this._maxBbox.x), p.center.y = this._particle.position.y + .5 * (this._minBbox.y + this._maxBbox.y), p.center.z = this._particle.position.z + .5 * (this._minBbox.z + this._maxBbox.z), p.radius = .5 * this._bSphereRadiusFactor * Math.sqrt((this._maxBbox.x - this._minBbox.x) * (this._maxBbox.x - this._minBbox.x) + (this._maxBbox.y - this._minBbox.y) * (this._maxBbox.y - this._minBbox.y) + (this._maxBbox.z - this._minBbox.z) * (this._maxBbox.z - this._minBbox.z)), p._update(this.mesh._worldMatrix)
					}
					o = n + 3, a = s + 4, c = h + 2
				}
				if (r && (this._computeParticleColor && this.mesh.updateVerticesData(e.VertexBuffer.ColorKind, this._colors32, !1, !1), this._computeParticleTexture && this.mesh.updateVerticesData(e.VertexBuffer.UVKind, this._uvs32, !1, !1), this.mesh.updateVerticesData(e.VertexBuffer.PositionKind, this._positions32, !1, !1), !this.mesh.areNormalsFrozen)) {
					if (this._computeParticleVertex) {
						e.VertexData.ComputeNormals(this._positions32, this._indices, this._normals32);
						for (var _ = 0; _ < this._normals32.length; _++) this._fixedNormal32[_] = this._normals32[_]
					}
					this.mesh.updateVerticesData(e.VertexBuffer.NormalKind, this._normals32, !1, !1)
				}
				this._computeBoundingBox && (this.mesh._boundingInfo = new e.BoundingInfo(this._minimum, this._maximum), this.mesh._boundingInfo.update(this.mesh._worldMatrix)), this.afterUpdateParticles(t, i, r)
			}
		}, t.prototype._quaternionRotationYPR = function() {
			this._halfroll = .5 * this._roll, this._halfpitch = .5 * this._pitch, this._halfyaw = .5 * this._yaw, this._sinRoll = Math.sin(this._halfroll), this._cosRoll = Math.cos(this._halfroll), this._sinPitch = Math.sin(this._halfpitch), this._cosPitch = Math.cos(this._halfpitch), this._sinYaw = Math.sin(this._halfyaw), this._cosYaw = Math.cos(this._halfyaw), this._quaternion.x = this._cosYaw * this._sinPitch * this._cosRoll + this._sinYaw * this._cosPitch * this._sinRoll, this._quaternion.y = this._sinYaw * this._cosPitch * this._cosRoll - this._cosYaw * this._sinPitch * this._sinRoll, this._quaternion.z = this._cosYaw * this._cosPitch * this._sinRoll - this._sinYaw * this._sinPitch * this._cosRoll, this._quaternion.w = this._cosYaw * this._cosPitch * this._cosRoll + this._sinYaw * this._sinPitch * this._sinRoll
		}, t.prototype._quaternionToRotationMatrix = function() {
			this._rotMatrix.m[0] = 1 - 2 * (this._quaternion.y * this._quaternion.y + this._quaternion.z * this._quaternion.z), this._rotMatrix.m[1] = 2 * (this._quaternion.x * this._quaternion.y + this._quaternion.z * this._quaternion.w), this._rotMatrix.m[2] = 2 * (this._quaternion.z * this._quaternion.x - this._quaternion.y * this._quaternion.w), this._rotMatrix.m[3] = 0, this._rotMatrix.m[4] = 2 * (this._quaternion.x * this._quaternion.y - this._quaternion.z * this._quaternion.w), this._rotMatrix.m[5] = 1 - 2 * (this._quaternion.z * this._quaternion.z + this._quaternion.x * this._quaternion.x), this._rotMatrix.m[6] = 2 * (this._quaternion.y * this._quaternion.z + this._quaternion.x * this._quaternion.w), this._rotMatrix.m[7] = 0, this._rotMatrix.m[8] = 2 * (this._quaternion.z * this._quaternion.x + this._quaternion.y * this._quaternion.w), this._rotMatrix.m[9] = 2 * (this._quaternion.y * this._quaternion.z - this._quaternion.x * this._quaternion.w), this._rotMatrix.m[10] = 1 - 2 * (this._quaternion.y * this._quaternion.y + this._quaternion.x * this._quaternion.x), this._rotMatrix.m[11] = 0, this._rotMatrix.m[12] = 0, this._rotMatrix.m[13] = 0, this._rotMatrix.m[14] = 0, this._rotMatrix.m[15] = 1
		}, t.prototype.dispose = function() {
			this.mesh.dispose(), this.vars = null, this._positions = null, this._indices = null, this._normals = null, this._uvs = null, this._colors = null, this._positions32 = null, this._normals32 = null, this._fixedNormal32 = null, this._uvs32 = null, this._colors32 = null, this.pickedParticles = null
		}, t.prototype.refreshVisibleSize = function() {
			this._isVisibilityBoxLocked || this.mesh.refreshBoundingInfo()
		}, t.prototype.setVisibilityBox = function(t) {
			var i = t / 2;
			this.mesh._boundingInfo = new e.BoundingInfo(new e.Vector3((-i), (-i), (-i)), new e.Vector3(i, i, i))
		}, Object.defineProperty(t.prototype, "isAlwaysVisible", {
			get: function() {
				return this._alwaysVisible
			},
			set: function(e) {
				this._alwaysVisible = e, this.mesh.alwaysSelectAsActiveMesh = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "isVisibilityBoxLocked", {
			get: function() {
				return this._isVisibilityBoxLocked
			},
			set: function(e) {
				this._isVisibilityBoxLocked = e, this.mesh.getBoundingInfo().isLocked = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "computeParticleRotation", {
			get: function() {
				return this._computeParticleRotation
			},
			set: function(e) {
				this._computeParticleRotation = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "computeParticleColor", {
			get: function() {
				return this._computeParticleColor
			},
			set: function(e) {
				this._computeParticleColor = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "computeParticleTexture", {
			get: function() {
				return this._computeParticleTexture
			},
			set: function(e) {
				this._computeParticleTexture = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "computeParticleVertex", {
			get: function() {
				return this._computeParticleVertex
			},
			set: function(e) {
				this._computeParticleVertex = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "computeBoundingBox", {
			get: function() {
				return this._computeBoundingBox
			},
			set: function(e) {
				this._computeBoundingBox = e
			},
			enumerable: !0,
			configurable: !0
		}), t.prototype.initParticles = function() {}, t.prototype.recycleParticle = function(e) {
			return e
		}, t.prototype.updateParticle = function(e) {
			return e
		}, t.prototype.updateParticleVertex = function(e, t, i) {
			return t
		}, t.prototype.beforeUpdateParticles = function(e, t, i) {}, t.prototype.afterUpdateParticles = function(e, t, i) {}, t
	})();
	e.SolidParticleSystem = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
				function e(e, t, i, r) {
					this.name = e, this.worldAxisForNormal = t, this.worldAxisForFileX = i, this.worldAxisForFileY = r
				}
				return e
			})(),
			r = (function() {
				function t() {}
				return t.ConvertCubeMapToSphericalPolynomial = function(t) {
					for (var i = new e.SphericalHarmonics, r = 0, n = 2 / t.size, o = n, s = .5 * n - 1, a = 0; a < 6; a++)
						for (var h = this.FileFaces[a], c = t[h.name], l = s, u = 0; u < t.size; u++) {
							for (var d = s, f = 0; f < t.size; f++) {
								var p = h.worldAxisForFileX.scale(d).add(h.worldAxisForFileY.scale(l)).add(h.worldAxisForNormal);
								p.normalize();
								var m, _ = Math.pow(1 + d * d + l * l, -1.5),
									g = c[u * t.size * 3 + 3 * f + 0],
									v = c[u * t.size * 3 + 3 * f + 1],
									y = c[u * t.size * 3 + 3 * f + 2],
									m = new e.Color3(g, v, y);
								i.addLight(p, m, _), r += _, d += n
							}
							l += o
						}
					var x = 4 * Math.PI,
						b = x / r;
					return i.scale(b), i.scale(1 / Math.PI), e.SphericalPolynomial.getSphericalPolynomialFromHarmonics(i)
				}, t.FileFaces = [new i("right", new e.Vector3(1, 0, 0), new e.Vector3(0, 0, (-1)), new e.Vector3(0, (-1), 0)), new i("left", new e.Vector3((-1), 0, 0), new e.Vector3(0, 0, 1), new e.Vector3(0, (-1), 0)), new i("up", new e.Vector3(0, 1, 0), new e.Vector3(1, 0, 0), new e.Vector3(0, 0, 1)), new i("down", new e.Vector3(0, (-1), 0), new e.Vector3(1, 0, 0), new e.Vector3(0, 0, (-1))), new i("front", new e.Vector3(0, 0, 1), new e.Vector3(1, 0, 0), new e.Vector3(0, (-1), 0)), new i("back", new e.Vector3(0, 0, (-1)), new e.Vector3((-1), 0, 0), new e.Vector3(0, (-1), 0))], t
			})();
		t.CubeMapToSphericalPolynomialTools = r
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
			function t() {}
			return t.ConvertPanoramaToCubemap = function(e, t, i, r) {
				if (!e) throw "ConvertPanoramaToCubemap: input cannot be null";
				if (e.length != t * i * 3) throw "ConvertPanoramaToCubemap: input size is wrong";
				var n = this.CreateCubemapTexture(r, this.FACE_FRONT, e, t, i),
					o = this.CreateCubemapTexture(r, this.FACE_BACK, e, t, i),
					s = this.CreateCubemapTexture(r, this.FACE_LEFT, e, t, i),
					a = this.CreateCubemapTexture(r, this.FACE_RIGHT, e, t, i),
					h = this.CreateCubemapTexture(r, this.FACE_UP, e, t, i),
					c = this.CreateCubemapTexture(r, this.FACE_DOWN, e, t, i);
				return {
					front: n,
					back: o,
					left: s,
					right: a,
					up: h,
					down: c,
					size: r
				}
			}, t.CreateCubemapTexture = function(e, t, i, r, n) {
				for (var o = new ArrayBuffer(e * e * 4 * 3), s = new Float32Array(o), a = t[1].subtract(t[0]).scale(1 / e), h = t[3].subtract(t[2]).scale(1 / e), c = 1 / e, l = 0, u = 0; u < e; u++) {
					for (var d = t[0], f = t[2], p = 0; p < e; p++) {
						var m = f.subtract(d).scale(l).add(d);
						m.normalize();
						var _ = this.CalcProjectionSpherical(m, i, r, n);
						s[u * e * 3 + 3 * p + 0] = _.r, s[u * e * 3 + 3 * p + 1] = _.g, s[u * e * 3 + 3 * p + 2] = _.b, d = d.add(a), f = f.add(h)
					}
					l += c
				}
				return s
			}, t.CalcProjectionSpherical = function(e, t, i, r) {
				for (var n = Math.atan2(e.z, e.x), o = Math.acos(e.y); n < -Math.PI;) n += 2 * Math.PI;
				for (; n > Math.PI;) n -= 2 * Math.PI;
				var s = n / Math.PI,
					a = o / Math.PI;
				s = .5 * s + .5;
				var h = Math.round(s * i);
				h < 0 ? h = 0 : h >= i && (h = i - 1);
				var c = Math.round(a * r);
				c < 0 ? c = 0 : c >= r && (c = r - 1);
				var l = r - c - 1,
					u = t[l * i * 3 + 3 * h + 0],
					d = t[l * i * 3 + 3 * h + 1],
					f = t[l * i * 3 + 3 * h + 2];
				return {
					r: u,
					g: d,
					b: f
				}
			}, t.FACE_FRONT = [new e.Vector3((-1), (-1), (-1)), new e.Vector3(1, (-1), (-1)), new e.Vector3((-1), 1, (-1)), new e.Vector3(1, 1, (-1))], t.FACE_BACK = [new e.Vector3(1, (-1), 1), new e.Vector3((-1), (-1), 1), new e.Vector3(1, 1, 1), new e.Vector3((-1), 1, 1)], t.FACE_RIGHT = [new e.Vector3(1, (-1), (-1)), new e.Vector3(1, (-1), 1), new e.Vector3(1, 1, (-1)), new e.Vector3(1, 1, 1)], t.FACE_LEFT = [new e.Vector3((-1), (-1), 1), new e.Vector3((-1), (-1), (-1)), new e.Vector3((-1), 1, 1), new e.Vector3((-1), 1, (-1))], t.FACE_DOWN = [new e.Vector3((-1), 1, (-1)), new e.Vector3(1, 1, (-1)), new e.Vector3((-1), 1, 1), new e.Vector3(1, 1, 1)], t.FACE_UP = [new e.Vector3((-1), (-1), 1), new e.Vector3(1, (-1), 1), new e.Vector3((-1), (-1), (-1)), new e.Vector3(1, (-1), (-1))], t
		})();
		t.PanoramaToCubeMapTools = i
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(e) {
		var t = (function() {
			function t() {}
			return t.Ldexp = function(e, t) {
				return t > 1023 ? e * Math.pow(2, 1023) * Math.pow(2, t - 1023) : t < -1074 ? e * Math.pow(2, -1074) * Math.pow(2, t + 1074) : e * Math.pow(2, t)
			}, t.Rgbe2float = function(e, t, i, r, n, o) {
				n > 0 ? (n = this.Ldexp(1, n - 136), e[o + 0] = t * n, e[o + 1] = i * n, e[o + 2] = r * n) : (e[o + 0] = 0, e[o + 1] = 0, e[o + 2] = 0)
			}, t.readStringLine = function(e, t) {
				for (var i = "", r = "", n = t; n < e.length - t && (r = String.fromCharCode(e[n]), "\n" != r); n++) i += r;
				return i
			}, t.RGBE_ReadHeader = function(e) {
				var t = 0,
					i = 0,
					r = this.readStringLine(e, 0);
				if ("#" != r[0] || "?" != r[1]) throw "Bad HDR Format.";
				var n = !1,
					o = !1,
					s = 0;
				do s += r.length + 1, r = this.readStringLine(e, s), "FORMAT=32-bit_rle_rgbe" == r ? o = !0 : 0 == r.length && (n = !0); while (!n);
				if (!o) throw "HDR Bad header format, unsupported FORMAT";
				s += r.length + 1, r = this.readStringLine(e, s);
				var a = /^\-Y (.*) \+X (.*)$/g,
					h = a.exec(r);
				if (h.length < 3) throw "HDR Bad header format, no size";
				if (i = parseInt(h[2]), t = parseInt(h[1]), i < 8 || i > 32767) throw "HDR Bad header format, unsupported size";
				return s += r.length + 1, {
					height: t,
					width: i,
					dataPosition: s
				}
			}, t.GetCubeMapTextureData = function(t, i) {
				var r = new Uint8Array(t),
					n = this.RGBE_ReadHeader(r),
					o = this.RGBE_ReadPixels_RLE(r, n),
					s = e.PanoramaToCubeMapTools.ConvertPanoramaToCubemap(o, n.width, n.height, i);
				return s
			}, t.RGBE_ReadPixels = function(e, t) {
				return this.RGBE_ReadPixels_RLE(e, t)
			}, t.RGBE_ReadPixels_RLE = function(e, t) {
				for (var i, r, n, o, s, a = t.height, h = t.width, c = t.dataPosition, l = 0, u = 0, d = 0, f = new ArrayBuffer(4 * h), p = new Uint8Array(f), m = new ArrayBuffer(t.width * t.height * 4 * 3), _ = new Float32Array(m); a > 0;) {
					if (i = e[c++], r = e[c++], n = e[c++], o = e[c++], 2 != i || 2 != r || 128 & n) throw "HDR Bad header format, not RLE";
					if ((n << 8 | o) != h) throw "HDR Bad header format, wrong scan line width";
					for (l = 0, d = 0; d < 4; d++)
						for (u = (d + 1) * h; l < u;)
							if (i = e[c++], r = e[c++], i > 128) {
								if (s = i - 128, 0 == s || s > u - l) throw "HDR Bad Format, bad scanline data (run)";
								for (; s-- > 0;) p[l++] = r
							} else {
								if (s = i, 0 == s || s > u - l) throw "HDR Bad Format, bad scanline data (non-run)";
								if (p[l++] = r, --s > 0)
									for (var g = 0; g < s; g++) p[l++] = e[c++]
							}
					for (d = 0; d < h; d++) i = p[d], r = p[d + h], n = p[d + 2 * h], o = p[d + 3 * h], this.Rgbe2float(_, i, r, n, o, (t.height - a) * h * 3 + 3 * d);
					a--
				}
				return _
			}, t
		})();
		e.HDRTools = t
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
				function t() {
					this.min = new e.Vector3(0, 0, 0), this.max = new e.Vector3(0, 0, 0), this.clear()
				}
				return t.prototype.clear = function() {
					this.min.x = t.MAX, this.min.y = t.MAX, this.min.z = t.MAX, this.max.x = t.MIN, this.max.y = t.MIN, this.max.z = t.MIN
				}, t.prototype.augment = function(e, t, i) {
					this.min.x = Math.min(this.min.x, e), this.min.y = Math.min(this.min.y, t), this.min.z = Math.min(this.min.z, i), this.max.x = Math.max(this.max.x, e), this.max.y = Math.max(this.max.y, t), this.max.z = Math.max(this.max.z, i)
				}, t.prototype.clampMin = function(e, t, i) {
					this.min.x = Math.max(this.min.x, e), this.min.y = Math.max(this.min.y, t), this.min.z = Math.max(this.min.z, i)
				}, t.prototype.clampMax = function(e, t, i) {
					this.max.x = Math.min(this.max.x, e), this.max.y = Math.min(this.max.y, t), this.max.z = Math.min(this.max.z, i)
				}, t.prototype.empty = function() {
					return this.min.x > this.max.y || this.min.y > this.max.y || this.min.z > this.max.y
				}, t.MAX = Number.MAX_VALUE, t.MIN = Number.MIN_VALUE, t
			})(),
			r = (function() {
				function t(e, t, i, r, n, o, s, a, h, c) {
					this.input = e, this.inputSize = t, this.outputSize = i, this.maxNumMipLevels = r, this.numChannels = n, this.isFloat = o, this.specularPower = s, this.cosinePowerDropPerMip = a, this.excludeBase = h, this.fixup = c, this._outputSurface = [], this._numMipLevels = 0
				}
				return t.prototype.filterCubeMap = function() {
					return this.init(), this.filterCubeMapMipChain(), this._outputSurface
				}, t.prototype.init = function() {
					var e, i, r;
					for (0 == this.maxNumMipLevels && (this.maxNumMipLevels = t.CP_MAX_MIPLEVELS), r = this.outputSize, i = 0; i < this.maxNumMipLevels; i++) {
						for (this._outputSurface.length++, this._outputSurface[i] = [], e = 0; e < 6; e++) this._outputSurface[i].length++, this.isFloat ? this._outputSurface[i][e] = new Float32Array(r * r * this.numChannels) : this._outputSurface[i][e] = new Uint32Array(r * r * this.numChannels);
						if (r >>= 1, this._numMipLevels++, 0 == r) return void(this.maxNumMipLevels = i)
					}
				}, t.prototype.filterCubeMapMipChain = function() {
					var e = this.specularPower;
					this.precomputeFilterLookupTables(this.inputSize);
					for (var t = 0; t < this._numMipLevels; t++) {
						this.excludeBase && 0 == t && (e = 1e5);
						var i = this.input,
							r = this._outputSurface[t],
							n = this.outputSize >> t,
							o = this.getBaseFilterAngle(e);
						this.filterCubeSurfaces(i, this.inputSize, r, n, o, e), this.fixup && this.fixupCubeEdges(r, n), this.excludeBase && 0 == t && (e = this.specularPower), e *= this.cosinePowerDropPerMip
					}
				}, t.prototype.getBaseFilterAngle = function(e) {
					var t = 1e-6,
						i = 180;
					return i = Math.acos(Math.pow(t, 1 / e)), i *= 180 / Math.PI, i *= 2
				}, t.prototype.precomputeFilterLookupTables = function(e) {
					this._normCubeMap = [], this.buildNormalizerSolidAngleCubemap(e)
				}, t.prototype.buildNormalizerSolidAngleCubemap = function(e) {
					var t, i, r;
					for (t = 0; t < 6; t++) {
						this._normCubeMap.push(new Float32Array(e * e * 4));
						this.input[t];
						for (r = 0; r < e; r++)
							for (i = 0; i < e; i++) {
								var n = this.texelCoordToVect(t, i, r, e, this.fixup);
								this._normCubeMap[t][4 * (r * e + i) + 0] = n.x, this._normCubeMap[t][4 * (r * e + i) + 1] = n.y, this._normCubeMap[t][4 * (r * e + i) + 2] = n.z;
								var o = this.texelCoordSolidAngle(t, i, r, e);
								this._normCubeMap[t][4 * (r * e + i) + 4] = o
							}
					}
				}, t.prototype.texelCoordToVect = function(e, i, r, n, o) {
					var s, a;
					if (s = 2 * (i + .5) / n - 1, a = 2 * (r + .5) / n - 1, o && n > 1) {
						var h = Math.pow(n, 2) / Math.pow(n - 1, 3);
						s = h * Math.pow(s, 3) + s, a = h * Math.pow(a, 3) + a
					}
					var c = t._sgFace2DMapping[e][t.CP_UDIR];
					t._vectorTemp.x = c[0] * s, t._vectorTemp.y = c[1] * s, t._vectorTemp.z = c[2] * s;
					var l = t._sgFace2DMapping[e][t.CP_VDIR];
					t._vectorTemp.x += l[0] * a, t._vectorTemp.y += l[1] * a, t._vectorTemp.z += l[2] * a;
					var u = t._sgFace2DMapping[e][t.CP_FACEAXIS];
					return t._vectorTemp.x += u[0], t._vectorTemp.y += u[1], t._vectorTemp.z += u[2], t._vectorTemp.normalize(), t._vectorTemp
				}, t.prototype.vectToTexelCoord = function(e, i, r, n) {
					var o, s, a = Math.abs(e),
						h = Math.abs(i),
						c = Math.abs(r);
					a >= h && a >= c ? (o = a, s = e >= 0 ? t.CP_FACE_X_POS : t.CP_FACE_X_NEG) : h >= a && h >= c ? (o = h, s = i >= 0 ? t.CP_FACE_Y_POS : t.CP_FACE_Y_NEG) : (o = c, s = r >= 0 ? t.CP_FACE_Z_POS : t.CP_FACE_Z_NEG);
					var l = 1 / o;
					e *= l, i *= l, r *= l;
					var u = t._sgFace2DMapping[s][t.CP_UDIR],
						d = u[0] * e + u[1] * i + u[2] * r;
					u = t._sgFace2DMapping[s][t.CP_VDIR];
					var f = u[0] * e + u[1] * i + u[2] * r,
						p = Math.floor(.5 * (n - 1) * (d + 1)),
						m = Math.floor(.5 * (n - 1) * (f + 1));
					return t._vectorTemp.x = s, t._vectorTemp.y = p, t._vectorTemp.z = m, t._vectorTemp
				}, t.prototype.areaElement = function(e, t) {
					return Math.atan2(e * t, Math.sqrt(e * e + t * t + 1))
				}, t.prototype.texelCoordSolidAngle = function(e, t, i, r) {
					t = 2 * (t + .5) / r - 1, i = 2 * (i + .5) / r - 1;
					var n = 1 / r,
						o = t - n,
						s = i - n,
						a = t + n,
						h = i + n,
						c = this.areaElement(o, s) - this.areaElement(o, h) - this.areaElement(a, s) + this.areaElement(a, h);
					return c
				}, t.prototype.filterCubeSurfaces = function(e, t, r, n, o, s) {
					var a, h, c, l = [];
					for (a = 0; a < 6; a++) l.push(new i);
					var u = 180 / Math.PI * Math.atan2(1, t),
						d = o / 2;
					d < u && (d = u), d > 90 && (d = 90);
					var f = Math.ceil(d / u);
					f < 1 && (f = 1);
					var p = Math.cos(Math.PI / 180 * d);
					for (a = 0; a < 6; a++)
						for (c = 0; c < n; c++)
							for (h = 0; h < n; h++) {
								var m = this.texelCoordToVect(a, h, c, n, this.fixup).clone();
								this.clearFilterExtents(l), this.determineFilterExtents(m, t, f, l);
								var _ = this.processFilterExtents(m, p, l, e, t, s);
								r[a][(c * n + h) * this.numChannels + 0] = _.x, r[a][(c * n + h) * this.numChannels + 1] = _.y, r[a][(c * n + h) * this.numChannels + 2] = _.z
							}
				}, t.prototype.clearFilterExtents = function(e) {
					for (var t = 0; t < 6; t++) e[t].clear()
				}, t.prototype.determineFilterExtents = function(e, i, r, n) {
					var o, s, a, h = [0, 0, 0, 0],
						c = [0, 0, 0, 0],
						l = [0, 0, 0, 0],
						u = this.vectToTexelCoord(e.x, e.y, e.z, i),
						d = u.x,
						f = u.y,
						p = u.z;
					n[d].augment(f - r, p - r, 0), n[d].augment(f + r, p + r, 0), n[d].clampMin(0, 0, 0), n[d].clampMax(i - 1, i - 1, 0);
					var m = n[d].min.x,
						_ = n[d].min.y,
						g = n[d].max.x,
						v = n[d].max.y;
					h[0] = r - f, c[0] = _, l[0] = v, h[1] = f + r - (i - 1), c[1] = _, l[1] = v, h[2] = r - p, c[2] = m, l[2] = g, h[3] = p + r - (i - 1), c[3] = m, l[3] = g;
					for (var y = 0; y < 4; y++) {
						if (h[y] > 0) {
							switch (o = t._sgCubeNgh[d][y][0], s = t._sgCubeNgh[d][y][1], y != s && y + s != 3 || (c[y] = i - 1 - c[y], l[y] = i - 1 - l[y]), t._sgCubeNgh[d][y][1]) {
								case t.CP_EDGE_LEFT:
									n[o].augment(0, c[y], 0), n[o].augment(h[y], l[y], 0);
									break;
								case t.CP_EDGE_RIGHT:
									n[o].augment(i - 1, c[y], 0), n[o].augment(i - 1 - h[y], l[y], 0);
									break;
								case t.CP_EDGE_TOP:
									n[o].augment(c[y], 0, 0), n[o].augment(l[y], h[y], 0);
									break;
								case t.CP_EDGE_BOTTOM:
									n[o].augment(c[y], i - 1, 0), n[o].augment(l[y], i - 1 - h[y], 0)
							}
							n[o].clampMin(0, 0, 0), n[o].clampMax(i - 1, i - 1, 0)
						}
						if (h[y] > i) {
							switch (d) {
								case t.CP_FACE_X_POS:
									a = t.CP_FACE_X_NEG;
									break;
								case t.CP_FACE_X_NEG:
									a = t.CP_FACE_X_POS;
									break;
								case t.CP_FACE_Y_POS:
									a = t.CP_FACE_Y_NEG;
									break;
								case t.CP_FACE_Y_NEG:
									a = t.CP_FACE_Y_POS;
									break;
								case t.CP_FACE_Z_POS:
									a = t.CP_FACE_Z_NEG;
									break;
								case t.CP_FACE_Z_NEG:
									a = t.CP_FACE_Z_POS
							}
							n[a].augment(0, 0, 0), n[a].augment(i - 1, i - 1, 0)
						}
					}
				}, t.prototype.processFilterExtents = function(e, i, r, n, o, s) {
					for (var a = [0, 0, 0, 0], h = 0, c = 0, l = this.numChannels, u = o, d = 4 * u, f = u * this.numChannels, p = 1, m = 0; m < 6; m++)
						if (!r[m].empty())
							for (var _ = r[m].min.x, g = r[m].min.y, v = r[m].max.x, y = r[m].max.y, x = 4 * (g * u + _), b = this.numChannels * (g * u + _), T = g; T <= y; T++) {
								for (var A = 0, E = 0, P = _; P <= v; P++) {
									var M = this._normCubeMap[m][x + A + 0],
										S = this._normCubeMap[m][x + A + 1],
										C = this._normCubeMap[m][x + A + 2],
										R = M * e.x + S * e.y + C * e.z;
									if (R >= i && R > 0) {
										var O = this._normCubeMap[m][x + A + 3];
										for (O *= Math.pow(R, s + p), c = 0; c < l; c++) a[c] += O * n[m][b + E], E++;
										h += O
									} else E += l;
									A += 4
								}
								x += d, b += f
							}
					if (0 != h) t._vectorTemp.x = a[0] / h, t._vectorTemp.y = a[1] / h, t._vectorTemp.z = a[2] / h, this.numChannels > 3 && (t._vectorTemp.w = a[3] / h);
					else {
						var D = this.vectToTexelCoord(e.x, e.y, e.z, o).clone();
						t._vectorTemp.x = n[D.x][this.numChannels * (D.z * o + D.y) + 0], t._vectorTemp.y = n[D.x][this.numChannels * (D.z * o + D.y) + 1], t._vectorTemp.z = n[D.x][this.numChannels * (D.z * o + D.y) + 2], this.numChannels > 3 && (t._vectorTemp.z = n[D.x][this.numChannels * (D.z * o + D.y) + 3])
					}
					return t._vectorTemp
				}, t.prototype.fixupCubeEdges = function(e, i) {
					var r, n, o, s, a = 0,
						h = [0, 0, 0, 0, 0, 0, 0, 0],
						c = [
							[],
							[],
							[],
							[]
						],
						l = [
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							],
							[
								[],
								[],
								[]
							]
						];
					if (!(i < 1))
						if (1 != i) {
							for (s = 0; s < 6; s++)
								for (c[0] = [s, 0], c[1] = [s, (i - 1) * this.numChannels], c[2] = [s, i * (i - 1) * this.numChannels], c[3] = [s, (i * (i - 1) + (i - 1)) * this.numChannels], a = 0; a < 4; a++) {
									var u = t._sgCubeCornerList[s][a];
									l[u][h[u]] = c[a], h[u]++
								}
							for (a = 0; a < 8; a++)
								for (r = 0; r < this.numChannels; r++) {
									var d = 0;
									for (o = 0; o < 3; o++) d += e[l[a][o][0]][l[a][o][1] + r];
									for (d *= 1 / 3, o = 0; o < 3; o++) e[l[a][o][0]][l[a][o][1] + r] = d
								}
							for (o = 0; o < 12; o++) {
								var f = t._sgCubeEdgeList[o][0],
									p = t._sgCubeEdgeList[o][1],
									m = t._sgCubeNgh[f][p][0],
									_ = t._sgCubeNgh[f][p][1],
									g = 0,
									v = 0,
									y = 0,
									x = 0;
								switch (p) {
									case t.CP_EDGE_LEFT:
										y = this.numChannels * i;
										break;
									case t.CP_EDGE_RIGHT:
										g += (i - 1) * this.numChannels, y = this.numChannels * i;
										break;
									case t.CP_EDGE_TOP:
										y = this.numChannels;
										break;
									case t.CP_EDGE_BOTTOM:
										g += i * (i - 1) * this.numChannels, y = this.numChannels
								}
								if (p == _ || p + _ == 3) switch (_) {
									case t.CP_EDGE_LEFT:
										v += (i - 1) * i * this.numChannels, x = -(this.numChannels * i);
										break;
									case t.CP_EDGE_RIGHT:
										v += ((i - 1) * i + (i - 1)) * this.numChannels, x = -(this.numChannels * i);
										break;
									case t.CP_EDGE_TOP:
										v += (i - 1) * this.numChannels, x = -this.numChannels;
										break;
									case t.CP_EDGE_BOTTOM:
										v += ((i - 1) * i + (i - 1)) * this.numChannels, x = -this.numChannels
								} else switch (_) {
									case t.CP_EDGE_LEFT:
										x = this.numChannels * i;
										break;
									case t.CP_EDGE_RIGHT:
										v += (i - 1) * this.numChannels, x = this.numChannels * i;
										break;
									case t.CP_EDGE_TOP:
										x = this.numChannels;
										break;
									case t.CP_EDGE_BOTTOM:
										v += i * (i - 1) * this.numChannels, x = this.numChannels
								}
								for (g += y, v += x, n = 1; n < i - 1; n++) {
									for (r = 0; r < this.numChannels; r++) {
										var b = e[f][g + r],
											T = e[m][v + r],
											A = .5 * (b + T);
										e[f][g + r] = A, e[m][v + r] = A
									}
									g += y, v += x
								}
							}
						} else
							for (r = 0; r < this.numChannels; r++) {
								var E = 0;
								for (s = 0; s < 6; s++) E += e[s][r];
								for (E /= 6, s = 0; s < 6; s++) e[s][r] = E
							}
				}, t.CP_MAX_MIPLEVELS = 16, t.CP_UDIR = 0, t.CP_VDIR = 1, t.CP_FACEAXIS = 2, t.CP_FACE_X_POS = 0, t.CP_FACE_X_NEG = 1, t.CP_FACE_Y_POS = 2, t.CP_FACE_Y_NEG = 3, t.CP_FACE_Z_POS = 4, t.CP_FACE_Z_NEG = 5, t.CP_EDGE_LEFT = 0, t.CP_EDGE_RIGHT = 1, t.CP_EDGE_TOP = 2, t.CP_EDGE_BOTTOM = 3, t.CP_CORNER_NNN = 0, t.CP_CORNER_NNP = 1, t.CP_CORNER_NPN = 2, t.CP_CORNER_NPP = 3, t.CP_CORNER_PNN = 4, t.CP_CORNER_PNP = 5, t.CP_CORNER_PPN = 6, t.CP_CORNER_PPP = 7, t._vectorTemp = new e.Vector4(0, 0, 0, 0), t._sgFace2DMapping = [
					[
						[0, 0, -1],
						[0, -1, 0],
						[1, 0, 0]
					],
					[
						[0, 0, 1],
						[0, -1, 0],
						[-1, 0, 0]
					],
					[
						[1, 0, 0],
						[0, 0, 1],
						[0, 1, 0]
					],
					[
						[1, 0, 0],
						[0, 0, -1],
						[0, -1, 0]
					],
					[
						[1, 0, 0],
						[0, -1, 0],
						[0, 0, 1]
					],
					[
						[-1, 0, 0],
						[0, -1, 0],
						[0, 0, -1]
					]
				], t._sgCubeNgh = [
					[
						[t.CP_FACE_Z_POS, t.CP_EDGE_RIGHT],
						[t.CP_FACE_Z_NEG, t.CP_EDGE_LEFT],
						[t.CP_FACE_Y_POS, t.CP_EDGE_RIGHT],
						[t.CP_FACE_Y_NEG, t.CP_EDGE_RIGHT]
					],
					[
						[t.CP_FACE_Z_NEG, t.CP_EDGE_RIGHT],
						[t.CP_FACE_Z_POS, t.CP_EDGE_LEFT],
						[t.CP_FACE_Y_POS, t.CP_EDGE_LEFT],
						[t.CP_FACE_Y_NEG, t.CP_EDGE_LEFT]
					],
					[
						[t.CP_FACE_X_NEG, t.CP_EDGE_TOP],
						[t.CP_FACE_X_POS, t.CP_EDGE_TOP],
						[t.CP_FACE_Z_NEG, t.CP_EDGE_TOP],
						[t.CP_FACE_Z_POS, t.CP_EDGE_TOP]
					],
					[
						[t.CP_FACE_X_NEG, t.CP_EDGE_BOTTOM],
						[t.CP_FACE_X_POS, t.CP_EDGE_BOTTOM],
						[t.CP_FACE_Z_POS, t.CP_EDGE_BOTTOM],
						[t.CP_FACE_Z_NEG, t.CP_EDGE_BOTTOM]
					],
					[
						[t.CP_FACE_X_NEG, t.CP_EDGE_RIGHT],
						[t.CP_FACE_X_POS, t.CP_EDGE_LEFT],
						[t.CP_FACE_Y_POS, t.CP_EDGE_BOTTOM],
						[t.CP_FACE_Y_NEG, t.CP_EDGE_TOP]
					],
					[
						[t.CP_FACE_X_POS, t.CP_EDGE_RIGHT],
						[t.CP_FACE_X_NEG, t.CP_EDGE_LEFT],
						[t.CP_FACE_Y_POS, t.CP_EDGE_TOP],
						[t.CP_FACE_Y_NEG, t.CP_EDGE_BOTTOM]
					]
				], t._sgCubeEdgeList = [
					[t.CP_FACE_X_POS, t.CP_EDGE_LEFT],
					[t.CP_FACE_X_POS, t.CP_EDGE_RIGHT],
					[t.CP_FACE_X_POS, t.CP_EDGE_TOP],
					[t.CP_FACE_X_POS, t.CP_EDGE_BOTTOM],
					[t.CP_FACE_X_NEG, t.CP_EDGE_LEFT],
					[t.CP_FACE_X_NEG, t.CP_EDGE_RIGHT],
					[t.CP_FACE_X_NEG, t.CP_EDGE_TOP],
					[t.CP_FACE_X_NEG, t.CP_EDGE_BOTTOM],
					[t.CP_FACE_Z_POS, t.CP_EDGE_TOP],
					[t.CP_FACE_Z_POS, t.CP_EDGE_BOTTOM],
					[t.CP_FACE_Z_NEG, t.CP_EDGE_TOP],
					[t.CP_FACE_Z_NEG, t.CP_EDGE_BOTTOM]
				], t._sgCubeCornerList = [
					[t.CP_CORNER_PPP, t.CP_CORNER_PPN, t.CP_CORNER_PNP, t.CP_CORNER_PNN],
					[t.CP_CORNER_NPN, t.CP_CORNER_NPP, t.CP_CORNER_NNN, t.CP_CORNER_NNP],
					[t.CP_CORNER_NPN, t.CP_CORNER_PPN, t.CP_CORNER_NPP, t.CP_CORNER_PPP],
					[t.CP_CORNER_NNP, t.CP_CORNER_PNP, t.CP_CORNER_NNN, t.CP_CORNER_PNN],
					[t.CP_CORNER_NPP, t.CP_CORNER_PPP, t.CP_CORNER_NNP, t.CP_CORNER_PNP],
					[t.CP_CORNER_PPN, t.CP_CORNER_NPN, t.CP_CORNER_PNN, t.CP_CORNER_NNN]
				], t
			})();
		t.PMREMGenerator = r
	})(t = e.Internals || (e.Internals = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s, a, h) {
			void 0 === o && (o = !1), void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === h && (h = !1), t.call(this, r), this._useInGammaSpace = !1, this._generateHarmonics = !0, this._isBABYLONPreprocessed = !1, this.coordinatesMode = e.Texture.CUBIC_MODE, this.sphericalPolynomial = null, this.isPMREM = !1, i && (this.name = i, this.url = i, this.hasAlpha = !1, this.isCube = !0, this._textureMatrix = e.Matrix.Identity(), n ? (this._isBABYLONPreprocessed = !1, this._noMipmap = o, this._size = n, this._useInGammaSpace = a, this._usePMREMGenerator = h && r.getEngine().getCaps().textureLOD && this.getScene().getEngine().getCaps().textureFloat && !this._useInGammaSpace) : (this._isBABYLONPreprocessed = !0, this._noMipmap = !1, this._useInGammaSpace = !1, this._usePMREMGenerator = r.getEngine().getCaps().textureLOD && this.getScene().getEngine().getCaps().textureFloat && !this._useInGammaSpace), this.isPMREM = this._usePMREMGenerator, this._texture = this._getFromCache(i, this._noMipmap), this._texture || (r.useDelayedTextureLoading ? this.delayLoadState = e.Engine.DELAYLOADSTATE_NOTLOADED : this.loadTexture()))
		}
		return __extends(i, t), i.prototype.loadBabylonTexture = function() {
			var t = this,
				i = 0,
				r = null,
				n = !this._useInGammaSpace && this.getScene().getEngine().getCaps().textureFloat ? function(e) {
					for (var n = [], o = 30, s = 0; s < i; s++) {
						n.push([]);
						for (var a = 3 * Math.pow(t._size >> s, 2), h = 0; h < 6; h++) {
							var c = r.subarray(o, o + a);
							n[s].push(c), o += a
						}
					}
					return n
				} : null,
				o = function(o) {
					var s = new Int32Array(o);
					r = new Float32Array(o);
					s[0];
					t._size = s[1], t.getScene().getEngine().updateTextureSize(t._texture, t._size, t._size), t.sphericalPolynomial = new e.SphericalPolynomial, t.sphericalPolynomial.x.copyFromFloats(r[2], r[3], r[4]), t.sphericalPolynomial.y.copyFromFloats(r[5], r[6], r[7]), t.sphericalPolynomial.z.copyFromFloats(r[8], r[9], r[10]), t.sphericalPolynomial.xx.copyFromFloats(r[11], r[12], r[13]), t.sphericalPolynomial.yy.copyFromFloats(r[14], r[15], r[16]), t.sphericalPolynomial.zz.copyFromFloats(r[17], r[18], r[19]), t.sphericalPolynomial.xy.copyFromFloats(r[20], r[21], r[22]), t.sphericalPolynomial.yz.copyFromFloats(r[23], r[24], r[25]), t.sphericalPolynomial.zx.copyFromFloats(r[26], r[27], r[28]), i = s[29];
					for (var a = 30, h = [], c = 3 * Math.pow(t._size, 2), l = 0; l < 6; l++) h.push(r.subarray(a, a + c)), a += c;
					for (var u = [], d = null, f = 0; f < 6; f++) {
						var p = null;
						if (n) p = h[f];
						else {
							var m = [0, 2, 4, 1, 3, 5][f];
							if (p = h[m], !t.getScene().getEngine().getCaps().textureFloat) {
								var _ = new ArrayBuffer(c);
								d = new Uint8Array(_)
							}
							for (var g = 0; g < t._size * t._size; g++)
								if (t._useInGammaSpace && (p[3 * g + 0] = Math.pow(p[3 * g + 0], e.ToGammaSpace), p[3 * g + 1] = Math.pow(p[3 * g + 1], e.ToGammaSpace), p[3 * g + 2] = Math.pow(p[3 * g + 2], e.ToGammaSpace)), d) {
									var v = Math.max(255 * p[3 * g + 0], 0),
										y = Math.max(255 * p[3 * g + 1], 0),
										x = Math.max(255 * p[3 * g + 2], 0),
										b = Math.max(Math.max(v, y), x);
									if (b > 255) {
										var T = 255 / b;
										v *= T, y *= T, x *= T
									}
									d[3 * g + 0] = v, d[3 * g + 1] = y, d[3 * g + 2] = x
								}
						}
						d ? u.push(d) : u.push(p)
					}
					return u
				};
			this._texture = this.getScene().getEngine().createRawCubeTexture(this.url, this.getScene(), this._size, e.Engine.TEXTUREFORMAT_RGB, this.getScene().getEngine().getCaps().textureFloat ? e.Engine.TEXTURETYPE_FLOAT : e.Engine.TEXTURETYPE_UNSIGNED_INT, this._noMipmap, o, n)
		}, i.prototype.loadHDRTexture = function() {
			var t = this,
				r = function(r) {
					var n = e.Internals.HDRTools.GetCubeMapTextureData(r, t._size);
					t._generateHarmonics && (t.sphericalPolynomial = e.Internals.CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(n));
					for (var o = [], s = null, a = 0; a < 6; a++) {
						if (!t.getScene().getEngine().getCaps().textureFloat) {
							var h = new ArrayBuffer(t._size * t._size * 3);
							s = new Uint8Array(h)
						}
						var c = n[i._facesMapping[a]];
						if (t._useInGammaSpace || s)
							for (var l = 0; l < t._size * t._size; l++)
								if (t._useInGammaSpace && (c[3 * l + 0] = Math.pow(c[3 * l + 0], e.ToGammaSpace), c[3 * l + 1] = Math.pow(c[3 * l + 1], e.ToGammaSpace), c[3 * l + 2] = Math.pow(c[3 * l + 2], e.ToGammaSpace)), s) {
									var u = Math.max(255 * c[3 * l + 0], 0),
										d = Math.max(255 * c[3 * l + 1], 0),
										f = Math.max(255 * c[3 * l + 2], 0),
										p = Math.max(Math.max(u, d), f);
									if (p > 255) {
										var m = 255 / p;
										u *= m, d *= m, f *= m
									}
									s[3 * l + 0] = u, s[3 * l + 1] = d, s[3 * l + 2] = f
								}
						s ? o.push(s) : o.push(c)
					}
					return o
				},
				n = null;
			!this._noMipmap && this._usePMREMGenerator && (n = function(i) {
				var r = new e.Internals.PMREMGenerator(i, t._size, t._size, 0, 3, t.getScene().getEngine().getCaps().textureFloat, 2048, .25, (!1), (!0));
				return r.filterCubeMap()
			}), this._texture = this.getScene().getEngine().createRawCubeTexture(this.url, this.getScene(), this._size, e.Engine.TEXTUREFORMAT_RGB, this.getScene().getEngine().getCaps().textureFloat ? e.Engine.TEXTURETYPE_FLOAT : e.Engine.TEXTURETYPE_UNSIGNED_INT, this._noMipmap, r, n)
		}, i.prototype.loadTexture = function() {
			this._isBABYLONPreprocessed ? this.loadBabylonTexture() : this.loadHDRTexture()
		}, i.prototype.clone = function() {
			var e = this._isBABYLONPreprocessed ? null : this._size,
				t = new i(this.url, this.getScene(), e, this._noMipmap, this._generateHarmonics, this._useInGammaSpace, this._usePMREMGenerator);
			return t.level = this.level, t.wrapU = this.wrapU, t.wrapV = this.wrapV, t.coordinatesIndex = this.coordinatesIndex, t.coordinatesMode = this.coordinatesMode, t
		}, i.prototype.delayLoad = function() {
			this.delayLoadState === e.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = e.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap), this._texture || this.loadTexture())
		}, i.prototype.getReflectionTextureMatrix = function() {
			return this._textureMatrix
		}, i.Parse = function(t, i, r) {
			var n = null;
			if (t.name && !t.isRenderTarget) {
				var o = t.isBABYLONPreprocessed ? null : t.size;
				n = new e.HDRCubeTexture(r + t.name, i, o, t.generateHarmonics, t.useInGammaSpace, t.usePMREMGenerator), n.name = t.name, n.hasAlpha = t.hasAlpha, n.level = t.level, n.coordinatesMode = t.coordinatesMode
			}
			return n
		}, i.prototype.serialize = function() {
			if (!this.name) return null;
			var e = {};
			return e.name = this.name, e.hasAlpha = this.hasAlpha, e.isCube = !0, e.level = this.level, e.size = this._size, e.coordinatesMode = this.coordinatesMode, e.useInGammaSpace = this._useInGammaSpace, e.generateHarmonics = this._generateHarmonics, e.usePMREMGenerator = this._usePMREMGenerator, e.isBABYLONPreprocessed = this._isBABYLONPreprocessed, e.customType = "BABYLON.HDRCubeTexture", e
		}, i.generateBabylonHDROnDisk = function(e, t, r) {
			void 0 === r && (r = null);
			var n = function(e) {
				var t = new Blob([e], {
						type: "application/octet-stream"
					}),
					i = window.URL.createObjectURL(t),
					r = document.createElement("a");
				document.body.appendChild(r), r.style.display = "none", r.href = i, r.download = "envmap.babylon.hdr", r.click()
			};
			i.generateBabylonHDR(e, t, n, r)
		}, i.generateBabylonHDR = function(t, i, r, n) {
			if (void 0 === n && (n = null), !t) return null;
			if (!e.Tools.IsExponentOfTwo(i)) return null;
			var o = function(t) {
				var n = e.Internals.HDRTools.GetCubeMapTextureData(t, i),
					o = e.Internals.CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(n),
					s = [];
				s.push(n.right), s.push(n.left), s.push(n.up), s.push(n.down), s.push(n.front), s.push(n.back);
				var a = new e.Internals.PMREMGenerator(s, i, i, 0, 3, (!0), 2048, .25, (!1), (!0)),
					h = a.filterCubeMap(),
					c = 4;
				c += 4, c += 108, c += 4;
				for (var l = 0; l < h.length; l++) {
					var u = i >> l;
					c += 6 * u * u * 3 * 4
				}
				var d = new ArrayBuffer(c),
					f = new Int32Array(d),
					p = new Float32Array(d);
				f[0] = 1, f[1] = i, o.x.toArray(p, 2), o.y.toArray(p, 5), o.z.toArray(p, 8), o.xx.toArray(p, 11), o.yy.toArray(p, 14), o.zz.toArray(p, 17), o.xy.toArray(p, 20), o.yz.toArray(p, 23), o.zx.toArray(p, 26), f[29] = h.length;
				for (var m = 30, l = 0; l < h.length; l++)
					for (var _ = 3 * Math.pow(i >> l, 2), g = 0; g < 6; g++) p.set(h[l][g], m), m += _;
				r(d)
			};
			e.Tools.LoadFile(t, (function(e) {
				o(e)
			}), null, null, !0, n)
		}, i._facesMapping = ["right", "up", "front", "left", "down", "back"], i
	})(e.BaseTexture);
	e.HDRCubeTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
			function t(t, i, r, n, o) {
				void 0 === n && (n = !0), void 0 === o && (o = 1), this.skeleton = t, this.mesh = i, this.autoUpdateBonesMatrices = n, this.renderingGroupId = o, this.color = e.Color3.White(), this._debugLines = [], this._isEnabled = !1, this._scene = r, this.update(), this._renderFunction = this.update.bind(this)
			}
			return Object.defineProperty(t.prototype, "isEnabled", {
				get: function() {
					return this._isEnabled
				},
				set: function(e) {
					this._isEnabled !== e && (this._isEnabled = e, e ? this._scene.registerBeforeRender(this._renderFunction) : this._scene.unregisterBeforeRender(this._renderFunction))
				},
				enumerable: !0,
				configurable: !0
			}), t.prototype._getBonePosition = function(t, i, r, n, o, s) {
				void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === s && (s = 0);
				var a = e.Tmp.Matrix[0],
					h = i.getParent();
				if (a.copyFrom(i.getLocalMatrix()), 0 !== n || 0 !== o || 0 !== s) {
					var c = e.Tmp.Matrix[1];
					e.Matrix.IdentityToRef(c), c.m[12] = n, c.m[13] = o, c.m[14] = s, c.multiplyToRef(a, a)
				}
				h && a.multiplyToRef(h.getAbsoluteTransform(), a), a.multiplyToRef(r, a), t.x = a.m[12], t.y = a.m[13], t.z = a.m[14]
			}, t.prototype._getLinesForBonesWithLength = function(t, i) {
				for (var r = t.length, n = 0; n < r; n++) {
					var o = t[n],
						s = this._debugLines[n];
					s || (s = [e.Vector3.Zero(), e.Vector3.Zero()], this._debugLines[n] = s), this._getBonePosition(s[0], o, i), this._getBonePosition(s[1], o, i, 0, o.length, 0)
				}
			}, t.prototype._getLinesForBonesNoLength = function(t, i) {
				for (var r = t.length, n = 0, o = r - 1; o >= 0; o--) {
					var s = t[o],
						a = s.getParent();
					if (a) {
						var h = this._debugLines[n];
						h || (h = [e.Vector3.Zero(), e.Vector3.Zero()], this._debugLines[n] = h), s.getAbsolutePositionToRef(this.mesh, h[0]), a.getAbsolutePositionToRef(this.mesh, h[1]), n++
					}
				}
			}, t.prototype.update = function() {
				this.autoUpdateBonesMatrices && this.skeleton.computeAbsoluteTransforms(), void 0 === this.skeleton.bones[0].length ? this._getLinesForBonesNoLength(this.skeleton.bones, this.mesh.getWorldMatrix()) : this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix()), this._debugMesh ? e.MeshBuilder.CreateLineSystem(null, {
					lines: this._debugLines,
					updatable: !0,
					instance: this._debugMesh
				}, this._scene) : (this._debugMesh = e.MeshBuilder.CreateLineSystem(null, {
					lines: this._debugLines,
					updatable: !0
				}, this._scene), this._debugMesh.renderingGroupId = this.renderingGroupId), this._debugMesh.color = this.color
			}, t.prototype.dispose = function() {
				this._debugMesh && (this.isEnabled = !1, this._debugMesh.dispose(), this._debugMesh = null)
			}, t
		})();
		t.SkeletonViewer = i
	})(t = e.Debug || (e.Debug = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function() {
			function t(t, i) {
				void 0 === i && (i = 1), this._xline = [e.Vector3.Zero(), e.Vector3.Zero()], this._yline = [e.Vector3.Zero(), e.Vector3.Zero()], this._zline = [e.Vector3.Zero(), e.Vector3.Zero()], this.scaleLines = 1, this.scaleLines = i, this._xmesh = e.Mesh.CreateLines("xline", this._xline, t, !0), this._ymesh = e.Mesh.CreateLines("yline", this._yline, t, !0), this._zmesh = e.Mesh.CreateLines("zline", this._zline, t, !0), this._xmesh.renderingGroupId = 2, this._ymesh.renderingGroupId = 2, this._zmesh.renderingGroupId = 2, this._xmesh.material.checkReadyOnlyOnce = !0, this._xmesh.color = new e.Color3(1, 0, 0), this._ymesh.material.checkReadyOnlyOnce = !0, this._ymesh.color = new e.Color3(0, 1, 0), this._zmesh.material.checkReadyOnlyOnce = !0, this._zmesh.color = new e.Color3(0, 0, 1), this.scene = t
			}
			return t.prototype.update = function(t, i, r, n) {
				var o = this.scaleLines,
					s = this._xline[0],
					a = this._xline[1];
				s.x = t.x, s.y = t.y, s.z = t.z, a.x = s.x + i.x * o, a.y = s.y + i.y * o, a.z = s.z + i.z * o, e.Mesh.CreateLines(null, this._xline, null, null, this._xmesh), s = this._yline[0], a = this._yline[1], s.x = t.x, s.y = t.y, s.z = t.z, a.x = s.x + r.x * o, a.y = s.y + r.y * o, a.z = s.z + r.z * o, e.Mesh.CreateLines(null, this._yline, null, null, this._ymesh), s = this._zline[0], a = this._zline[1], s.x = t.x, s.y = t.y, s.z = t.z, a.x = s.x + n.x * o, a.y = s.y + n.y * o, a.z = s.z + n.z * o, e.Mesh.CreateLines(null, this._zline, null, null, this._zmesh)
			}, t.prototype.dispose = function() {
				this._xmesh && (this._xmesh.dispose(), this._ymesh.dispose(), this._zmesh.dispose(), this._xmesh = null, this._ymesh = null, this._zmesh = null, this._xline = null, this._yline = null, this._zline = null, this.scene = null)
			}, t
		})();
		t.AxesViewer = i
	})(t = e.Debug || (e.Debug = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t;
	!(function(t) {
		var i = (function(t) {
			function i(i, r, n, o) {
				void 0 === o && (o = 1), t.call(this, i, o), this.pos = e.Vector3.Zero(), this.xaxis = e.Vector3.Zero(), this.yaxis = e.Vector3.Zero(), this.zaxis = e.Vector3.Zero(), this.mesh = n, this.bone = r
			}
			return __extends(i, t), i.prototype.update = function() {
				var i = this.bone;
				i.getAbsolutePositionToRef(this.mesh, this.pos), i.getDirectionToRef(e.Axis.X, this.mesh, this.xaxis), i.getDirectionToRef(e.Axis.Y, this.mesh, this.yaxis), i.getDirectionToRef(e.Axis.Z, this.mesh, this.zaxis), t.prototype.update.call(this, this.pos, this.xaxis, this.yaxis, this.zaxis)
			}, i.prototype.dispose = function() {
				this.pos && (this.pos = null, this.xaxis = null, this.yaxis = null, this.zaxis = null, this.mesh = null, this.bone = null, t.prototype.dispose.call(this))
			}, i
		})(t.AxesViewer);
		t.BoneAxesViewer = i
	})(t = e.Debug || (e.Debug = {}))
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r) {
			t.call(this, r), i && (this._textureMatrix = e.Matrix.Identity(), this.name = i, this.url = i, this.hasAlpha = !1, this.isCube = !1, this.wrapU = e.Texture.CLAMP_ADDRESSMODE, this.wrapV = e.Texture.CLAMP_ADDRESSMODE, this.anisotropicFilteringLevel = 1, this._texture = this._getFromCache(i, !0), this._texture || (r.useDelayedTextureLoading ? this.delayLoadState = e.Engine.DELAYLOADSTATE_NOTLOADED : this.loadTexture()))
		}
		return __extends(i, t), i.prototype.getTextureMatrix = function() {
			return this._textureMatrix
		}, i.prototype.load3dlTexture = function() {
			var t = this,
				r = this.getScene().getEngine().createRawTexture(null, 1, 1, e.Engine.TEXTUREFORMAT_RGBA, !1, !1, e.Texture.BILINEAR_SAMPLINGMODE);
			this._texture = r;
			var n = function(n) {
				for (var o, s, a, h = n.split("\n"), c = 0, l = 0, u = 0, d = 0, f = 0, p = 0; p < h.length; p++)
					if (a = h[p], i._noneEmptyLineRegex.test(a) && 0 !== a.indexOf("#")) {
						var m = a.split(" ");
						if (0 !== c) {
							if (0 != c) {
								var _ = Math.max(parseInt(m[0]), 0),
									g = Math.max(parseInt(m[1]), 0),
									v = Math.max(parseInt(m[2]), 0);
								f = Math.max(_, f), f = Math.max(g, f), f = Math.max(v, f);
								var y = 4 * (l + d * c + u * c * c);
								s[y + 0] = _, s[y + 1] = g, s[y + 2] = v, s[y + 3] = 0, d++, d % c == 0 && (u++, d = 0, u % c == 0 && (l++, u = 0))
							}
						} else c = m.length, o = new Uint8Array(c * c * c * 4), s = new Float32Array(c * c * c * 4)
					}
				for (var p = 0; p < s.length; p++) {
					var x = s[p];
					o[p] = x / f * 255
				}
				t.getScene().getEngine().updateTextureSize(r, c * c, c), t.getScene().getEngine().updateRawTexture(r, o, e.Engine.TEXTUREFORMAT_RGBA, !1)
			};
			return e.Tools.LoadFile(this.url, n), this._texture
		}, i.prototype.loadTexture = function() {
			this.url && this.url.toLocaleLowerCase().indexOf(".3dl") == this.url.length - 4 && this.load3dlTexture()
		}, i.prototype.clone = function() {
			var e = new i(this.url, this.getScene());
			return e.level = this.level, e
		}, i.prototype.delayLoad = function() {
			this.delayLoadState === e.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = e.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, !0), this._texture || this.loadTexture())
		}, i.Bind = function(e, t) {
			t.setTexture("cameraColorGrading2DSampler", e);
			var i = e.level,
				r = e.getSize().height,
				n = r - 1,
				o = 1 / r;
			t.setFloat4("vCameraColorGradingInfos", i, r, n, o);
			var s = o / r,
				a = o,
				h = n * s,
				c = n / r,
				l = .5 * s,
				u = .5 * a;
			t.setFloat4("vCameraColorGradingScaleOffset", h, c, l, u)
		}, i.PrepareUniformsAndSamplers = function(e, t) {
			e.push("vCameraColorGradingInfos", "vCameraColorGradingScaleOffset"), t.push("cameraColorGrading2DSampler")
		}, i.Parse = function(t, i, r) {
			var n = null;
			return t.name && !t.isRenderTarget && (n = new e.ColorGradingTexture(t.name, i), n.name = t.name, n.level = t.level), n
		}, i.prototype.serialize = function() {
			if (!this.name) return null;
			var e = {};
			return e.name = this.name, e.level = this.level, e.customType = "BABYLON.ColorGradingTexture", e
		}, i._noneEmptyLineRegex = /\S+/, i
	})(e.BaseTexture);
	e.ColorGradingTexture = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t() {
			this._dirty = !0, this._tempColor = new e.Color4(0, 0, 0, 0), this._globalCurve = new e.Color4(0, 0, 0, 0), this._highlightsCurve = new e.Color4(0, 0, 0, 0), this._midtonesCurve = new e.Color4(0, 0, 0, 0), this._shadowsCurve = new e.Color4(0, 0, 0, 0), this._positiveCurve = new e.Color4(0, 0, 0, 0), this._negativeCurve = new e.Color4(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0
		}
		return Object.defineProperty(t.prototype, "GlobalHue", {
			get: function() {
				return this._globalHue
			},
			set: function(e) {
				this._globalHue = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "GlobalDensity", {
			get: function() {
				return this._globalDensity
			},
			set: function(e) {
				this._globalDensity = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "GlobalSaturation", {
			get: function() {
				return this._globalSaturation
			},
			set: function(e) {
				this._globalSaturation = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "HighlightsHue", {
			get: function() {
				return this._highlightsHue
			},
			set: function(e) {
				this._highlightsHue = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "HighlightsDensity", {
			get: function() {
				return this._highlightsDensity
			},
			set: function(e) {
				this._highlightsDensity = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "HighlightsSaturation", {
			get: function() {
				return this._highlightsSaturation
			},
			set: function(e) {
				this._highlightsSaturation = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "HighlightsExposure", {
			get: function() {
				return this._highlightsExposure
			},
			set: function(e) {
				this._highlightsExposure = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "MidtonesHue", {
			get: function() {
				return this._midtonesHue
			},
			set: function(e) {
				this._midtonesHue = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "MidtonesDensity", {
			get: function() {
				return this._midtonesDensity
			},
			set: function(e) {
				this._midtonesDensity = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "MidtonesSaturation", {
			get: function() {
				return this._midtonesSaturation
			},
			set: function(e) {
				this._midtonesSaturation = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "MidtonesExposure", {
			get: function() {
				return this._midtonesExposure
			},
			set: function(e) {
				this._midtonesExposure = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "ShadowsHue", {
			get: function() {
				return this._shadowsHue
			},
			set: function(e) {
				this._shadowsHue = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "ShadowsDensity", {
			get: function() {
				return this._shadowsDensity
			},
			set: function(e) {
				this._shadowsDensity = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "ShadowsSaturation", {
			get: function() {
				return this._shadowsSaturation
			},
			set: function(e) {
				this._shadowsSaturation = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(t.prototype, "ShadowsExposure", {
			get: function() {
				return this._shadowsExposure
			},
			set: function(e) {
				this._shadowsExposure = e, this._dirty = !0
			},
			enumerable: !0,
			configurable: !0
		}), t.Bind = function(e, t) {
			e._dirty && (e._dirty = !1, e.getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e.getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e.getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e.getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t.setFloat4("vCameraColorCurvePositive", e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4("vCameraColorCurveNeutral", e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4("vCameraColorCurveNegative", e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a)
		}, t.PrepareUniforms = function(e) {
			e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative")
		}, t.prototype.getColorGradingDataToRef = function(e, i, r, n, o) {
			null != e && (e = t.clamp(e, 0, 360), i = t.clamp(i, -100, 100), r = t.clamp(r, -100, 100), n = t.clamp(n, -100, 100), i = t.applyColorGradingSliderNonlinear(i), i *= .5, n = t.applyColorGradingSliderNonlinear(n), i < 0 && (i *= -1, e = (e + 180) % 360), t.fromHSBToRef(e, i, 50 + .25 * n, o), o.scaleToRef(2, o), o.a = 1 + .01 * r)
		}, t.applyColorGradingSliderNonlinear = function(e) {
			e /= 100;
			var t = Math.abs(e);
			return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100
		}, t.fromHSBToRef = function(e, i, r, n) {
			var o = t.clamp(e, 0, 360),
				s = t.clamp(i / 100, 0, 1),
				a = t.clamp(r / 100, 0, 1);
			if (0 === s) n.r = a, n.g = a, n.b = a;
			else {
				o /= 60;
				var h = Math.floor(o),
					c = o - h,
					l = a * (1 - s),
					u = a * (1 - s * c),
					d = a * (1 - s * (1 - c));
				switch (h) {
					case 0:
						n.r = a, n.g = d, n.b = l;
						break;
					case 1:
						n.r = u, n.g = a, n.b = l;
						break;
					case 2:
						n.r = l, n.g = a, n.b = d;
						break;
					case 3:
						n.r = l, n.g = u, n.b = a;
						break;
					case 4:
						n.r = d, n.g = l, n.b = a;
						break;
					default:
						n.r = a, n.g = l, n.b = u
				}
			}
			n.a = 1
		}, t.clamp = function(e, t, i) {
			return Math.min(Math.max(e, t), i)
		}, t.prototype.clone = function() {
			return e.SerializationHelper.Clone((function() {
				return new t
			}), this)
		}, t.prototype.serialize = function() {
			return e.SerializationHelper.Serialize(this)
		}, t.Parse = function(i) {
			return e.SerializationHelper.Parse((function() {
				return new t
			}), i, null, null)
		}, __decorate([e.serialize()], t.prototype, "_globalHue", void 0), __decorate([e.serialize()], t.prototype, "_globalDensity", void 0), __decorate([e.serialize()], t.prototype, "_globalSaturation", void 0), __decorate([e.serialize()], t.prototype, "_globalExposure", void 0), __decorate([e.serialize()], t.prototype, "_highlightsHue", void 0), __decorate([e.serialize()], t.prototype, "_highlightsDensity", void 0), __decorate([e.serialize()], t.prototype, "_highlightsSaturation", void 0), __decorate([e.serialize()], t.prototype, "_highlightsExposure", void 0), __decorate([e.serialize()], t.prototype, "_midtonesHue", void 0), __decorate([e.serialize()], t.prototype, "_midtonesDensity", void 0), __decorate([e.serialize()], t.prototype, "_midtonesSaturation", void 0), __decorate([e.serialize()], t.prototype, "_midtonesExposure", void 0), t
	})();
	e.ColorCurves = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(e) {
			function t() {
				e.call(this), this.ALBEDO = !1, this.AMBIENT = !1, this.OPACITY = !1, this.OPACITYRGB = !1, this.REFLECTION = !1, this.EMISSIVE = !1, this.REFLECTIVITY = !1, this.BUMP = !1, this.PARALLAX = !1, this.PARALLAXOCCLUSION = !1, this.SPECULAROVERALPHA = !1, this.CLIPPLANE = !1, this.ALPHATEST = !1, this.ALPHAFROMALBEDO = !1, this.POINTSIZE = !1, this.FOG = !1, this.SPECULARTERM = !1, this.OPACITYFRESNEL = !1, this.EMISSIVEFRESNEL = !1, this.FRESNEL = !1, this.NORMAL = !1, this.UV1 = !1, this.UV2 = !1, this.VERTEXCOLOR = !1, this.VERTEXALPHA = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.INSTANCES = !1, this.MICROSURFACEFROMREFLECTIVITYMAP = !1, this.MICROSURFACEAUTOMATIC = !1, this.EMISSIVEASILLUMINATION = !1, this.LINKEMISSIVEWITHALBEDO = !1, this.LIGHTMAP = !1, this.USELIGHTMAPASSHADOWMAP = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.INVERTCUBICMAP = !1, this.LOGARITHMICDEPTH = !1, this.CAMERATONEMAP = !1, this.CAMERACONTRAST = !1, this.CAMERACOLORGRADING = !1, this.CAMERACOLORCURVES = !1, this.OVERLOADEDVALUES = !1, this.OVERLOADEDSHADOWVALUES = !1, this.USESPHERICALFROMREFLECTIONMAP = !1, this.REFRACTION = !1, this.REFRACTIONMAP_3D = !1, this.LINKREFRACTIONTOTRANSPARENCY = !1, this.REFRACTIONMAPINLINEARSPACE = !1, this.LODBASEDMICROSFURACE = !1, this.USEPHYSICALLIGHTFALLOFF = !1, this.RADIANCEOVERALPHA = !1, this.USEPMREMREFLECTION = !1, this.USEPMREMREFRACTION = !1, this.OPENGLNORMALMAP = !1, this.INVERTNORMALMAPX = !1, this.INVERTNORMALMAPY = !1, this.SHADOWFULLFLOAT = !1, this.METALLICWORKFLOW = !1, this.METALLICROUGHNESSGSTOREINALPHA = !1, this.METALLICROUGHNESSGSTOREINGREEN = !1, this.rebuild()
			}
			return __extends(t, e), t
		})(e.MaterialDefines),
		i = (function(i) {
			function r(r, n) {
				var o = this;
				i.call(this, r, n), this.directIntensity = 1, this.emissiveIntensity = 1, this.environmentIntensity = 1, this.specularIntensity = 1, this._lightingInfos = new e.Vector4(this.directIntensity, this.emissiveIntensity, this.environmentIntensity, this.specularIntensity), this.disableBumpMap = !1, this.overloadedShadowIntensity = 1, this.overloadedShadeIntensity = 1, this._overloadedShadowInfos = new e.Vector4(this.overloadedShadowIntensity, this.overloadedShadeIntensity, 0, 0), this.cameraExposure = 1, this.cameraContrast = 1, this.cameraColorGradingTexture = null, this.cameraColorCurves = null, this._cameraInfos = new e.Vector4(1, 1, 0, 0), this._microsurfaceTextureLods = new e.Vector2(0, 0), this.overloadedAmbient = e.Color3.White(), this.overloadedAmbientIntensity = 0, this.overloadedAlbedo = e.Color3.White(), this.overloadedAlbedoIntensity = 0, this.overloadedReflectivity = new e.Color3(.3, .3, .3), this.overloadedReflectivityIntensity = 0, this.overloadedEmissive = e.Color3.White(), this.overloadedEmissiveIntensity = 0, this._overloadedIntensity = new e.Vector4(this.overloadedAmbientIntensity, this.overloadedAlbedoIntensity, this.overloadedReflectivityIntensity, this.overloadedEmissiveIntensity), this.overloadedReflection = e.Color3.White(), this.overloadedReflectionIntensity = 0, this.overloadedMicroSurface = 0, this.overloadedMicroSurfaceIntensity = 0, this._overloadedMicroSurface = new e.Vector3(this.overloadedMicroSurface, this.overloadedMicroSurfaceIntensity, this.overloadedReflectionIntensity), this.ambientTextureStrength = 1, this.ambientColor = new e.Color3(0, 0, 0), this.albedoColor = new e.Color3(1, 1, 1), this.reflectivityColor = new e.Color3(1, 1, 1), this.reflectionColor = new e.Color3(.5, .5, .5), this.emissiveColor = new e.Color3(0, 0, 0), this.microSurface = .9, this.indexOfRefraction = .66, this.invertRefractionY = !1, this.linkRefractionWithTransparency = !1, this.linkEmissiveWithAlbedo = !1, this.useLightmapAsShadowmap = !1, this.useEmissiveAsIllumination = !1, this.useAlphaFromAlbedoTexture = !1, this.useSpecularOverAlpha = !0, this.useMicroSurfaceFromReflectivityMapAlpha = !1, this.useRoughnessFromMetallicTextureAlpha = !0, this.useRoughnessFromMetallicTextureGreen = !1, this.useAutoMicroSurfaceFromReflectivityMap = !1, this.useScalarInLinearSpace = !1, this.usePhysicalLightFalloff = !0, this.useRadianceOverAlpha = !0, this.useParallax = !1, this.useParallaxOcclusion = !1, this.parallaxScaleBias = .05, this.disableLighting = !1, this.maxSimultaneousLights = 4, this.invertNormalMapX = !1, this.invertNormalMapY = !1, this._renderTargets = new e.SmartArray(16), this._worldViewProjectionMatrix = e.Matrix.Zero(), this._globalAmbientColor = new e.Color3(0, 0, 0), this._tempColor = new e.Color3, this._defines = new t, this._cachedDefines = new t, this._myScene = null, this._myShadowGenerator = null, this._cachedDefines.BonesPerMesh = -1, this.getRenderTargetTextures = function() {
					return o._renderTargets.reset(), o.reflectionTexture && o.reflectionTexture.isRenderTarget && o._renderTargets.push(o.reflectionTexture), o.refractionTexture && o.refractionTexture.isRenderTarget && o._renderTargets.push(o.refractionTexture), o._renderTargets
				}
			}
			return __extends(r, i), Object.defineProperty(r.prototype, "useLogarithmicDepth", {
				get: function() {
					return this._useLogarithmicDepth
				},
				set: function(e) {
					this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported
				},
				enumerable: !0,
				configurable: !0
			}), r.prototype.needAlphaBlending = function() {
				return !this.linkRefractionWithTransparency && (this.alpha < 1 || null != this.opacityTexture || this._shouldUseAlphaFromAlbedoTexture() || this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled)
			}, r.prototype.needAlphaTesting = function() {
				return !this.linkRefractionWithTransparency && (null != this.albedoTexture && this.albedoTexture.hasAlpha)
			}, r.prototype._shouldUseAlphaFromAlbedoTexture = function() {
				return null != this.albedoTexture && this.albedoTexture.hasAlpha && this.useAlphaFromAlbedoTexture
			}, r.prototype.getAlphaTestTexture = function() {
				return this.albedoTexture
			}, r.prototype._checkCache = function(e, t, i) {
				return !t || this._defines.INSTANCES === i && !(!t._materialDefines || !t._materialDefines.isEqual(this._defines))
			}, r.prototype.convertColorToLinearSpaceToRef = function(e, t) {
				r.convertColorToLinearSpaceToRef(e, t, this.useScalarInLinearSpace)
			}, r.convertColorToLinearSpaceToRef = function(e, t, i) {
				i ? (t.r = e.r, t.g = e.g, t.b = e.b) : e.toLinearSpaceToRef(t)
			}, r.BindLights = function(t, i, n, o, s, a, h) {
				for (var c = 0, l = !1, u = 0; u < t.lights.length; u++) {
					var d = t.lights[u];
					if (d.isEnabled() && d.canAffectMesh(i) && (e.MaterialHelper.BindLightProperties(d, n, c), this.convertColorToLinearSpaceToRef(d.diffuse, r._scaledAlbedo, s), r._scaledAlbedo.scaleToRef(d.intensity, r._scaledAlbedo), n.setColor4("vLightDiffuse" + c, r._scaledAlbedo, h ? d.radius : d.range), o.SPECULARTERM && (this.convertColorToLinearSpaceToRef(d.specular, r._scaledReflectivity, s), r._scaledReflectivity.scaleToRef(d.intensity, r._scaledReflectivity), n.setColor3("vLightSpecular" + c, r._scaledReflectivity)), t.shadowsEnabled && (l = e.MaterialHelper.BindLightShadow(d, t, i, c, n, l)), c++, c === a)) break
				}
			}, r.prototype.isReady = function(i, r) {
				if (this.checkReadyOnlyOnce && this._wasPreviouslyReady) return !0;
				var n = this.getScene(),
					o = n.getEngine(),
					s = !1,
					a = !1;
				if (this._defines.reset(), n.lightsEnabled && !this.disableLighting && (s = e.MaterialHelper.PrepareDefinesForLights(n, i, this._defines, this.maxSimultaneousLights) || s), !this.checkReadyOnEveryCall && this._renderId === n.getRenderId() && this._checkCache(n, i, r)) return !0;
				if (n.texturesEnabled) {
					if (n.getEngine().getCaps().textureLOD && (this._defines.LODBASEDMICROSFURACE = !0), this.albedoTexture && e.StandardMaterial.DiffuseTextureEnabled) {
						if (!this.albedoTexture.isReady()) return !1;
						a = !0, this._defines.ALBEDO = !0
					}
					if (this.ambientTexture && e.StandardMaterial.AmbientTextureEnabled) {
						if (!this.ambientTexture.isReady()) return !1;
						a = !0, this._defines.AMBIENT = !0
					}
					if (this.opacityTexture && e.StandardMaterial.OpacityTextureEnabled) {
						if (!this.opacityTexture.isReady()) return !1;
						a = !0, this._defines.OPACITY = !0, this.opacityTexture.getAlphaFromRGB && (this._defines.OPACITYRGB = !0)
					}
					if (this.reflectionTexture && e.StandardMaterial.ReflectionTextureEnabled) {
						if (!this.reflectionTexture.isReady()) return !1;
						switch (s = !0, this._defines.REFLECTION = !0, this.reflectionTexture.coordinatesMode === e.Texture.INVCUBIC_MODE && (this._defines.INVERTCUBICMAP = !0), this._defines.REFLECTIONMAP_3D = this.reflectionTexture.isCube, this.reflectionTexture.coordinatesMode) {
							case e.Texture.CUBIC_MODE:
							case e.Texture.INVCUBIC_MODE:
								this._defines.REFLECTIONMAP_CUBIC = !0;
								break;
							case e.Texture.EXPLICIT_MODE:
								this._defines.REFLECTIONMAP_EXPLICIT = !0;
								break;
							case e.Texture.PLANAR_MODE:
								this._defines.REFLECTIONMAP_PLANAR = !0;
								break;
							case e.Texture.PROJECTION_MODE:
								this._defines.REFLECTIONMAP_PROJECTION = !0;
								break;
							case e.Texture.SKYBOX_MODE:
								this._defines.REFLECTIONMAP_SKYBOX = !0;
								break;
							case e.Texture.SPHERICAL_MODE:
								this._defines.REFLECTIONMAP_SPHERICAL = !0;
								break;
							case e.Texture.EQUIRECTANGULAR_MODE:
								this._defines.REFLECTIONMAP_EQUIRECTANGULAR = !0
						}
						this.reflectionTexture instanceof e.HDRCubeTexture && this.reflectionTexture && (this._defines.USESPHERICALFROMREFLECTIONMAP = !0, s = !0, this.reflectionTexture.isPMREM && (this._defines.USEPMREMREFLECTION = !0))
					}
					if (this.lightmapTexture && e.StandardMaterial.LightmapTextureEnabled) {
						if (!this.lightmapTexture.isReady()) return !1;
						a = !0, this._defines.LIGHTMAP = !0, this._defines.USELIGHTMAPASSHADOWMAP = this.useLightmapAsShadowmap
					}
					if (this.emissiveTexture && e.StandardMaterial.EmissiveTextureEnabled) {
						if (!this.emissiveTexture.isReady()) return !1;
						a = !0, this._defines.EMISSIVE = !0
					}
					if (e.StandardMaterial.SpecularTextureEnabled)
						if (this.metallicTexture) {
							if (!this.metallicTexture.isReady()) return !1;
							a = !0, this._defines.METALLICWORKFLOW = !0, this._defines.METALLICROUGHNESSGSTOREINALPHA = this.useRoughnessFromMetallicTextureAlpha, this._defines.METALLICROUGHNESSGSTOREINGREEN = !this.useRoughnessFromMetallicTextureAlpha && this.useRoughnessFromMetallicTextureGreen
						} else if (this.reflectivityTexture) {
						if (!this.reflectivityTexture.isReady()) return !1;
						a = !0, this._defines.REFLECTIVITY = !0, this._defines.MICROSURFACEFROMREFLECTIVITYMAP = this.useMicroSurfaceFromReflectivityMapAlpha, this._defines.MICROSURFACEAUTOMATIC = this.useAutoMicroSurfaceFromReflectivityMap
					}
					if (n.getEngine().getCaps().standardDerivatives && this.bumpTexture && e.StandardMaterial.BumpTextureEnabled && !this.disableBumpMap) {
						if (!this.bumpTexture.isReady()) return !1;
						a = !0, this._defines.BUMP = !0, this.useParallax && this.albedoTexture && e.StandardMaterial.DiffuseTextureEnabled && (this._defines.PARALLAX = !0, this.useParallaxOcclusion && (this._defines.PARALLAXOCCLUSION = !0)), this.invertNormalMapX && (this._defines.INVERTNORMALMAPX = !0), this.invertNormalMapY && (this._defines.INVERTNORMALMAPY = !0)
					}
					if (this.refractionTexture && e.StandardMaterial.RefractionTextureEnabled) {
						if (!this.refractionTexture.isReady()) return !1;
						a = !0, this._defines.REFRACTION = !0, this._defines.REFRACTIONMAP_3D = this.refractionTexture.isCube, this.linkRefractionWithTransparency && (this._defines.LINKREFRACTIONTOTRANSPARENCY = !0), this.refractionTexture instanceof e.HDRCubeTexture && (this._defines.REFRACTIONMAPINLINEARSPACE = !0, this.refractionTexture.isPMREM && (this._defines.USEPMREMREFRACTION = !0))
					}
					if (this.cameraColorGradingTexture && e.StandardMaterial.ColorGradingTextureEnabled) {
						if (!this.cameraColorGradingTexture.isReady()) return !1;
						this._defines.CAMERACOLORGRADING = !0
					}
				}
				if (n.clipPlane && (this._defines.CLIPPLANE = !0), o.getAlphaTesting() && (this._defines.ALPHATEST = !0), this._shouldUseAlphaFromAlbedoTexture() && (this._defines.ALPHAFROMALBEDO = !0), this.useEmissiveAsIllumination && (this._defines.EMISSIVEASILLUMINATION = !0), this.linkEmissiveWithAlbedo && (this._defines.LINKEMISSIVEWITHALBEDO = !0), this.useLogarithmicDepth && (this._defines.LOGARITHMICDEPTH = !0), 1 != this.cameraContrast && (this._defines.CAMERACONTRAST = !0), 1 != this.cameraExposure && (this._defines.CAMERATONEMAP = !0), this.cameraColorCurves && (this._defines.CAMERACOLORCURVES = !0), 1 == this.overloadedShadeIntensity && 1 == this.overloadedShadowIntensity || (this._defines.OVERLOADEDSHADOWVALUES = !0), (this.overloadedMicroSurfaceIntensity > 0 || this.overloadedEmissiveIntensity > 0 || this.overloadedReflectivityIntensity > 0 || this.overloadedAlbedoIntensity > 0 || this.overloadedAmbientIntensity > 0 || this.overloadedReflectionIntensity > 0) && (this._defines.OVERLOADEDVALUES = !0), (this.pointsCloud || n.forcePointsCloud) && (this._defines.POINTSIZE = !0), n.fogEnabled && i && i.applyFog && n.fogMode !== e.Scene.FOGMODE_NONE && this.fogEnabled && (this._defines.FOG = !0), e.StandardMaterial.FresnelEnabled && (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled || this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) && (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && (this._defines.OPACITYFRESNEL = !0), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (this._defines.EMISSIVEFRESNEL = !0), s = !0, this._defines.FRESNEL = !0), this._defines.SPECULARTERM && this.useSpecularOverAlpha && (this._defines.SPECULAROVERALPHA = !0), this.usePhysicalLightFalloff && (this._defines.USEPHYSICALLIGHTFALLOFF = !0), this.useRadianceOverAlpha && (this._defines.RADIANCEOVERALPHA = !0), i && (s && i.isVerticesDataPresent(e.VertexBuffer.NormalKind) && (this._defines.NORMAL = !0), a && (i.isVerticesDataPresent(e.VertexBuffer.UVKind) && (this._defines.UV1 = !0), i.isVerticesDataPresent(e.VertexBuffer.UV2Kind) && (this._defines.UV2 = !0)), i.useVertexColors && i.isVerticesDataPresent(e.VertexBuffer.ColorKind) && (this._defines.VERTEXCOLOR = !0, i.hasVertexAlpha && (this._defines.VERTEXALPHA = !0)), i.useBones && i.computeBonesUsingShaders && (this._defines.NUM_BONE_INFLUENCERS = i.numBoneInfluencers, this._defines.BonesPerMesh = i.skeleton.bones.length + 1), r && (this._defines.INSTANCES = !0)), !this._defines.isEqual(this._cachedDefines)) {
					this._defines.cloneTo(this._cachedDefines), n.resetCachedMaterial();
					var h = new e.EffectFallbacks;
					this._defines.REFLECTION && h.addFallback(0, "REFLECTION"), this._defines.REFRACTION && h.addFallback(0, "REFRACTION"), this._defines.REFLECTIVITY && h.addFallback(0, "REFLECTIVITY"), this._defines.BUMP && h.addFallback(0, "BUMP"), this._defines.PARALLAX && h.addFallback(1, "PARALLAX"), this._defines.PARALLAXOCCLUSION && h.addFallback(0, "PARALLAXOCCLUSION"), this._defines.SPECULAROVERALPHA && h.addFallback(0, "SPECULAROVERALPHA"), this._defines.FOG && h.addFallback(1, "FOG"), this._defines.POINTSIZE && h.addFallback(0, "POINTSIZE"), this._defines.LOGARITHMICDEPTH && h.addFallback(0, "LOGARITHMICDEPTH"), e.MaterialHelper.HandleFallbacksForShadows(this._defines, h, this.maxSimultaneousLights), this._defines.SPECULARTERM && h.addFallback(0, "SPECULARTERM"), this._defines.OPACITYFRESNEL && h.addFallback(1, "OPACITYFRESNEL"), this._defines.EMISSIVEFRESNEL && h.addFallback(2, "EMISSIVEFRESNEL"), this._defines.FRESNEL && h.addFallback(3, "FRESNEL"), this._defines.NUM_BONE_INFLUENCERS > 0 && h.addCPUSkinningFallback(0, i);
					var c = [e.VertexBuffer.PositionKind];
					this._defines.NORMAL && c.push(e.VertexBuffer.NormalKind), this._defines.UV1 && c.push(e.VertexBuffer.UVKind), this._defines.UV2 && c.push(e.VertexBuffer.UV2Kind), this._defines.VERTEXCOLOR && c.push(e.VertexBuffer.ColorKind), e.MaterialHelper.PrepareAttributesForBones(c, i, this._defines, h), e.MaterialHelper.PrepareAttributesForInstances(c, this._defines);
					var l = this._defines.toString(),
						u = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vAlbedoColor", "vReflectivityColor", "vEmissiveColor", "vReflectionColor", "vFogInfos", "vFogColor", "pointSize", "vAlbedoInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vEmissiveInfos", "vReflectivityInfos", "vBumpInfos", "vLightmapInfos", "vRefractionInfos", "mBones", "vClipPlane", "albedoMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "reflectivityMatrix", "bumpMatrix", "lightmapMatrix", "refractionMatrix", "depthValues", "opacityParts", "emissiveLeftColor", "emissiveRightColor", "vLightingIntensity", "vOverloadedShadowIntensity", "vOverloadedIntensity", "vOverloadedAlbedo", "vOverloadedReflection", "vOverloadedReflectivity", "vOverloadedEmissive", "vOverloadedMicroSurface", "logarithmicDepthConstant", "vSphericalX", "vSphericalY", "vSphericalZ", "vSphericalXX", "vSphericalYY", "vSphericalZZ", "vSphericalXY", "vSphericalYZ", "vSphericalZX", "vMicrosurfaceTextureLods", "vCameraInfos"],
						d = ["albedoSampler", "ambientSampler", "opacitySampler", "reflectionCubeSampler", "reflection2DSampler", "emissiveSampler", "reflectivitySampler", "bumpSampler", "lightmapSampler", "refractionCubeSampler", "refraction2DSampler"];
					e.ColorCurves.PrepareUniforms(u), e.ColorGradingTexture.PrepareUniformsAndSamplers(u, d), e.MaterialHelper.PrepareUniformsAndSamplersList(u, d, this._defines, this.maxSimultaneousLights), this._effect = n.getEngine().createEffect("pbr", c, u, d, l, h, this.onCompiled, this.onError, {
						maxSimultaneousLights: this.maxSimultaneousLights
					})
				}
				return !!this._effect.isReady() && (this._renderId = n.getRenderId(), this._wasPreviouslyReady = !0, i && (i._materialDefines || (i._materialDefines = new t), this._defines.cloneTo(i._materialDefines)), !0)
			}, r.prototype.unbind = function() {
				this.reflectionTexture && this.reflectionTexture.isRenderTarget && this._effect.setTexture("reflection2DSampler", null), this.refractionTexture && this.refractionTexture.isRenderTarget && this._effect.setTexture("refraction2DSampler", null), i.prototype.unbind.call(this)
			}, r.prototype.bindOnlyWorldMatrix = function(e) {
				this._effect.setMatrix("world", e)
			}, r.prototype.bind = function(t, n) {
				if (this._myScene = this.getScene(), this.bindOnlyWorldMatrix(t), e.MaterialHelper.BindBonesParameters(n, this._effect), this._myScene.getCachedMaterial() !== this) {
					if (this._effect.setMatrix("viewProjection", this._myScene.getTransformMatrix()), e.StandardMaterial.FresnelEnabled && (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && this._effect.setColor4("opacityParts", new e.Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (this._effect.setColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), this._effect.setColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), this._myScene.texturesEnabled) {
						if (this.albedoTexture && e.StandardMaterial.DiffuseTextureEnabled && (this._effect.setTexture("albedoSampler", this.albedoTexture), this._effect.setFloat2("vAlbedoInfos", this.albedoTexture.coordinatesIndex, this.albedoTexture.level),
								this._effect.setMatrix("albedoMatrix", this.albedoTexture.getTextureMatrix())), this.ambientTexture && e.StandardMaterial.AmbientTextureEnabled && (this._effect.setTexture("ambientSampler", this.ambientTexture), this._effect.setFloat3("vAmbientInfos", this.ambientTexture.coordinatesIndex, this.ambientTexture.level, this.ambientTextureStrength), this._effect.setMatrix("ambientMatrix", this.ambientTexture.getTextureMatrix())), this.opacityTexture && e.StandardMaterial.OpacityTextureEnabled && (this._effect.setTexture("opacitySampler", this.opacityTexture), this._effect.setFloat2("vOpacityInfos", this.opacityTexture.coordinatesIndex, this.opacityTexture.level), this._effect.setMatrix("opacityMatrix", this.opacityTexture.getTextureMatrix())), this.reflectionTexture && e.StandardMaterial.ReflectionTextureEnabled && (this._microsurfaceTextureLods.x = Math.round(Math.log(this.reflectionTexture.getSize().width) * Math.LOG2E), this.reflectionTexture.isCube ? this._effect.setTexture("reflectionCubeSampler", this.reflectionTexture) : this._effect.setTexture("reflection2DSampler", this.reflectionTexture), this._effect.setMatrix("reflectionMatrix", this.reflectionTexture.getReflectionTextureMatrix()), this._effect.setFloat2("vReflectionInfos", this.reflectionTexture.level, 0), this._defines.USESPHERICALFROMREFLECTIONMAP && (this._effect.setFloat3("vSphericalX", this.reflectionTexture.sphericalPolynomial.x.x, this.reflectionTexture.sphericalPolynomial.x.y, this.reflectionTexture.sphericalPolynomial.x.z), this._effect.setFloat3("vSphericalY", this.reflectionTexture.sphericalPolynomial.y.x, this.reflectionTexture.sphericalPolynomial.y.y, this.reflectionTexture.sphericalPolynomial.y.z), this._effect.setFloat3("vSphericalZ", this.reflectionTexture.sphericalPolynomial.z.x, this.reflectionTexture.sphericalPolynomial.z.y, this.reflectionTexture.sphericalPolynomial.z.z), this._effect.setFloat3("vSphericalXX", this.reflectionTexture.sphericalPolynomial.xx.x, this.reflectionTexture.sphericalPolynomial.xx.y, this.reflectionTexture.sphericalPolynomial.xx.z), this._effect.setFloat3("vSphericalYY", this.reflectionTexture.sphericalPolynomial.yy.x, this.reflectionTexture.sphericalPolynomial.yy.y, this.reflectionTexture.sphericalPolynomial.yy.z), this._effect.setFloat3("vSphericalZZ", this.reflectionTexture.sphericalPolynomial.zz.x, this.reflectionTexture.sphericalPolynomial.zz.y, this.reflectionTexture.sphericalPolynomial.zz.z), this._effect.setFloat3("vSphericalXY", this.reflectionTexture.sphericalPolynomial.xy.x, this.reflectionTexture.sphericalPolynomial.xy.y, this.reflectionTexture.sphericalPolynomial.xy.z), this._effect.setFloat3("vSphericalYZ", this.reflectionTexture.sphericalPolynomial.yz.x, this.reflectionTexture.sphericalPolynomial.yz.y, this.reflectionTexture.sphericalPolynomial.yz.z), this._effect.setFloat3("vSphericalZX", this.reflectionTexture.sphericalPolynomial.zx.x, this.reflectionTexture.sphericalPolynomial.zx.y, this.reflectionTexture.sphericalPolynomial.zx.z))), this.emissiveTexture && e.StandardMaterial.EmissiveTextureEnabled && (this._effect.setTexture("emissiveSampler", this.emissiveTexture), this._effect.setFloat2("vEmissiveInfos", this.emissiveTexture.coordinatesIndex, this.emissiveTexture.level), this._effect.setMatrix("emissiveMatrix", this.emissiveTexture.getTextureMatrix())), this.lightmapTexture && e.StandardMaterial.LightmapTextureEnabled && (this._effect.setTexture("lightmapSampler", this.lightmapTexture), this._effect.setFloat2("vLightmapInfos", this.lightmapTexture.coordinatesIndex, this.lightmapTexture.level), this._effect.setMatrix("lightmapMatrix", this.lightmapTexture.getTextureMatrix())), e.StandardMaterial.SpecularTextureEnabled && (this.metallicTexture ? (this._effect.setTexture("reflectivitySampler", this.metallicTexture), this._effect.setFloat2("vReflectivityInfos", this.metallicTexture.coordinatesIndex, this.metallicTexture.level), this._effect.setMatrix("reflectivityMatrix", this.metallicTexture.getTextureMatrix())) : this.reflectivityTexture && (this._effect.setTexture("reflectivitySampler", this.reflectivityTexture), this._effect.setFloat2("vReflectivityInfos", this.reflectivityTexture.coordinatesIndex, this.reflectivityTexture.level), this._effect.setMatrix("reflectivityMatrix", this.reflectivityTexture.getTextureMatrix()))), this.bumpTexture && this._myScene.getEngine().getCaps().standardDerivatives && e.StandardMaterial.BumpTextureEnabled && !this.disableBumpMap && (this._effect.setTexture("bumpSampler", this.bumpTexture), this._effect.setFloat3("vBumpInfos", this.bumpTexture.coordinatesIndex, 1 / this.bumpTexture.level, this.parallaxScaleBias), this._effect.setMatrix("bumpMatrix", this.bumpTexture.getTextureMatrix())), this.refractionTexture && e.StandardMaterial.RefractionTextureEnabled) {
							this._microsurfaceTextureLods.y = Math.round(Math.log(this.refractionTexture.getSize().width) * Math.LOG2E);
							var o = 1;
							this.refractionTexture.isCube ? this._effect.setTexture("refractionCubeSampler", this.refractionTexture) : (this._effect.setTexture("refraction2DSampler", this.refractionTexture), this._effect.setMatrix("refractionMatrix", this.refractionTexture.getReflectionTextureMatrix()), this.refractionTexture.depth && (o = this.refractionTexture.depth)), this._effect.setFloat4("vRefractionInfos", this.refractionTexture.level, this.indexOfRefraction, o, this.invertRefractionY ? -1 : 1)
						}(this.reflectionTexture || this.refractionTexture) && this._effect.setFloat2("vMicrosurfaceTextureLods", this._microsurfaceTextureLods.x, this._microsurfaceTextureLods.y), this.cameraColorGradingTexture && e.StandardMaterial.ColorGradingTextureEnabled && e.ColorGradingTexture.Bind(this.cameraColorGradingTexture, this._effect)
					}
					e.MaterialHelper.BindClipPlane(this._effect, this._myScene), this.pointsCloud && this._effect.setFloat("pointSize", this.pointSize), this._myScene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), this.convertColorToLinearSpaceToRef(this.reflectivityColor, r._scaledReflectivity), this._effect.setVector3("vEyePosition", this._myScene._mirroredCameraPosition ? this._myScene._mirroredCameraPosition : this._myScene.activeCamera.position), this._effect.setColor3("vAmbientColor", this._globalAmbientColor), this._effect.setColor4("vReflectivityColor", r._scaledReflectivity, this.microSurface), this.convertColorToLinearSpaceToRef(this.emissiveColor, r._scaledEmissive), this._effect.setColor3("vEmissiveColor", r._scaledEmissive), this.convertColorToLinearSpaceToRef(this.reflectionColor, r._scaledReflection), this._effect.setColor3("vReflectionColor", r._scaledReflection)
				}
				this._myScene.getCachedMaterial() === this && this.isFrozen || (this.convertColorToLinearSpaceToRef(this.albedoColor, r._scaledAlbedo), this._effect.setColor4("vAlbedoColor", r._scaledAlbedo, this.alpha * n.visibility), this._myScene.lightsEnabled && !this.disableLighting && r.BindLights(this._myScene, n, this._effect, this._defines, this.useScalarInLinearSpace, this.maxSimultaneousLights, this.usePhysicalLightFalloff), (this._myScene.fogEnabled && n.applyFog && this._myScene.fogMode !== e.Scene.FOGMODE_NONE || this.reflectionTexture) && this._effect.setMatrix("view", this._myScene.getViewMatrix()), e.MaterialHelper.BindFogParameters(this._myScene, n, this._effect), this._lightingInfos.x = this.directIntensity, this._lightingInfos.y = this.emissiveIntensity, this._lightingInfos.z = this.environmentIntensity, this._lightingInfos.w = this.specularIntensity, this._effect.setVector4("vLightingIntensity", this._lightingInfos), this._overloadedShadowInfos.x = this.overloadedShadowIntensity, this._overloadedShadowInfos.y = this.overloadedShadeIntensity, this._effect.setVector4("vOverloadedShadowIntensity", this._overloadedShadowInfos), this._cameraInfos.x = this.cameraExposure, this._cameraInfos.y = this.cameraContrast, this._effect.setVector4("vCameraInfos", this._cameraInfos), this.cameraColorCurves && e.ColorCurves.Bind(this.cameraColorCurves, this._effect), this._overloadedIntensity.x = this.overloadedAmbientIntensity, this._overloadedIntensity.y = this.overloadedAlbedoIntensity, this._overloadedIntensity.z = this.overloadedReflectivityIntensity, this._overloadedIntensity.w = this.overloadedEmissiveIntensity, this._effect.setVector4("vOverloadedIntensity", this._overloadedIntensity), this.convertColorToLinearSpaceToRef(this.overloadedAmbient, this._tempColor), this._effect.setColor3("vOverloadedAmbient", this._tempColor), this.convertColorToLinearSpaceToRef(this.overloadedAlbedo, this._tempColor), this._effect.setColor3("vOverloadedAlbedo", this._tempColor), this.convertColorToLinearSpaceToRef(this.overloadedReflectivity, this._tempColor), this._effect.setColor3("vOverloadedReflectivity", this._tempColor), this.convertColorToLinearSpaceToRef(this.overloadedEmissive, this._tempColor), this._effect.setColor3("vOverloadedEmissive", this._tempColor), this.convertColorToLinearSpaceToRef(this.overloadedReflection, this._tempColor), this._effect.setColor3("vOverloadedReflection", this._tempColor), this._overloadedMicroSurface.x = this.overloadedMicroSurface, this._overloadedMicroSurface.y = this.overloadedMicroSurfaceIntensity, this._overloadedMicroSurface.z = this.overloadedReflectionIntensity, this._effect.setVector3("vOverloadedMicroSurface", this._overloadedMicroSurface), e.MaterialHelper.BindLogDepth(this._defines, this._effect, this._myScene)), i.prototype.bind.call(this, t, n), this._myScene = null
			}, r.prototype.getAnimatables = function() {
				var e = [];
				return this.albedoTexture && this.albedoTexture.animations && this.albedoTexture.animations.length > 0 && e.push(this.albedoTexture), this.ambientTexture && this.ambientTexture.animations && this.ambientTexture.animations.length > 0 && e.push(this.ambientTexture), this.opacityTexture && this.opacityTexture.animations && this.opacityTexture.animations.length > 0 && e.push(this.opacityTexture), this.reflectionTexture && this.reflectionTexture.animations && this.reflectionTexture.animations.length > 0 && e.push(this.reflectionTexture), this.emissiveTexture && this.emissiveTexture.animations && this.emissiveTexture.animations.length > 0 && e.push(this.emissiveTexture), this.metallicTexture && this.metallicTexture.animations && this.metallicTexture.animations.length > 0 ? e.push(this.metallicTexture) : this.reflectivityTexture && this.reflectivityTexture.animations && this.reflectivityTexture.animations.length > 0 && e.push(this.reflectivityTexture), this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0 && e.push(this.bumpTexture), this.lightmapTexture && this.lightmapTexture.animations && this.lightmapTexture.animations.length > 0 && e.push(this.lightmapTexture), this.refractionTexture && this.refractionTexture.animations && this.refractionTexture.animations.length > 0 && e.push(this.refractionTexture), this.cameraColorGradingTexture && this.cameraColorGradingTexture.animations && this.cameraColorGradingTexture.animations.length > 0 && e.push(this.cameraColorGradingTexture), e
			}, r.prototype.dispose = function(e, t) {
				t && (this.albedoTexture && this.albedoTexture.dispose(), this.ambientTexture && this.ambientTexture.dispose(), this.opacityTexture && this.opacityTexture.dispose(), this.reflectionTexture && this.reflectionTexture.dispose(), this.emissiveTexture && this.emissiveTexture.dispose(), this.metallicTexture && this.metallicTexture.dispose(), this.reflectivityTexture && this.reflectivityTexture.dispose(), this.bumpTexture && this.bumpTexture.dispose(), this.lightmapTexture && this.lightmapTexture.dispose(), this.refractionTexture && this.refractionTexture.dispose(), this.cameraColorGradingTexture && this.cameraColorGradingTexture.dispose()), i.prototype.dispose.call(this, e, t)
			}, r.prototype.clone = function(t) {
				var i = this;
				return e.SerializationHelper.Clone((function() {
					return new r(t, i.getScene())
				}), this)
			}, r.prototype.serialize = function() {
				var t = e.SerializationHelper.Serialize(this);
				return t.customType = "BABYLON.PBRMaterial", t
			}, r.Parse = function(t, i, n) {
				return e.SerializationHelper.Parse((function() {
					return new r(t.name, i)
				}), t, i, n)
			}, r._scaledAlbedo = new e.Color3, r._scaledReflectivity = new e.Color3, r._scaledEmissive = new e.Color3, r._scaledReflection = new e.Color3, __decorate([e.serialize()], r.prototype, "directIntensity", void 0), __decorate([e.serialize()], r.prototype, "emissiveIntensity", void 0), __decorate([e.serialize()], r.prototype, "environmentIntensity", void 0), __decorate([e.serialize()], r.prototype, "specularIntensity", void 0), __decorate([e.serialize()], r.prototype, "disableBumpMap", void 0), __decorate([e.serialize()], r.prototype, "overloadedShadowIntensity", void 0), __decorate([e.serialize()], r.prototype, "overloadedShadeIntensity", void 0), __decorate([e.serialize()], r.prototype, "cameraExposure", void 0), __decorate([e.serialize()], r.prototype, "cameraContrast", void 0), __decorate([e.serializeAsTexture()], r.prototype, "cameraColorGradingTexture", void 0), __decorate([e.serializeAsColorCurves()], r.prototype, "cameraColorCurves", void 0), __decorate([e.serializeAsColor3()], r.prototype, "overloadedAmbient", void 0), __decorate([e.serialize()], r.prototype, "overloadedAmbientIntensity", void 0), __decorate([e.serializeAsColor3()], r.prototype, "overloadedAlbedo", void 0), __decorate([e.serialize()], r.prototype, "overloadedAlbedoIntensity", void 0), __decorate([e.serializeAsColor3()], r.prototype, "overloadedReflectivity", void 0), __decorate([e.serialize()], r.prototype, "overloadedReflectivityIntensity", void 0), __decorate([e.serializeAsColor3()], r.prototype, "overloadedEmissive", void 0), __decorate([e.serialize()], r.prototype, "overloadedEmissiveIntensity", void 0), __decorate([e.serializeAsColor3()], r.prototype, "overloadedReflection", void 0), __decorate([e.serialize()], r.prototype, "overloadedReflectionIntensity", void 0), __decorate([e.serialize()], r.prototype, "overloadedMicroSurface", void 0), __decorate([e.serialize()], r.prototype, "overloadedMicroSurfaceIntensity", void 0), __decorate([e.serializeAsTexture()], r.prototype, "albedoTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "ambientTexture", void 0), __decorate([e.serialize()], r.prototype, "ambientTextureStrength", void 0), __decorate([e.serializeAsTexture()], r.prototype, "opacityTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "reflectionTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "emissiveTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "reflectivityTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "metallicTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "bumpTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "lightmapTexture", void 0), __decorate([e.serializeAsTexture()], r.prototype, "refractionTexture", void 0), __decorate([e.serializeAsColor3("ambient")], r.prototype, "ambientColor", void 0), __decorate([e.serializeAsColor3("albedo")], r.prototype, "albedoColor", void 0), __decorate([e.serializeAsColor3("reflectivity")], r.prototype, "reflectivityColor", void 0), __decorate([e.serializeAsColor3("reflection")], r.prototype, "reflectionColor", void 0), __decorate([e.serializeAsColor3("emissive")], r.prototype, "emissiveColor", void 0), __decorate([e.serialize()], r.prototype, "microSurface", void 0), __decorate([e.serialize()], r.prototype, "indexOfRefraction", void 0), __decorate([e.serialize()], r.prototype, "invertRefractionY", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "opacityFresnelParameters", void 0), __decorate([e.serializeAsFresnelParameters()], r.prototype, "emissiveFresnelParameters", void 0), __decorate([e.serialize()], r.prototype, "linkRefractionWithTransparency", void 0), __decorate([e.serialize()], r.prototype, "linkEmissiveWithAlbedo", void 0), __decorate([e.serialize()], r.prototype, "useLightmapAsShadowmap", void 0), __decorate([e.serialize()], r.prototype, "useEmissiveAsIllumination", void 0), __decorate([e.serialize()], r.prototype, "useAlphaFromAlbedoTexture", void 0), __decorate([e.serialize()], r.prototype, "useSpecularOverAlpha", void 0), __decorate([e.serialize()], r.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0), __decorate([e.serialize()], r.prototype, "useRoughnessFromMetallicTextureAlpha", void 0), __decorate([e.serialize()], r.prototype, "useRoughnessFromMetallicTextureGreen", void 0), __decorate([e.serialize()], r.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0), __decorate([e.serialize()], r.prototype, "useScalarInLinearSpace", void 0), __decorate([e.serialize()], r.prototype, "usePhysicalLightFalloff", void 0), __decorate([e.serialize()], r.prototype, "useRadianceOverAlpha", void 0), __decorate([e.serialize()], r.prototype, "useParallax", void 0), __decorate([e.serialize()], r.prototype, "useParallaxOcclusion", void 0), __decorate([e.serialize()], r.prototype, "parallaxScaleBias", void 0), __decorate([e.serialize()], r.prototype, "disableLighting", void 0), __decorate([e.serialize()], r.prototype, "maxSimultaneousLights", void 0), __decorate([e.serialize()], r.prototype, "invertNormalMapX", void 0), __decorate([e.serialize()], r.prototype, "invertNormalMapY", void 0), __decorate([e.serialize()], r.prototype, "useLogarithmicDepth", null), r
		})(e.Material);
	e.PBRMaterial = i
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function() {
		function t(t) {
			var i = this;
			this._transformationMatrix = e.Matrix.Identity(), this._enabled = !1, this._labelsEnabled = !1, this._displayStatistics = !0, this._displayTree = !1, this._displayLogs = !1, this._skeletonViewers = new Array, this._identityMatrix = e.Matrix.Identity(), this.axisRatio = .02, this.accentColor = "orange", this._scene = t, this._syncPositions = function() {
				var e = i._scene.getEngine(),
					t = e.getRenderingCanvasClientRect();
				i._showUI && (i._statsDiv.style.left = t.width - 410 + "px", i._statsDiv.style.top = t.height - 290 + "px", i._statsDiv.style.width = "400px", i._statsDiv.style.height = "auto", i._statsSubsetDiv.style.maxHeight = "240px", i._optionsDiv.style.left = "0px", i._optionsDiv.style.top = "10px", i._optionsDiv.style.width = "200px", i._optionsDiv.style.height = "auto", i._optionsSubsetDiv.style.maxHeight = t.height - 225 + "px", i._logDiv.style.left = "0px", i._logDiv.style.top = t.height - 170 + "px", i._logDiv.style.width = "600px", i._logDiv.style.height = "160px", i._treeDiv.style.left = t.width - 310 + "px", i._treeDiv.style.top = "10px", i._treeDiv.style.width = "300px", i._treeDiv.style.height = "auto", i._treeSubsetDiv.style.maxHeight = t.height - 340 + "px"), i._globalDiv.style.left = t.left + "px", i._globalDiv.style.top = t.top + "px", i._drawingCanvas.style.left = "0px", i._drawingCanvas.style.top = "0px", i._drawingCanvas.style.width = e.getRenderWidth() + "px", i._drawingCanvas.style.height = e.getRenderHeight() + "px";
				var r = window.devicePixelRatio || 1,
					n = i._drawingContext,
					o = n.webkitBackingStorePixelRatio || n.mozBackingStorePixelRatio || n.msBackingStorePixelRatio || n.oBackingStorePixelRatio || n.backingStorePixelRatio || 1;
				i._ratio = r / o, i._drawingCanvas.width = e.getRenderWidth() * i._ratio, i._drawingCanvas.height = e.getRenderHeight() * i._ratio
			}, this._onCanvasClick = function(e) {
				i._clickPosition = {
					x: e.clientX * i._ratio,
					y: e.clientY * i._ratio
				}
			}, this._syncUI = function() {
				i._showUI && (i._displayStatistics ? (i._displayStats(), i._statsDiv.style.display = "") : i._statsDiv.style.display = "none", i._displayLogs ? i._logDiv.style.display = "" : i._logDiv.style.display = "none", i._displayTree ? (i._treeDiv.style.display = "", i._needToRefreshMeshesTree && (i._needToRefreshMeshesTree = !1, i._refreshMeshesTreeContent())) : i._treeDiv.style.display = "none")
			}, this._syncData = function() {
				if (i._labelsEnabled || !i._showUI) {
					i._camera.getViewMatrix().multiplyToRef(i._camera.getProjectionMatrix(), i._transformationMatrix), i._drawingContext.clearRect(0, 0, i._drawingCanvas.width, i._drawingCanvas.height);
					var t, r, n = i._scene.getEngine(),
						o = i._camera.viewport,
						s = o.toGlobal(n.getRenderWidth(), n.getRenderHeight()),
						a = i._camera.getActiveMeshes();
					for (t = 0; t < a.length; t++) {
						var h = a.data[t],
							c = h.getBoundingInfo().boundingSphere.center;
						r = e.Vector3.Project(c, h.getWorldMatrix(), i._transformationMatrix, s), (h.renderOverlay || i.shouldDisplayAxis && i.shouldDisplayAxis(h)) && i._renderAxis(r, h, s), i.shouldDisplayLabel && !i.shouldDisplayLabel(h) || i._renderLabel(h.name, r, 12, (function() {
							h.renderOverlay = !h.renderOverlay
						}), (function() {
							return h.renderOverlay ? "red" : "black"
						}))
					}
					var l = i._scene.cameras;
					for (t = 0; t < l.length; t++) {
						var u = l[t];
						u !== i._camera && (r = e.Vector3.Project(e.Vector3.Zero(), u.getWorldMatrix(), i._transformationMatrix, s), i.shouldDisplayLabel && !i.shouldDisplayLabel(u) || i._renderLabel(u.name, r, 12, (function() {
							i._camera.detachControl(n.getRenderingCanvas()), i._camera = u, i._camera.attachControl(n.getRenderingCanvas())
						}), (function() {
							return "purple"
						})))
					}
					var d = i._scene.lights;
					for (t = 0; t < d.length; t++) {
						var f = d[t];
						f.position && (r = e.Vector3.Project(f.getAbsolutePosition(), i._identityMatrix, i._transformationMatrix, s), i.shouldDisplayLabel && !i.shouldDisplayLabel(f) || i._renderLabel(f.name, r, -20, (function() {
							f.setEnabled(!f.isEnabled())
						}), (function() {
							return f.isEnabled() ? "orange" : "gray"
						})))
					}
				}
				i._clickPosition = void 0
			}
		}
		return t.prototype._refreshMeshesTreeContent = function() {
			for (; this._treeSubsetDiv.hasChildNodes();) this._treeSubsetDiv.removeChild(this._treeSubsetDiv.lastChild);
			var e = this._scene.meshes.slice(0, this._scene.meshes.length);
			e.sort((function(e, t) {
				return e.name === t.name ? 0 : e.name > t.name ? 1 : -1
			}));
			for (var t = 0; t < e.length; t++) {
				var i = e[t];
				i.isEnabled() && this._generateAdvancedCheckBox(this._treeSubsetDiv, i.name, i.getTotalVertices() + " verts", i.isVisible, (function(e, t) {
					t.isVisible = e.checked
				}), i)
			}
		}, t.prototype._renderSingleAxis = function(e, t, i, r, n) {
			this._drawingContext.beginPath(), this._drawingContext.moveTo(e.x, e.y), this._drawingContext.lineTo(t.x, t.y), this._drawingContext.strokeStyle = n, this._drawingContext.lineWidth = 4, this._drawingContext.stroke(), this._drawingContext.font = "normal 14px Segoe UI", this._drawingContext.fillStyle = n, this._drawingContext.fillText(r, i.x, i.y)
		}, t.prototype._renderAxis = function(t, i, r) {
			var n = i.getBoundingInfo().boundingSphere.center,
				o = i.getWorldMatrix(),
				s = e.Vector3.UnprojectFromTransform(t.add(new e.Vector3(this._drawingCanvas.width * this.axisRatio, 0, 0)), r.width, r.height, o, this._transformationMatrix),
				a = s.subtract(n).length(),
				h = e.Vector3.Project(n.add(new e.Vector3(a, 0, 0)), o, this._transformationMatrix, r),
				c = e.Vector3.Project(n.add(new e.Vector3(1.5 * a, 0, 0)), o, this._transformationMatrix, r);
			this._renderSingleAxis(t, h, c, "x", "#FF0000");
			var l = e.Vector3.Project(n.add(new e.Vector3(0, a, 0)), o, this._transformationMatrix, r),
				u = e.Vector3.Project(n.add(new e.Vector3(0, 1.5 * a, 0)), o, this._transformationMatrix, r);
			this._renderSingleAxis(t, l, u, "y", "#00FF00");
			var d = e.Vector3.Project(n.add(new e.Vector3(0, 0, a)), o, this._transformationMatrix, r),
				f = e.Vector3.Project(n.add(new e.Vector3(0, 0, 1.5 * a)), o, this._transformationMatrix, r);
			this._renderSingleAxis(t, d, f, "z", "#0000FF")
		}, t.prototype._renderLabel = function(e, t, i, r, n) {
			if (t.z > 0 && t.z < 1) {
				this._drawingContext.font = "normal 12px Segoe UI";
				var o = this._drawingContext.measureText(e),
					s = t.x - o.width / 2,
					a = t.y,
					h = this._drawingCanvas.getBoundingClientRect();
				this._showUI && this._isClickInsideRect(h.left * this._ratio + s - 5, h.top * this._ratio + a - i - 12, o.width + 10, 17) && r(), this._drawingContext.beginPath(), this._drawingContext.rect(s - 5, a - i - 12, o.width + 10, 17), this._drawingContext.fillStyle = n(), this._drawingContext.globalAlpha = .5, this._drawingContext.fill(), this._drawingContext.globalAlpha = 1, this._drawingContext.strokeStyle = "#FFFFFF", this._drawingContext.lineWidth = 1, this._drawingContext.stroke(), this._drawingContext.fillStyle = "#FFFFFF", this._drawingContext.fillText(e, s, a - i), this._drawingContext.beginPath(), this._drawingContext.arc(t.x, a, 5, 0, 2 * Math.PI, !1), this._drawingContext.fill()
			}
		}, t.prototype._isClickInsideRect = function(e, t, i, r) {
			return !!this._clickPosition && (!(this._clickPosition.x < e || this._clickPosition.x > e + i) && !(this._clickPosition.y < t || this._clickPosition.y > t + r))
		}, t.prototype.isVisible = function() {
			return this._enabled
		}, t.prototype.hide = function() {
			if (this._enabled) {
				this._enabled = !1;
				var t = this._scene.getEngine();
				this._scene.unregisterBeforeRender(this._syncData), this._scene.unregisterAfterRender(this._syncUI), this._rootElement.removeChild(this._globalDiv), this._scene.forceShowBoundingBoxes = !1, this._scene.forceWireframe = !1, e.StandardMaterial.DiffuseTextureEnabled = !0, e.StandardMaterial.AmbientTextureEnabled = !0, e.StandardMaterial.SpecularTextureEnabled = !0, e.StandardMaterial.EmissiveTextureEnabled = !0, e.StandardMaterial.BumpTextureEnabled = !0, e.StandardMaterial.OpacityTextureEnabled = !0, e.StandardMaterial.ReflectionTextureEnabled = !0, e.StandardMaterial.LightmapTextureEnabled = !0, e.StandardMaterial.RefractionTextureEnabled = !0, e.StandardMaterial.ColorGradingTextureEnabled = !0, this._scene.shadowsEnabled = !0, this._scene.particlesEnabled = !0, this._scene.postProcessesEnabled = !0, this._scene.collisionsEnabled = !0, this._scene.lightsEnabled = !0, this._scene.texturesEnabled = !0, this._scene.lensFlaresEnabled = !0, this._scene.proceduralTexturesEnabled = !0, this._scene.renderTargetsEnabled = !0, this._scene.probesEnabled = !0, t.getRenderingCanvas().removeEventListener("click", this._onCanvasClick), this._clearSkeletonViewers()
			}
		}, t.prototype._clearSkeletonViewers = function() {
			for (var e = 0; e < this._skeletonViewers.length; e++) this._skeletonViewers[e].dispose();
			this._skeletonViewers = []
		}, t.prototype.show = function(e, t, i) {
			if (void 0 === e && (e = !0), void 0 === t && (t = null), void 0 === i && (i = null), !this._enabled) {
				this._enabled = !0, t ? this._camera = t : this._camera = this._scene.activeCamera, this._showUI = e;
				var r = this._scene.getEngine();
				this._globalDiv = document.createElement("div"), this._rootElement = i || document.body, this._rootElement.appendChild(this._globalDiv), this._generateDOMelements(), r.getRenderingCanvas().addEventListener("click", this._onCanvasClick), this._syncPositions(), this._scene.registerBeforeRender(this._syncData), this._scene.registerAfterRender(this._syncUI)
			}
		}, t.prototype._clearLabels = function() {
			this._drawingContext.clearRect(0, 0, this._drawingCanvas.width, this._drawingCanvas.height);
			for (var e = 0; e < this._scene.meshes.length; e++) {
				var t = this._scene.meshes[e];
				t.renderOverlay = !1
			}
		}, t.prototype._generateheader = function(e, t) {
			var i = document.createElement("div");
			i.innerHTML = t + "&nbsp;", i.style.textAlign = "right", i.style.width = "100%", i.style.color = "white", i.style.backgroundColor = "Black", i.style.padding = "5px 5px 4px 0px", i.style.marginLeft = "-5px", i.style.fontWeight = "bold", e.appendChild(i)
		}, t.prototype._generateTexBox = function(e, t, i) {
			var r = document.createElement("label");
			r.style.display = "inline", r.innerHTML = t, r.style.color = i, e.appendChild(r), e.appendChild(document.createElement("br"))
		}, t.prototype._generateAdvancedCheckBox = function(e, t, i, r, n, o) {
			void 0 === o && (o = null);
			var s = document.createElement("label");
			s.style.display = "inline";
			var a = document.createElement("input");
			a.type = "checkbox", a.checked = r, a.style.display = "inline", a.style.margin = "0px 5px 0px 0px", a.style.verticalAlign = "sub", a.addEventListener("change", (function(e) {
				n(e.target, o)
			})), s.appendChild(a);
			var h = document.createElement("span"),
				c = document.createElement("span"),
				l = document.createElement("span");
			l.style.cssFloat = "right", c.innerHTML = t, l.innerHTML = i, l.style.fontSize = "12px", l.style.maxWidth = "200px", h.appendChild(c), h.appendChild(l), s.appendChild(h), e.appendChild(s), e.appendChild(document.createElement("br"))
		}, t.prototype._generateCheckBox = function(e, t, i, r, n) {
			void 0 === n && (n = null);
			var o = document.createElement("label");
			o.style.display = "inline";
			var s = document.createElement("input");
			s.type = "checkbox", s.checked = i, s.style.display = "inline", s.style.margin = "0px 5px 0px 0px", s.style.verticalAlign = "sub", s.addEventListener("change", (function(e) {
				r(e.target, n)
			})), o.appendChild(s), o.appendChild(document.createTextNode(t)), e.appendChild(o), e.appendChild(document.createElement("br"))
		}, t.prototype._generateButton = function(e, t, i, r) {
			void 0 === r && (r = null);
			var n = document.createElement("button");
			n.innerHTML = t, n.style.height = "24px", n.style.width = "150px", n.style.marginBottom = "5px", n.style.color = "#444444", n.style.border = "1px solid white", n.className = "debugLayerButton", n.addEventListener("click", (function(e) {
				i(e.target, r)
			})), e.appendChild(n), e.appendChild(document.createElement("br"))
		}, t.prototype._generateRadio = function(e, t, i, r, n, o) {
			void 0 === o && (o = null);
			var s = document.createElement("label");
			s.style.display = "inline";
			var a = document.createElement("input");
			a.type = "radio", a.name = i, a.checked = r, a.style.display = "inline", a.style.margin = "0px 5px 0px 0px", a.style.verticalAlign = "sub", a.addEventListener("change", (function(e) {
				n(e.target, o)
			})), s.appendChild(a), s.appendChild(document.createTextNode(t)), e.appendChild(s), e.appendChild(document.createElement("br"))
		}, t.prototype._generateDOMelements = function() {
			var t = this;
			if (this._globalDiv.id = "DebugLayer", this._globalDiv.style.position = "absolute", this._globalDiv.style.fontFamily = "Segoe UI, Arial", this._globalDiv.style.fontSize = "14px", this._globalDiv.style.color = "white", this._drawingCanvas = document.createElement("canvas"), this._drawingCanvas.id = "DebugLayerDrawingCanvas", this._drawingCanvas.style.position = "absolute", this._drawingCanvas.style.pointerEvents = "none", this._drawingCanvas.style.backgroundColor = "transparent", this._drawingContext = this._drawingCanvas.getContext("2d"), this._globalDiv.appendChild(this._drawingCanvas), this._showUI) {
				var i = "rgba(128, 128, 128, 0.4)",
					r = "rgb(180, 180, 180) solid 1px";
				this._statsDiv = document.createElement("div"), this._statsDiv.id = "DebugLayerStats", this._statsDiv.style.border = r, this._statsDiv.style.position = "absolute", this._statsDiv.style.background = i, this._statsDiv.style.padding = "0px 0px 0px 5px", this._generateheader(this._statsDiv, "STATISTICS"), this._statsSubsetDiv = document.createElement("div"), this._statsSubsetDiv.style.paddingTop = "5px", this._statsSubsetDiv.style.paddingBottom = "5px", this._statsSubsetDiv.style.overflowY = "auto", this._statsDiv.appendChild(this._statsSubsetDiv), this._treeDiv = document.createElement("div"), this._treeDiv.id = "DebugLayerTree", this._treeDiv.style.border = r, this._treeDiv.style.position = "absolute", this._treeDiv.style.background = i, this._treeDiv.style.padding = "0px 0px 0px 5px", this._treeDiv.style.display = "none", this._generateheader(this._treeDiv, "MESHES TREE"), this._treeSubsetDiv = document.createElement("div"), this._treeSubsetDiv.style.paddingTop = "5px", this._treeSubsetDiv.style.paddingRight = "5px", this._treeSubsetDiv.style.overflowY = "auto", this._treeSubsetDiv.style.maxHeight = "300px", this._treeDiv.appendChild(this._treeSubsetDiv), this._needToRefreshMeshesTree = !0, this._logDiv = document.createElement("div"), this._logDiv.style.border = r, this._logDiv.id = "DebugLayerLogs", this._logDiv.style.position = "absolute", this._logDiv.style.background = i, this._logDiv.style.padding = "0px 0px 0px 5px", this._logDiv.style.display = "none", this._generateheader(this._logDiv, "LOGS"), this._logSubsetDiv = document.createElement("div"), this._logSubsetDiv.style.height = "127px", this._logSubsetDiv.style.paddingTop = "5px", this._logSubsetDiv.style.overflowY = "auto", this._logSubsetDiv.style.fontSize = "12px", this._logSubsetDiv.style.fontFamily = "consolas", this._logSubsetDiv.innerHTML = e.Tools.LogCache, this._logDiv.appendChild(this._logSubsetDiv), e.Tools.OnNewCacheEntry = function(e) {
						t._logSubsetDiv.innerHTML = e + t._logSubsetDiv.innerHTML
					}, this._optionsDiv = document.createElement("div"), this._optionsDiv.id = "DebugLayerOptions", this._optionsDiv.style.border = r, this._optionsDiv.style.position = "absolute", this._optionsDiv.style.background = i, this._optionsDiv.style.padding = "0px 0px 0px 5px", this._optionsDiv.style.overflowY = "auto", this._generateheader(this._optionsDiv, "OPTIONS"), this._optionsSubsetDiv = document.createElement("div"), this._optionsSubsetDiv.style.paddingTop = "5px", this._optionsSubsetDiv.style.paddingBottom = "5px", this._optionsSubsetDiv.style.overflowY = "auto", this._optionsSubsetDiv.style.maxHeight = "200px", this._optionsDiv.appendChild(this._optionsSubsetDiv), this._generateTexBox(this._optionsSubsetDiv, "<b>Windows:</b>", this.accentColor), this._generateCheckBox(this._optionsSubsetDiv, "Statistics", this._displayStatistics, (function(e) {
						t._displayStatistics = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Logs", this._displayLogs, (function(e) {
						t._displayLogs = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Meshes tree", this._displayTree, (function(e) {
						t._displayTree = e.checked, t._needToRefreshMeshesTree = !0
					})), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>General:</b>", this.accentColor), this._generateCheckBox(this._optionsSubsetDiv, "Bounding boxes", this._scene.forceShowBoundingBoxes, (function(e) {
						t._scene.forceShowBoundingBoxes = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Clickable labels", this._labelsEnabled, (function(e) {
						t._labelsEnabled = e.checked, t._labelsEnabled || t._clearLabels()
					})),
					this._generateCheckBox(this._optionsSubsetDiv, "Generate user marks (F12)", e.Tools.PerformanceLogLevel === e.Tools.PerformanceUserMarkLogLevel, (function(t) {
						t.checked ? e.Tools.PerformanceLogLevel = e.Tools.PerformanceUserMarkLogLevel : e.Tools.PerformanceLogLevel = e.Tools.PerformanceNoneLogLevel
					})), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>Rendering mode:</b>", this.accentColor), this._generateRadio(this._optionsSubsetDiv, "Solid", "renderMode", !this._scene.forceWireframe && !this._scene.forcePointsCloud, (function(e) {
						e.checked && (t._scene.forceWireframe = !1, t._scene.forcePointsCloud = !1)
					})), this._generateRadio(this._optionsSubsetDiv, "Wireframe", "renderMode", this._scene.forceWireframe, (function(e) {
						e.checked && (t._scene.forceWireframe = !0, t._scene.forcePointsCloud = !1)
					})), this._generateRadio(this._optionsSubsetDiv, "Point", "renderMode", this._scene.forcePointsCloud, (function(e) {
						e.checked && (t._scene.forceWireframe = !1, t._scene.forcePointsCloud = !0)
					})), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>Texture channels:</b>", this.accentColor), this._generateCheckBox(this._optionsSubsetDiv, "Diffuse", e.StandardMaterial.DiffuseTextureEnabled, (function(t) {
						e.StandardMaterial.DiffuseTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Ambient", e.StandardMaterial.AmbientTextureEnabled, (function(t) {
						e.StandardMaterial.AmbientTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Specular", e.StandardMaterial.SpecularTextureEnabled, (function(t) {
						e.StandardMaterial.SpecularTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Emissive", e.StandardMaterial.EmissiveTextureEnabled, (function(t) {
						e.StandardMaterial.EmissiveTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Bump", e.StandardMaterial.BumpTextureEnabled, (function(t) {
						e.StandardMaterial.BumpTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Opacity", e.StandardMaterial.OpacityTextureEnabled, (function(t) {
						e.StandardMaterial.OpacityTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Reflection", e.StandardMaterial.ReflectionTextureEnabled, (function(t) {
						e.StandardMaterial.ReflectionTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Refraction", e.StandardMaterial.RefractionTextureEnabled, (function(t) {
						e.StandardMaterial.RefractionTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "ColorGrading", e.StandardMaterial.ColorGradingTextureEnabled, (function(t) {
						e.StandardMaterial.ColorGradingTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Lightmap", e.StandardMaterial.LightmapTextureEnabled, (function(t) {
						e.StandardMaterial.LightmapTextureEnabled = t.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Fresnel", e.StandardMaterial.FresnelEnabled, (function(t) {
						e.StandardMaterial.FresnelEnabled = t.checked
					})), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>Options:</b>", this.accentColor), this._generateCheckBox(this._optionsSubsetDiv, "Animations", this._scene.animationsEnabled, (function(e) {
						t._scene.animationsEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Collisions", this._scene.collisionsEnabled, (function(e) {
						t._scene.collisionsEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Fog", this._scene.fogEnabled, (function(e) {
						t._scene.fogEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Lens flares", this._scene.lensFlaresEnabled, (function(e) {
						t._scene.lensFlaresEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Lights", this._scene.lightsEnabled, (function(e) {
						t._scene.lightsEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Particles", this._scene.particlesEnabled, (function(e) {
						t._scene.particlesEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Post-processes", this._scene.postProcessesEnabled, (function(e) {
						t._scene.postProcessesEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Probes", this._scene.probesEnabled, (function(e) {
						t._scene.probesEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Procedural textures", this._scene.proceduralTexturesEnabled, (function(e) {
						t._scene.proceduralTexturesEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Render targets", this._scene.renderTargetsEnabled, (function(e) {
						t._scene.renderTargetsEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Shadows", this._scene.shadowsEnabled, (function(e) {
						t._scene.shadowsEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Skeletons", this._scene.skeletonsEnabled, (function(e) {
						t._scene.skeletonsEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Sprites", this._scene.spritesEnabled, (function(e) {
						t._scene.spritesEnabled = e.checked
					})), this._generateCheckBox(this._optionsSubsetDiv, "Textures", this._scene.texturesEnabled, (function(e) {
						t._scene.texturesEnabled = e.checked
					})), e.AudioEngine && e.Engine.audioEngine.canUseWebAudio && (this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>Audio:</b>", this.accentColor), this._generateRadio(this._optionsSubsetDiv, "Headphones", "panningModel", this._scene.headphone, (function(e) {
						e.checked && (t._scene.headphone = !0)
					})), this._generateRadio(this._optionsSubsetDiv, "Normal Speakers", "panningModel", !this._scene.headphone, (function(e) {
						e.checked && (t._scene.headphone = !1)
					})), this._generateCheckBox(this._optionsSubsetDiv, "Disable audio", !this._scene.audioEnabled, (function(e) {
						t._scene.audioEnabled = !e.checked
					}))), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>Viewers:</b>", this.accentColor), this._generateCheckBox(this._optionsSubsetDiv, "Skeletons", !1, (function(i) {
						if (!i.checked) return void t._clearSkeletonViewers();
						for (var r = 0; r < t._scene.meshes.length; r++) {
							var n = t._scene.meshes[r];
							if (n.skeleton) {
								for (var o = !1, s = 0; s < t._skeletonViewers.length; s++)
									if (t._skeletonViewers[s].skeleton === n.skeleton) {
										o = !0;
										break
									}
								if (o) continue;
								var a = new e.Debug.SkeletonViewer(n.skeleton, n, t._scene);
								a.isEnabled = !0, t._skeletonViewers.push(a)
							}
						}
					})), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._generateTexBox(this._optionsSubsetDiv, "<b>Tools:</b>", this.accentColor), this._generateButton(this._optionsSubsetDiv, "Dump rendertargets", (function(e) {
						t._scene.dumpNextRenderTargets = !0
					})), this._generateButton(this._optionsSubsetDiv, "Run SceneOptimizer", (function(i) {
						e.SceneOptimizer.OptimizeAsync(t._scene)
					})), this._generateButton(this._optionsSubsetDiv, "Log camera object", (function(e) {
						t._camera ? console.log(t._camera) : console.warn("No camera defined, or debug layer created before camera creation!")
					})), this._optionsSubsetDiv.appendChild(document.createElement("br")), this._globalDiv.appendChild(this._statsDiv), this._globalDiv.appendChild(this._logDiv), this._globalDiv.appendChild(this._optionsDiv), this._globalDiv.appendChild(this._treeDiv)
			}
		}, t.prototype._displayStats = function() {
			var t = this._scene,
				i = t.getEngine(),
				r = i.getGlInfo();
			this._statsSubsetDiv.innerHTML = "Babylon.js v" + e.Engine.Version + " - <b>" + e.Tools.Format(i.getFps(), 0) + " fps</b><br><br><div style='column-count: 2;-moz-column-count:2;-webkit-column-count:2'><b>Count</b><br>Total meshes: " + t.meshes.length + "<br>Total lights: " + t.lights.length + "<br>Total vertices: " + t.getTotalVertices() + "<br>Total materials: " + t.materials.length + "<br>Total textures: " + t.textures.length + "<br>Active meshes: " + t.getActiveMeshes().length + "<br>Active indices: " + t.getActiveIndices() + "<br>Active bones: " + t.getActiveBones() + "<br>Active particles: " + t.getActiveParticles() + "<br><b>Draw calls: " + i.drawCalls + "</b><br><br><b>Duration</b><br>Meshes selection:</i> " + e.Tools.Format(t.getEvaluateActiveMeshesDuration()) + " ms<br>Render Targets: " + e.Tools.Format(t.getRenderTargetsDuration()) + " ms<br>Particles: " + e.Tools.Format(t.getParticlesDuration()) + " ms<br>Sprites: " + e.Tools.Format(t.getSpritesDuration()) + " ms<br><br>Render: <b>" + e.Tools.Format(t.getRenderDuration()) + " ms</b><br>Frame: " + e.Tools.Format(t.getLastFrameDuration()) + " ms<br>Potential FPS: " + e.Tools.Format(1e3 / t.getLastFrameDuration(), 0) + "<br>Resolution: " + i.getRenderWidth() + "x" + i.getRenderHeight() + "<br><br></div><div style='column-count: 2;-moz-column-count:2;-webkit-column-count:2'><b>Extensions</b><br>Std derivatives: " + (i.getCaps().standardDerivatives ? "Yes" : "No") + "<br>Compressed textures: " + (i.getCaps().s3tc ? "Yes" : "No") + "<br>Hardware instances: " + (i.getCaps().instancedArrays ? "Yes" : "No") + "<br>Texture float: " + (i.getCaps().textureFloat ? "Yes" : "No") + "<br><br>32bits indices: " + (i.getCaps().uintIndices ? "Yes" : "No") + "<br>Fragment depth: " + (i.getCaps().fragmentDepthSupported ? "Yes" : "No") + "<br>High precision shaders: " + (i.getCaps().highPrecisionShaderSupported ? "Yes" : "No") + "<br>Draw buffers: " + (i.getCaps().drawBuffersExtension ? "Yes" : "No") + "<br></div><br><div style='column-count: 2;-moz-column-count:2;-webkit-column-count:2'><b>Caps.</b><br>Stencil: " + (i.isStencilEnable ? "Enabled" : "Disabled") + "<br>Max textures units: " + i.getCaps().maxTexturesImageUnits + "<br>Max textures size: " + i.getCaps().maxTextureSize + "<br>Max anisotropy: " + i.getCaps().maxAnisotropy + "<br><b>Info</b><br>WebGL feature level: " + i.webGLVersion + "<br>" + r.version + "<br></div><br>" + r.renderer + "<br>", this.customStatsFunction && (this._statsSubsetDiv.innerHTML += this.customStatsFunction())
		}, t
	})();
	e.DebugLayer = t
})(BABYLON || (BABYLON = {}));
var BABYLON;
!(function(e) {
	var t = (function(t) {
		function i(i, r, n, o, s) {
			var a = this;
			void 0 === o && (o = null), t.call(this, r.getEngine(), i), this.downSampleX4PostProcess = null, this.brightPassPostProcess = null, this.gaussianBlurHPostProcesses = [], this.gaussianBlurVPostProcesses = [], this.textureAdderPostProcess = null, this.textureAdderFinalPostProcess = null, this.lensFlarePostProcess = null, this.lensFlareComposePostProcess = null, this.depthOfFieldPostProcess = null, this.brightThreshold = 1, this.blurWidth = 2, this.gaussianCoefficient = .25, this.gaussianMean = 1, this.gaussianStandardDeviation = 1, this.exposure = 1, this.lensTexture = null, this.lensColorTexture = null, this.lensFlareStrength = 20, this.lensFlareGhostDispersal = 1.4, this.lensFlareHaloWidth = .7, this.lensFlareDistortionStrength = 16, this.lensStarTexture = null, this.lensFlareDirtTexture = null, this.depthOfFieldDistance = 10, this.animations = [], this._depthRenderer = null, this._depthOfFieldEnabled = !0, this._lensFlareEnabled = !0, this._scene = r, o ? this.originalPostProcess = o : this.originalPostProcess = new e.PostProcess("HDRPass", "standard", [], [], n, null, e.Texture.BILINEAR_SAMPLINGMODE, r.getEngine(), (!0), "#define PASS_POST_PROCESS", e.Engine.TEXTURETYPE_FLOAT), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), "HDRPassPostProcess", function() {
				return a.originalPostProcess
			}, (!0))), this._createDownSampleX4PostProcess(r, n / 2), this._createBrightPassPostProcess(r, n / 2), this._createGaussianBlurPostProcesses(r, n / 2, 0), this._createGaussianBlurPostProcesses(r, n / 4, 1), this._createGaussianBlurPostProcesses(r, n / 8, 2), this._createGaussianBlurPostProcesses(r, n / 16, 3), this._createTextureAdderPostProcess(r, n), this.textureAdderFinalPostProcess = new e.PostProcess("HDRDepthOfFieldSource", "standard", [], [], n, null, e.Texture.BILINEAR_SAMPLINGMODE, r.getEngine(), (!0), "#define PASS_POST_PROCESS", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new e.PostProcessRenderEffect(r.getEngine(), "HDRDepthOfFieldSource", function() {
				return a.textureAdderFinalPostProcess
			}, (!0))), this._createLensFlarePostProcess(r, n), this._createGaussianBlurPostProcesses(r, n / 2, 5), this._createDepthOfFieldPostProcess(r, n), r.postProcessRenderPipelineManager.addPipeline(this), null !== s && r.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(i, s), this.LensFlareEnabled = !1, this.DepthOfFieldEnabled = !1
		}
		return __extends(i, t), Object.defineProperty(i.prototype, "DepthOfFieldEnabled", {
			get: function() {
				return this._depthOfFieldEnabled
			},
			set: function(e) {
				var t = this.gaussianBlurHPostProcesses.length - 1;
				e && !this._depthOfFieldEnabled ? (this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRGaussianBlurH" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRGaussianBlurV" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRDepthOfField", this._scene.cameras), this._depthRenderer = this._scene.enableDepthRenderer()) : !e && this._depthOfFieldEnabled && (this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRGaussianBlurH" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRGaussianBlurV" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRDepthOfField", this._scene.cameras)), this._depthOfFieldEnabled = e
			},
			enumerable: !0,
			configurable: !0
		}), Object.defineProperty(i.prototype, "LensFlareEnabled", {
			get: function() {
				return this._lensFlareEnabled
			},
			set: function(e) {
				var t = this.gaussianBlurHPostProcesses.length - 2;
				e && !this._lensFlareEnabled ? (this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRLensFlare", this._scene.cameras), this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRLensFlareShift", this._scene.cameras), this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRGaussianBlurH" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRGaussianBlurV" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.enableEffectInPipeline(this._name, "HDRLensFlareCompose", this._scene.cameras)) : !e && this._lensFlareEnabled && (this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRLensFlare", this._scene.cameras), this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRLensFlareShift", this._scene.cameras), this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRGaussianBlurH" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRGaussianBlurV" + t, this._scene.cameras), this._scene.postProcessRenderPipelineManager.disableEffectInPipeline(this._name, "HDRLensFlareCompose", this._scene.cameras)), this._lensFlareEnabled = e
			},
			enumerable: !0,
			configurable: !0
		}), i.prototype._createDownSampleX4PostProcess = function(t, i) {
			var r = this,
				n = new Array(32);
			this.downSampleX4PostProcess = new e.PostProcess("HDRDownSampleX4", "standard", ["dsOffsets"], [], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define DOWN_SAMPLE_X4", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.downSampleX4PostProcess.onApply = function(e) {
				for (var t = 0, i = -2; i < 2; i++)
					for (var o = -2; o < 2; o++) n[t] = (i + .5) * (1 / r.downSampleX4PostProcess.width), n[t + 1] = (o + .5) * (1 / r.downSampleX4PostProcess.height), t += 2;
				e.setArray2("dsOffsets", n)
			}, this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRDownSampleX4", function() {
				return r.downSampleX4PostProcess
			}, (!0)))
		}, i.prototype._createBrightPassPostProcess = function(t, i) {
			var r = this,
				n = new Array(8);
			this.brightPassPostProcess = new e.PostProcess("HDRBrightPass", "standard", ["dsOffsets", "brightThreshold"], [], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define BRIGHT_PASS", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.brightPassPostProcess.onApply = function(e) {
				var t = 1 / r.brightPassPostProcess.width,
					i = 1 / r.brightPassPostProcess.height;
				n[0] = -.5 * t, n[1] = .5 * i, n[2] = .5 * t, n[3] = .5 * i, n[4] = -.5 * t, n[5] = -.5 * i, n[6] = .5 * t, n[7] = -.5 * i, e.setArray2("dsOffsets", n), e.setFloat("brightThreshold", r.brightThreshold)
			}, this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRBrightPass", function() {
				return r.brightPassPostProcess
			}, (!0)))
		}, i.prototype._createGaussianBlurPostProcesses = function(t, i, r) {
			var n = this,
				o = new Array(9),
				s = new Array(9),
				a = ["blurOffsets", "blurWeights", "blurWidth"],
				h = function(e) {
					return function(i) {
						for (var r = 0, a = 0; a < 9; a++) r = (a - 4) / 4, s[a] = n.gaussianCoefficient * (1 / Math.sqrt(2 * Math.PI * n.gaussianStandardDeviation)) * Math.exp(-((r - n.gaussianMean) * (r - n.gaussianMean)) / (2 * n.gaussianStandardDeviation * n.gaussianStandardDeviation));
						for (var h = {
								width: t.getEngine().getRenderWidth(),
								height: t.getEngine().getRenderHeight()
							}, a = 0; a < 9; a++) {
							var c = (a - 4) * (1 / (e === !0 ? h.height : h.width));
							o[a] = c
						}
						i.setArray("blurOffsets", o), i.setArray("blurWeights", s), i.setFloat("blurWidth", n.blurWidth)
					}
				},
				c = new e.PostProcess("HDRGaussianBlurH" + i, "standard", a, [], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define GAUSSIAN_BLUR_H", e.Engine.TEXTURETYPE_UNSIGNED_INT);
			c.onApply = h(!1);
			var l = new e.PostProcess("HDRGaussianBlurV" + i, "standard", a, [], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define GAUSSIAN_BLUR_V", e.Engine.TEXTURETYPE_UNSIGNED_INT);
			l.onApply = h(!0), this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRGaussianBlurH" + r, function() {
				return c
			}, (!0))), this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRGaussianBlurV" + r, function() {
				return l
			}, (!0))), this.gaussianBlurHPostProcesses.push(c), this.gaussianBlurVPostProcesses.push(l)
		}, i.prototype._createTextureAdderPostProcess = function(t, i) {
			var r = this;
			this.gaussianBlurVPostProcesses[3];
			this.textureAdderPostProcess = new e.PostProcess("HDRTextureAdder", "standard", ["exposure"], ["otherSampler", "lensSampler"], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define TEXTURE_ADDER", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.textureAdderPostProcess.onApply = function(e) {
				e.setTextureFromPostProcess("otherSampler", r.originalPostProcess), e.setTexture("lensSampler", r.lensTexture), e.setFloat("exposure", r.exposure)
			}, this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRTextureAdder", function() {
				return r.textureAdderPostProcess
			}, (!0)))
		}, i.prototype._createLensFlarePostProcess = function(t, i) {
			var r = this;
			this.lensFlarePostProcess = new e.PostProcess("HDRLensFlare", "standard", ["strength", "ghostDispersal", "haloWidth", "resolution", "distortionStrength"], ["lensColorSampler"], i / 2, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!0), "#define LENS_FLARE", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRLensFlare", function() {
				return r.lensFlarePostProcess
			}, (!1))), this._createGaussianBlurPostProcesses(t, i / 4, 4), this.lensFlareComposePostProcess = new e.PostProcess("HDRLensFlareCompose", "standard", ["lensStarMatrix"], ["otherSampler", "lensDirtSampler", "lensStarSampler"], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define LENS_FLARE_COMPOSE", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRLensFlareCompose", function() {
				return r.lensFlareComposePostProcess
			}, (!1)));
			var n = new e.Vector2(0, 0);
			this.lensFlarePostProcess.onApply = function(e) {
				e.setTextureFromPostProcess("textureSampler", r.gaussianBlurHPostProcesses[0]), e.setTexture("lensColorSampler", r.lensColorTexture), e.setFloat("strength", r.lensFlareStrength), e.setFloat("ghostDispersal", r.lensFlareGhostDispersal), e.setFloat("haloWidth", r.lensFlareHaloWidth), n.x = r.lensFlarePostProcess.width, n.y = r.lensFlarePostProcess.height, e.setVector2("resolution", n), e.setFloat("distortionStrength", r.lensFlareDistortionStrength)
			};
			var o = e.Matrix.FromValues(2, 0, -1, 0, 0, 2, -1, 0, 0, 0, 1, 0, 0, 0, 0, 1),
				s = e.Matrix.FromValues(.5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			this.lensFlareComposePostProcess.onApply = function(t) {
				t.setTextureFromPostProcess("otherSampler", r.textureAdderFinalPostProcess), t.setTexture("lensDirtSampler", r.lensFlareDirtTexture), t.setTexture("lensStarSampler", r.lensStarTexture);
				var i = r._scene.activeCamera.getViewMatrix().getRow(0),
					n = r._scene.activeCamera.getViewMatrix().getRow(2),
					a = e.Vector3.Dot(i.toVector3(), new e.Vector3(1, 0, 0)) + e.Vector3.Dot(n.toVector3(), new e.Vector3(0, 0, 1));
				a *= 4;
				var h = e.Matrix.FromValues(.5 * Math.cos(a), -Math.sin(a), 0, 0, Math.sin(a), .5 * Math.cos(a), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
					c = s.multiply(h).multiply(o);
				t.setMatrix("lensStarMatrix", c)
			}
		}, i.prototype._createDepthOfFieldPostProcess = function(t, i) {
			var r = this;
			this.depthOfFieldPostProcess = new e.PostProcess("HDRDepthOfField", "standard", ["distance"], ["otherSampler", "depthSampler"], i, null, e.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), (!1), "#define DEPTH_OF_FIELD", e.Engine.TEXTURETYPE_UNSIGNED_INT), this.depthOfFieldPostProcess.onApply = function(e) {
				e.setTextureFromPostProcess("otherSampler", r.textureAdderFinalPostProcess), e.setTexture("depthSampler", r._depthRenderer.getDepthMap()), e.setFloat("distance", r.depthOfFieldDistance)
			}, this.addEffect(new e.PostProcessRenderEffect(t.getEngine(), "HDRDepthOfField", function() {
				return r.depthOfFieldPostProcess
			}, (!0)))
		}, i.prototype.dispose = function() {
			for (var e = 0; e < this._scene.cameras.length; e++) {
				var i = this._scene.cameras[e];
				this.originalPostProcess.dispose(i), this.downSampleX4PostProcess.dispose(i), this.brightPassPostProcess.dispose(i), this.textureAdderPostProcess.dispose(i);
				for (var r = 0; r < this.gaussianBlurHPostProcesses.length; r++) this.gaussianBlurHPostProcesses[r].dispose(i);
				for (var r = 0; r < this.gaussianBlurVPostProcesses.length; r++) this.gaussianBlurVPostProcesses[r].dispose(i);
				this.textureAdderFinalPostProcess.dispose(i), this.lensFlarePostProcess.dispose(i), this.lensFlareComposePostProcess.dispose(i), this.depthOfFieldPostProcess.dispose(i)
			}
			this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras), t.prototype.dispose.call(this)
		}, i
	})(e.PostProcessRenderPipeline);
	e.StandardRenderingPipeline = t
})(BABYLON || (BABYLON = {})), BABYLON.Effect.ShadersStore = {
		anaglyphPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D leftSampler;\nvoid main(void)\n{\nvec4 leftFrag=texture2D(leftSampler,vUV);\nleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\nvec4 rightFrag=texture2D(textureSampler,vUV);\nrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\ngl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\n}",
		blackAndWhitePixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nvoid main(void) \n{\nfloat luminance=dot(texture2D(textureSampler,vUV).rgb,vec3(0.3,0.59,0.11));\ngl_FragColor=vec4(luminance,luminance,luminance,1.0);\n}",
		blurPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\nvoid main(void)\n{\nfloat weights[7];\nweights[0]=0.05;\nweights[1]=0.1;\nweights[2]=0.2;\nweights[3]=0.3;\nweights[4]=0.2;\nweights[5]=0.1;\nweights[6]=0.05;\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\nvec2 texelStep=texelSize*direction*blurWidth;\nvec2 start=vUV-3.0*texelStep;\nvec4 baseColor=vec4(0.,0.,0.,0.);\nvec2 texelOffset=vec2(0.,0.);\nfor (int i=0; i<7; i++)\n{\nbaseColor+=texture2D(textureSampler,start+texelOffset)*weights[i];\ntexelOffset+=texelStep;\n}\ngl_FragColor=baseColor;\n}",
		chromaticAberrationPixelShader: "\nuniform sampler2D textureSampler; \n\nuniform float chromatic_aberration;\nuniform float screen_width;\nuniform float screen_height;\n\nvarying vec2 vUV;\nvoid main(void)\n{\nvec2 centered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\n+centered_screen_pos.y*centered_screen_pos.y;\nfloat radius=sqrt(radius2);\nvec4 original=texture2D(textureSampler,vUV);\nif (chromatic_aberration>0.0) {\n\nvec3 ref_indices=vec3(-0.3,0.0,0.3);\nfloat ref_shiftX=chromatic_aberration*radius*17.0/screen_width;\nfloat ref_shiftY=chromatic_aberration*radius*17.0/screen_height;\n\nvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\nvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\nvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\noriginal.r=texture2D(textureSampler,ref_coords_r).r;\noriginal.g=texture2D(textureSampler,ref_coords_g).g;\noriginal.b=texture2D(textureSampler,ref_coords_b).b;\n}\ngl_FragColor=original;\n}",
		colorPixelShader: "uniform vec4 color;\nvoid main(void) {\ngl_FragColor=color;\n}",
		colorVertexShader: "\nattribute vec3 position;\n\nuniform mat4 worldViewProjection;\nvoid main(void) {\ngl_Position=worldViewProjection*vec4(position,1.0);\n}",
		colorCorrectionPixelShader: "\nuniform sampler2D textureSampler; \nuniform sampler2D colorTable; \n\nvarying vec2 vUV;\n\nconst float SLICE_COUNT=16.0; \n\nvec4 sampleAs3DTexture(sampler2D texture,vec3 uv,float width) {\nfloat sliceSize=1.0/width; \nfloat slicePixelSize=sliceSize/width; \nfloat sliceInnerSize=slicePixelSize*(width-1.0); \nfloat zSlice0=min(floor(uv.z*width),width-1.0);\nfloat zSlice1=min(zSlice0+1.0,width-1.0);\nfloat xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;\nfloat s0=xOffset+(zSlice0*sliceSize);\nfloat s1=xOffset+(zSlice1*sliceSize);\nvec4 slice0Color=texture2D(texture,vec2(s0,uv.y));\nvec4 slice1Color=texture2D(texture,vec2(s1,uv.y));\nfloat zOffset=mod(uv.z*width,1.0);\nvec4 result=mix(slice0Color,slice1Color,zOffset);\nreturn result;\n}\nvoid main(void)\n{\nvec4 screen_color=texture2D(textureSampler,vUV);\ngl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);\n}",
		convolutionPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\nuniform float kernel[9];\nvoid main(void)\n{\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\nvec4 colorSum =\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];\nfloat kernelWeight =\nkernel[0] +\nkernel[1] +\nkernel[2] +\nkernel[3] +\nkernel[4] +\nkernel[5] +\nkernel[6] +\nkernel[7] +\nkernel[8];\nif (kernelWeight<=0.0) {\nkernelWeight=1.0;\n}\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);\n}",
		defaultPixelShader: "#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n#define RECIPROCAL_PI2 0.15915494\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<helperFunctions>\n\n#include<lightFragmentDeclaration>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform sampler2D diffuseSampler;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform sampler2D lightmapSampler;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\nuniform vec4 refractionRightColor;\n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform sampler2D specularSampler;\n#endif\n\n#include<fresnelFunction>\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\nuniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvarying vec3 vDirectionW;\n#endif\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\nuniform mat4 reflectionMatrix;\n#endif\n#endif\n#include<reflectionFunction>\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\nuniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef CAMERACOLORGRADING\n#include<colorGradingDefinition> \n#include<colorGrading>\n#endif\n#ifdef CAMERACOLORCURVES\n#include<colorCurvesDefinition>\n#include<colorCurves>\n#endif\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#include<bumpFragment>\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\nspecularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;\n#ifdef LIGHTMAP\nvec3 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset).rgb*vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n\nvec3 refractionColor=vec3(0.,0.,0.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nif (dot(refractionVector,viewDirectionW)<1.0)\n{\nrefractionColor=textureCube(refractionCubeSampler,refractionVector).rgb*vRefractionInfos.x;\n}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\nrefractionColor=texture2D(refraction2DSampler,refractionCoords).rgb*vRefractionInfos.x;\n#endif\n#endif\n\nvec3 reflectionColor=vec3(0.,0.,0.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias).rgb*vReflectionInfos.x;\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW).rgb*vReflectionInfos.x;\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\nreflectionColor=texture2D(reflection2DSampler,coords).rgb*vReflectionInfos.x;\n#endif\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\nrefractionColor*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor+emissiveColor+refractionColor,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor+refractionColor,alpha);\n#endif\n\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor;\n#else\ncolor.rgb+=lightmapColor;\n#endif\n#endif\n#endif\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef CAMERACOLORGRADING\ncolor=colorGrades(color);\n#endif\n#ifdef CAMERACOLORCURVES\ncolor.rgb=applyColorCurves(color.rgb);\n#endif\ngl_FragColor=color;\n}",
		defaultVertexShader: "\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nvarying vec2 vSpecularUV;\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#include<pointCloudVertexDeclaration>\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<shadowsVertexDeclaration>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\nvoid main(void) {\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=position;\n#endif \n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\nvec4 worldPos=finalWorld*vec4(position,1.0);\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x == 0.)\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef AMBIENT\nif (vAmbientInfos.x == 0.)\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef OPACITY\nif (vOpacityInfos.x == 0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef EMISSIVE\nif (vEmissiveInfos.x == 0.)\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef LIGHTMAP\nif (vLightmapInfos.x == 0.)\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nif (vSpecularInfos.x == 0.)\n{\nvSpecularUV=vec2(specularMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef BUMP\nif (vBumpInfos.x == 0.)\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n}",
		depthPixelShader: "#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\nuniform float far;\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\nfloat depth=(gl_FragCoord.z/gl_FragCoord.w)/far;\ngl_FragColor=vec4(depth,depth*depth,0.0,1.0);\n}",
		depthVertexShader: "\nattribute vec3 position;\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvoid main(void)\n{\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}",
		depthBoxBlurPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nvoid main(void)\n{\nvec4 colorDepth=vec4(0.0);\nfor (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\n}",
		depthOfFieldPixelShader: "\n\n\n\n\nuniform sampler2D textureSampler;\nuniform sampler2D highlightsSampler;\nuniform sampler2D depthSampler;\nuniform sampler2D grainSampler;\n\nuniform float grain_amount;\nuniform bool blur_noise;\nuniform float screen_width;\nuniform float screen_height;\nuniform float distortion;\nuniform bool dof_enabled;\n\nuniform float screen_distance; \nuniform float aperture;\nuniform float darken;\nuniform float edge_blur;\nuniform bool highlights;\n\nuniform float near;\nuniform float far;\n\nvarying vec2 vUV;\n\n#define PI 3.14159265\n#define TWOPI 6.28318530\n#define inverse_focal_length 0.1 \n\nvec2 centered_screen_pos;\nvec2 distorted_coords;\nfloat radius2;\nfloat radius;\n\nvec2 rand(vec2 co)\n{\nfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\nfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\nreturn clamp(vec2(noise1,noise2),0.0,1.0);\n}\n\nvec2 getDistortedCoords(vec2 coords) {\nif (distortion == 0.0) { return coords; }\nvec2 direction=1.0*normalize(centered_screen_pos);\nvec2 dist_coords=vec2(0.5,0.5);\ndist_coords.x=0.5+direction.x*radius2*1.0;\ndist_coords.y=0.5+direction.y*radius2*1.0;\nfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\ndist_coords=mix(coords,dist_coords,dist_amount);\nreturn dist_coords;\n}\n\nfloat sampleScreen(inout vec4 color,const in vec2 offset,const in float weight) {\n\nvec2 coords=distorted_coords;\nfloat angle=rand(coords*100.0).x*TWOPI;\ncoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\ncolor+=texture2D(textureSampler,coords)*weight;\nreturn weight;\n}\n\nfloat getBlurLevel(float size) {\nreturn min(3.0,ceil(size/1.0));\n}\n\nvec4 getBlurColor(float size) {\nvec4 col=texture2D(textureSampler,distorted_coords);\nif (size == 0.0) { return col; }\n\n\nfloat blur_level=getBlurLevel(size);\nfloat w=(size/screen_width);\nfloat h=(size/screen_height);\nfloat total_weight=1.0;\nvec2 sample_coords;\ntotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\ntotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\ntotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\ntotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\ntotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\ntotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\ntotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\ntotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\ntotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\nif (blur_level>1.0) {\ntotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\ntotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\ntotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\ntotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\ntotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\ntotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\ntotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\ntotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\ntotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\n}\nif (blur_level>2.0) {\ntotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\ntotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\ntotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\ntotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\ntotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\ntotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\ntotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\ntotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\ntotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\n}\ncol/=total_weight; \n\nif (darken>0.0) {\ncol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\n}\n\n\n\n\nreturn col;\n}\nvoid main(void)\n{\n\ncentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\nradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\nradius=sqrt(radius2);\ndistorted_coords=getDistortedCoords(vUV); \nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); \nfloat depth=texture2D(depthSampler,distorted_coords).r; \nfloat distance=near+(far-near)*depth; \nvec4 color=texture2D(textureSampler,vUV); \n\n\nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\n\nif (dof_enabled == false || coc<0.07) { coc=0.0; }\n\nfloat edge_blur_amount=0.0;\nif (edge_blur>0.0) {\nedge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\n}\n\nfloat blur_amount=max(edge_blur_amount,coc);\n\nif (blur_amount == 0.0) {\ngl_FragColor=texture2D(textureSampler,distorted_coords);\n}\nelse {\n\ngl_FragColor=getBlurColor(blur_amount*1.7);\n\nif (highlights) {\ngl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\n}\nif (blur_noise) {\n\nvec2 noise=rand(distorted_coords)*0.01*blur_amount;\nvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\ngl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\n}\n}\n\nif (grain_amount>0.0) {\nvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\ngl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\n}\n}\n",
		displayPassPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D passSampler;\nvoid main(void)\n{\ngl_FragColor=texture2D(passSampler,vUV);\n}",
		filterPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform mat4 kernelMatrix;\nvoid main(void)\n{\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\nvec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;\ngl_FragColor=vec4(updatedColor,1.0);\n}",
		fxaaPixelShader: "#define FXAA_REDUCE_MIN (1.0/128.0)\n#define FXAA_REDUCE_MUL (1.0/8.0)\n#define FXAA_SPAN_MAX 8.0\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 texelSize;\nvoid main(){\nvec2 localTexelSize=texelSize;\nvec4 rgbNW=texture2D(textureSampler,(vUV+vec2(-1.0,-1.0)*localTexelSize));\nvec4 rgbNE=texture2D(textureSampler,(vUV+vec2(1.0,-1.0)*localTexelSize));\nvec4 rgbSW=texture2D(textureSampler,(vUV+vec2(-1.0,1.0)*localTexelSize));\nvec4 rgbSE=texture2D(textureSampler,(vUV+vec2(1.0,1.0)*localTexelSize));\nvec4 rgbM=texture2D(textureSampler,vUV);\nvec4 luma=vec4(0.299,0.587,0.114,1.0);\nfloat lumaNW=dot(rgbNW,luma);\nfloat lumaNE=dot(rgbNE,luma);\nfloat lumaSW=dot(rgbSW,luma);\nfloat lumaSE=dot(rgbSE,luma);\nfloat lumaM=dot(rgbM,luma);\nfloat lumaMin=min(lumaM,min(min(lumaNW,lumaNE),min(lumaSW,lumaSE)));\nfloat lumaMax=max(lumaM,max(max(lumaNW,lumaNE),max(lumaSW,lumaSE)));\nvec2 dir=vec2(-((lumaNW+lumaNE)-(lumaSW+lumaSE)),((lumaNW+lumaSW)-(lumaNE+lumaSE)));\nfloat dirReduce=max(\n(lumaNW+lumaNE+lumaSW+lumaSE)*(0.25*FXAA_REDUCE_MUL),\nFXAA_REDUCE_MIN);\nfloat rcpDirMin=1.0/(min(abs(dir.x),abs(dir.y))+dirReduce);\ndir=min(vec2(FXAA_SPAN_MAX,FXAA_SPAN_MAX),\nmax(vec2(-FXAA_SPAN_MAX,-FXAA_SPAN_MAX),\ndir*rcpDirMin))*localTexelSize;\nvec4 rgbA=0.5*(\ntexture2D(textureSampler,vUV+dir*(1.0/3.0-0.5)) +\ntexture2D(textureSampler,vUV+dir*(2.0/3.0-0.5)));\nvec4 rgbB=rgbA*0.5+0.25*(\ntexture2D(textureSampler,vUV+dir*-0.5) +\ntexture2D(textureSampler,vUV+dir*0.5));\nfloat lumaB=dot(rgbB,luma);\nif ((lumaB<lumaMin) || (lumaB>lumaMax)) {\ngl_FragColor=rgbA;\n}\nelse {\ngl_FragColor=rgbB;\n}\n}",
		glowBlurPostProcessPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\nuniform vec2 direction;\nuniform float blurWidth;\n\nfloat getLuminance(vec3 color)\n{\nreturn dot(color,vec3(0.2126,0.7152,0.0722));\n}\nvoid main(void)\n{\nfloat weights[7];\nweights[0]=0.05;\nweights[1]=0.1;\nweights[2]=0.2;\nweights[3]=0.3;\nweights[4]=0.2;\nweights[5]=0.1;\nweights[6]=0.05;\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\nvec2 texelStep=texelSize*direction*blurWidth;\nvec2 start=vUV-3.0*texelStep;\nvec4 baseColor=vec4(0.,0.,0.,0.);\nvec2 texelOffset=vec2(0.,0.);\nfor (int i=0; i<7; i++)\n{\n\nvec4 texel=texture2D(textureSampler,start+texelOffset);\nbaseColor.a+=texel.a*weights[i];\n\nfloat luminance=getLuminance(baseColor.rgb);\nfloat luminanceTexel=getLuminance(texel.rgb);\nfloat choice=step(luminanceTexel,luminance);\nbaseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;\ntexelOffset+=texelStep;\n}\ngl_FragColor=baseColor;\n}",
		glowMapGenerationPixelShader: "#ifdef ALPHATEST\nvarying vec2 vUVDiffuse;\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\nuniform sampler2D emissiveSampler;\n#endif\nuniform vec4 color;\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUVDiffuse).a<0.4)\ndiscard;\n#endif\n#ifdef EMISSIVE\ngl_FragColor=texture2D(emissiveSampler,vUVEmissive);\n#else\ngl_FragColor=color;\n#endif\n}",
		glowMapGenerationVertexShader: "\nattribute vec3 position;\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nvarying vec4 vPosition;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef ALPHATEST\nvarying vec2 vUVDiffuse;\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vUVEmissive;\nuniform mat4 emissiveMatrix;\n#endif\nvoid main(void)\n{\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef CUBEMAP\nvPosition=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#else\nvPosition=viewProjection*finalWorld*vec4(position,1.0);\ngl_Position=vPosition;\n#endif\n#ifdef ALPHATEST\n#ifdef DIFFUSEUV1\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef DIFFUSEUV2\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#ifdef EMISSIVE\n#ifdef EMISSIVEUV1\nvUVEmissive=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef EMISSIVEUV2\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}",
		glowMapMergePixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform float offset;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\nbaseColor.a=abs(offset-baseColor.a);\ngl_FragColor=baseColor;\n}",
		glowMapMergeVertexShader: "\nattribute vec2 position;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) {\nvUV=position*madd+madd;\ngl_Position=vec4(position,0.0,1.0);\n}",
		hdrPixelShader: "uniform sampler2D textureSampler;\nvarying vec2 vUV;\n#if defined(GAUSSIAN_BLUR_H) || defined(GAUSSIAN_BLUR_V)\nuniform float blurOffsets[9];\nuniform float blurWeights[9];\nuniform float multiplier;\nvoid main(void) {\nvec4 color=vec4(0.0,0.0,0.0,0.0);\nfor (int i=0; i<9; i++) {\n#ifdef GAUSSIAN_BLUR_H\ncolor+=(texture2D(textureSampler,vUV+vec2(blurOffsets[i]*multiplier,0.0))*blurWeights[i]);\n#else\ncolor+=(texture2D(textureSampler,vUV+vec2(0.0,blurOffsets[i]*multiplier))*blurWeights[i]);\n#endif\n}\ncolor.a=1.0;\ngl_FragColor=color;\n}\n#endif\n#if defined(TEXTURE_ADDER)\nuniform sampler2D otherSampler;\nvoid main() {\nvec4 sum=texture2D(textureSampler,vUV)+texture2D(otherSampler,vUV);\nsum.a=clamp(sum.a,0.0,1.0);\ngl_FragColor=sum;\n}\n#endif\n#if defined(LUMINANCE_GENERATOR)\nuniform vec2 lumOffsets[4];\nvoid main() {\nfloat average=0.0;\nvec4 color=vec4(0.0,0.0,0.0,0.0);\nfloat maximum=-1e20;\nfor (int i=0; i<4; i++) {\ncolor=texture2D(textureSampler,vUV+lumOffsets[i]);\nfloat GreyValue=length(color.rgb);\nmaximum=max(maximum,GreyValue);\naverage+=(0.25*log(1e-5+GreyValue));\n}\naverage=exp(average);\ngl_FragColor=vec4(average,maximum,0.0,1.0);\n}\n#endif\n#if defined(DOWN_SAMPLE)\nuniform vec2 dsOffsets[9];\nuniform float halfDestPixelSize;\n#ifdef FINAL_DOWN_SAMPLE\nvec4 pack(float value) {\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(value*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\n#endif\nvoid main() {\nvec4 color=vec4(0.0,0.0,0.0,0.0);\nfloat average=0.0;\nfor (int i=0; i<9; i++) {\ncolor=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);\naverage+=color.r;\n}\naverage/=9.0;\n#ifndef FINAL_DOWN_SAMPLE\ngl_FragColor=vec4(average,average,0.0,1.0);\n#else\ngl_FragColor=pack(average);\n#endif\n}\n#endif\n#if defined(BRIGHT_PASS)\nuniform vec2 dsOffsets[4];\nuniform float brightThreshold;\nvoid main() {\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\naverage*=0.25;\nfloat luminance=length(average.rgb);\nif (luminance<brightThreshold) {\naverage=vec4(0.0,0.0,0.0,1.0);\n}\ngl_FragColor=average;\n}\n#endif\n#if defined(DOWN_SAMPLE_X4)\nuniform vec2 dsOffsets[16];\nvoid main() {\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\naverage/=16.0;\ngl_FragColor=average;\n}\n#endif\n#if defined(HDR)\nuniform sampler2D otherSampler;\nuniform float exposure;\nuniform float avgLuminance;\nvoid main() {\nvec4 color=texture2D(textureSampler,vUV)+texture2D(otherSampler,vUV);\nvec4 adjustedColor=color/avgLuminance*exposure;\ncolor=adjustedColor;\ncolor.a=1.0;\ngl_FragColor=color;\n}\n#endif\n",
		layerPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec4 color;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=baseColor*color;\n}",
		layerVertexShader: "\nattribute vec2 position;\n\nuniform vec2 scale;\nuniform vec2 offset;\nuniform mat4 textureMatrix;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) { \nvec2 shiftedPosition=position*scale+offset;\nvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\ngl_Position=vec4(shiftedPosition,0.0,1.0);\n}",
		lensFlarePixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec4 color;\nvoid main(void) {\nvec4 baseColor=texture2D(textureSampler,vUV);\ngl_FragColor=baseColor*color;\n}",
		lensFlareVertexShader: "\nattribute vec2 position;\n\nuniform mat4 viewportMatrix;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) { \nvUV=position*madd+madd;\ngl_Position=viewportMatrix*vec4(position,0.0,1.0);\n}",
		lensHighlightsPixelShader: "\nuniform sampler2D textureSampler; \n\nuniform float gain;\nuniform float threshold;\nuniform float screen_width;\nuniform float screen_height;\n\nvarying vec2 vUV;\n\nvec4 highlightColor(vec4 color) {\nvec4 highlight=color;\nfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\nfloat lum_threshold;\nif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\nelse { lum_threshold=0.5+0.44*threshold; }\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\nhighlight*=luminance*gain;\nhighlight.a=1.0;\nreturn highlight;\n}\nvoid main(void)\n{\nvec4 original=texture2D(textureSampler,vUV);\n\nif (gain == -1.0) {\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\nreturn;\n}\nfloat w=2.0/screen_width;\nfloat h=2.0/screen_height;\nfloat weight=1.0;\n\nvec4 blurred=vec4(0.0,0.0,0.0,0.0);\n#ifdef PENTAGON\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\n#else\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\n#endif\nblurred/=39.0;\ngl_FragColor=blurred;\n\n}",
		linePixelShader: "uniform vec4 color;\nvoid main(void) {\ngl_FragColor=color;\n}",
		lineVertexShader: "\nattribute vec3 position;\nattribute vec4 normal;\n\nuniform mat4 worldViewProjection;\nuniform float width;\nuniform float aspectRatio;\nvoid main(void) {\nvec4 viewPosition=worldViewProjection*vec4(position,1.0);\nvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\nvec2 currentScreen=viewPosition.xy/viewPosition.w;\nvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\ncurrentScreen.x*=aspectRatio;\nnextScreen.x*=aspectRatio;\nvec2 dir=normalize(nextScreen-currentScreen);\nvec2 normalDir=vec2(-dir.y,dir.x);\nnormalDir*=width/2.0;\nnormalDir.x/=aspectRatio;\nvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\ngl_Position=viewPosition+offset;\n}",
		outlinePixelShader: "uniform vec4 color;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\nvoid main(void) {\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\ngl_FragColor=color;\n}",
		outlineVertexShader: "\nattribute vec3 position;\nattribute vec3 normal;\n#include<bonesDeclaration>\n\nuniform float offset;\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvoid main(void)\n{\nvec3 offsetPosition=position+normal*offset;\n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(offsetPosition,1.0);\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n",
		particlesPixelShader: "\nvarying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\nvoid main(void) {\n#ifdef CLIPPLANE\nif (fClipDistance>0.0)\ndiscard;\n#endif\nvec4 baseColor=texture2D(diffuseSampler,vUV);\ngl_FragColor=(baseColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\n}",
		particlesVertexShader: "\nattribute vec3 position;\nattribute vec4 color;\nattribute vec4 options;\n\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nuniform mat4 invView;\nvarying float fClipDistance;\n#endif\nvoid main(void) { \nvec3 viewPos=(view*vec4(position,1.0)).xyz; \nvec3 cornerPos;\nfloat size=options.y;\nfloat angle=options.x;\nvec2 offset=options.zw;\ncornerPos=vec3(offset.x-0.5,offset.y-0.5,0.)*size;\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n\nviewPos+=rotatedCorner;\ngl_Position=projection*vec4(viewPos,1.0); \nvColor=color;\nvUV=offset;\n\n#ifdef CLIPPLANE\nvec4 worldPos=invView*vec4(viewPos,1.0);\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n}",
		passPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nvoid main(void) \n{\ngl_FragColor=texture2D(textureSampler,vUV);\n}",
		pbrPixelShader: "#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec3 vReflectionColor;\nuniform vec4 vAlbedoColor;\n\nuniform vec4 vLightingIntensity;\nuniform vec4 vCameraInfos;\n#ifdef OVERLOADEDVALUES\nuniform vec4 vOverloadedIntensity;\nuniform vec3 vOverloadedAmbient;\nuniform vec3 vOverloadedAlbedo;\nuniform vec3 vOverloadedReflectivity;\nuniform vec3 vOverloadedEmissive;\nuniform vec3 vOverloadedReflection;\nuniform vec3 vOverloadedMicroSurface;\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\nuniform vec4 vOverloadedShadowIntensity;\n#endif\n#if defined(REFLECTION) || defined(REFRACTION)\nuniform vec2 vMicrosurfaceTextureLods;\n#endif\nuniform vec4 vReflectivityColor;\nuniform vec3 vEmissiveColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<lightFragmentDeclaration>[0..maxSimultaneousLights]\n\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform sampler2D albedoSampler;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec3 vAmbientInfos;\n#endif\n#ifdef OPACITY \nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform sampler2D lightmapSampler;\n#endif\n#if defined(REFLECTIVITY) || defined(METALLICWORKFLOW) \nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform sampler2D reflectivitySampler;\n#endif\n\n#include<fresnelFunction>\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\nuniform mat4 refractionMatrix;\n#endif\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvarying vec3 vDirectionW;\n#endif\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\nuniform mat4 reflectionMatrix;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#ifdef CAMERACOLORGRADING\n#include<colorGradingDefinition>\n#endif\n#ifdef CAMERACOLORCURVES\n#include<colorCurvesDefinition>\n#endif\n\n#include<pbrShadowFunctions>\n#include<pbrFunctions>\n#ifdef CAMERACOLORGRADING\n#include<colorGrading>\n#endif\n#ifdef CAMERACOLORCURVES\n#include<colorCurves>\n#endif\n#include<harmonicsFunctions>\n#include<pbrLightFunctions>\n#include<helperFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#include<bumpFragment>\n\nvec4 surfaceAlbedo=vec4(1.,1.,1.,1.);\nvec3 surfaceAlbedoContribution=vAlbedoColor.rgb;\n\nfloat alpha=vAlbedoColor.a;\n#ifdef ALBEDO\nsurfaceAlbedo=texture2D(albedoSampler,vAlbedoUV+uvOffset);\nsurfaceAlbedo=vec4(toLinearSpace(surfaceAlbedo.rgb),surfaceAlbedo.a);\n#ifndef LINKREFRACTIONTOTRANSPARENCY\n#ifdef ALPHATEST\nif (surfaceAlbedo.a<0.4)\ndiscard;\n#endif\n#endif\n#ifdef ALPHAFROMALBEDO\nalpha*=surfaceAlbedo.a;\n#endif\nsurfaceAlbedo.rgb*=vAlbedoInfos.y;\n#else\n\nsurfaceAlbedo.rgb=surfaceAlbedoContribution;\nsurfaceAlbedoContribution=vec3(1.,1.,1.);\n#endif\n#ifdef VERTEXCOLOR\nsurfaceAlbedo.rgb*=vColor.rgb;\n#endif\n#ifdef OVERLOADEDVALUES\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,vOverloadedAlbedo,vOverloadedIntensity.y);\n#endif\n\nvec3 ambientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nambientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\nambientColor=vec3(1.,1.,1.)-((vec3(1.,1.,1.)-ambientColor)*vAmbientInfos.z);\n#ifdef OVERLOADEDVALUES\nambientColor.rgb=mix(ambientColor.rgb,vOverloadedAmbient,vOverloadedIntensity.x);\n#endif\n#endif\n\nfloat microSurface=vReflectivityColor.a;\nvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\n#ifdef OVERLOADEDVALUES\nsurfaceReflectivityColor.rgb=mix(surfaceReflectivityColor.rgb,vOverloadedReflectivity,vOverloadedIntensity.z);\n#endif\n#ifdef REFLECTIVITY\nvec4 surfaceReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\nsurfaceReflectivityColor=surfaceReflectivityColorMap.rgb;\nsurfaceReflectivityColor=toLinearSpace(surfaceReflectivityColor);\n#ifdef OVERLOADEDVALUES\nsurfaceReflectivityColor=mix(surfaceReflectivityColor,vOverloadedReflectivity,vOverloadedIntensity.z);\n#endif\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\nmicroSurface=surfaceReflectivityColorMap.a;\n#else\n#ifdef MICROSURFACEAUTOMATIC\nmicroSurface=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\n#endif\n#endif\n#endif\n#ifdef METALLICWORKFLOW\nvec4 surfaceMetallicColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\n\nfloat metallic=surfaceMetallicColorMap.r; \n\nvec3 baseColor=surfaceAlbedo.rgb;\n\nsurfaceAlbedo.rgb*=(1.0-metallic);\n\n\nconst vec3 DefaultSpecularReflectanceDielectric=vec3(0.04,0.04,0.04);\n\nsurfaceReflectivityColor=mix(DefaultSpecularReflectanceDielectric,baseColor,metallic);\n#ifdef OVERLOADEDVALUES\nsurfaceReflectivityColor=mix(surfaceReflectivityColor,vOverloadedReflectivity,vOverloadedIntensity.z);\n#endif\n#ifdef METALLICROUGHNESSGSTOREINALPHA\nmicroSurface=1.0-surfaceMetallicColorMap.a;\n#else\n#ifdef METALLICROUGHNESSGSTOREINGREEN\nmicroSurface=1.0-surfaceMetallicColorMap.g;\n#endif\n#endif\n#endif\n#ifdef OVERLOADEDVALUES\nmicroSurface=mix(microSurface,vOverloadedMicroSurface.x,vOverloadedMicroSurface.y);\n#endif\n\nfloat NdotV=max(0.00000000001,dot(normalW,viewDirectionW));\n\nmicroSurface=clamp(microSurface,0.,1.)*0.98;\n\nfloat roughness=clamp(1.-microSurface,0.000001,1.0);\n\nvec3 lightDiffuseContribution=vec3(0.,0.,0.);\n#ifdef OVERLOADEDSHADOWVALUES\nvec3 shadowedOnlyLightDiffuseContribution=vec3(1.,1.,1.);\n#endif\n#ifdef SPECULARTERM\nvec3 lightSpecularContribution=vec3(0.,0.,0.);\n#endif\nfloat notShadowLevel=1.; \n#ifdef LIGHTMAP\nvec3 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset).rgb*vLightmapInfos.y;\n#endif\nfloat NdotL=-1.;\nlightingInfo info;\n\nfloat reflectance=max(max(surfaceReflectivityColor.r,surfaceReflectivityColor.g),surfaceReflectivityColor.b);\n\n\nfloat reflectance90=clamp(reflectance*25.0,0.0,1.0);\nvec3 specularEnvironmentR0=surfaceReflectivityColor.rgb;\nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0)*reflectance90;\n#include<pbrLightFunctionsCall>[0..maxSimultaneousLights]\n#ifdef SPECULARTERM\nlightSpecularContribution*=vLightingIntensity.w;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n\nvec3 surfaceRefractionColor=vec3(0.,0.,0.);\n\n#ifdef LODBASEDMICROSFURACE\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\n#endif\n#ifdef REFRACTION\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\n#ifdef LODBASEDMICROSFURACE\n#ifdef USEPMREMREFRACTION\nfloat lodRefraction=getMipMapIndexFromAverageSlopeWithPMREM(vMicrosurfaceTextureLods.y,alphaG);\n#else\nfloat lodRefraction=getMipMapIndexFromAverageSlope(vMicrosurfaceTextureLods.y,alphaG);\n#endif\n#else\nfloat biasRefraction=(vMicrosurfaceTextureLods.y+2.)*(1.0-microSurface);\n#endif\n#ifdef REFRACTIONMAP_3D\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nif (dot(refractionVector,viewDirectionW)<1.0)\n{\n#ifdef LODBASEDMICROSFURACE\n#ifdef USEPMREMREFRACTION\n\nif ((vMicrosurfaceTextureLods.y-lodRefraction)>4.0)\n{\n\nfloat scaleRefraction=1.-exp2(lodRefraction)/exp2(vMicrosurfaceTextureLods.y); \nfloat maxRefraction=max(max(abs(refractionVector.x),abs(refractionVector.y)),abs(refractionVector.z));\nif (abs(refractionVector.x) != maxRefraction) refractionVector.x*=scaleRefraction;\nif (abs(refractionVector.y) != maxRefraction) refractionVector.y*=scaleRefraction;\nif (abs(refractionVector.z) != maxRefraction) refractionVector.z*=scaleRefraction;\n}\n#endif\nsurfaceRefractionColor=textureCubeLodEXT(refractionCubeSampler,refractionVector,lodRefraction).rgb*vRefractionInfos.x;\n#else\nsurfaceRefractionColor=textureCube(refractionCubeSampler,refractionVector,biasRefraction).rgb*vRefractionInfos.x;\n#endif\n}\n#ifndef REFRACTIONMAPINLINEARSPACE\nsurfaceRefractionColor=toLinearSpace(surfaceRefractionColor.rgb);\n#endif\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\n#ifdef LODBASEDMICROSFURACE\nsurfaceRefractionColor=texture2DLodEXT(refraction2DSampler,refractionCoords,lodRefraction).rgb*vRefractionInfos.x;\n#else\nsurfaceRefractionColor=texture2D(refraction2DSampler,refractionCoords,biasRefraction).rgb*vRefractionInfos.x;\n#endif \nsurfaceRefractionColor=toLinearSpace(surfaceRefractionColor.rgb);\n#endif\n#endif\n\nvec3 environmentRadiance=vReflectionColor.rgb;\nvec3 environmentIrradiance=vReflectionColor.rgb;\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef LODBASEDMICROSFURACE\n#ifdef USEPMREMREFLECTION\nfloat lodReflection=getMipMapIndexFromAverageSlopeWithPMREM(vMicrosurfaceTextureLods.x,alphaG);\n#else\nfloat lodReflection=getMipMapIndexFromAverageSlope(vMicrosurfaceTextureLods.x,alphaG);\n#endif\n#else\nfloat biasReflection=(vMicrosurfaceTextureLods.x+2.)*(1.0-microSurface);\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef LODBASEDMICROSFURACE\n#ifdef USEPMREMREFLECTION\n\nif ((vMicrosurfaceTextureLods.y-lodReflection)>4.0)\n{\n\nfloat scaleReflection=1.-exp2(lodReflection)/exp2(vMicrosurfaceTextureLods.x); \nfloat maxReflection=max(max(abs(vReflectionUVW.x),abs(vReflectionUVW.y)),abs(vReflectionUVW.z));\nif (abs(vReflectionUVW.x) != maxReflection) vReflectionUVW.x*=scaleReflection;\nif (abs(vReflectionUVW.y) != maxReflection) vReflectionUVW.y*=scaleReflection;\nif (abs(vReflectionUVW.z) != maxReflection) vReflectionUVW.z*=scaleReflection;\n}\n#endif\nenvironmentRadiance=textureCubeLodEXT(reflectionCubeSampler,vReflectionUVW,lodReflection).rgb*vReflectionInfos.x;\n#else\nenvironmentRadiance=textureCube(reflectionCubeSampler,vReflectionUVW,biasReflection).rgb*vReflectionInfos.x;\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifndef REFLECTIONMAP_SKYBOX\nvec3 normalEnvironmentSpace=(reflectionMatrix*vec4(normalW,1)).xyz;\nenvironmentIrradiance=EnvironmentIrradiance(normalEnvironmentSpace);\n#endif\n#else\nenvironmentRadiance=toLinearSpace(environmentRadiance.rgb);\nenvironmentIrradiance=textureCube(reflectionCubeSampler,normalW,20.).rgb*vReflectionInfos.x;\nenvironmentIrradiance=toLinearSpace(environmentIrradiance.rgb);\nenvironmentIrradiance*=0.2; \n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\n#ifdef LODBASEDMICROSFURACE\nenvironmentRadiance=texture2DLodEXT(reflection2DSampler,coords,lodReflection).rgb*vReflectionInfos.x;\n#else\nenvironmentRadiance=texture2D(reflection2DSampler,coords,biasReflection).rgb*vReflectionInfos.x;\n#endif\nenvironmentRadiance=toLinearSpace(environmentRadiance.rgb);\nenvironmentIrradiance=texture2D(reflection2DSampler,coords,20.).rgb*vReflectionInfos.x;\nenvironmentIrradiance=toLinearSpace(environmentIrradiance.rgb);\n#endif\n#endif\n#ifdef OVERLOADEDVALUES\nenvironmentIrradiance=mix(environmentIrradiance,vOverloadedReflection,vOverloadedMicroSurface.z);\nenvironmentRadiance=mix(environmentRadiance,vOverloadedReflection,vOverloadedMicroSurface.z);\n#endif\nenvironmentRadiance*=vLightingIntensity.z;\nenvironmentIrradiance*=vLightingIntensity.z;\n\nvec3 specularEnvironmentReflectance=FresnelSchlickEnvironmentGGX(clamp(NdotV,0.,1.),specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\n\nvec3 refractance=vec3(0.0,0.0,0.0);\n#ifdef REFRACTION\nvec3 transmission=vec3(1.0,1.0,1.0);\n#ifdef LINKREFRACTIONTOTRANSPARENCY\n\ntransmission*=(1.0-alpha);\n\n\nvec3 mixedAlbedo=surfaceAlbedoContribution.rgb*surfaceAlbedo.rgb;\nfloat maxChannel=max(max(mixedAlbedo.r,mixedAlbedo.g),mixedAlbedo.b);\nvec3 tint=clamp(maxChannel*mixedAlbedo,0.0,1.0);\n\nsurfaceAlbedoContribution*=alpha;\n\nenvironmentIrradiance*=alpha;\n\nsurfaceRefractionColor*=tint;\n\nalpha=1.0;\n#endif\n\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\nspecularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,alpha);\n\ntransmission*=1.0-specularEnvironmentReflectance;\n\nrefractance=surfaceRefractionColor*transmission;\n#endif\n\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\nrefractance*=vLightingIntensity.z;\nenvironmentRadiance*=specularEnvironmentReflectance;\n\nvec3 surfaceEmissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\nsurfaceEmissiveColor=toLinearSpace(emissiveColorTex.rgb)*surfaceEmissiveColor*vEmissiveInfos.y;\n#endif\n#ifdef OVERLOADEDVALUES\nsurfaceEmissiveColor=mix(surfaceEmissiveColor,vOverloadedEmissive,vOverloadedIntensity.w);\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nsurfaceEmissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=max(lightDiffuseContribution*surfaceAlbedoContribution+vAmbientColor,0.0)*surfaceAlbedo.rgb;\n#ifdef OVERLOADEDSHADOWVALUES\nshadowedOnlyLightDiffuseContribution=max(shadowedOnlyLightDiffuseContribution*surfaceAlbedoContribution+vAmbientColor,0.0)*surfaceAlbedo.rgb;\n#endif\n#else\n#ifdef LINKEMISSIVEWITHALBEDO\nvec3 finalDiffuse=max((lightDiffuseContribution+surfaceEmissiveColor)*surfaceAlbedoContribution+vAmbientColor,0.0)*surfaceAlbedo.rgb;\n#ifdef OVERLOADEDSHADOWVALUES\nshadowedOnlyLightDiffuseContribution=max((shadowedOnlyLightDiffuseContribution+surfaceEmissiveColor)*surfaceAlbedoContribution+vAmbientColor,0.0)*surfaceAlbedo.rgb;\n#endif\n#else\nvec3 finalDiffuse=max(lightDiffuseContribution*surfaceAlbedoContribution+surfaceEmissiveColor+vAmbientColor,0.0)*surfaceAlbedo.rgb;\n#ifdef OVERLOADEDSHADOWVALUES\nshadowedOnlyLightDiffuseContribution=max(shadowedOnlyLightDiffuseContribution*surfaceAlbedoContribution+surfaceEmissiveColor+vAmbientColor,0.0)*surfaceAlbedo.rgb;\n#endif\n#endif\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\nfinalDiffuse=mix(finalDiffuse,shadowedOnlyLightDiffuseContribution,(1.0-vOverloadedShadowIntensity.y));\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=lightSpecularContribution*surfaceReflectivityColor;\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+getLuminance(finalSpecular),0.,1.);\n#endif\n#ifdef RADIANCEOVERALPHA\nalpha=clamp(alpha+getLuminance(environmentRadiance),0.,1.);\n#endif\n\n\n#ifdef EMISSIVEASILLUMINATION\nvec4 finalColor=vec4(finalDiffuse*ambientColor*vLightingIntensity.x+surfaceAlbedo.rgb*environmentIrradiance+finalSpecular*vLightingIntensity.x+environmentRadiance+surfaceEmissiveColor*vLightingIntensity.y+refractance,alpha);\n#else\nvec4 finalColor=vec4(finalDiffuse*ambientColor*vLightingIntensity.x+surfaceAlbedo.rgb*environmentIrradiance+finalSpecular*vLightingIntensity.x+environmentRadiance+refractance,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\nfinalColor.rgb*=lightmapColor;\n#else\nfinalColor.rgb+=lightmapColor;\n#endif\n#endif\n#endif\nfinalColor=max(finalColor,0.0);\n#ifdef CAMERATONEMAP\nfinalColor.rgb=toneMaps(finalColor.rgb);\n#endif\nfinalColor.rgb=toGammaSpace(finalColor.rgb);\n#include<logDepthFragment>\n#include<fogFragment>(color,finalColor)\n#ifdef CAMERACONTRAST\nfinalColor=contrasts(finalColor);\n#endif\nfinalColor.rgb=clamp(finalColor.rgb,0.,1.);\n#ifdef CAMERACOLORGRADING\nfinalColor=colorGrades(finalColor);\n#endif\n#ifdef CAMERACOLORCURVES\nfinalColor.rgb=applyColorCurves(finalColor.rgb);\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngl_FragColor=finalColor;\n}",
		pbrVertexShader: "precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform mat4 albedoMatrix;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec3 vAmbientInfos;\n#endif\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(REFLECTIVITY) || defined(METALLICWORKFLOW) \nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform mat4 reflectivityMatrix;\n#endif\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<shadowsVertexDeclaration>[0..maxSimultaneousLights]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\nvoid main(void) {\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=position;\n#endif \n#include<instancesVertex>\n#include<bonesVertex>\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\nvec4 worldPos=finalWorld*vec4(position,1.0);\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef ALBEDO\nif (vAlbedoInfos.x == 0.)\n{\nvAlbedoUV=vec2(albedoMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef AMBIENT\nif (vAmbientInfos.x == 0.)\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef OPACITY\nif (vOpacityInfos.x == 0.)\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef EMISSIVE\nif (vEmissiveInfos.x == 0.)\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef LIGHTMAP\nif (vLightmapInfos.x == 0.)\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#if defined(REFLECTIVITY) || defined(METALLICWORKFLOW) \nif (vReflectivityInfos.x == 0.)\n{\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef BUMP\nif (vBumpInfos.x == 0.)\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv,1.0,0.0));\n}\nelse\n{\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\n}\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\nvColor=color;\n#endif\n\n#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif\n\n#include<logDepthVertex>\n}",
		postprocessVertexShader: "\nattribute vec2 position;\nuniform vec2 scale;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) { \nvUV=(position*madd+madd)*scale;\ngl_Position=vec4(position,0.0,1.0);\n}",
		proceduralVertexShader: "\nattribute vec2 position;\n\nvarying vec2 vPosition;\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\nvoid main(void) { \nvPosition=position;\nvUV=position*madd+madd;\ngl_Position=vec4(position,0.0,1.0);\n}",
		refractionPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform sampler2D refractionSampler;\n\nuniform vec3 baseColor;\nuniform float depth;\nuniform float colorLevel;\nvoid main() {\nfloat ref=1.0-texture2D(refractionSampler,vUV).r;\nvec2 uv=vUV-vec2(0.5);\nvec2 offset=uv*depth*ref;\nvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\ngl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\n}",
		shadowMapPixelShader: "#ifndef FULLFLOAT\nvec4 pack(float depth)\n{\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(depth*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\n\nvec2 packHalf(float depth) \n{ \nconst vec2 bitOffset=vec2(1.0/255.,0.);\nvec2 color=vec2(depth,fract(depth*255.));\nreturn color-(color.yy*bitOffset);\n}\n#endif\nvarying vec4 vPosition;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#ifdef CUBEMAP\nuniform vec3 lightPosition;\nuniform vec2 depthValues;\n#endif\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef CUBEMAP\nvec3 directionToLight=vPosition.xyz-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth-depthValues.x)/(depthValues.y-depthValues.x);\ndepth=clamp(depth,0.,1.0);\n#else\nfloat depth=vPosition.z/vPosition.w;\ndepth=depth*0.5+0.5;\n#endif\n#ifdef VSM\nfloat moment1=depth;\nfloat moment2=moment1*moment1;\n#ifndef FULLFLOAT\ngl_FragColor=vec4(packHalf(moment1),packHalf(moment2));\n#else\ngl_FragColor=vec4(moment1,moment2,1.0,1.0);\n#endif\n#else\n#ifndef FULLFLOAT\ngl_FragColor=pack(depth);\n#else\ngl_FragColor=vec4(depth,1.0,1.0,1.0);\n#endif\n#endif\n}",
		shadowMapVertexShader: "\nattribute vec3 position;\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nvarying vec4 vPosition;\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvoid main(void)\n{\n#include<instancesVertex>\n#include<bonesVertex>\n#ifdef CUBEMAP\nvPosition=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\n#else\nvPosition=viewProjection*finalWorld*vec4(position,1.0);\ngl_Position=vPosition;\n#endif\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}",
		spritesPixelShader: "uniform bool alphaTest;\nvarying vec4 vColor;\n\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n\n#include<fogFragmentDeclaration>\nvoid main(void) {\nvec4 color=texture2D(diffuseSampler,vUV);\nif (alphaTest) \n{\nif (color.a<0.95)\ndiscard;\n}\ncolor*=vColor;\n#include<fogFragment>\ngl_FragColor=color;\n}",
		spritesVertexShader: "\nattribute vec4 position;\nattribute vec4 options;\nattribute vec4 cellInfo;\nattribute vec4 color;\n\nuniform vec2 textureInfos;\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n#include<fogVertexDeclaration>\nvoid main(void) { \nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; \nvec2 cornerPos;\nfloat angle=position.w;\nvec2 size=vec2(options.x,options.y);\nvec2 offset=options.zw;\nvec2 uvScale=textureInfos.xy;\ncornerPos=vec2(offset.x-0.5,offset.y-0.5)*size;\n\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n\nviewPos+=rotatedCorner;\ngl_Position=projection*vec4(viewPos,1.0); \n\nvColor=color;\n\nvec2 uvOffset=vec2(abs(offset.x-cellInfo.x),1.0-abs(offset.y-cellInfo.y));\nvUV=(uvOffset+cellInfo.zw)*uvScale;\n\n#ifdef FOG\nfFogDistance=viewPos.z;\n#endif\n}",
		ssaoPixelShader: "\nuniform sampler2D textureSampler;\nvarying vec2 vUV;\n#ifdef SSAO\nuniform sampler2D randomSampler;\nuniform float randTextureTiles;\nuniform float samplesFactor;\nuniform vec3 sampleSphere[SAMPLES];\nuniform float totalStrength;\nuniform float radius;\nuniform float area;\nuniform float fallOff;\nuniform float base;\nvec3 normalFromDepth(float depth,vec2 coords)\n{\nvec2 offset1=vec2(0.0,radius);\nvec2 offset2=vec2(radius,0.0);\nfloat depth1=texture2D(textureSampler,coords+offset1).r;\nfloat depth2=texture2D(textureSampler,coords+offset2).r;\nvec3 p1=vec3(offset1,depth1-depth);\nvec3 p2=vec3(offset2,depth2-depth);\nvec3 normal=cross(p1,p2);\nnormal.z=-normal.z;\nreturn normalize(normal);\n}\nvoid main()\n{\nvec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);\nfloat depth=texture2D(textureSampler,vUV).r;\nvec3 position=vec3(vUV,depth);\nvec3 normal=normalFromDepth(depth,vUV);\nfloat radiusDepth=radius/depth;\nfloat occlusion=0.0;\nvec3 ray;\nvec3 hemiRay;\nfloat occlusionDepth;\nfloat difference;\nfor (int i=0; i<SAMPLES; i++)\n{\nray=radiusDepth*reflect(sampleSphere[i],random);\nhemiRay=position+sign(dot(ray,normal))*ray;\nocclusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;\ndifference=depth-occlusionDepth;\nocclusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));\n}\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\nfloat result=clamp(ao+base,0.0,1.0);\ngl_FragColor.r=result;\ngl_FragColor.g=result;\ngl_FragColor.b=result;\ngl_FragColor.a=1.0;\n}\n#endif\n#ifdef BILATERAL_BLUR\nuniform sampler2D depthSampler;\nuniform float outSize;\nuniform float samplerOffsets[SAMPLES];\nvoid main()\n{\nfloat texelsize=1.0/outSize;\nfloat compareDepth=texture2D(depthSampler,vUV).r;\nfloat result=0.0;\nfloat weightSum=0.0;\nfor (int i=0; i<SAMPLES; ++i)\n{\n#ifdef BILATERAL_BLUR_H\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\n#else\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\n#endif\nvec2 samplePos=vUV+sampleOffset;\nfloat sampleDepth=texture2D(depthSampler,samplePos).r;\nfloat weight=(1.0/(0.0001+abs(compareDepth-sampleDepth)));\nresult+=texture2D(textureSampler,samplePos).r*weight;\nweightSum+=weight;\n}\nresult/=weightSum;\ngl_FragColor.rgb=vec3(result);\ngl_FragColor.a=1.0;\n}\n#endif\n",
		ssaoCombinePixelShader: "uniform sampler2D textureSampler;\nuniform sampler2D originalColor;\nvarying vec2 vUV;\nvoid main(void) {\nvec4 ssaoColor=texture2D(textureSampler,vUV);\nvec4 sceneColor=texture2D(originalColor,vUV);\ngl_FragColor=sceneColor*ssaoColor;\n}\n",
		standardPixelShader: "uniform sampler2D textureSampler;\nvarying vec2 vUV;\n#if defined(PASS_POST_PROCESS)\nvoid main(void)\n{\nvec4 color=texture2D(textureSampler,vUV);\ngl_FragColor=color;\n}\n#endif\n#if defined(DOWN_SAMPLE_X4)\nuniform vec2 dsOffsets[16];\nvoid main(void)\n{\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\naverage/=16.0;\ngl_FragColor=average;\n}\n#endif\n#if defined(BRIGHT_PASS)\nuniform vec2 dsOffsets[4];\nuniform float brightThreshold;\nvoid main(void)\n{\nvec4 average=vec4(0.0,0.0,0.0,0.0);\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\naverage*=0.25;\nfloat luminance=length(average.rgb);\nif (luminance<brightThreshold) {\naverage=vec4(0.0,0.0,0.0,1.0);\n}\ngl_FragColor=average;\n}\n#endif\n#if defined(GAUSSIAN_BLUR_H) || defined(GAUSSIAN_BLUR_V)\nuniform float blurOffsets[9];\nuniform float blurWeights[9];\nuniform float blurWidth;\nvoid main(void)\n{\nvec4 color=vec4(0.0,0.0,0.0,0.0);\nfor (int i=0; i<9; i++) {\n#ifdef GAUSSIAN_BLUR_H\ncolor+=(texture2D(textureSampler,vUV+vec2(blurOffsets[i]*blurWidth,0.0))*blurWeights[i]);\ncolor+=(texture2D(textureSampler,vUV-vec2(blurOffsets[i]*blurWidth,0.0))*blurWeights[i]);\n#else\ncolor+=(texture2D(textureSampler,vUV+vec2(0.0,blurOffsets[i]*blurWidth))*blurWeights[i]);\ncolor+=(texture2D(textureSampler,vUV-vec2(0.0,blurOffsets[i]*blurWidth))*blurWeights[i]);\n#endif\n}\ncolor.a=1.0;\ngl_FragColor=color;\n}\n#endif\n#if defined(TEXTURE_ADDER)\nuniform sampler2D otherSampler;\nuniform sampler2D lensSampler;\nuniform float exposure;\nvoid main(void)\n{\nvec3 colour=texture2D(textureSampler,vUV).rgb;\ncolour*=exposure;\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\ncolour=retColor*retColor;\ncolour+=colour*texture2D(lensSampler,vUV).rgb;\nvec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);\ngl_FragColor=finalColor;\n}\n#endif\n#if defined(LENS_FLARE)\n#define GHOSTS 3\nuniform sampler2D lensColorSampler;\nuniform float strength;\nuniform float ghostDispersal;\nuniform float haloWidth;\nuniform vec2 resolution;\nuniform float distortionStrength;\nfloat hash(vec2 p)\n{\nfloat h=dot(p,vec2(127.1,311.7));\nreturn -1.0+2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(in vec2 p)\n{\nvec2 i=floor(p);\nvec2 f=fract(p);\nvec2 u=f*f*(3.0-2.0*f);\nreturn mix(mix(hash(i+vec2(0.0,0.0)),\nhash(i+vec2(1.0,0.0)),u.x),\nmix(hash(i+vec2(0.0,1.0)),\nhash(i+vec2(1.0,1.0)),u.x),u.y);\n}\nfloat fbm(vec2 p)\n{\nfloat f=0.0;\nf+=0.5000*noise(p); p*=2.02;\nf+=0.2500*noise(p); p*=2.03;\nf+=0.1250*noise(p); p*=2.01;\nf+=0.0625*noise(p); p*=2.04;\nf/=0.9375;\nreturn f;\n}\nvec3 pattern(vec2 uv)\n{\nvec2 p=-1.0+2.0*uv;\nfloat p2=dot(p,p);\nfloat f=fbm(vec2(15.0*p2))/2.0;\nfloat r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));\nfloat g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));\nfloat b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));\nreturn (1.0-f)*vec3(r,g,b);\n}\nfloat luminance(vec3 color)\n{\nreturn dot(color.rgb,vec3(0.2126,0.7152,0.0722));\n}\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\n{\nreturn vec4(\ntexture2D(tex,texcoord+direction*distortion.r).r,\ntexture2D(tex,texcoord+direction*distortion.g).g,\ntexture2D(tex,texcoord+direction*distortion.b).b,\n1.0\n);\n}\nvoid main(void)\n{\nvec2 uv=-vUV+vec2(1.0);\nvec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;\nvec2 texelSize=1.0/resolution;\nvec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);\nvec4 result=vec4(0.0);\nfloat ghostIndice=1.0;\nfor (int i=0; i<GHOSTS; ++i)\n{\nvec2 offset=fract(uv+ghostDir*ghostIndice);\nfloat weight=length(vec2(0.5)-offset)/length(vec2(0.5));\nweight=pow(1.0-weight,10.0);\nresult+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;\nghostIndice+=1.0;\n}\nvec2 haloVec=normalize(ghostDir)*haloWidth;\nfloat weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));\nweight=pow(1.0-weight,10.0);\nresult+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;\nresult*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));\ngl_FragColor=result;\n}\n#endif\n#if defined(LENS_FLARE_COMPOSE)\nuniform sampler2D otherSampler;\nuniform sampler2D lensDirtSampler;\nuniform sampler2D lensStarSampler;\nuniform mat4 lensStarMatrix;\nvoid main(void)\n{\nvec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;\nvec4 lensMod=texture2D(lensDirtSampler,vUV);\nlensMod+=texture2D(lensStarSampler,vUV);\nvec4 result=texture2D(textureSampler,vUV)*lensMod;\ngl_FragColor=texture2D(otherSampler,vUV)+result;\n}\n#endif\n#if defined(DEPTH_OF_FIELD)\nuniform sampler2D otherSampler;\nuniform sampler2D depthSampler;\nuniform float distance;\nvoid main(void)\n{\nvec4 sharp=texture2D(otherSampler,vUV);\nvec4 blur=texture2D(textureSampler,vUV);\nfloat dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);\nfloat factor=0.0;\nif (dist<0.05)\nfactor=1.0;\nelse if (dist<0.1)\nfactor=20.0*(0.1-dist);\nelse if (dist<0.5)\nfactor=0.0;\nelse\nfactor=2.0*(dist-0.5);\nfactor=clamp(factor,0.0,0.90);\ngl_FragColor=mix(sharp,blur,factor);\n}\n#endif\n",
		stereoscopicInterlacePixelShader: "const vec3 TWO=vec3(2.0,2.0,2.0);\nvarying vec2 vUV;\nuniform sampler2D camASampler;\nuniform sampler2D textureSampler;\nuniform vec2 stepSize;\nvoid main(void)\n{\nbool useCamB;\nvec2 texCoord1;\nvec2 texCoord2;\nvec3 frag1;\nvec3 frag2;\n#ifdef IS_STEREOSCOPIC_HORIZ\nuseCamB=vUV.x>0.5;\ntexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\ntexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\n#else\nuseCamB=vUV.y>0.5;\ntexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\ntexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\n#endif\n\nif (useCamB){\nfrag1=texture2D(textureSampler,texCoord1).rgb;\nfrag2=texture2D(textureSampler,texCoord2).rgb;\n}else{\nfrag1=texture2D(camASampler ,texCoord1).rgb;\nfrag2=texture2D(camASampler ,texCoord2).rgb;\n}\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);\n}",
		tonemapPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform float _ExposureAdjustment;\n#if defined(HABLE_TONEMAPPING)\nconst float A=0.15;\nconst float B=0.50;\nconst float C=0.10;\nconst float D=0.20;\nconst float E=0.02;\nconst float F=0.30;\nconst float W=11.2;\n#endif\nfloat Luminance(vec3 c)\n{\nreturn dot(c,vec3(0.22,0.707,0.071));\n}\nvoid main(void) \n{\nvec3 colour=texture2D(textureSampler,vUV).rgb;\n#if defined(REINHARD_TONEMAPPING)\nfloat lum=Luminance(colour.rgb); \nfloat lumTm=lum*_ExposureAdjustment;\nfloat scale=lumTm/(1.0+lumTm); \ncolour*=scale/lum;\n#elif defined(HABLE_TONEMAPPING)\ncolour*=_ExposureAdjustment;\nconst float ExposureBias=2.0;\nvec3 x=ExposureBias*colour;\nvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\nx=vec3(W,W,W);\nvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\ncolour=curr*whiteScale;\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\ncolour*=_ExposureAdjustment;\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\ncolour=retColor*retColor;\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\ncolour=vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\n#endif\ngl_FragColor=vec4(colour.rgb,1.0);\n}",
		volumetricLightScatteringPixelShader: "uniform sampler2D textureSampler;\nuniform sampler2D lightScatteringSampler;\nuniform float decay;\nuniform float exposure;\nuniform float weight;\nuniform float density;\nuniform vec2 meshPositionOnScreen;\nvarying vec2 vUV;\nvoid main(void) {\nvec2 tc=vUV;\nvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\ndeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\nfloat illuminationDecay=1.0;\nvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\nfor(int i=0; i<NUM_SAMPLES; i++) {\ntc-=deltaTexCoord;\nvec4 sample=texture2D(lightScatteringSampler,tc)*0.4;\nsample*=illuminationDecay*weight;\ncolor+=sample;\nilluminationDecay*=decay;\n}\nvec4 realColor=texture2D(textureSampler,vUV);\ngl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\n}\n",
		volumetricLightScatteringPassPixelShader: "#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\n#endif\n#if defined(ALPHATEST)\nuniform sampler2D diffuseSampler;\n#endif\nvoid main(void)\n{\n#if defined(ALPHATEST)\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\nif (diffuseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\n}\n",
		vrDistortionCorrectionPixelShader: "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 LensCenter;\nuniform vec2 Scale;\nuniform vec2 ScaleIn;\nuniform vec4 HmdWarpParam;\nvec2 HmdWarp(vec2 in01) {\nvec2 theta=(in01-LensCenter)*ScaleIn; \nfloat rSq=theta.x*theta.x+theta.y*theta.y;\nvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\nreturn LensCenter+Scale*rvector;\n}\nvoid main(void)\n{\nvec2 tc=HmdWarp(vUV);\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\nelse{\ngl_FragColor=vec4(texture2D(textureSampler,tc).rgb,1.0);\n}\n}"
	}, BABYLON.Effect.IncludesShadersStore = {
		bonesDeclaration: "#if NUM_BONE_INFLUENCERS>0\nuniform mat4 mBones[BonesPerMesh];\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#endif",
		bonesVertex: "#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif \n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif \nfinalWorld=finalWorld*influence;\n#endif",
		bumpFragment: "vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX)\nmat3 TBN=cotangent_frame(normalW*vBumpInfos.y,-viewDirectionW,vBumpUV);\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef BUMP\nnormalW=perturbNormal(viewDirectionW,TBN,vBumpUV+uvOffset);\n#endif",
		bumpFragmentFunctions: "#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec3 vBumpInfos;\nuniform sampler2D bumpSampler;\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\n{\n\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\n\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\n\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\nreturn mat3(tangent*invmax,binormal*invmax,normal);\n}\nvec3 perturbNormal(vec3 viewDir,mat3 cotangentFrame,vec2 uv)\n{\nvec3 map=texture2D(bumpSampler,uv).xyz;\n#ifdef INVERTNORMALMAPX\nmap.x=1.0-map.x;\n#endif\n#ifdef INVERTNORMALMAPY\nmap.y=1.0-map.y;\n#endif\nmap=map*255./127.-128./127.;\nreturn normalize(cotangentFrame*map);\n}\n#ifdef PARALLAX\nconst float minSamples=4.;\nconst float maxSamples=15.;\nconst int iMaxSamples=15;\n\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\nparallaxLimit*=parallaxScale;\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\nfloat stepSize=1.0/numSamples;\n\nfloat currRayHeight=1.0;\nvec2 vCurrOffset=vec2(0,0);\nvec2 vLastOffset=vec2(0,0);\nfloat lastSampledHeight=1.0;\nfloat currSampledHeight=1.0;\nfor (int i=0; i<iMaxSamples; i++)\n{\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\n\nif (currSampledHeight>currRayHeight)\n{\nfloat delta1=currSampledHeight-currRayHeight;\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\nfloat ratio=delta1/(delta1+delta2);\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\n\nbreak;\n}\nelse\n{\ncurrRayHeight-=stepSize;\nvLastOffset=vCurrOffset;\nvCurrOffset+=stepSize*vMaxOffset;\nlastSampledHeight=currSampledHeight;\n}\n}\nreturn vCurrOffset;\n}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{\n\nfloat height=texture2D(bumpSampler,vBumpUV).w;\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\nreturn -texCoordOffset;\n}\n#endif\n#endif",
		clipPlaneFragment: "#ifdef CLIPPLANE\nif (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif",
		clipPlaneFragmentDeclaration: "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif",
		clipPlaneVertex: "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif",
		clipPlaneVertexDeclaration: "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif",
		colorCurves: "const vec3 HDTVRec709_RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\nvec3 applyColorCurves(vec3 original) {\nvec3 result=original;\n\n\n\nfloat luma=dot(result.rgb,HDTVRec709_RGBLuminanceCoefficients);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0,0.0),vec2(1.0,1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma,luma,luma),result.rgb,colorCurve.a);\nreturn result;\n}",
		colorCurvesDefinition: "uniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\nuniform vec4 vCameraColorCurveNegative;",
		colorGrading: "vec4 colorGrades(vec4 color) \n{ \n\nfloat sliceContinuous=color.z*vCameraColorGradingInfos.z;\nfloat sliceInteger=floor(sliceContinuous);\n\n\nfloat sliceFraction=sliceContinuous-sliceInteger; \n\nvec2 sliceUV=color.xy*vCameraColorGradingScaleOffset.xy+vCameraColorGradingScaleOffset.zw;\n\n\nsliceUV.x+=sliceInteger*vCameraColorGradingInfos.w;\nvec4 slice0Color=texture2D(cameraColorGrading2DSampler,sliceUV);\nsliceUV.x+=vCameraColorGradingInfos.w;\nvec4 slice1Color=texture2D(cameraColorGrading2DSampler,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\ncolor.rgb=mix(color.rgb,result,vCameraColorGradingInfos.x);\nreturn color;\n}",
		colorGradingDefinition: "uniform sampler2D cameraColorGrading2DSampler;\nuniform vec4 vCameraColorGradingInfos;\nuniform vec4 vCameraColorGradingScaleOffset;",
		fogFragment: "#ifdef FOG\nfloat fog=CalcFogFactor();\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\n#endif",
		fogFragmentDeclaration: "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying float fFogDistance;\nfloat CalcFogFactor()\n{\nfloat fogCoeff=1.0;\nfloat fogStart=vFogInfos.y;\nfloat fogEnd=vFogInfos.z;\nfloat fogDensity=vFogInfos.w;\nif (FOGMODE_LINEAR == vFogInfos.x)\n{\nfogCoeff=(fogEnd-fFogDistance)/(fogEnd-fogStart);\n}\nelse if (FOGMODE_EXP == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fFogDistance*fogDensity);\n}\nelse if (FOGMODE_EXP2 == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fFogDistance*fFogDistance*fogDensity*fogDensity);\n}\nreturn clamp(fogCoeff,0.0,1.0);\n}\n#endif",
		fogVertex: "#ifdef FOG\nfFogDistance=(view*worldPos).z;\n#endif",
		fogVertexDeclaration: "#ifdef FOG\nvarying float fFogDistance;\n#endif",
		fresnelFunction: "#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\nreturn clamp(fresnelTerm,0.,1.);\n}\n#endif",
		harmonicsFunctions: "#ifdef USESPHERICALFROMREFLECTIONMAP\nuniform vec3 vSphericalX;\nuniform vec3 vSphericalY;\nuniform vec3 vSphericalZ;\nuniform vec3 vSphericalXX;\nuniform vec3 vSphericalYY;\nuniform vec3 vSphericalZZ;\nuniform vec3 vSphericalXY;\nuniform vec3 vSphericalYZ;\nuniform vec3 vSphericalZX;\nvec3 EnvironmentIrradiance(vec3 normal)\n{\n\n\n\nvec3 result =\nvSphericalX*normal.x +\nvSphericalY*normal.y +\nvSphericalZ*normal.z +\nvSphericalXX*normal.x*normal.x +\nvSphericalYY*normal.y*normal.y +\nvSphericalZZ*normal.z*normal.z +\nvSphericalYZ*normal.y*normal.z +\nvSphericalZX*normal.z*normal.x +\nvSphericalXY*normal.x*normal.y;\nreturn result.rgb;\n}\n#endif",
		helperFunctions: "mat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}",
		instancesDeclaration: "#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#else\nuniform mat4 world;\n#endif",
		instancesVertex: "#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#else\nmat4 finalWorld=world;\n#endif",
		lightFragment: "#ifdef LIGHT{X}\n#if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n#else\n#ifndef SPECULARTERM\nvec3 vLightSpecular{X}=vec3(0.);\n#endif\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,vLightData{X},vLightDirection{X},vLightDiffuse{X}.rgb,vLightSpecular{X},vLightDiffuse{X}.a,glossiness);\n#endif\n#ifdef HEMILIGHT{X}\ninfo=computeHemisphericLighting(viewDirectionW,normalW,vLightData{X},vLightDiffuse{X}.rgb,vLightSpecular{X},vLightGround{X},glossiness);\n#endif\n#if defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,vLightData{X},vLightDiffuse{X}.rgb,vLightSpecular{X},vLightDiffuse{X}.a,glossiness);\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWVSM{X}\nshadow=computeShadowWithVSM(vPositionFromLight{X},shadowSampler{X},shadowsInfo{X}.z,shadowsInfo{X}.x);\n#else\n#ifdef SHADOWPCF{X}\n#if defined(POINTLIGHT{X})\nshadow=computeShadowWithPCFCube(vLightData{X}.xyz,shadowSampler{X},shadowsInfo{X}.y,shadowsInfo{X}.z,shadowsInfo{X}.x);\n#else\nshadow=computeShadowWithPCF(vPositionFromLight{X},shadowSampler{X},shadowsInfo{X}.y,shadowsInfo{X}.z,shadowsInfo{X}.x);\n#endif\n#else\n#if defined(POINTLIGHT{X})\nshadow=computeShadowCube(vLightData{X}.xyz,shadowSampler{X},shadowsInfo{X}.x,shadowsInfo{X}.z);\n#else\nshadow=computeShadow(vPositionFromLight{X},shadowSampler{X},shadowsInfo{X}.x,shadowsInfo{X}.z);\n#endif\n#endif\n#endif\n#else\nshadow=1.;\n#endif\n#if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor;\n#endif\n#endif\n#else\ndiffuseBase+=info.diffuse*shadow;\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#endif\n#endif",
		lightFragmentDeclaration: "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec3 vLightSpecular{X};\n#endif\n#ifdef SHADOW{X}\n#if defined(SPOTLIGHT{X}) || defined(DIRLIGHT{X})\nvarying vec4 vPositionFromLight{X};\nuniform sampler2D shadowSampler{X};\n#else\nuniform samplerCube shadowSampler{X};\n#endif\nuniform vec3 shadowsInfo{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\n#endif\n#ifdef HEMILIGHT{X}\nuniform vec3 vLightGround{X};\n#endif\n#endif",
		lightsFragmentFunctions: "\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 lightVectorW;\nfloat attenuation=1.0;\nif (lightData.w == 0.)\n{\nvec3 direction=lightData.xyz-vPositionW;\nattenuation=max(0.,1.0-length(direction)/range);\nlightVectorW=normalize(direction);\n}\nelse\n{\nlightVectorW=normalize(-lightData.xyz);\n}\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 direction=lightData.xyz-vPositionW;\nvec3 lightVectorW=normalize(direction);\nfloat attenuation=max(0.,1.0-length(direction)/range);\n\nfloat cosAngle=max(0.,dot(-lightDirection.xyz,lightVectorW));\nif (cosAngle>=lightDirection.w)\n{\ncosAngle=max(0.,pow(cosAngle,lightData.w));\nattenuation*=cosAngle;\n\nfloat ndl=max(0.,dot(vNormal,-lightDirection.xyz));\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW-lightDirection.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\nlightingInfo result;\n\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor;\n#endif\nreturn result;\n}\n",
		logDepthDeclaration: "#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif",
		logDepthFragment: "#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif",
		logDepthVertex: "#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif",
		pbrFunctions: "\n#define RECIPROCAL_PI2 0.15915494\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n\nconst float kPi=3.1415926535897932384626433832795;\nconst float kRougnhessToAlphaScale=0.1;\nconst float kRougnhessToAlphaOffset=0.29248125;\nfloat Square(float value)\n{\nreturn value*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,vec3(0.2126,0.7152,0.0722)),0.,1.);\n}\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n\nconst float kMinimumVariance=0.0005;\nfloat alphaG=Square(roughness)+kMinimumVariance;\nreturn alphaG;\n}\n\nfloat getMipMapIndexFromAverageSlope(float maxMipLevel,float alpha)\n{\n\n\n\n\n\n\n\nfloat mip=kRougnhessToAlphaOffset+maxMipLevel+(maxMipLevel*kRougnhessToAlphaScale*log2(alpha));\nreturn clamp(mip,0.,maxMipLevel);\n}\nfloat getMipMapIndexFromAverageSlopeWithPMREM(float maxMipLevel,float alphaG)\n{\nfloat specularPower=clamp(2./alphaG-2.,0.000001,2048.);\n\nreturn clamp(- 0.5*log2(specularPower)+5.5,0.,maxMipLevel);\n}\n\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot,float alphaG)\n{\nfloat tanSquared=(1.0-dot*dot)/(dot*dot);\nreturn 2.0/(1.0+sqrt(1.0+alphaG*alphaG*tanSquared));\n}\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL,float NdotV,float alphaG)\n{\nreturn smithVisibilityG1_TrowbridgeReitzGGX(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGX(NdotV,alphaG);\n}\n\n\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\n{\n\n\n\nfloat a2=Square(alphaG);\nfloat d=NdotH*NdotH*(a2-1.0)+1.0;\nreturn a2/(kPi*d*d);\n}\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\n{\nreturn reflectance0+(reflectance90-reflectance0)*pow(clamp(1.0-VdotH,0.,1.),5.0);\n}\nvec3 FresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\n{\n\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow(clamp(1.0-VdotN,0.,1.),5.0);\n}\n\nvec3 computeSpecularTerm(float NdotH,float NdotL,float NdotV,float VdotH,float roughness,vec3 specularColor,vec3 reflectance90)\n{\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\nfloat visibility=smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL,NdotV,alphaG);\nvisibility/=(4.0*NdotL*NdotV); \nvec3 fresnel=fresnelSchlickGGX(VdotH,specularColor,reflectance90);\nfloat specTerm=max(0.,visibility*distribution)*NdotL;\nreturn fresnel*specTerm*kPi; \n}\nfloat computeDiffuseTerm(float NdotL,float NdotV,float VdotH,float roughness)\n{\n\n\nfloat diffuseFresnelNV=pow(clamp(1.0-NdotL,0.000001,1.),5.0);\nfloat diffuseFresnelNL=pow(clamp(1.0-NdotV,0.000001,1.),5.0);\nfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\nfloat diffuseFresnelTerm =\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\nreturn diffuseFresnelTerm*NdotL;\n\n\n}\nfloat adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance)\n{\n#ifdef USEPHYSICALLIGHTFALLOFF\n\nfloat lightRoughness=lightRadius/lightDistance;\n\nfloat totalRoughness=clamp(lightRoughness+roughness,0.,1.);\nreturn totalRoughness;\n#else\nreturn roughness;\n#endif\n}\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\n{\nfloat kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\nreturn microSurface;\n}\nvec3 toLinearSpace(vec3 color)\n{\nreturn vec3(pow(color.r,2.2),pow(color.g,2.2),pow(color.b,2.2));\n}\nvec3 toGammaSpace(vec3 color)\n{\nreturn vec3(pow(color.r,1.0/2.2),pow(color.g,1.0/2.2),pow(color.b,1.0/2.2));\n}\n#ifdef CAMERATONEMAP\nvec3 toneMaps(vec3 color)\n{\ncolor=max(color,0.0);\n\ncolor.rgb=color.rgb*vCameraInfos.x;\nfloat tuning=1.5; \n\n\nvec3 tonemapped=1.0-exp2(-color.rgb*tuning); \ncolor.rgb=mix(color.rgb,tonemapped,1.0);\nreturn color;\n}\n#endif\n#ifdef CAMERACONTRAST\nvec4 contrasts(vec4 color)\n{\ncolor=clamp(color,0.0,1.0);\nvec3 resultHighContrast=color.rgb*color.rgb*(3.0-2.0*color.rgb);\nfloat contrast=vCameraInfos.y;\nif (contrast<1.0)\n{\n\ncolor.rgb=mix(vec3(0.5,0.5,0.5),color.rgb,contrast);\n}\nelse\n{\n\ncolor.rgb=mix(color.rgb,resultHighContrast,contrast-1.0);\n}\nreturn color;\n}\n#endif",
		pbrLightFunctions: "\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n};\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range)\n{ \n#ifdef USEPHYSICALLIGHTFALLOFF\nfloat lightDistanceFalloff=1.0/((lightDistanceSquared+0.0001));\n#else\nfloat lightDistanceFalloff=max(0.,1.0-length(lightOffset)/range);\n#endif\nreturn lightDistanceFalloff;\n}\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngle,float exponent)\n{\nfloat falloff=0.0;\n#ifdef USEPHYSICALLIGHTFALLOFF\nfloat cosHalfAngle=cos(lightAngle*0.5);\nconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \n\n\n\n\n\nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\n\n\nvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\nfalloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\n#else\nfloat cosAngle=max(0.000000000000001,dot(-lightDirection,directionToLightCenterW));\nif (cosAngle>=lightAngle)\n{\nfalloff=max(0.,pow(cosAngle,exponent));\n}\n#endif\nreturn falloff;\n}\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float rangeRadius,float roughness,float NdotV,vec3 reflectance90,out float NdotL) {\nlightingInfo result;\nvec3 lightDirection;\nfloat attenuation=1.0;\nfloat lightDistance;\n\nif (lightData.w == 0.)\n{\nvec3 lightOffset=lightData.xyz-vPositionW;\nfloat lightDistanceSquared=dot(lightOffset,lightOffset);\nattenuation=computeDistanceLightFalloff(lightOffset,lightDistanceSquared,rangeRadius);\nlightDistance=sqrt(lightDistanceSquared);\nlightDirection=normalize(lightOffset);\n}\n\nelse\n{\nlightDistance=length(-lightData.xyz);\nlightDirection=normalize(-lightData.xyz);\n}\n\nroughness=adjustRoughnessFromLightProperties(roughness,rangeRadius,lightDistance);\n\nvec3 H=normalize(viewDirectionW+lightDirection);\nNdotL=max(0.00000000001,dot(vNormal,lightDirection));\nfloat VdotH=clamp(0.00000000001,1.0,dot(viewDirectionW,H));\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\nresult.diffuse=diffuseTerm*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nfloat NdotH=max(0.00000000001,dot(vNormal,H));\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,specularColor,reflectance90);\nresult.specular=specTerm*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float rangeRadius,float roughness,float NdotV,vec3 reflectance90,out float NdotL) {\nlightingInfo result;\nvec3 lightOffset=lightData.xyz-vPositionW;\nvec3 directionToLightCenterW=normalize(lightOffset);\n\nfloat lightDistanceSquared=dot(lightOffset,lightOffset);\nfloat attenuation=computeDistanceLightFalloff(lightOffset,lightDistanceSquared,rangeRadius);\n\nfloat directionalAttenuation=computeDirectionalLightFalloff(lightDirection.xyz,directionToLightCenterW,lightDirection.w,lightData.w);\nattenuation*=directionalAttenuation;\n\nfloat lightDistance=sqrt(lightDistanceSquared);\nroughness=adjustRoughnessFromLightProperties(roughness,rangeRadius,lightDistance);\n\nvec3 H=normalize(viewDirectionW-lightDirection.xyz);\nNdotL=max(0.00000000001,dot(vNormal,-lightDirection.xyz));\nfloat VdotH=clamp(dot(viewDirectionW,H),0.00000000001,1.0);\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\nresult.diffuse=diffuseTerm*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nfloat NdotH=max(0.00000000001,dot(vNormal,H));\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,specularColor,reflectance90);\nresult.specular=specTerm*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float roughness,float NdotV,vec3 reflectance90,out float NdotL) {\nlightingInfo result;\n\n\n\nNdotL=dot(vNormal,lightData.xyz)*0.5+0.5;\nresult.diffuse=mix(groundColor,diffuseColor,NdotL);\n#ifdef SPECULARTERM\n\nvec3 lightVectorW=normalize(lightData.xyz);\nvec3 H=normalize(viewDirectionW+lightVectorW);\nfloat NdotH=max(0.00000000001,dot(vNormal,H));\nNdotL=max(0.00000000001,NdotL);\nfloat VdotH=clamp(0.00000000001,1.0,dot(viewDirectionW,H));\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,specularColor,reflectance90);\nresult.specular=specTerm;\n#endif\nreturn result;\n}",
		pbrLightFunctionsCall: "#ifdef LIGHT{X}\n#if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n#else\n#ifndef SPECULARTERM\nvec3 vLightSpecular{X}=vec3(0.0);\n#endif\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,vLightData{X},vLightDirection{X},vLightDiffuse{X}.rgb,vLightSpecular{X},vLightDiffuse{X}.a,roughness,NdotV,specularEnvironmentR90,NdotL);\n#endif\n#ifdef HEMILIGHT{X}\ninfo=computeHemisphericLighting(viewDirectionW,normalW,vLightData{X},vLightDiffuse{X}.rgb,vLightSpecular{X},vLightGround{X},roughness,NdotV,specularEnvironmentR90,NdotL);\n#endif\n#if defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,vLightData{X},vLightDiffuse{X}.rgb,vLightSpecular{X},vLightDiffuse{X}.a,roughness,NdotV,specularEnvironmentR90,NdotL);\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWVSM{X}\nnotShadowLevel=computeShadowWithVSM(vPositionFromLight{X},shadowSampler{X},shadowsInfo{X}.z,shadowsInfo{X}.x);\n#else\n#ifdef SHADOWPCF{X}\n#if defined(POINTLIGHT{X})\nnotShadowLevel=computeShadowWithPCFCube(vLightData{X}.xyz,shadowSampler{X},shadowsInfo{X}.y,shadowsInfo{X}.z,shadowsInfo{X}.x);\n#else\nnotShadowLevel=computeShadowWithPCF(vPositionFromLight{X},shadowSampler{X},shadowsInfo{X}.y,shadowsInfo{X}.z,shadowsInfo{X}.x);\n#endif\n#else\n#if defined(POINTLIGHT{X})\nnotShadowLevel=computeShadowCube(vLightData{X}.xyz,shadowSampler{X},shadowsInfo{X}.x,shadowsInfo{X}.z);\n#else\nnotShadowLevel=computeShadow(vPositionFromLight{X},shadowSampler{X},shadowsInfo{X}.x,shadowsInfo{X}.z);\n#endif\n#endif\n#endif\n#else\nnotShadowLevel=1.;\n#endif\n#if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\nlightDiffuseContribution+=lightmapColor*notShadowLevel;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nlightSpecularContribution+=info.specular*notShadowLevel*lightmapColor;\n#endif\n#endif\n#else\nlightDiffuseContribution+=info.diffuse*notShadowLevel;\n#ifdef OVERLOADEDSHADOWVALUES\nif (NdotL<0.000000000011)\n{\nnotShadowLevel=1.;\n}\nshadowedOnlyLightDiffuseContribution*=notShadowLevel;\n#endif\n#ifdef SPECULARTERM\nlightSpecularContribution+=info.specular*notShadowLevel;\n#endif\n#endif\n#endif",
		pbrShadowFunctions: "\n#ifdef SHADOWS\n#ifndef SHADOWFULLFLOAT\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nuniform vec2 depthValues;\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float bias)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y =-directionToLight.y;\n#ifndef SHADOWFULLFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight))+bias;\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x+bias;\n#endif\nif (depth>shadow)\n{\n#ifdef OVERLOADEDSHADOWVALUES\nreturn mix(1.0,darkness,vOverloadedShadowIntensity.x);\n#else\nreturn darkness;\n#endif\n}\nreturn 1.0;\n}\nfloat computeShadowWithPCFCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float bias,float darkness)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth-depthValues.x)/(depthValues.y-depthValues.x);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n\nfloat biasedDepth=depth-bias;\n#ifndef SHADOWFULLFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<biasedDepth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<biasedDepth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<biasedDepth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<biasedDepth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<biasedDepth) visibility-=0.25;\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\nreturn min(1.0,mix(1.0,visibility+darkness,vOverloadedShadowIntensity.x));\n#else\nreturn min(1.0,visibility+darkness);\n#endif\n}\nfloat computeShadow(vec4 vPositionFromLight,sampler2D shadowSampler,float darkness,float bias)\n{\nvec3 depth=vPositionFromLight.xyz/vPositionFromLight.w;\ndepth=0.5*depth+vec3(0.5);\nvec2 uv=depth.xy;\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\n#ifndef SHADOWFULLFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv))+bias;\n#else\nfloat shadow=texture2D(shadowSampler,uv).x+bias;\n#endif\nif (depth.z>shadow)\n{\n#ifdef OVERLOADEDSHADOWVALUES\nreturn mix(1.0,darkness,vOverloadedShadowIntensity.x);\n#else\nreturn darkness;\n#endif\n}\nreturn 1.;\n}\nfloat computeShadowWithPCF(vec4 vPositionFromLight,sampler2D shadowSampler,float mapSize,float bias,float darkness)\n{\nvec3 depth=vPositionFromLight.xyz/vPositionFromLight.w;\ndepth=0.5*depth+vec3(0.5);\nvec2 uv=depth.xy;\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n\nfloat biasedDepth=depth.z-bias;\n#ifndef SHADOWFULLFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<biasedDepth) visibility-=0.25;\n#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<biasedDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<biasedDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<biasedDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<biasedDepth) visibility-=0.25;\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\nreturn min(1.0,mix(1.0,visibility+darkness,vOverloadedShadowIntensity.x));\n#else\nreturn min(1.0,visibility+darkness);\n#endif\n}\n#ifndef SHADOWFULLFLOAT\n\nfloat unpackHalf(vec2 color)\n{\nreturn color.x+(color.y/255.0);\n}\n#endif\nfloat linstep(float low,float high,float v) {\nreturn clamp((v-low)/(high-low),0.0,1.0);\n}\nfloat ChebychevInequality(vec2 moments,float compare,float bias)\n{\nfloat p=smoothstep(compare-bias,compare,moments.x);\nfloat variance=max(moments.y-moments.x*moments.x,0.02);\nfloat d=compare-moments.x;\nfloat p_max=linstep(0.2,1.0,variance/(variance+d*d));\nreturn clamp(max(p,p_max),0.0,1.0);\n}\nfloat computeShadowWithVSM(vec4 vPositionFromLight,sampler2D shadowSampler,float bias,float darkness)\n{\nvec3 depth=vPositionFromLight.xyz/vPositionFromLight.w;\ndepth=0.5*depth+vec3(0.5);\nvec2 uv=depth.xy;\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0 || depth.z>=1.0)\n{\nreturn 1.0;\n}\nvec4 texel=texture2D(shadowSampler,uv);\n#ifndef SHADOWFULLFLOAT\nvec2 moments=vec2(unpackHalf(texel.xy),unpackHalf(texel.zw));\n#else\nvec2 moments=texel.xy;\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\nreturn min(1.0,mix(1.0,1.0-ChebychevInequality(moments,depth.z,bias)+darkness,vOverloadedShadowIntensity.x));\n#else\nreturn min(1.0,1.0-ChebychevInequality(moments,depth.z,bias)+darkness);\n#endif\n}\n#endif",
		pointCloudVertex: "#ifdef POINTSIZE\ngl_PointSize=pointSize;\n#endif",
		pointCloudVertexDeclaration: "#ifdef POINTSIZE\nuniform float pointSize;\n#endif",
		reflectionFunction: "vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nfloat t=clamp(direction.y*-0.5+0.5,0.,1.0);\nfloat s=atan(direction.z,direction.x)*RECIPROCAL_PI2+0.5;\nreturn vec3(s,t,0);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nvec3 cameraToVertex=normalize(worldPos.xyz-vEyePosition);\nvec3 r=reflect(cameraToVertex,worldNormal);\nfloat t=clamp(r.y*-0.5+0.5,0.,1.0);\nfloat s=atan(r.z,r.x)*RECIPROCAL_PI2+0.5;\nreturn vec3(s,t,0);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nvec3 viewDir=worldPos.xyz-vEyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n#endif\n#ifdef REFLECTIONMAP_CUBIC\nvec3 viewDir=worldPos.xyz-vEyePosition;\nvec3 coords=reflect(viewDir,worldNormal);\n#ifdef INVERTCUBICMAP\ncoords.y=1.0-coords.y;\n#endif\nreturn vec3(reflectionMatrix*vec4(coords,0));\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn vec3(reflectionMatrix*(view*worldPos));\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn vPositionUVW;\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}",
		shadowsFragmentFunctions: "#ifdef SHADOWS\n#ifndef SHADOWFULLFLOAT\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nuniform vec2 depthValues;\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float bias)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth-depthValues.x)/(depthValues.y-depthValues.x);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFULLFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight))+bias;\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x+bias;\n#endif\nif (depth>shadow)\n{\nreturn darkness;\n}\nreturn 1.0;\n}\nfloat computeShadowWithPCFCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float bias,float darkness)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth-depthValues.x)/(depthValues.y-depthValues.x);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n\nfloat biasedDepth=depth-bias;\n#ifndef SHADOWFULLFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<biasedDepth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<biasedDepth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<biasedDepth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<biasedDepth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<biasedDepth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\nfloat computeShadow(vec4 vPositionFromLight,sampler2D shadowSampler,float darkness,float bias)\n{\nvec3 depth=vPositionFromLight.xyz/vPositionFromLight.w;\ndepth=0.5*depth+vec3(0.5);\nvec2 uv=depth.xy;\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\n#ifndef SHADOWFULLFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv))+bias;\n#else\nfloat shadow=texture2D(shadowSampler,uv).x+bias;\n#endif\nif (depth.z>shadow)\n{\nreturn darkness;\n}\nreturn 1.;\n}\nfloat computeShadowWithPCF(vec4 vPositionFromLight,sampler2D shadowSampler,float mapSize,float bias,float darkness)\n{\nvec3 depth=vPositionFromLight.xyz/vPositionFromLight.w;\ndepth=0.5*depth+vec3(0.5);\nvec2 uv=depth.xy;\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n\nfloat biasedDepth=depth.z-bias;\n#ifndef SHADOWFULLFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<biasedDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<biasedDepth) visibility-=0.25;\n#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<biasedDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<biasedDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<biasedDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<biasedDepth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\n#ifndef SHADOWFULLFLOAT\n\nfloat unpackHalf(vec2 color)\n{\nreturn color.x+(color.y/255.0);\n}\n#endif\nfloat linstep(float low,float high,float v) {\nreturn clamp((v-low)/(high-low),0.0,1.0);\n}\nfloat ChebychevInequality(vec2 moments,float compare,float bias)\n{\nfloat p=smoothstep(compare-bias,compare,moments.x);\nfloat variance=max(moments.y-moments.x*moments.x,0.02);\nfloat d=compare-moments.x;\nfloat p_max=linstep(0.2,1.0,variance/(variance+d*d));\nreturn clamp(max(p,p_max),0.0,1.0);\n}\nfloat computeShadowWithVSM(vec4 vPositionFromLight,sampler2D shadowSampler,float bias,float darkness)\n{\nvec3 depth=vPositionFromLight.xyz/vPositionFromLight.w;\ndepth=0.5*depth+vec3(0.5);\nvec2 uv=depth.xy;\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0 || depth.z>=1.0)\n{\nreturn 1.0;\n}\nvec4 texel=texture2D(shadowSampler,uv);\n#ifndef SHADOWFULLFLOAT\nvec2 moments=vec2(unpackHalf(texel.xy),unpackHalf(texel.zw));\n#else\nvec2 moments=texel.xy;\n#endif\nreturn min(1.0,1.0-ChebychevInequality(moments,depth.z,bias)+darkness);\n}\n#endif",
		shadowsVertex: "#ifdef SHADOWS\n#if defined(SPOTLIGHT{X}) || defined(DIRLIGHT{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#endif\n#endif",
		shadowsVertexDeclaration: "#ifdef SHADOWS\n#if defined(SPOTLIGHT{X}) || defined(DIRLIGHT{X})\nuniform mat4 lightMatrix{X};\nvarying vec4 vPositionFromLight{X};\n#endif\n#endif\n"
	}, BABYLON.CollisionWorker = 'var BABYLON;!function(t){var e=function(t,e,o,i){return!(t.x>o.x+i)&&(!(o.x-i>e.x)&&(!(t.y>o.y+i)&&(!(o.y-i>e.y)&&(!(t.z>o.z+i)&&!(o.z-i>e.z)))))},o=function(){var t={root:0,found:!1};return function(e,o,i,s){t.root=0,t.found=!1;var r=o*o-4*e*i;if(r<0)return t;var n=Math.sqrt(r),c=(-o-n)/(2*e),h=(-o+n)/(2*e);if(c>h){var a=h;h=c,c=a}return c>0&&c<s?(t.root=c,t.found=!0,t):h>0&&h<s?(t.root=h,t.found=!0,t):t}}(),i=function(){function i(){this.radius=new t.Vector3(1,1,1),this.retry=0,this.basePointWorld=t.Vector3.Zero(),this.velocityWorld=t.Vector3.Zero(),this.normalizedVelocity=t.Vector3.Zero(),this._collisionPoint=t.Vector3.Zero(),this._planeIntersectionPoint=t.Vector3.Zero(),this._tempVector=t.Vector3.Zero(),this._tempVector2=t.Vector3.Zero(),this._tempVector3=t.Vector3.Zero(),this._tempVector4=t.Vector3.Zero(),this._edge=t.Vector3.Zero(),this._baseToVertex=t.Vector3.Zero(),this._destinationPoint=t.Vector3.Zero(),this._slidePlaneNormal=t.Vector3.Zero(),this._displacementVector=t.Vector3.Zero()}return i.prototype._initialize=function(e,o,i){this.velocity=o,t.Vector3.NormalizeToRef(o,this.normalizedVelocity),this.basePoint=e,e.multiplyToRef(this.radius,this.basePointWorld),o.multiplyToRef(this.radius,this.velocityWorld),this.velocityWorldLength=this.velocityWorld.length(),this.epsilon=i,this.collisionFound=!1},i.prototype._checkPointInTriangle=function(e,o,i,s,r){o.subtractToRef(e,this._tempVector),i.subtractToRef(e,this._tempVector2),t.Vector3.CrossToRef(this._tempVector,this._tempVector2,this._tempVector4);var n=t.Vector3.Dot(this._tempVector4,r);return!(n<0)&&(s.subtractToRef(e,this._tempVector3),t.Vector3.CrossToRef(this._tempVector2,this._tempVector3,this._tempVector4),n=t.Vector3.Dot(this._tempVector4,r),!(n<0)&&(t.Vector3.CrossToRef(this._tempVector3,this._tempVector,this._tempVector4),n=t.Vector3.Dot(this._tempVector4,r),n>=0))},i.prototype._canDoCollision=function(o,i,s,r){var n=t.Vector3.Distance(this.basePointWorld,o),c=Math.max(this.radius.x,this.radius.y,this.radius.z);return!(n>this.velocityWorldLength+c+i)&&!!e(s,r,this.basePointWorld,this.velocityWorldLength+c)},i.prototype._testTriangle=function(e,i,s,r,n,c){var h,a=!1;i||(i=[]),i[e]||(i[e]=new t.Plane(0,0,0,0),i[e].copyFromPoints(s,r,n));var l=i[e];if(c||l.isFrontFacingTo(this.normalizedVelocity,0)){var _=l.signedDistanceTo(this.basePoint),d=t.Vector3.Dot(l.normal,this.velocity);if(0==d){if(Math.abs(_)>=1)return;a=!0,h=0}else{h=(-1-_)/d;var V=(1-_)/d;if(h>V){var u=V;V=h,h=u}if(h>1||V<0)return;h<0&&(h=0),h>1&&(h=1)}this._collisionPoint.copyFromFloats(0,0,0);var P=!1,p=1;if(a||(this.basePoint.subtractToRef(l.normal,this._planeIntersectionPoint),this.velocity.scaleToRef(h,this._tempVector),this._planeIntersectionPoint.addInPlace(this._tempVector),this._checkPointInTriangle(this._planeIntersectionPoint,s,r,n,l.normal)&&(P=!0,p=h,this._collisionPoint.copyFrom(this._planeIntersectionPoint))),!P){var f=this.velocity.lengthSquared(),m=f;this.basePoint.subtractToRef(s,this._tempVector);var T=2*t.Vector3.Dot(this.velocity,this._tempVector),b=this._tempVector.lengthSquared()-1,y=o(m,T,b,p);y.found&&(p=y.root,P=!0,this._collisionPoint.copyFrom(s)),this.basePoint.subtractToRef(r,this._tempVector),T=2*t.Vector3.Dot(this.velocity,this._tempVector),b=this._tempVector.lengthSquared()-1,y=o(m,T,b,p),y.found&&(p=y.root,P=!0,this._collisionPoint.copyFrom(r)),this.basePoint.subtractToRef(n,this._tempVector),T=2*t.Vector3.Dot(this.velocity,this._tempVector),b=this._tempVector.lengthSquared()-1,y=o(m,T,b,p),y.found&&(p=y.root,P=!0,this._collisionPoint.copyFrom(n)),r.subtractToRef(s,this._edge),s.subtractToRef(this.basePoint,this._baseToVertex);var g=this._edge.lengthSquared(),v=t.Vector3.Dot(this._edge,this.velocity),R=t.Vector3.Dot(this._edge,this._baseToVertex);if(m=g*-f+v*v,T=g*(2*t.Vector3.Dot(this.velocity,this._baseToVertex))-2*v*R,b=g*(1-this._baseToVertex.lengthSquared())+R*R,y=o(m,T,b,p),y.found){var D=(v*y.root-R)/g;D>=0&&D<=1&&(p=y.root,P=!0,this._edge.scaleInPlace(D),s.addToRef(this._edge,this._collisionPoint))}n.subtractToRef(r,this._edge),r.subtractToRef(this.basePoint,this._baseToVertex),g=this._edge.lengthSquared(),v=t.Vector3.Dot(this._edge,this.velocity),R=t.Vector3.Dot(this._edge,this._baseToVertex),m=g*-f+v*v,T=g*(2*t.Vector3.Dot(this.velocity,this._baseToVertex))-2*v*R,b=g*(1-this._baseToVertex.lengthSquared())+R*R,y=o(m,T,b,p),y.found&&(D=(v*y.root-R)/g,D>=0&&D<=1&&(p=y.root,P=!0,this._edge.scaleInPlace(D),r.addToRef(this._edge,this._collisionPoint))),s.subtractToRef(n,this._edge),n.subtractToRef(this.basePoint,this._baseToVertex),g=this._edge.lengthSquared(),v=t.Vector3.Dot(this._edge,this.velocity),R=t.Vector3.Dot(this._edge,this._baseToVertex),m=g*-f+v*v,T=g*(2*t.Vector3.Dot(this.velocity,this._baseToVertex))-2*v*R,b=g*(1-this._baseToVertex.lengthSquared())+R*R,y=o(m,T,b,p),y.found&&(D=(v*y.root-R)/g,D>=0&&D<=1&&(p=y.root,P=!0,this._edge.scaleInPlace(D),n.addToRef(this._edge,this._collisionPoint)))}if(P){var x=p*this.velocity.length();(!this.collisionFound||x<this.nearestDistance)&&(this.intersectionPoint?this.intersectionPoint.copyFrom(this._collisionPoint):this.intersectionPoint=this._collisionPoint.clone(),this.nearestDistance=x,this.collisionFound=!0)}}},i.prototype._collide=function(t,e,o,i,s,r,n){for(var c=i;c<s;c+=3){var h=e[o[c]-r],a=e[o[c+1]-r],l=e[o[c+2]-r];this._testTriangle(c,t,l,a,h,n)}},i.prototype._getResponse=function(e,o){e.addToRef(o,this._destinationPoint),o.scaleInPlace(this.nearestDistance/o.length()),this.basePoint.addToRef(o,e),e.subtractToRef(this.intersectionPoint,this._slidePlaneNormal),this._slidePlaneNormal.normalize(),this._slidePlaneNormal.scaleToRef(this.epsilon,this._displacementVector),e.addInPlace(this._displacementVector),this.intersectionPoint.addInPlace(this._displacementVector),this._slidePlaneNormal.scaleInPlace(t.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint,this._slidePlaneNormal,this._destinationPoint)),this._destinationPoint.subtractInPlace(this._slidePlaneNormal),this._destinationPoint.subtractToRef(this.intersectionPoint,o)},i}();t.Collider=i}(BABYLON||(BABYLON={}));var BABYLON;!function(o){o.WorkerIncluded=!0;var e=function(){function o(){this._meshes={},this._geometries={}}return o.prototype.getMeshes=function(){return this._meshes},o.prototype.getGeometries=function(){return this._geometries},o.prototype.getMesh=function(o){return this._meshes[o]},o.prototype.addMesh=function(o){this._meshes[o.uniqueId]=o},o.prototype.removeMesh=function(o){delete this._meshes[o]},o.prototype.getGeometry=function(o){return this._geometries[o]},o.prototype.addGeometry=function(o){this._geometries[o.id]=o},o.prototype.removeGeometry=function(o){delete this._geometries[o]},o}();o.CollisionCache=e;var i=function(){function e(e,i,r){this.collider=e,this._collisionCache=i,this.finalPosition=r,this.collisionsScalingMatrix=o.Matrix.Zero(),this.collisionTranformationMatrix=o.Matrix.Zero()}return e.prototype.collideWithWorld=function(o,e,i,r){var t=.01;if(this.collider.retry>=i)return void this.finalPosition.copyFrom(o);this.collider._initialize(o,e,t);for(var s,l=this._collisionCache.getMeshes(),n=Object.keys(l),a=n.length,c=0;c<a;++c)if(s=n[c],parseInt(s)!=r){var d=l[s];d.checkCollisions&&this.checkCollision(d)}return this.collider.collisionFound?(0===e.x&&0===e.y&&0===e.z||this.collider._getResponse(o,e),e.length()<=t?void this.finalPosition.copyFrom(o):(this.collider.retry++,void this.collideWithWorld(o,e,i,r))):void o.addToRef(e,this.finalPosition)},e.prototype.checkCollision=function(e){if(this.collider._canDoCollision(o.Vector3.FromArray(e.sphereCenter),e.sphereRadius,o.Vector3.FromArray(e.boxMinimum),o.Vector3.FromArray(e.boxMaximum))){o.Matrix.ScalingToRef(1/this.collider.radius.x,1/this.collider.radius.y,1/this.collider.radius.z,this.collisionsScalingMatrix);var i=o.Matrix.FromArray(e.worldMatrixFromCache);i.multiplyToRef(this.collisionsScalingMatrix,this.collisionTranformationMatrix),this.processCollisionsForSubMeshes(this.collisionTranformationMatrix,e)}},e.prototype.processCollisionsForSubMeshes=function(o,e){var i=e.subMeshes,r=i.length;if(!e.geometryId)return void console.log("no mesh geometry id");var t=this._collisionCache.getGeometry(e.geometryId);if(!t)return void console.log("couldn\'t find geometry",e.geometryId);for(var s=0;s<r;s++){var l=i[s];r>1&&!this.checkSubmeshCollision(l)||(this.collideForSubMesh(l,o,t),this.collider.collisionFound&&(this.collider.collidedMesh=e.uniqueId))}},e.prototype.collideForSubMesh=function(e,i,r){if(!r.positionsArray){r.positionsArray=[];for(var t=0,s=r.positions.length;t<s;t+=3){var l=o.Vector3.FromArray([r.positions[t],r.positions[t+1],r.positions[t+2]]);r.positionsArray.push(l)}}if(!e._lastColliderWorldVertices||!e._lastColliderTransformMatrix.equals(i)){e._lastColliderTransformMatrix=i.clone(),e._lastColliderWorldVertices=[],e._trianglePlanes=[];for(var n=e.verticesStart,a=e.verticesStart+e.verticesCount,t=n;t<a;t++)e._lastColliderWorldVertices.push(o.Vector3.TransformCoordinates(r.positionsArray[t],i))}this.collider._collide(e._trianglePlanes,e._lastColliderWorldVertices,r.indices,e.indexStart,e.indexStart+e.indexCount,e.verticesStart,e.hasMaterial)},e.prototype.checkSubmeshCollision=function(e){return this.collider._canDoCollision(o.Vector3.FromArray(e.sphereCenter),e.sphereRadius,o.Vector3.FromArray(e.boxMinimum),o.Vector3.FromArray(e.boxMaximum))},e}();o.CollideWorker=i;var r=function(){function r(){}return r.prototype.onInit=function(i){this._collisionCache=new e;var r={error:o.WorkerReplyType.SUCCESS,taskType:o.WorkerTaskType.INIT};postMessage(r,void 0)},r.prototype.onUpdate=function(e){var i=this,r={error:o.WorkerReplyType.SUCCESS,taskType:o.WorkerTaskType.UPDATE};try{for(var t in e.updatedGeometries)e.updatedGeometries.hasOwnProperty(t)&&this._collisionCache.addGeometry(e.updatedGeometries[t]);for(var s in e.updatedMeshes)e.updatedMeshes.hasOwnProperty(s)&&this._collisionCache.addMesh(e.updatedMeshes[s]);e.removedGeometries.forEach(function(o){i._collisionCache.removeGeometry(o)}),e.removedMeshes.forEach(function(o){i._collisionCache.removeMesh(o)})}catch(l){r.error=o.WorkerReplyType.UNKNOWN_ERROR}postMessage(r,void 0)},r.prototype.onCollision=function(e){var r=o.Vector3.Zero(),t=new o.Collider;t.radius=o.Vector3.FromArray(e.collider.radius);var s=new i(t,this._collisionCache,r);s.collideWithWorld(o.Vector3.FromArray(e.collider.position),o.Vector3.FromArray(e.collider.velocity),e.maximumRetry,e.excludedMeshUniqueId);var l={collidedMeshUniqueId:t.collidedMesh,collisionId:e.collisionId,newPosition:r.asArray()},n={error:o.WorkerReplyType.SUCCESS,taskType:o.WorkerTaskType.COLLIDE,payload:l};postMessage(n,void 0)},r}();o.CollisionDetectorTransferable=r;try{if(self&&self instanceof WorkerGlobalScope){window={},o.Collider||(importScripts("./babylon.collisionCoordinator.js"),importScripts("./babylon.collider.js"),importScripts("../Math/babylon.math.js"));var t=new r,s=function(e){var i=e.data;switch(i.taskType){case o.WorkerTaskType.INIT:t.onInit(i.payload);break;case o.WorkerTaskType.COLLIDE:t.onCollision(i.payload);break;case o.WorkerTaskType.UPDATE:t.onUpdate(i.payload)}};self.onmessage=s}}catch(l){console.log("single worker init")}}(BABYLON||(BABYLON={}));var BABYLON;!function(e){e.CollisionWorker="",function(e){e[e.INIT=0]="INIT",e[e.UPDATE=1]="UPDATE",e[e.COLLIDE=2]="COLLIDE"}(e.WorkerTaskType||(e.WorkerTaskType={}));var o=e.WorkerTaskType;!function(e){e[e.SUCCESS=0]="SUCCESS",e[e.UNKNOWN_ERROR=1]="UNKNOWN_ERROR"}(e.WorkerReplyType||(e.WorkerReplyType={}));var i=e.WorkerReplyType,t=function(){function t(){var r=this;this._scaledPosition=e.Vector3.Zero(),this._scaledVelocity=e.Vector3.Zero(),this.onMeshUpdated=function(e){r._addUpdateMeshesList[e.uniqueId]=t.SerializeMesh(e)},this.onGeometryUpdated=function(e){r._addUpdateGeometriesList[e.id]=t.SerializeGeometry(e)},this._afterRender=function(){if(r._init&&!(0==r._toRemoveGeometryArray.length&&0==r._toRemoveMeshesArray.length&&0==Object.keys(r._addUpdateGeometriesList).length&&0==Object.keys(r._addUpdateMeshesList).length||r._runningUpdated>4)){++r._runningUpdated;var e={updatedMeshes:r._addUpdateMeshesList,updatedGeometries:r._addUpdateGeometriesList,removedGeometries:r._toRemoveGeometryArray,removedMeshes:r._toRemoveMeshesArray},i={payload:e,taskType:o.UPDATE},t=[];for(var s in e.updatedGeometries)e.updatedGeometries.hasOwnProperty(s)&&(t.push(i.payload.updatedGeometries[s].indices.buffer),t.push(i.payload.updatedGeometries[s].normals.buffer),t.push(i.payload.updatedGeometries[s].positions.buffer));r._worker.postMessage(i,t),r._addUpdateMeshesList={},r._addUpdateGeometriesList={},r._toRemoveGeometryArray=[],r._toRemoveMeshesArray=[]}},this._onMessageFromWorker=function(t){var s=t.data;if(s.error!=i.SUCCESS)return void e.Tools.Warn("error returned from worker!");switch(s.taskType){case o.INIT:r._init=!0,r._scene.meshes.forEach(function(e){r.onMeshAdded(e)}),r._scene.getGeometries().forEach(function(e){r.onGeometryAdded(e)});break;case o.UPDATE:r._runningUpdated--;break;case o.COLLIDE:r._runningCollisionTask=!1;var n=s.payload;if(!r._collisionsCallbackArray[n.collisionId])return;r._collisionsCallbackArray[n.collisionId](n.collisionId,e.Vector3.FromArray(n.newPosition),r._scene.getMeshByUniqueID(n.collidedMeshUniqueId)),r._collisionsCallbackArray[n.collisionId]=void 0}},this._collisionsCallbackArray=[],this._init=!1,this._runningUpdated=0,this._runningCollisionTask=!1,this._addUpdateMeshesList={},this._addUpdateGeometriesList={},this._toRemoveGeometryArray=[],this._toRemoveMeshesArray=[]}return t.prototype.getNewPosition=function(e,i,t,r,s,n,a){if(this._init&&!this._collisionsCallbackArray[a]&&!this._collisionsCallbackArray[a+1e5]){e.divideToRef(t.radius,this._scaledPosition),i.divideToRef(t.radius,this._scaledVelocity),this._collisionsCallbackArray[a]=n;var d={collider:{position:this._scaledPosition.asArray(),velocity:this._scaledVelocity.asArray(),radius:t.radius.asArray()},collisionId:a,excludedMeshUniqueId:s?s.uniqueId:null,maximumRetry:r},l={payload:d,taskType:o.COLLIDE};this._worker.postMessage(l)}},t.prototype.init=function(i){this._scene=i,this._scene.registerAfterRender(this._afterRender);var t=e.WorkerIncluded?e.Engine.CodeRepository+"Collisions/babylon.collisionWorker.js":URL.createObjectURL(new Blob([e.CollisionWorker],{type:"application/javascript"}));this._worker=new Worker(t),this._worker.onmessage=this._onMessageFromWorker;var r={payload:{},taskType:o.INIT};this._worker.postMessage(r)},t.prototype.destroy=function(){this._scene.unregisterAfterRender(this._afterRender),this._worker.terminate()},t.prototype.onMeshAdded=function(e){e.registerAfterWorldMatrixUpdate(this.onMeshUpdated),this.onMeshUpdated(e)},t.prototype.onMeshRemoved=function(e){this._toRemoveMeshesArray.push(e.uniqueId)},t.prototype.onGeometryAdded=function(e){e.onGeometryUpdated=this.onGeometryUpdated,this.onGeometryUpdated(e)},t.prototype.onGeometryDeleted=function(e){this._toRemoveGeometryArray.push(e.id)},t.SerializeMesh=function(o){var i=[];o.subMeshes&&(i=o.subMeshes.map(function(e,o){return{position:o,verticesStart:e.verticesStart,verticesCount:e.verticesCount,indexStart:e.indexStart,indexCount:e.indexCount,hasMaterial:!!e.getMaterial(),sphereCenter:e.getBoundingInfo().boundingSphere.centerWorld.asArray(),sphereRadius:e.getBoundingInfo().boundingSphere.radiusWorld,boxMinimum:e.getBoundingInfo().boundingBox.minimumWorld.asArray(),boxMaximum:e.getBoundingInfo().boundingBox.maximumWorld.asArray()}}));var t=null;return o instanceof e.Mesh?t=o.geometry?o.geometry.id:null:o instanceof e.InstancedMesh&&(t=o.sourceMesh&&o.sourceMesh.geometry?o.sourceMesh.geometry.id:null),{uniqueId:o.uniqueId,id:o.id,name:o.name,geometryId:t,sphereCenter:o.getBoundingInfo().boundingSphere.centerWorld.asArray(),sphereRadius:o.getBoundingInfo().boundingSphere.radiusWorld,boxMinimum:o.getBoundingInfo().boundingBox.minimumWorld.asArray(),boxMaximum:o.getBoundingInfo().boundingBox.maximumWorld.asArray(),worldMatrixFromCache:o.worldMatrixFromCache.asArray(),subMeshes:i,checkCollisions:o.checkCollisions}},t.SerializeGeometry=function(o){return{id:o.id,positions:new Float32Array(o.getVerticesData(e.VertexBuffer.PositionKind)||[]),normals:new Float32Array(o.getVerticesData(e.VertexBuffer.NormalKind)||[]),indices:new Int32Array(o.getIndices()||[])}},t}();e.CollisionCoordinatorWorker=t;var r=function(){function o(){this._scaledPosition=e.Vector3.Zero(),this._scaledVelocity=e.Vector3.Zero(),this._finalPosition=e.Vector3.Zero()}return o.prototype.getNewPosition=function(e,o,i,t,r,s,n){e.divideToRef(i.radius,this._scaledPosition),o.divideToRef(i.radius,this._scaledVelocity),i.collidedMesh=null,i.retry=0,i.initialVelocity=this._scaledVelocity,i.initialPosition=this._scaledPosition,this._collideWithWorld(this._scaledPosition,this._scaledVelocity,i,t,this._finalPosition,r),this._finalPosition.multiplyInPlace(i.radius),s(n,this._finalPosition,i.collidedMesh)},o.prototype.init=function(e){this._scene=e},o.prototype.destroy=function(){},o.prototype.onMeshAdded=function(e){},o.prototype.onMeshUpdated=function(e){},o.prototype.onMeshRemoved=function(e){},o.prototype.onGeometryAdded=function(e){},o.prototype.onGeometryUpdated=function(e){},o.prototype.onGeometryDeleted=function(e){},o.prototype._collideWithWorld=function(o,i,t,r,s,n){void 0===n&&(n=null);var a=10*e.Engine.CollisionsEpsilon;if(t.retry>=r)return void s.copyFrom(o);t._initialize(o,i,a);for(var d=0;d<this._scene.meshes.length;d++){var l=this._scene.meshes[d];l.isEnabled()&&l.checkCollisions&&l.subMeshes&&l!==n&&l._checkCollision(t)}return t.collisionFound?(0===i.x&&0===i.y&&0===i.z||t._getResponse(o,i),i.length()<=a?void s.copyFrom(o):(t.retry++,void this._collideWithWorld(o,i,t,r,s,n))):void o.addToRef(i,s)},o}();e.CollisionCoordinatorLegacy=r}(BABYLON||(BABYLON={}));var BABYLON;!function(t){t.ToGammaSpace=1/2.2,t.ToLinearSpace=2.2,t.Epsilon=.001;var i=function(){function t(){}return t.WithinEpsilon=function(t,i,n){void 0===n&&(n=1.401298e-45);var r=t-i;return-n<=r&&r<=n},t.ToHex=function(t){var i=t.toString(16);return t<=15?("0"+i).toUpperCase():i.toUpperCase()},t.Sign=function(t){return t=+t,0===t||isNaN(t)?t:t>0?1:-1},t.Clamp=function(t,i,n){return void 0===i&&(i=0),void 0===n&&(n=1),Math.min(n,Math.max(i,t))},t}();t.MathTools=i;var n=function(){function n(t,i,n){void 0===t&&(t=0),void 0===i&&(i=0),void 0===n&&(n=0),this.r=t,this.g=i,this.b=n}return n.prototype.toString=function(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"},n.prototype.getClassName=function(){return"Color3"},n.prototype.getHashCode=function(){var t=this.r||0;return t=397*t^(this.g||0),t=397*t^(this.b||0)},n.prototype.toArray=function(t,i){return void 0===i&&(i=0),t[i]=this.r,t[i+1]=this.g,t[i+2]=this.b,this},n.prototype.toColor4=function(t){return void 0===t&&(t=1),new r(this.r,this.g,this.b,t)},n.prototype.asArray=function(){var t=[];return this.toArray(t,0),t},n.prototype.toLuminance=function(){return.3*this.r+.59*this.g+.11*this.b},n.prototype.multiply=function(t){return new n(this.r*t.r,this.g*t.g,this.b*t.b)},n.prototype.multiplyToRef=function(t,i){return i.r=this.r*t.r,i.g=this.g*t.g,i.b=this.b*t.b,this},n.prototype.equals=function(t){return t&&this.r===t.r&&this.g===t.g&&this.b===t.b},n.prototype.equalsFloats=function(t,i,n){return this.r===t&&this.g===i&&this.b===n},n.prototype.scale=function(t){return new n(this.r*t,this.g*t,this.b*t)},n.prototype.scaleToRef=function(t,i){return i.r=this.r*t,i.g=this.g*t,i.b=this.b*t,this},n.prototype.add=function(t){return new n(this.r+t.r,this.g+t.g,this.b+t.b)},n.prototype.addToRef=function(t,i){return i.r=this.r+t.r,i.g=this.g+t.g,i.b=this.b+t.b,this},n.prototype.subtract=function(t){return new n(this.r-t.r,this.g-t.g,this.b-t.b)},n.prototype.subtractToRef=function(t,i){return i.r=this.r-t.r,i.g=this.g-t.g,i.b=this.b-t.b,this},n.prototype.clone=function(){return new n(this.r,this.g,this.b)},n.prototype.copyFrom=function(t){return this.r=t.r,this.g=t.g,this.b=t.b,this},n.prototype.copyFromFloats=function(t,i,n){return this.r=t,this.g=i,this.b=n,this},n.prototype.toHexString=function(){var t=255*this.r|0,n=255*this.g|0,r=255*this.b|0;return"#"+i.ToHex(t)+i.ToHex(n)+i.ToHex(r)},n.prototype.toLinearSpace=function(){var t=new n;return this.toLinearSpaceToRef(t),t},n.prototype.toLinearSpaceToRef=function(i){return i.r=Math.pow(this.r,t.ToLinearSpace),i.g=Math.pow(this.g,t.ToLinearSpace),i.b=Math.pow(this.b,t.ToLinearSpace),this},n.prototype.toGammaSpace=function(){var t=new n;return this.toGammaSpaceToRef(t),t},n.prototype.toGammaSpaceToRef=function(i){return i.r=Math.pow(this.r,t.ToGammaSpace),i.g=Math.pow(this.g,t.ToGammaSpace),i.b=Math.pow(this.b,t.ToGammaSpace),this},n.FromHexString=function(t){if("#"!==t.substring(0,1)||7!==t.length)return new n(0,0,0);var i=parseInt(t.substring(1,3),16),r=parseInt(t.substring(3,5),16),o=parseInt(t.substring(5,7),16);return n.FromInts(i,r,o)},n.FromArray=function(t,i){return void 0===i&&(i=0),new n(t[i],t[i+1],t[i+2])},n.FromInts=function(t,i,r){return new n(t/255,i/255,r/255)},n.Lerp=function(t,i,r){var o=t.r+(i.r-t.r)*r,e=t.g+(i.g-t.g)*r,s=t.b+(i.b-t.b)*r;return new n(o,e,s)},n.Red=function(){return new n(1,0,0)},n.Green=function(){return new n(0,1,0)},n.Blue=function(){return new n(0,0,1)},n.Black=function(){return new n(0,0,0)},n.White=function(){return new n(1,1,1)},n.Purple=function(){return new n(.5,0,.5)},n.Magenta=function(){return new n(1,0,1)},n.Yellow=function(){return new n(1,1,0)},n.Gray=function(){return new n(.5,.5,.5)},n}();t.Color3=n;var r=function(){function t(t,i,n,r){this.r=t,this.g=i,this.b=n,this.a=r}return t.prototype.addInPlace=function(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this},t.prototype.asArray=function(){var t=[];return this.toArray(t,0),t},t.prototype.toArray=function(t,i){return void 0===i&&(i=0),t[i]=this.r,t[i+1]=this.g,t[i+2]=this.b,t[i+3]=this.a,this},t.prototype.add=function(i){return new t(this.r+i.r,this.g+i.g,this.b+i.b,this.a+i.a)},t.prototype.subtract=function(i){return new t(this.r-i.r,this.g-i.g,this.b-i.b,this.a-i.a)},t.prototype.subtractToRef=function(t,i){return i.r=this.r-t.r,i.g=this.g-t.g,i.b=this.b-t.b,i.a=this.a-t.a,this},t.prototype.scale=function(i){return new t(this.r*i,this.g*i,this.b*i,this.a*i)},t.prototype.scaleToRef=function(t,i){return i.r=this.r*t,i.g=this.g*t,i.b=this.b*t,i.a=this.a*t,this},t.prototype.multiply=function(i){return new t(this.r*i.r,this.g*i.g,this.b*i.b,this.a*i.a)},t.prototype.multiplyToRef=function(t,i){return i.r=this.r*t.r,i.g=this.g*t.g,i.b=this.b*t.b,i.a=this.a*t.a,i},t.prototype.toString=function(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"},t.prototype.getClassName=function(){return"Color4"},t.prototype.getHashCode=function(){var t=this.r||0;return t=397*t^(this.g||0),t=397*t^(this.b||0),t=397*t^(this.a||0)},t.prototype.clone=function(){return new t(this.r,this.g,this.b,this.a)},t.prototype.copyFrom=function(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this},t.prototype.toHexString=function(){var t=255*this.r|0,n=255*this.g|0,r=255*this.b|0,o=255*this.a|0;return"#"+i.ToHex(t)+i.ToHex(n)+i.ToHex(r)+i.ToHex(o)},t.FromHexString=function(i){if("#"!==i.substring(0,1)||9!==i.length)return new t(0,0,0,0);var n=parseInt(i.substring(1,3),16),r=parseInt(i.substring(3,5),16),o=parseInt(i.substring(5,7),16),e=parseInt(i.substring(7,9),16);return t.FromInts(n,r,o,e)},t.Lerp=function(i,n,r){var o=new t(0,0,0,0);return t.LerpToRef(i,n,r,o),o},t.LerpToRef=function(t,i,n,r){r.r=t.r+(i.r-t.r)*n,r.g=t.g+(i.g-t.g)*n,r.b=t.b+(i.b-t.b)*n,r.a=t.a+(i.a-t.a)*n},t.FromArray=function(i,n){return void 0===n&&(n=0),new t(i[n],i[n+1],i[n+2],i[n+3])},t.FromInts=function(i,n,r,o){return new t(i/255,n/255,r/255,o/255)},t.CheckColors4=function(t,i){if(t.length===3*i){for(var n=[],r=0;r<t.length;r+=3){var o=r/3*4;n[o]=t[r],n[o+1]=t[r+1],n[o+2]=t[r+2],n[o+3]=1}return n}return t},t}();t.Color4=r;var o=function(){function n(t,i){this.x=t,this.y=i}return n.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+"}"},n.prototype.getClassName=function(){return"Vector2"},n.prototype.getHashCode=function(){var t=this.x||0;return t=397*t^(this.y||0)},n.prototype.toArray=function(t,i){return void 0===i&&(i=0),t[i]=this.x,t[i+1]=this.y,this},n.prototype.asArray=function(){var t=[];return this.toArray(t,0),t},n.prototype.copyFrom=function(t){return this.x=t.x,this.y=t.y,this},n.prototype.copyFromFloats=function(t,i){return this.x=t,this.y=i,this},n.prototype.add=function(t){return new n(this.x+t.x,this.y+t.y)},n.prototype.addToRef=function(t,i){return i.x=this.x+t.x,i.y=this.y+t.y,this},n.prototype.addInPlace=function(t){return this.x+=t.x,this.y+=t.y,this},n.prototype.addVector3=function(t){return new n(this.x+t.x,this.y+t.y)},n.prototype.subtract=function(t){return new n(this.x-t.x,this.y-t.y)},n.prototype.subtractToRef=function(t,i){return i.x=this.x-t.x,i.y=this.y-t.y,this},n.prototype.subtractInPlace=function(t){return this.x-=t.x,this.y-=t.y,this},n.prototype.multiplyInPlace=function(t){return this.x*=t.x,this.y*=t.y,this},n.prototype.multiply=function(t){return new n(this.x*t.x,this.y*t.y)},n.prototype.multiplyToRef=function(t,i){return i.x=this.x*t.x,i.y=this.y*t.y,this},n.prototype.multiplyByFloats=function(t,i){return new n(this.x*t,this.y*i)},n.prototype.divide=function(t){return new n(this.x/t.x,this.y/t.y)},n.prototype.divideToRef=function(t,i){return i.x=this.x/t.x,i.y=this.y/t.y,this},n.prototype.negate=function(){return new n((-this.x),(-this.y))},n.prototype.scaleInPlace=function(t){return this.x*=t,this.y*=t,this},n.prototype.scale=function(t){return new n(this.x*t,this.y*t)},n.prototype.equals=function(t){return t&&this.x===t.x&&this.y===t.y},n.prototype.equalsWithEpsilon=function(n,r){return void 0===r&&(r=t.Epsilon),n&&i.WithinEpsilon(this.x,n.x,r)&&i.WithinEpsilon(this.y,n.y,r)},n.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},n.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y},n.prototype.normalize=function(){var t=this.length();if(0===t)return this;var i=1/t;return this.x*=i,this.y*=i,this},n.prototype.clone=function(){return new n(this.x,this.y)},n.Zero=function(){return new n(0,0)},n.FromArray=function(t,i){return void 0===i&&(i=0),new n(t[i],t[i+1])},n.FromArrayToRef=function(t,i,n){n.x=t[i],n.y=t[i+1]},n.CatmullRom=function(t,i,r,o,e){var s=e*e,h=e*s,a=.5*(2*i.x+(-t.x+r.x)*e+(2*t.x-5*i.x+4*r.x-o.x)*s+(-t.x+3*i.x-3*r.x+o.x)*h),u=.5*(2*i.y+(-t.y+r.y)*e+(2*t.y-5*i.y+4*r.y-o.y)*s+(-t.y+3*i.y-3*r.y+o.y)*h);return new n(a,u)},n.Clamp=function(t,i,r){var o=t.x;o=o>r.x?r.x:o,o=o<i.x?i.x:o;var e=t.y;return e=e>r.y?r.y:e,e=e<i.y?i.y:e,new n(o,e)},n.Hermite=function(t,i,r,o,e){var s=e*e,h=e*s,a=2*h-3*s+1,u=-2*h+3*s,m=h-2*s+e,y=h-s,c=t.x*a+r.x*u+i.x*m+o.x*y,p=t.y*a+r.y*u+i.y*m+o.y*y;return new n(c,p)},n.Lerp=function(t,i,r){var o=t.x+(i.x-t.x)*r,e=t.y+(i.y-t.y)*r;return new n(o,e)},n.Dot=function(t,i){return t.x*i.x+t.y*i.y},n.Normalize=function(t){var i=t.clone();return i.normalize(),i},n.Minimize=function(t,i){var r=t.x<i.x?t.x:i.x,o=t.y<i.y?t.y:i.y;return new n(r,o)},n.Maximize=function(t,i){var r=t.x>i.x?t.x:i.x,o=t.y>i.y?t.y:i.y;return new n(r,o)},n.Transform=function(t,i){var r=n.Zero();return n.TransformToRef(t,i,r),r},n.TransformToRef=function(t,i,n){var r=t.x*i.m[0]+t.y*i.m[4]+i.m[12],o=t.x*i.m[1]+t.y*i.m[5]+i.m[13];n.x=r,n.y=o},n.PointInTriangle=function(t,i,n,r){var o=.5*(-n.y*r.x+i.y*(-n.x+r.x)+i.x*(n.y-r.y)+n.x*r.y),e=o<0?-1:1,s=(i.y*r.x-i.x*r.y+(r.y-i.y)*t.x+(i.x-r.x)*t.y)*e,h=(i.x*n.y-i.y*n.x+(i.y-n.y)*t.x+(n.x-i.x)*t.y)*e;return s>0&&h>0&&s+h<2*o*e},n.Distance=function(t,i){return Math.sqrt(n.DistanceSquared(t,i))},n.DistanceSquared=function(t,i){var n=t.x-i.x,r=t.y-i.y;return n*n+r*r},n.Center=function(t,i){var n=t.add(i);return n.scaleInPlace(.5),n},n.DistanceOfPointFromSegment=function(t,i,r){var o=n.DistanceSquared(i,r);if(0===o)return n.Distance(t,i);var e=r.subtract(i),s=Math.max(0,Math.min(1,n.Dot(t.subtract(i),e)/o)),h=i.add(e.multiplyByFloats(s,s));return n.Distance(t,h)},n}();t.Vector2=o;var e=function(){function n(t,i,n){this.x=t,this.y=i,this.z=n}return n.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+"}"},n.prototype.getClassName=function(){return"Vector3"},n.prototype.getHashCode=function(){var t=this.x||0;return t=397*t^(this.y||0),t=397*t^(this.z||0)},n.prototype.asArray=function(){var t=[];return this.toArray(t,0),t},n.prototype.toArray=function(t,i){return void 0===i&&(i=0),t[i]=this.x,t[i+1]=this.y,t[i+2]=this.z,this},n.prototype.toQuaternion=function(){var t=new a(0,0,0,1),i=Math.cos(.5*(this.x+this.z)),n=Math.sin(.5*(this.x+this.z)),r=Math.cos(.5*(this.z-this.x)),o=Math.sin(.5*(this.z-this.x)),e=Math.cos(.5*this.y),s=Math.sin(.5*this.y);return t.x=r*s,t.y=-o*s,t.z=n*e,t.w=i*e,t},n.prototype.addInPlace=function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this},n.prototype.add=function(t){return new n(this.x+t.x,this.y+t.y,this.z+t.z)},n.prototype.addToRef=function(t,i){return i.x=this.x+t.x,i.y=this.y+t.y,i.z=this.z+t.z,this},n.prototype.subtractInPlace=function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this},n.prototype.subtract=function(t){return new n(this.x-t.x,this.y-t.y,this.z-t.z)},n.prototype.subtractToRef=function(t,i){return i.x=this.x-t.x,i.y=this.y-t.y,i.z=this.z-t.z,this},n.prototype.subtractFromFloats=function(t,i,r){return new n(this.x-t,this.y-i,this.z-r)},n.prototype.subtractFromFloatsToRef=function(t,i,n,r){return r.x=this.x-t,r.y=this.y-i,r.z=this.z-n,this},n.prototype.negate=function(){return new n((-this.x),(-this.y),(-this.z))},n.prototype.scaleInPlace=function(t){return this.x*=t,this.y*=t,this.z*=t,this},n.prototype.scale=function(t){return new n(this.x*t,this.y*t,this.z*t)},n.prototype.scaleToRef=function(t,i){i.x=this.x*t,i.y=this.y*t,i.z=this.z*t},n.prototype.equals=function(t){return t&&this.x===t.x&&this.y===t.y&&this.z===t.z},n.prototype.equalsWithEpsilon=function(n,r){return void 0===r&&(r=t.Epsilon),n&&i.WithinEpsilon(this.x,n.x,r)&&i.WithinEpsilon(this.y,n.y,r)&&i.WithinEpsilon(this.z,n.z,r)},n.prototype.equalsToFloats=function(t,i,n){return this.x===t&&this.y===i&&this.z===n},n.prototype.multiplyInPlace=function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this},n.prototype.multiply=function(t){return new n(this.x*t.x,this.y*t.y,this.z*t.z)},n.prototype.multiplyToRef=function(t,i){return i.x=this.x*t.x,i.y=this.y*t.y,i.z=this.z*t.z,this},n.prototype.multiplyByFloats=function(t,i,r){return new n(this.x*t,this.y*i,this.z*r)},n.prototype.divide=function(t){return new n(this.x/t.x,this.y/t.y,this.z/t.z)},n.prototype.divideToRef=function(t,i){return i.x=this.x/t.x,i.y=this.y/t.y,i.z=this.z/t.z,this},n.prototype.MinimizeInPlace=function(t){return t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z),this},n.prototype.MaximizeInPlace=function(t){return t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z),this},n.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},n.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y+this.z*this.z},n.prototype.normalize=function(){var t=this.length();if(0===t||1===t)return this;var i=1/t;return this.x*=i,this.y*=i,this.z*=i,this},n.prototype.clone=function(){return new n(this.x,this.y,this.z)},n.prototype.copyFrom=function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this},n.prototype.copyFromFloats=function(t,i,n){return this.x=t,this.y=i,this.z=n,this},n.GetClipFactor=function(t,i,r,o){var e=n.Dot(t,r)-o,s=n.Dot(i,r)-o,h=e/(e-s);return h},n.FromArray=function(t,i){return i||(i=0),new n(t[i],t[i+1],t[i+2])},n.FromFloatArray=function(t,i){return i||(i=0),new n(t[i],t[i+1],t[i+2])},n.FromArrayToRef=function(t,i,n){n.x=t[i],n.y=t[i+1],n.z=t[i+2]},n.FromFloatArrayToRef=function(t,i,n){n.x=t[i],n.y=t[i+1],n.z=t[i+2]},n.FromFloatsToRef=function(t,i,n,r){r.x=t,r.y=i,r.z=n},n.Zero=function(){return new n(0,0,0)},n.Up=function(){return new n(0,1,0)},n.Forward=function(){return new n(0,0,1)},n.Right=function(){return new n(1,0,0)},n.Left=function(){return new n((-1),0,0)},n.TransformCoordinates=function(t,i){var r=n.Zero();return n.TransformCoordinatesToRef(t,i,r),r},n.TransformCoordinatesToRef=function(t,i,n){var r=t.x*i.m[0]+t.y*i.m[4]+t.z*i.m[8]+i.m[12],o=t.x*i.m[1]+t.y*i.m[5]+t.z*i.m[9]+i.m[13],e=t.x*i.m[2]+t.y*i.m[6]+t.z*i.m[10]+i.m[14],s=t.x*i.m[3]+t.y*i.m[7]+t.z*i.m[11]+i.m[15];n.x=r/s,n.y=o/s,n.z=e/s},n.TransformCoordinatesFromFloatsToRef=function(t,i,n,r,o){var e=t*r.m[0]+i*r.m[4]+n*r.m[8]+r.m[12],s=t*r.m[1]+i*r.m[5]+n*r.m[9]+r.m[13],h=t*r.m[2]+i*r.m[6]+n*r.m[10]+r.m[14],a=t*r.m[3]+i*r.m[7]+n*r.m[11]+r.m[15];o.x=e/a,o.y=s/a,o.z=h/a},n.TransformNormal=function(t,i){var r=n.Zero();return n.TransformNormalToRef(t,i,r),r},n.TransformNormalToRef=function(t,i,n){var r=t.x*i.m[0]+t.y*i.m[4]+t.z*i.m[8],o=t.x*i.m[1]+t.y*i.m[5]+t.z*i.m[9],e=t.x*i.m[2]+t.y*i.m[6]+t.z*i.m[10];n.x=r,n.y=o,n.z=e},n.TransformNormalFromFloatsToRef=function(t,i,n,r,o){o.x=t*r.m[0]+i*r.m[4]+n*r.m[8],o.y=t*r.m[1]+i*r.m[5]+n*r.m[9],o.z=t*r.m[2]+i*r.m[6]+n*r.m[10]},n.CatmullRom=function(t,i,r,o,e){var s=e*e,h=e*s,a=.5*(2*i.x+(-t.x+r.x)*e+(2*t.x-5*i.x+4*r.x-o.x)*s+(-t.x+3*i.x-3*r.x+o.x)*h),u=.5*(2*i.y+(-t.y+r.y)*e+(2*t.y-5*i.y+4*r.y-o.y)*s+(-t.y+3*i.y-3*r.y+o.y)*h),m=.5*(2*i.z+(-t.z+r.z)*e+(2*t.z-5*i.z+4*r.z-o.z)*s+(-t.z+3*i.z-3*r.z+o.z)*h);return new n(a,u,m)},n.Clamp=function(t,i,r){var o=t.x;o=o>r.x?r.x:o,o=o<i.x?i.x:o;var e=t.y;e=e>r.y?r.y:e,e=e<i.y?i.y:e;var s=t.z;return s=s>r.z?r.z:s,s=s<i.z?i.z:s,new n(o,e,s)},n.Hermite=function(t,i,r,o,e){var s=e*e,h=e*s,a=2*h-3*s+1,u=-2*h+3*s,m=h-2*s+e,y=h-s,c=t.x*a+r.x*u+i.x*m+o.x*y,p=t.y*a+r.y*u+i.y*m+o.y*y,f=t.z*a+r.z*u+i.z*m+o.z*y;return new n(c,p,f)},n.Lerp=function(t,i,r){var o=t.x+(i.x-t.x)*r,e=t.y+(i.y-t.y)*r,s=t.z+(i.z-t.z)*r;return new n(o,e,s)},n.Dot=function(t,i){return t.x*i.x+t.y*i.y+t.z*i.z},n.Cross=function(t,i){var r=n.Zero();return n.CrossToRef(t,i,r),r},n.CrossToRef=function(t,i,n){M.Vector3[0].x=t.y*i.z-t.z*i.y,M.Vector3[0].y=t.z*i.x-t.x*i.z,M.Vector3[0].z=t.x*i.y-t.y*i.x,n.copyFrom(M.Vector3[0])},n.Normalize=function(t){var i=n.Zero();return n.NormalizeToRef(t,i),i},n.NormalizeToRef=function(t,i){i.copyFrom(t),i.normalize()},n.Project=function(t,i,r,o){var e=o.width,s=o.height,h=o.x,a=o.y,m=n._viewportMatrixCache?n._viewportMatrixCache:n._viewportMatrixCache=new u;u.FromValuesToRef(e/2,0,0,0,0,-s/2,0,0,0,0,1,0,h+e/2,s/2+a,0,1,m);var y=n._matrixCache?n._matrixCache:n._matrixCache=new u;return i.multiplyToRef(r,y),y.multiplyToRef(m,y),n.TransformCoordinates(t,y)},n.UnprojectFromTransform=function(t,r,o,e,s){var h=n._matrixCache?n._matrixCache:n._matrixCache=new u;e.multiplyToRef(s,h),h.invert(),t.x=t.x/r*2-1,t.y=-(t.y/o*2-1);var a=n.TransformCoordinates(t,h),m=t.x*h.m[3]+t.y*h.m[7]+t.z*h.m[11]+h.m[15];return i.WithinEpsilon(m,1)&&(a=a.scale(1/m)),a},n.Unproject=function(t,r,o,e,s,h){var a=n._matrixCache?n._matrixCache:n._matrixCache=new u;e.multiplyToRef(s,a),a.multiplyToRef(h,a),a.invert();var m=new n(t.x/r*2-1,(-(t.y/o*2-1)),t.z),y=n.TransformCoordinates(m,a),c=m.x*a.m[3]+m.y*a.m[7]+m.z*a.m[11]+a.m[15];return i.WithinEpsilon(c,1)&&(y=y.scale(1/c)),y},n.Minimize=function(t,i){var n=t.clone();return n.MinimizeInPlace(i),n},n.Maximize=function(t,i){var n=t.clone();return n.MaximizeInPlace(i),n},n.Distance=function(t,i){return Math.sqrt(n.DistanceSquared(t,i))},n.DistanceSquared=function(t,i){var n=t.x-i.x,r=t.y-i.y,o=t.z-i.z;return n*n+r*r+o*o},n.Center=function(t,i){var n=t.add(i);return n.scaleInPlace(.5),n},n.RotationFromAxis=function(t,i,r){var o=n.Zero();return n.RotationFromAxisToRef(t,i,r,o),o},n.RotationFromAxisToRef=function(r,o,e,s){var h=r.normalize(),a=e.normalize(),u=p.X,m=p.Y,y=0,c=0,f=0,x=0,l=0,z=0,w=0,v=-1,d=0,g=M.Vector3[0],R=0,T=M.Vector3[1];i.WithinEpsilon(a.z,0,t.Epsilon)?z=1:i.WithinEpsilon(a.x,0,t.Epsilon)?x=1:(w=a.z/a.x,x=-w*Math.sqrt(1/(1+w*w)),z=Math.sqrt(1/(1+w*w))),T.x=x,T.y=l,T.z=z,T.normalize(),n.CrossToRef(h,T,g),g.normalize(),n.Dot(a,g)<0&&(v=1),R=n.Dot(h,T),R=Math.min(1,Math.max(-1,R)),f=Math.acos(R)*v,n.Dot(T,u)<0&&(f=Math.PI+f,T=T.scaleInPlace(-1),d++);var _=M.Vector3[2],A=M.Vector3[3];x=0,l=0,z=0,v=-1,i.WithinEpsilon(a.z,0,t.Epsilon)?x=1:(w=T.z/T.x,x=-w*Math.sqrt(1/(1+w*w)),z=Math.sqrt(1/(1+w*w))),_.x=x,_.y=l,_.z=z,_.normalize(),n.CrossToRef(_,T,A),A.normalize(),n.CrossToRef(a,_,g),g.normalize(),n.Dot(T,g)<0&&(v=1),R=n.Dot(a,_),R=Math.min(1,Math.max(-1,R)),c=Math.acos(R)*v,n.Dot(A,m)<0&&(c=Math.PI+c,d++),v=-1,n.CrossToRef(u,T,g),g.normalize(),n.Dot(g,m)<0&&(v=1),R=n.Dot(T,u),R=Math.min(1,Math.max(-1,R)),y=-Math.acos(R)*v,R<0&&d<2&&(y=Math.PI+y),s.x=c,s.y=y,s.z=f},n}();t.Vector3=e;var s=function(){function n(t,i,n,r){this.x=t,this.y=i,this.z=n,this.w=r}return n.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+" W:"+this.w+"}"},n.prototype.getClassName=function(){return"Vector4"},n.prototype.getHashCode=function(){var t=this.x||0;return t=397*t^(this.y||0),t=397*t^(this.z||0),t=397*t^(this.w||0)},n.prototype.asArray=function(){var t=[];return this.toArray(t,0),t},n.prototype.toArray=function(t,i){return void 0===i&&(i=0),t[i]=this.x,t[i+1]=this.y,t[i+2]=this.z,t[i+3]=this.w,this},n.prototype.addInPlace=function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this},n.prototype.add=function(t){return new n(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)},n.prototype.addToRef=function(t,i){return i.x=this.x+t.x,i.y=this.y+t.y,i.z=this.z+t.z,i.w=this.w+t.w,this},n.prototype.subtractInPlace=function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this},n.prototype.subtract=function(t){return new n(this.x-t.x,this.y-t.y,this.z-t.z,this.w-t.w)},n.prototype.subtractToRef=function(t,i){return i.x=this.x-t.x,i.y=this.y-t.y,i.z=this.z-t.z,i.w=this.w-t.w,this},n.prototype.subtractFromFloats=function(t,i,r,o){return new n(this.x-t,this.y-i,this.z-r,this.w-o)},n.prototype.subtractFromFloatsToRef=function(t,i,n,r,o){return o.x=this.x-t,o.y=this.y-i,o.z=this.z-n,o.w=this.w-r,this},n.prototype.negate=function(){return new n((-this.x),(-this.y),(-this.z),(-this.w))},n.prototype.scaleInPlace=function(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this},n.prototype.scale=function(t){return new n(this.x*t,this.y*t,this.z*t,this.w*t)},n.prototype.scaleToRef=function(t,i){i.x=this.x*t,i.y=this.y*t,i.z=this.z*t,i.w=this.w*t},n.prototype.equals=function(t){return t&&this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w},n.prototype.equalsWithEpsilon=function(n,r){return void 0===r&&(r=t.Epsilon),n&&i.WithinEpsilon(this.x,n.x,r)&&i.WithinEpsilon(this.y,n.y,r)&&i.WithinEpsilon(this.z,n.z,r)&&i.WithinEpsilon(this.w,n.w,r)},n.prototype.equalsToFloats=function(t,i,n,r){return this.x===t&&this.y===i&&this.z===n&&this.w===r},n.prototype.multiplyInPlace=function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this},n.prototype.multiply=function(t){return new n(this.x*t.x,this.y*t.y,this.z*t.z,this.w*t.w)},n.prototype.multiplyToRef=function(t,i){return i.x=this.x*t.x,i.y=this.y*t.y,i.z=this.z*t.z,i.w=this.w*t.w,this},n.prototype.multiplyByFloats=function(t,i,r,o){return new n(this.x*t,this.y*i,this.z*r,this.w*o)},n.prototype.divide=function(t){return new n(this.x/t.x,this.y/t.y,this.z/t.z,this.w/t.w)},n.prototype.divideToRef=function(t,i){return i.x=this.x/t.x,i.y=this.y/t.y,i.z=this.z/t.z,i.w=this.w/t.w,this},n.prototype.MinimizeInPlace=function(t){return t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z),t.w<this.w&&(this.w=t.w),this},n.prototype.MaximizeInPlace=function(t){return t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z),t.w>this.w&&(this.w=t.w),this},n.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},n.prototype.lengthSquared=function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},n.prototype.normalize=function(){var t=this.length();if(0===t)return this;var i=1/t;return this.x*=i,this.y*=i,this.z*=i,this.w*=i,this},n.prototype.toVector3=function(){return new e(this.x,this.y,this.z)},n.prototype.clone=function(){return new n(this.x,this.y,this.z,this.w)},n.prototype.copyFrom=function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this},n.prototype.copyFromFloats=function(t,i,n,r){return this.x=t,this.y=i,this.z=n,this.w=r,this},n.FromArray=function(t,i){return i||(i=0),new n(t[i],t[i+1],t[i+2],t[i+3])},n.FromArrayToRef=function(t,i,n){n.x=t[i],n.y=t[i+1],n.z=t[i+2],n.w=t[i+3]},n.FromFloatArrayToRef=function(t,i,n){n.x=t[i],n.y=t[i+1],n.z=t[i+2],n.w=t[i+3]},n.FromFloatsToRef=function(t,i,n,r,o){o.x=t,o.y=i,o.z=n,o.w=r},n.Zero=function(){return new n(0,0,0,0)},n.Normalize=function(t){var i=n.Zero();return n.NormalizeToRef(t,i),i},n.NormalizeToRef=function(t,i){i.copyFrom(t),i.normalize()},n.Minimize=function(t,i){var n=t.clone();return n.MinimizeInPlace(i),n},n.Maximize=function(t,i){var n=t.clone();return n.MaximizeInPlace(i),n},n.Distance=function(t,i){return Math.sqrt(n.DistanceSquared(t,i))},n.DistanceSquared=function(t,i){var n=t.x-i.x,r=t.y-i.y,o=t.z-i.z,e=t.w-i.w;return n*n+r*r+o*o+e*e},n.Center=function(t,i){var n=t.add(i);return n.scaleInPlace(.5),n},n}();t.Vector4=s;var h=function(){function t(t,i){this.width=t,this.height=i}return t.prototype.toString=function(){return"{W: "+this.width+", H: "+this.height+"}"},t.prototype.getClassName=function(){return"Size"},t.prototype.getHashCode=function(){var t=this.width||0;return t=397*t^(this.height||0)},t.prototype.copyFrom=function(t){this.width=t.width,this.height=t.height},t.prototype.copyFromFloats=function(t,i){this.width=t,this.height=i},t.prototype.multiplyByFloats=function(i,n){return new t(this.width*i,this.height*n)},t.prototype.clone=function(){return new t(this.width,this.height)},t.prototype.equals=function(t){return!!t&&(this.width===t.width&&this.height===t.height)},Object.defineProperty(t.prototype,"surface",{get:function(){return this.width*this.height},enumerable:!0,configurable:!0}),t.Zero=function(){return new t(0,0)},t.prototype.add=function(i){var n=new t(this.width+i.width,this.height+i.height);return n},t.prototype.substract=function(i){var n=new t(this.width-i.width,this.height-i.height);return n},t.Lerp=function(i,n,r){var o=i.width+(n.width-i.width)*r,e=i.height+(n.height-i.height)*r;return new t(o,e)},t}();t.Size=h;var a=function(){function t(t,i,n,r){void 0===t&&(t=0),void 0===i&&(i=0),void 0===n&&(n=0),void 0===r&&(r=1),this.x=t,this.y=i,this.z=n,this.w=r}return t.prototype.toString=function(){return"{X: "+this.x+" Y:"+this.y+" Z:"+this.z+" W:"+this.w+"}"},t.prototype.getClassName=function(){return"Quaternion"},t.prototype.getHashCode=function(){var t=this.x||0;return t=397*t^(this.y||0),t=397*t^(this.z||0),t=397*t^(this.w||0)},t.prototype.asArray=function(){return[this.x,this.y,this.z,this.w]},t.prototype.equals=function(t){return t&&this.x===t.x&&this.y===t.y&&this.z===t.z&&this.w===t.w},t.prototype.clone=function(){return new t(this.x,this.y,this.z,this.w)},t.prototype.copyFrom=function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this},t.prototype.copyFromFloats=function(t,i,n,r){return this.x=t,this.y=i,this.z=n,this.w=r,this},t.prototype.add=function(i){return new t(this.x+i.x,this.y+i.y,this.z+i.z,this.w+i.w)},t.prototype.subtract=function(i){return new t(this.x-i.x,this.y-i.y,this.z-i.z,this.w-i.w)},t.prototype.scale=function(i){return new t(this.x*i,this.y*i,this.z*i,this.w*i)},t.prototype.multiply=function(i){var n=new t(0,0,0,1);return this.multiplyToRef(i,n),n},t.prototype.multiplyToRef=function(t,i){var n=this.x*t.w+this.y*t.z-this.z*t.y+this.w*t.x,r=-this.x*t.z+this.y*t.w+this.z*t.x+this.w*t.y,o=this.x*t.y-this.y*t.x+this.z*t.w+this.w*t.z,e=-this.x*t.x-this.y*t.y-this.z*t.z+this.w*t.w;return i.copyFromFloats(n,r,o,e),this},t.prototype.multiplyInPlace=function(t){return this.multiplyToRef(t,this),this},t.prototype.conjugateToRef=function(t){return t.copyFromFloats(-this.x,-this.y,-this.z,this.w),this},t.prototype.conjugateInPlace=function(){return this.x*=-1,this.y*=-1,this.z*=-1,this},t.prototype.conjugate=function(){var i=new t((-this.x),(-this.y),(-this.z),this.w);return i},t.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},t.prototype.normalize=function(){var t=1/this.length();return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this},t.prototype.toEulerAngles=function(t){void 0===t&&(t="YZX");var i=e.Zero();return this.toEulerAnglesToRef(i,t),i},t.prototype.toEulerAnglesToRef=function(t,i){void 0===i&&(i="YZX");var n=this.z,r=this.x,o=this.y,e=this.w,s=e*e,h=n*n,a=r*r,u=o*o,m=o*n-r*e,y=.4999999;return m<-y?(t.y=2*Math.atan2(o,e),t.x=Math.PI/2,t.z=0):m>y?(t.y=2*Math.atan2(o,e),t.x=-Math.PI/2,t.z=0):(t.z=Math.atan2(2*(r*o+n*e),-h-a+u+s),t.x=Math.asin(-2*(n*o-r*e)),t.y=Math.atan2(2*(n*r+o*e),h-a-u+s)),this},t.prototype.toRotationMatrix=function(t){var i=this.x*this.x,n=this.y*this.y,r=this.z*this.z,o=this.x*this.y,e=this.z*this.w,s=this.z*this.x,h=this.y*this.w,a=this.y*this.z,u=this.x*this.w;return t.m[0]=1-2*(n+r),t.m[1]=2*(o+e),t.m[2]=2*(s-h),t.m[3]=0,t.m[4]=2*(o-e),t.m[5]=1-2*(r+i),t.m[6]=2*(a+u),t.m[7]=0,t.m[8]=2*(s+h),t.m[9]=2*(a-u),t.m[10]=1-2*(n+i),t.m[11]=0,t.m[12]=0,t.m[13]=0,t.m[14]=0,t.m[15]=1,this},t.prototype.fromRotationMatrix=function(i){return t.FromRotationMatrixToRef(i,this),this},t.FromRotationMatrix=function(i){var n=new t;return t.FromRotationMatrixToRef(i,n),n},t.FromRotationMatrixToRef=function(t,i){var n,r=t.m,o=r[0],e=r[4],s=r[8],h=r[1],a=r[5],u=r[9],m=r[2],y=r[6],c=r[10],p=o+a+c;p>0?(n=.5/Math.sqrt(p+1),i.w=.25/n,i.x=(y-u)*n,i.y=(s-m)*n,i.z=(h-e)*n):o>a&&o>c?(n=2*Math.sqrt(1+o-a-c),i.w=(y-u)/n,i.x=.25*n,i.y=(e+h)/n,i.z=(s+m)/n):a>c?(n=2*Math.sqrt(1+a-o-c),i.w=(s-m)/n,i.x=(e+h)/n,i.y=.25*n,i.z=(u+y)/n):(n=2*Math.sqrt(1+c-o-a),i.w=(h-e)/n,i.x=(s+m)/n,i.y=(u+y)/n,i.z=.25*n)},t.Inverse=function(i){return new t((-i.x),(-i.y),(-i.z),i.w)},t.Identity=function(){return new t(0,0,0,1)},t.RotationAxis=function(i,n){return t.RotationAxisToRef(i,n,new t)},t.RotationAxisToRef=function(t,i,n){var r=Math.sin(i/2);return t.normalize(),n.w=Math.cos(i/2),n.x=t.x*r,n.y=t.y*r,n.z=t.z*r,n},t.FromArray=function(i,n){return n||(n=0),new t(i[n],i[n+1],i[n+2],i[n+3])},t.RotationYawPitchRoll=function(i,n,r){var o=new t;return t.RotationYawPitchRollToRef(i,n,r,o),o},t.RotationYawPitchRollToRef=function(t,i,n,r){var o=.5*n,e=.5*i,s=.5*t,h=Math.sin(o),a=Math.cos(o),u=Math.sin(e),m=Math.cos(e),y=Math.sin(s),c=Math.cos(s);r.x=c*u*a+y*m*h,r.y=y*m*a-c*u*h,r.z=c*m*h-y*u*a,r.w=c*m*a+y*u*h},t.RotationAlphaBetaGamma=function(i,n,r){var o=new t;return t.RotationAlphaBetaGammaToRef(i,n,r,o),o},t.RotationAlphaBetaGammaToRef=function(t,i,n,r){var o=.5*(n+t),e=.5*(n-t),s=.5*i;r.x=Math.cos(e)*Math.sin(s),r.y=Math.sin(e)*Math.sin(s),r.z=Math.sin(o)*Math.cos(s),r.w=Math.cos(o)*Math.cos(s)},t.Slerp=function(i,n,r){var o=t.Identity();return t.SlerpToRef(i,n,r,o),o},t.SlerpToRef=function(t,i,n,r){var o,e,s=n,h=t.x*i.x+t.y*i.y+t.z*i.z+t.w*i.w,a=!1;if(h<0&&(a=!0,h=-h),h>.999999)e=1-s,o=a?-s:s;else{var u=Math.acos(h),m=1/Math.sin(u);e=Math.sin((1-s)*u)*m,o=a?-Math.sin(s*u)*m:Math.sin(s*u)*m}r.x=e*t.x+o*i.x,r.y=e*t.y+o*i.y,r.z=e*t.z+o*i.z,r.w=e*t.w+o*i.w},t}();t.Quaternion=a;var u=function(){function t(){this.m=new Float32Array(16)}return t.prototype.isIdentity=function(){return 1===this.m[0]&&1===this.m[5]&&1===this.m[10]&&1===this.m[15]&&(0===this.m[1]&&0===this.m[2]&&0===this.m[3]&&0===this.m[4]&&0===this.m[6]&&0===this.m[7]&&0===this.m[8]&&0===this.m[9]&&0===this.m[11]&&0===this.m[12]&&0===this.m[13]&&0===this.m[14])},t.prototype.determinant=function(){var t=this.m[10]*this.m[15]-this.m[11]*this.m[14],i=this.m[9]*this.m[15]-this.m[11]*this.m[13],n=this.m[9]*this.m[14]-this.m[10]*this.m[13],r=this.m[8]*this.m[15]-this.m[11]*this.m[12],o=this.m[8]*this.m[14]-this.m[10]*this.m[12],e=this.m[8]*this.m[13]-this.m[9]*this.m[12];return this.m[0]*(this.m[5]*t-this.m[6]*i+this.m[7]*n)-this.m[1]*(this.m[4]*t-this.m[6]*r+this.m[7]*o)+this.m[2]*(this.m[4]*i-this.m[5]*r+this.m[7]*e)-this.m[3]*(this.m[4]*n-this.m[5]*o+this.m[6]*e)},t.prototype.toArray=function(){return this.m},t.prototype.asArray=function(){return this.toArray()},t.prototype.invert=function(){return this.invertToRef(this),this},t.prototype.reset=function(){for(var t=0;t<16;t++)this.m[t]=0;return this},t.prototype.add=function(i){var n=new t;return this.addToRef(i,n),n},t.prototype.addToRef=function(t,i){for(var n=0;n<16;n++)i.m[n]=this.m[n]+t.m[n];return this},t.prototype.addToSelf=function(t){for(var i=0;i<16;i++)this.m[i]+=t.m[i];return this},t.prototype.invertToRef=function(t){var i=this.m[0],n=this.m[1],r=this.m[2],o=this.m[3],e=this.m[4],s=this.m[5],h=this.m[6],a=this.m[7],u=this.m[8],m=this.m[9],y=this.m[10],c=this.m[11],p=this.m[12],f=this.m[13],x=this.m[14],l=this.m[15],z=y*l-c*x,w=m*l-c*f,v=m*x-y*f,d=u*l-c*p,g=u*x-y*p,R=u*f-m*p,T=s*z-h*w+a*v,_=-(e*z-h*d+a*g),M=e*w-s*d+a*R,A=-(e*v-s*g+h*R),b=1/(i*T+n*_+r*M+o*A),F=h*l-a*x,L=s*l-a*f,C=s*x-h*f,P=e*l-a*p,Z=e*x-h*p,S=e*f-s*p,I=h*c-a*y,H=s*c-a*m,q=s*y-h*m,D=e*c-a*u,V=e*y-h*u,N=e*m-s*u;return t.m[0]=T*b,t.m[4]=_*b,t.m[8]=M*b,t.m[12]=A*b,t.m[1]=-(n*z-r*w+o*v)*b,t.m[5]=(i*z-r*d+o*g)*b,t.m[9]=-(i*w-n*d+o*R)*b,t.m[13]=(i*v-n*g+r*R)*b,t.m[2]=(n*F-r*L+o*C)*b,t.m[6]=-(i*F-r*P+o*Z)*b,t.m[10]=(i*L-n*P+o*S)*b,t.m[14]=-(i*C-n*Z+r*S)*b,t.m[3]=-(n*I-r*H+o*q)*b,t.m[7]=(i*I-r*D+o*V)*b,t.m[11]=-(i*H-n*D+o*N)*b,t.m[15]=(i*q-n*V+r*N)*b,this},t.prototype.setTranslation=function(t){return this.m[12]=t.x,this.m[13]=t.y,this.m[14]=t.z,this},t.prototype.getTranslation=function(){return new e(this.m[12],this.m[13],this.m[14])},t.prototype.multiply=function(i){var n=new t;return this.multiplyToRef(i,n),n},t.prototype.copyFrom=function(t){for(var i=0;i<16;i++)this.m[i]=t.m[i];return this;\n},t.prototype.copyToArray=function(t,i){void 0===i&&(i=0);for(var n=0;n<16;n++)t[i+n]=this.m[n];return this},t.prototype.multiplyToRef=function(t,i){return this.multiplyToArray(t,i.m,0),this},t.prototype.multiplyToArray=function(t,i,n){var r=this.m[0],o=this.m[1],e=this.m[2],s=this.m[3],h=this.m[4],a=this.m[5],u=this.m[6],m=this.m[7],y=this.m[8],c=this.m[9],p=this.m[10],f=this.m[11],x=this.m[12],l=this.m[13],z=this.m[14],w=this.m[15],v=t.m[0],d=t.m[1],g=t.m[2],R=t.m[3],T=t.m[4],_=t.m[5],M=t.m[6],A=t.m[7],b=t.m[8],F=t.m[9],L=t.m[10],C=t.m[11],P=t.m[12],Z=t.m[13],S=t.m[14],I=t.m[15];return i[n]=r*v+o*T+e*b+s*P,i[n+1]=r*d+o*_+e*F+s*Z,i[n+2]=r*g+o*M+e*L+s*S,i[n+3]=r*R+o*A+e*C+s*I,i[n+4]=h*v+a*T+u*b+m*P,i[n+5]=h*d+a*_+u*F+m*Z,i[n+6]=h*g+a*M+u*L+m*S,i[n+7]=h*R+a*A+u*C+m*I,i[n+8]=y*v+c*T+p*b+f*P,i[n+9]=y*d+c*_+p*F+f*Z,i[n+10]=y*g+c*M+p*L+f*S,i[n+11]=y*R+c*A+p*C+f*I,i[n+12]=x*v+l*T+z*b+w*P,i[n+13]=x*d+l*_+z*F+w*Z,i[n+14]=x*g+l*M+z*L+w*S,i[n+15]=x*R+l*A+z*C+w*I,this},t.prototype.equals=function(t){return t&&this.m[0]===t.m[0]&&this.m[1]===t.m[1]&&this.m[2]===t.m[2]&&this.m[3]===t.m[3]&&this.m[4]===t.m[4]&&this.m[5]===t.m[5]&&this.m[6]===t.m[6]&&this.m[7]===t.m[7]&&this.m[8]===t.m[8]&&this.m[9]===t.m[9]&&this.m[10]===t.m[10]&&this.m[11]===t.m[11]&&this.m[12]===t.m[12]&&this.m[13]===t.m[13]&&this.m[14]===t.m[14]&&this.m[15]===t.m[15]},t.prototype.clone=function(){return t.FromValues(this.m[0],this.m[1],this.m[2],this.m[3],this.m[4],this.m[5],this.m[6],this.m[7],this.m[8],this.m[9],this.m[10],this.m[11],this.m[12],this.m[13],this.m[14],this.m[15])},t.prototype.getClassName=function(){return"Matrix"},t.prototype.getHashCode=function(){for(var t=this.m[0]||0,i=1;i<16;i++)t=397*t^(this.m[i]||0);return t},t.prototype.decompose=function(n,r,o){o.x=this.m[12],o.y=this.m[13],o.z=this.m[14];var e=i.Sign(this.m[0]*this.m[1]*this.m[2]*this.m[3])<0?-1:1,s=i.Sign(this.m[4]*this.m[5]*this.m[6]*this.m[7])<0?-1:1,h=i.Sign(this.m[8]*this.m[9]*this.m[10]*this.m[11])<0?-1:1;return n.x=e*Math.sqrt(this.m[0]*this.m[0]+this.m[1]*this.m[1]+this.m[2]*this.m[2]),n.y=s*Math.sqrt(this.m[4]*this.m[4]+this.m[5]*this.m[5]+this.m[6]*this.m[6]),n.z=h*Math.sqrt(this.m[8]*this.m[8]+this.m[9]*this.m[9]+this.m[10]*this.m[10]),0===n.x||0===n.y||0===n.z?(r.x=0,r.y=0,r.z=0,r.w=1,!1):(t.FromValuesToRef(this.m[0]/n.x,this.m[1]/n.x,this.m[2]/n.x,0,this.m[4]/n.y,this.m[5]/n.y,this.m[6]/n.y,0,this.m[8]/n.z,this.m[9]/n.z,this.m[10]/n.z,0,0,0,0,1,M.Matrix[0]),a.FromRotationMatrixToRef(M.Matrix[0],r),!0)},t.prototype.getRotationMatrix=function(){var i=t.Identity();return this.getRotationMatrixToRef(i),i},t.prototype.getRotationMatrixToRef=function(i){var n=this.m,r=n[0]*n[1]*n[2]*n[3]<0?-1:1,o=n[4]*n[5]*n[6]*n[7]<0?-1:1,e=n[8]*n[9]*n[10]*n[11]<0?-1:1,s=r*Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]),h=o*Math.sqrt(n[4]*n[4]+n[5]*n[5]+n[6]*n[6]),a=e*Math.sqrt(n[8]*n[8]+n[9]*n[9]+n[10]*n[10]);t.FromValuesToRef(n[0]/s,n[1]/s,n[2]/s,0,n[4]/h,n[5]/h,n[6]/h,0,n[8]/a,n[9]/a,n[10]/a,0,0,0,0,1,i)},t.FromArray=function(i,n){var r=new t;return n||(n=0),t.FromArrayToRef(i,n,r),r},t.FromArrayToRef=function(t,i,n){for(var r=0;r<16;r++)n.m[r]=t[r+i]},t.FromFloat32ArrayToRefScaled=function(t,i,n,r){for(var o=0;o<16;o++)r.m[o]=t[o+i]*n},t.FromValuesToRef=function(t,i,n,r,o,e,s,h,a,u,m,y,c,p,f,x,l){l.m[0]=t,l.m[1]=i,l.m[2]=n,l.m[3]=r,l.m[4]=o,l.m[5]=e,l.m[6]=s,l.m[7]=h,l.m[8]=a,l.m[9]=u,l.m[10]=m,l.m[11]=y,l.m[12]=c,l.m[13]=p,l.m[14]=f,l.m[15]=x},t.prototype.getRow=function(t){if(t<0||t>3)return null;var i=4*t;return new s(this.m[i+0],this.m[i+1],this.m[i+2],this.m[i+3])},t.prototype.setRow=function(t,i){if(t<0||t>3)return this;var n=4*t;return this.m[n+0]=i.x,this.m[n+1]=i.y,this.m[n+2]=i.z,this.m[n+3]=i.w,this},t.FromValues=function(i,n,r,o,e,s,h,a,u,m,y,c,p,f,x,l){var z=new t;return z.m[0]=i,z.m[1]=n,z.m[2]=r,z.m[3]=o,z.m[4]=e,z.m[5]=s,z.m[6]=h,z.m[7]=a,z.m[8]=u,z.m[9]=m,z.m[10]=y,z.m[11]=c,z.m[12]=p,z.m[13]=f,z.m[14]=x,z.m[15]=l,z},t.Compose=function(i,n,r){var o=t.FromValues(i.x,0,0,0,0,i.y,0,0,0,0,i.z,0,0,0,0,1),e=t.Identity();return n.toRotationMatrix(e),o=o.multiply(e),o.setTranslation(r),o},t.Identity=function(){return t.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},t.IdentityToRef=function(i){t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,i)},t.Zero=function(){return t.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)},t.RotationX=function(i){var n=new t;return t.RotationXToRef(i,n),n},t.Invert=function(i){var n=new t;return i.invertToRef(n),n},t.RotationXToRef=function(t,i){var n=Math.sin(t),r=Math.cos(t);i.m[0]=1,i.m[15]=1,i.m[5]=r,i.m[10]=r,i.m[9]=-n,i.m[6]=n,i.m[1]=0,i.m[2]=0,i.m[3]=0,i.m[4]=0,i.m[7]=0,i.m[8]=0,i.m[11]=0,i.m[12]=0,i.m[13]=0,i.m[14]=0},t.RotationY=function(i){var n=new t;return t.RotationYToRef(i,n),n},t.RotationYToRef=function(t,i){var n=Math.sin(t),r=Math.cos(t);i.m[5]=1,i.m[15]=1,i.m[0]=r,i.m[2]=-n,i.m[8]=n,i.m[10]=r,i.m[1]=0,i.m[3]=0,i.m[4]=0,i.m[6]=0,i.m[7]=0,i.m[9]=0,i.m[11]=0,i.m[12]=0,i.m[13]=0,i.m[14]=0},t.RotationZ=function(i){var n=new t;return t.RotationZToRef(i,n),n},t.RotationZToRef=function(t,i){var n=Math.sin(t),r=Math.cos(t);i.m[10]=1,i.m[15]=1,i.m[0]=r,i.m[1]=n,i.m[4]=-n,i.m[5]=r,i.m[2]=0,i.m[3]=0,i.m[6]=0,i.m[7]=0,i.m[8]=0,i.m[9]=0,i.m[11]=0,i.m[12]=0,i.m[13]=0,i.m[14]=0},t.RotationAxis=function(i,n){var r=t.Zero();return t.RotationAxisToRef(i,n,r),r},t.RotationAxisToRef=function(t,i,n){var r=Math.sin(-i),o=Math.cos(-i),e=1-o;t.normalize(),n.m[0]=t.x*t.x*e+o,n.m[1]=t.x*t.y*e-t.z*r,n.m[2]=t.x*t.z*e+t.y*r,n.m[3]=0,n.m[4]=t.y*t.x*e+t.z*r,n.m[5]=t.y*t.y*e+o,n.m[6]=t.y*t.z*e-t.x*r,n.m[7]=0,n.m[8]=t.z*t.x*e-t.y*r,n.m[9]=t.z*t.y*e+t.x*r,n.m[10]=t.z*t.z*e+o,n.m[11]=0,n.m[15]=1},t.RotationYawPitchRoll=function(i,n,r){var o=new t;return t.RotationYawPitchRollToRef(i,n,r,o),o},t.RotationYawPitchRollToRef=function(t,i,n,r){a.RotationYawPitchRollToRef(t,i,n,this._tempQuaternion),this._tempQuaternion.toRotationMatrix(r)},t.Scaling=function(i,n,r){var o=t.Zero();return t.ScalingToRef(i,n,r,o),o},t.ScalingToRef=function(t,i,n,r){r.m[0]=t,r.m[1]=0,r.m[2]=0,r.m[3]=0,r.m[4]=0,r.m[5]=i,r.m[6]=0,r.m[7]=0,r.m[8]=0,r.m[9]=0,r.m[10]=n,r.m[11]=0,r.m[12]=0,r.m[13]=0,r.m[14]=0,r.m[15]=1},t.Translation=function(i,n,r){var o=t.Identity();return t.TranslationToRef(i,n,r,o),o},t.TranslationToRef=function(i,n,r,o){t.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,i,n,r,1,o)},t.Lerp=function(i,n,r){for(var o=t.Zero(),e=0;e<16;e++)o.m[e]=i.m[e]*(1-r)+n.m[e]*r;return o},t.DecomposeLerp=function(i,n,r){var o=new e(0,0,0),s=new a,h=new e(0,0,0);i.decompose(o,s,h);var u=new e(0,0,0),m=new a,y=new e(0,0,0);n.decompose(u,m,y);var c=e.Lerp(o,u,r),p=a.Slerp(s,m,r),f=e.Lerp(h,y,r);return t.Compose(c,p,f)},t.LookAtLH=function(i,n,r){var o=t.Zero();return t.LookAtLHToRef(i,n,r,o),o},t.LookAtLHToRef=function(i,n,r,o){n.subtractToRef(i,this._zAxis),this._zAxis.normalize(),e.CrossToRef(r,this._zAxis,this._xAxis),0===this._xAxis.lengthSquared()?this._xAxis.x=1:this._xAxis.normalize(),e.CrossToRef(this._zAxis,this._xAxis,this._yAxis),this._yAxis.normalize();var s=-e.Dot(this._xAxis,i),h=-e.Dot(this._yAxis,i),a=-e.Dot(this._zAxis,i);return t.FromValuesToRef(this._xAxis.x,this._yAxis.x,this._zAxis.x,0,this._xAxis.y,this._yAxis.y,this._zAxis.y,0,this._xAxis.z,this._yAxis.z,this._zAxis.z,0,s,h,a,1,o)},t.LookAtRH=function(i,n,r){var o=t.Zero();return t.LookAtRHToRef(i,n,r,o),o},t.LookAtRHToRef=function(i,n,r,o){i.subtractToRef(n,this._zAxis),this._zAxis.normalize(),e.CrossToRef(r,this._zAxis,this._xAxis),0===this._xAxis.lengthSquared()?this._xAxis.x=1:this._xAxis.normalize(),e.CrossToRef(this._zAxis,this._xAxis,this._yAxis),this._yAxis.normalize();var s=-e.Dot(this._xAxis,i),h=-e.Dot(this._yAxis,i),a=-e.Dot(this._zAxis,i);return t.FromValuesToRef(this._xAxis.x,this._yAxis.x,this._zAxis.x,0,this._xAxis.y,this._yAxis.y,this._zAxis.y,0,this._xAxis.z,this._yAxis.z,this._zAxis.z,0,s,h,a,1,o)},t.OrthoLH=function(i,n,r,o){var e=t.Zero();return t.OrthoLHToRef(i,n,r,o,e),e},t.OrthoLHToRef=function(i,n,r,o,e){var s=2/i,h=2/n,a=1/(o-r),u=r/(r-o);t.FromValuesToRef(s,0,0,0,0,h,0,0,0,0,a,0,0,0,u,1,e)},t.OrthoOffCenterLH=function(i,n,r,o,e,s){var h=t.Zero();return t.OrthoOffCenterLHToRef(i,n,r,o,e,s,h),h},t.OrthoOffCenterLHToRef=function(t,i,n,r,o,e,s){s.m[0]=2/(i-t),s.m[1]=s.m[2]=s.m[3]=0,s.m[5]=2/(r-n),s.m[4]=s.m[6]=s.m[7]=0,s.m[10]=1/(e-o),s.m[8]=s.m[9]=s.m[11]=0,s.m[12]=(t+i)/(t-i),s.m[13]=(r+n)/(n-r),s.m[14]=-o/(e-o),s.m[15]=1},t.OrthoOffCenterRH=function(i,n,r,o,e,s){var h=t.Zero();return t.OrthoOffCenterRHToRef(i,n,r,o,e,s,h),h},t.OrthoOffCenterRHToRef=function(i,n,r,o,e,s,h){t.OrthoOffCenterLHToRef(i,n,r,o,e,s,h),h.m[10]*=-1},t.PerspectiveLH=function(i,n,r,o){var e=t.Zero();return e.m[0]=2*r/i,e.m[1]=e.m[2]=e.m[3]=0,e.m[5]=2*r/n,e.m[4]=e.m[6]=e.m[7]=0,e.m[10]=-o/(r-o),e.m[8]=e.m[9]=0,e.m[11]=1,e.m[12]=e.m[13]=e.m[15]=0,e.m[14]=r*o/(r-o),e},t.PerspectiveFovLH=function(i,n,r,o){var e=t.Zero();return t.PerspectiveFovLHToRef(i,n,r,o,e),e},t.PerspectiveFovLHToRef=function(t,i,n,r,o,e){void 0===e&&(e=!0);var s=1/Math.tan(.5*t);e?o.m[0]=s/i:o.m[0]=s,o.m[1]=o.m[2]=o.m[3]=0,e?o.m[5]=s:o.m[5]=s*i,o.m[4]=o.m[6]=o.m[7]=0,o.m[8]=o.m[9]=0,o.m[10]=r/(r-n),o.m[11]=1,o.m[12]=o.m[13]=o.m[15]=0,o.m[14]=-(n*r)/(r-n)},t.PerspectiveFovRH=function(i,n,r,o){var e=t.Zero();return t.PerspectiveFovRHToRef(i,n,r,o,e),e},t.PerspectiveFovRHToRef=function(t,i,n,r,o,e){void 0===e&&(e=!0);var s=1/Math.tan(.5*t);e?o.m[0]=s/i:o.m[0]=s,o.m[1]=o.m[2]=o.m[3]=0,e?o.m[5]=s:o.m[5]=s*i,o.m[4]=o.m[6]=o.m[7]=0,o.m[8]=o.m[9]=0,o.m[10]=r/(n-r),o.m[11]=-1,o.m[12]=o.m[13]=o.m[15]=0,o.m[14]=n*r/(n-r)},t.PerspectiveFovWebVRToRef=function(t,i,n,r,o){void 0===o&&(o=!0);var e=Math.tan(t.upDegrees*Math.PI/180),s=Math.tan(t.downDegrees*Math.PI/180),h=Math.tan(t.leftDegrees*Math.PI/180),a=Math.tan(t.rightDegrees*Math.PI/180),u=2/(h+a),m=2/(e+s);r.m[0]=u,r.m[1]=r.m[2]=r.m[3]=r.m[4]=0,r.m[5]=m,r.m[6]=r.m[7]=0,r.m[8]=(h-a)*u*.5,r.m[9]=-((e-s)*m*.5),r.m[10]=-n/(i-n),r.m[11]=1,r.m[12]=r.m[13]=r.m[15]=0,r.m[14]=i*n/(i-n)},t.GetFinalMatrix=function(i,n,r,o,e,s){var h=i.width,a=i.height,u=i.x,m=i.y,y=t.FromValues(h/2,0,0,0,0,-a/2,0,0,0,0,s-e,0,u+h/2,a/2+m,e,1);return n.multiply(r).multiply(o).multiply(y)},t.GetAsMatrix2x2=function(t){return new Float32Array([t.m[0],t.m[1],t.m[4],t.m[5]])},t.GetAsMatrix3x3=function(t){return new Float32Array([t.m[0],t.m[1],t.m[2],t.m[4],t.m[5],t.m[6],t.m[8],t.m[9],t.m[10]])},t.Transpose=function(i){var n=new t;return n.m[0]=i.m[0],n.m[1]=i.m[4],n.m[2]=i.m[8],n.m[3]=i.m[12],n.m[4]=i.m[1],n.m[5]=i.m[5],n.m[6]=i.m[9],n.m[7]=i.m[13],n.m[8]=i.m[2],n.m[9]=i.m[6],n.m[10]=i.m[10],n.m[11]=i.m[14],n.m[12]=i.m[3],n.m[13]=i.m[7],n.m[14]=i.m[11],n.m[15]=i.m[15],n},t.Reflection=function(i){var n=new t;return t.ReflectionToRef(i,n),n},t.ReflectionToRef=function(t,i){t.normalize();var n=t.normal.x,r=t.normal.y,o=t.normal.z,e=-2*n,s=-2*r,h=-2*o;i.m[0]=e*n+1,i.m[1]=s*n,i.m[2]=h*n,i.m[3]=0,i.m[4]=e*r,i.m[5]=s*r+1,i.m[6]=h*r,i.m[7]=0,i.m[8]=e*o,i.m[9]=s*o,i.m[10]=h*o+1,i.m[11]=0,i.m[12]=e*t.d,i.m[13]=s*t.d,i.m[14]=h*t.d,i.m[15]=1},t.FromXYZAxesToRef=function(t,i,n,r){r.m[0]=t.x,r.m[1]=t.y,r.m[2]=t.z,r.m[3]=0,r.m[4]=i.x,r.m[5]=i.y,r.m[6]=i.z,r.m[7]=0,r.m[8]=n.x,r.m[9]=n.y,r.m[10]=n.z,r.m[11]=0,r.m[12]=0,r.m[13]=0,r.m[14]=0,r.m[15]=1},t.FromQuaternionToRef=function(t,i){var n=t.x*t.x,r=t.y*t.y,o=t.z*t.z,e=t.x*t.y,s=t.z*t.w,h=t.z*t.x,a=t.y*t.w,u=t.y*t.z,m=t.x*t.w;i.m[0]=1-2*(r+o),i.m[1]=2*(e+s),i.m[2]=2*(h-a),i.m[3]=0,i.m[4]=2*(e-s),i.m[5]=1-2*(o+n),i.m[6]=2*(u+m),i.m[7]=0,i.m[8]=2*(h+a),i.m[9]=2*(u-m),i.m[10]=1-2*(r+n),i.m[11]=0,i.m[12]=0,i.m[13]=0,i.m[14]=0,i.m[15]=1},t._tempQuaternion=new a,t._xAxis=e.Zero(),t._yAxis=e.Zero(),t._zAxis=e.Zero(),t}();t.Matrix=u;var m=function(){function t(t,i,n,r){this.normal=new e(t,i,n),this.d=r}return t.prototype.asArray=function(){return[this.normal.x,this.normal.y,this.normal.z,this.d]},t.prototype.clone=function(){return new t(this.normal.x,this.normal.y,this.normal.z,this.d)},t.prototype.getClassName=function(){return"Plane"},t.prototype.getHashCode=function(){var t=this.normal.getHashCode();return t=397*t^(this.d||0)},t.prototype.normalize=function(){var t=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z),i=0;return 0!==t&&(i=1/t),this.normal.x*=i,this.normal.y*=i,this.normal.z*=i,this.d*=i,this},t.prototype.transform=function(i){var n=u.Transpose(i),r=this.normal.x,o=this.normal.y,e=this.normal.z,s=this.d,h=r*n.m[0]+o*n.m[1]+e*n.m[2]+s*n.m[3],a=r*n.m[4]+o*n.m[5]+e*n.m[6]+s*n.m[7],m=r*n.m[8]+o*n.m[9]+e*n.m[10]+s*n.m[11],y=r*n.m[12]+o*n.m[13]+e*n.m[14]+s*n.m[15];return new t(h,a,m,y)},t.prototype.dotCoordinate=function(t){return this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.d},t.prototype.copyFromPoints=function(t,i,n){var r,o=i.x-t.x,e=i.y-t.y,s=i.z-t.z,h=n.x-t.x,a=n.y-t.y,u=n.z-t.z,m=e*u-s*a,y=s*h-o*u,c=o*a-e*h,p=Math.sqrt(m*m+y*y+c*c);return r=0!==p?1/p:0,this.normal.x=m*r,this.normal.y=y*r,this.normal.z=c*r,this.d=-(this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z),this},t.prototype.isFrontFacingTo=function(t,i){var n=e.Dot(this.normal,t);return n<=i},t.prototype.signedDistanceTo=function(t){return e.Dot(t,this.normal)+this.d},t.FromArray=function(i){return new t(i[0],i[1],i[2],i[3])},t.FromPoints=function(i,n,r){var o=new t(0,0,0,0);return o.copyFromPoints(i,n,r),o},t.FromPositionAndNormal=function(i,n){var r=new t(0,0,0,0);return n.normalize(),r.normal=n,r.d=-(n.x*i.x+n.y*i.y+n.z*i.z),r},t.SignedDistanceToPlaneFromPositionAndNormal=function(t,i,n){var r=-(i.x*t.x+i.y*t.y+i.z*t.z);return e.Dot(n,i)+r},t}();t.Plane=m;var y=function(){function t(t,i,n,r){this.x=t,this.y=i,this.width=n,this.height=r}return t.prototype.toGlobal=function(i,n){return new t(this.x*i,this.y*n,this.width*i,this.height*n)},t}();t.Viewport=y;var c=function(){function t(){}return t.GetPlanes=function(i){for(var n=[],r=0;r<6;r++)n.push(new m(0,0,0,0));return t.GetPlanesToRef(i,n),n},t.GetPlanesToRef=function(t,i){i[0].normal.x=t.m[3]+t.m[2],i[0].normal.y=t.m[7]+t.m[6],i[0].normal.z=t.m[11]+t.m[10],i[0].d=t.m[15]+t.m[14],i[0].normalize(),i[1].normal.x=t.m[3]-t.m[2],i[1].normal.y=t.m[7]-t.m[6],i[1].normal.z=t.m[11]-t.m[10],i[1].d=t.m[15]-t.m[14],i[1].normalize(),i[2].normal.x=t.m[3]+t.m[0],i[2].normal.y=t.m[7]+t.m[4],i[2].normal.z=t.m[11]+t.m[8],i[2].d=t.m[15]+t.m[12],i[2].normalize(),i[3].normal.x=t.m[3]-t.m[0],i[3].normal.y=t.m[7]-t.m[4],i[3].normal.z=t.m[11]-t.m[8],i[3].d=t.m[15]-t.m[12],i[3].normalize(),i[4].normal.x=t.m[3]-t.m[1],i[4].normal.y=t.m[7]-t.m[5],i[4].normal.z=t.m[11]-t.m[9],i[4].d=t.m[15]-t.m[13],i[4].normalize(),i[5].normal.x=t.m[3]+t.m[1],i[5].normal.y=t.m[7]+t.m[5],i[5].normal.z=t.m[11]+t.m[9],i[5].d=t.m[15]+t.m[13],i[5].normalize()},t}();t.Frustum=c,function(t){t[t.LOCAL=0]="LOCAL",t[t.WORLD=1]="WORLD"}(t.Space||(t.Space={}));var p=(t.Space,function(){function t(){}return t.X=new e(1,0,0),t.Y=new e(0,1,0),t.Z=new e(0,0,1),t}());t.Axis=p;var f=function(){function t(){}return t.interpolate=function(t,i,n,r,o){for(var e=1-3*r+3*i,s=3*r-6*i,h=3*i,a=t,u=0;u<5;u++){var m=a*a,y=m*a,c=e*y+s*m+h*a,p=1/(3*e*m+2*s*a+h);a-=(c-t)*p,a=Math.min(1,Math.max(0,a))}return 3*Math.pow(1-a,2)*a*n+3*(1-a)*Math.pow(a,2)*o+Math.pow(a,3)},t}();t.BezierCurve=f,function(t){t[t.CW=0]="CW",t[t.CCW=1]="CCW"}(t.Orientation||(t.Orientation={}));var x=t.Orientation,l=function(){function t(t){var i=this;this.degrees=function(){return 180*i._radians/Math.PI},this.radians=function(){return i._radians},this._radians=t,this._radians<0&&(this._radians+=2*Math.PI)}return t.BetweenTwoPoints=function(i,n){var r=n.subtract(i),o=Math.atan2(r.y,r.x);return new t(o)},t.FromRadians=function(i){return new t(i)},t.FromDegrees=function(i){return new t(i*Math.PI/180)},t}();t.Angle=l;var z=function(){function t(t,i,n){this.startPoint=t,this.midPoint=i,this.endPoint=n;var r=Math.pow(i.x,2)+Math.pow(i.y,2),e=(Math.pow(t.x,2)+Math.pow(t.y,2)-r)/2,s=(r-Math.pow(n.x,2)-Math.pow(n.y,2))/2,h=(t.x-i.x)*(i.y-n.y)-(i.x-n.x)*(t.y-i.y);this.centerPoint=new o((e*(i.y-n.y)-s*(t.y-i.y))/h,((t.x-i.x)*s-(i.x-n.x)*e)/h),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=l.BetweenTwoPoints(this.centerPoint,this.startPoint);var a=this.startAngle.degrees(),u=l.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),m=l.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();u-a>180&&(u-=360),u-a<-180&&(u+=360),m-u>180&&(m-=360),m-u<-180&&(m+=360),this.orientation=u-a<0?x.CW:x.CCW,this.angle=l.FromDegrees(this.orientation===x.CW?a-m:m-a)}return t}();t.Arc2=z;var w=function(){function t(t,i){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new o(t,i))}return t.prototype.addLineTo=function(t,i){if(closed)return this;var n=new o(t,i),r=this._points[this._points.length-1];return this._points.push(n),this._length+=n.subtract(r).length(),this},t.prototype.addArcTo=function(t,i,n,r,e){if(void 0===e&&(e=36),closed)return this;var s=this._points[this._points.length-1],h=new o(t,i),a=new o(n,r),u=new z(s,h,a),m=u.angle.radians()/e;u.orientation===x.CW&&(m*=-1);for(var y=u.startAngle.radians()+m,c=0;c<e;c++){var p=Math.cos(y)*u.radius+u.centerPoint.x,f=Math.sin(y)*u.radius+u.centerPoint.y;this.addLineTo(p,f),y+=m}return this},t.prototype.close=function(){return this.closed=!0,this},t.prototype.length=function(){var t=this._length;if(!this.closed){var i=this._points[this._points.length-1],n=this._points[0];t+=n.subtract(i).length()}return t},t.prototype.getPoints=function(){return this._points},t.prototype.getPointAtLengthPosition=function(t){if(t<0||t>1)return o.Zero();for(var i=t*this.length(),n=0,r=0;r<this._points.length;r++){var e=(r+1)%this._points.length,s=this._points[r],h=this._points[e],a=h.subtract(s),u=a.length()+n;if(i>=n&&i<=u){var m=a.normalize(),y=i-n;return new o(s.x+m.x*y,s.y+m.y*y)}n=u}return o.Zero()},t.StartingAt=function(i,n){return new t(i,n)},t}();t.Path2=w;var v=function(){function n(t,i,n){this.path=t,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array;for(var r=0;r<t.length;r++)this._curve[r]=t[r].clone();this._raw=n||!1,this._compute(i)}return n.prototype.getCurve=function(){return this._curve},n.prototype.getTangents=function(){return this._tangents},n.prototype.getNormals=function(){return this._normals},n.prototype.getBinormals=function(){return this._binormals},n.prototype.getDistances=function(){return this._distances},n.prototype.update=function(t,i){for(var n=0;n<t.length;n++)this._curve[n].x=t[n].x,this._curve[n].y=t[n].y,this._curve[n].z=t[n].z;return this._compute(i),this},n.prototype._compute=function(t){var i=this._curve.length;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[i-1]=this._curve[i-1].subtract(this._curve[i-2]),this._raw||this._tangents[i-1].normalize();var n=this._tangents[0],r=this._normalVector(this._curve[0],n,t);this._normals[0]=r,this._raw||this._normals[0].normalize(),this._binormals[0]=e.Cross(n,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;for(var o,s,h,a,u=1;u<i;u++)o=this._getLastNonNullVector(u),u<i-1&&(s=this._getFirstNonNullVector(u),this._tangents[u]=o.add(s),this._tangents[u].normalize()),this._distances[u]=this._distances[u-1]+o.length(),h=this._tangents[u],a=this._binormals[u-1],this._normals[u]=e.Cross(a,h),this._raw||this._normals[u].normalize(),this._binormals[u]=e.Cross(h,this._normals[u]),this._raw||this._binormals[u].normalize()},n.prototype._getFirstNonNullVector=function(t){for(var i=1,n=this._curve[t+i].subtract(this._curve[t]);0===n.length()&&t+i+1<this._curve.length;)i++,n=this._curve[t+i].subtract(this._curve[t]);return n},n.prototype._getLastNonNullVector=function(t){for(var i=1,n=this._curve[t].subtract(this._curve[t-i]);0===n.length()&&t>i+1;)i++,n=this._curve[t].subtract(this._curve[t-i]);return n},n.prototype._normalVector=function(n,r,o){var s,h=r.length();if(0===h&&(h=1),void 0===o||null===o){var a;i.WithinEpsilon(Math.abs(r.y)/h,1,t.Epsilon)?i.WithinEpsilon(Math.abs(r.x)/h,1,t.Epsilon)?i.WithinEpsilon(Math.abs(r.z)/h,1,t.Epsilon)||(a=new e(0,0,1)):a=new e(1,0,0):a=new e(0,(-1),0),s=e.Cross(r,a)}else s=e.Cross(r,o),e.CrossToRef(s,r,s);return s.normalize(),s},n}();t.Path3D=v;var d=function(){function t(t){this._length=0,this._points=t,this._length=this._computeLength(t)}return t.CreateQuadraticBezier=function(i,n,r,o){o=o>2?o:3;for(var s=new Array,h=function(t,i,n,r){var o=(1-t)*(1-t)*i+2*t*(1-t)*n+t*t*r;return o},a=0;a<=o;a++)s.push(new e(h(a/o,i.x,n.x,r.x),h(a/o,i.y,n.y,r.y),h(a/o,i.z,n.z,r.z)));return new t(s)},t.CreateCubicBezier=function(i,n,r,o,s){s=s>3?s:4;for(var h=new Array,a=function(t,i,n,r,o){var e=(1-t)*(1-t)*(1-t)*i+3*t*(1-t)*(1-t)*n+3*t*t*(1-t)*r+t*t*t*o;return e},u=0;u<=s;u++)h.push(new e(a(u/s,i.x,n.x,r.x,o.x),a(u/s,i.y,n.y,r.y,o.y),a(u/s,i.z,n.z,r.z,o.z)));return new t(h)},t.CreateHermiteSpline=function(i,n,r,o,s){for(var h=new Array,a=1/s,u=0;u<=s;u++)h.push(e.Hermite(i,n,r,o,u*a));return new t(h)},t.prototype.getPoints=function(){return this._points},t.prototype.length=function(){return this._length},t.prototype["continue"]=function(i){for(var n=this._points[this._points.length-1],r=this._points.slice(),o=i.getPoints(),e=1;e<o.length;e++)r.push(o[e].subtract(o[0]).add(n));var s=new t(r);return s},t.prototype._computeLength=function(t){for(var i=0,n=1;n<t.length;n++)i+=t[n].subtract(t[n-1]).length();return i},t}();t.Curve3=d;var g=function(){function t(){this.L00=e.Zero(),this.L1_1=e.Zero(),this.L10=e.Zero(),this.L11=e.Zero(),this.L2_2=e.Zero(),this.L2_1=e.Zero(),this.L20=e.Zero(),this.L21=e.Zero(),this.L22=e.Zero()}return t.prototype.addLight=function(t,i,n){var r=new e(i.r,i.g,i.b),o=r.scale(n);this.L00=this.L00.add(o.scale(.282095)),this.L1_1=this.L1_1.add(o.scale(.488603*t.y)),this.L10=this.L10.add(o.scale(.488603*t.z)),this.L11=this.L11.add(o.scale(.488603*t.x)),this.L2_2=this.L2_2.add(o.scale(1.092548*t.x*t.y)),this.L2_1=this.L2_1.add(o.scale(1.092548*t.y*t.z)),this.L21=this.L21.add(o.scale(1.092548*t.x*t.z)),this.L20=this.L20.add(o.scale(.315392*(3*t.z*t.z-1))),this.L22=this.L22.add(o.scale(.546274*(t.x*t.x-t.y*t.y)))},t.prototype.scale=function(t){this.L00=this.L00.scale(t),this.L1_1=this.L1_1.scale(t),this.L10=this.L10.scale(t),this.L11=this.L11.scale(t),this.L2_2=this.L2_2.scale(t),this.L2_1=this.L2_1.scale(t),this.L20=this.L20.scale(t),this.L21=this.L21.scale(t),this.L22=this.L22.scale(t)},t}();t.SphericalHarmonics=g;var R=function(){function t(){this.x=e.Zero(),this.y=e.Zero(),this.z=e.Zero(),this.xx=e.Zero(),this.yy=e.Zero(),this.zz=e.Zero(),this.xy=e.Zero(),this.yz=e.Zero(),this.zx=e.Zero()}return t.prototype.addAmbient=function(t){var i=new e(t.r,t.g,t.b);this.xx=this.xx.add(i),this.yy=this.yy.add(i),this.zz=this.zz.add(i)},t.getSphericalPolynomialFromHarmonics=function(i){var n=new t;return n.x=i.L11.scale(1.02333),n.y=i.L1_1.scale(1.02333),n.z=i.L10.scale(1.02333),n.xx=i.L00.scale(.886277).subtract(i.L20.scale(.247708)).add(i.L22.scale(.429043)),n.yy=i.L00.scale(.886277).subtract(i.L20.scale(.247708)).subtract(i.L22.scale(.429043)),n.zz=i.L00.scale(.886277).add(i.L20.scale(.495417)),n.yz=i.L2_1.scale(.858086),n.zx=i.L21.scale(.858086),n.xy=i.L2_2.scale(.858086),n},t}();t.SphericalPolynomial=R;var T=function(){function t(t,i){void 0===t&&(t=e.Zero()),void 0===i&&(i=e.Up()),this.position=t,this.normal=i}return t.prototype.clone=function(){return new t(this.position.clone(),this.normal.clone())},t}();t.PositionNormalVertex=T;var _=function(){function t(t,i,n){void 0===t&&(t=e.Zero()),void 0===i&&(i=e.Up()),void 0===n&&(n=o.Zero()),this.position=t,this.normal=i,this.uv=n}return t.prototype.clone=function(){return new t(this.position.clone(),this.normal.clone(),this.uv.clone())},t}();t.PositionNormalTextureVertex=_;var M=function(){function t(){}return t.Color3=[n.Black(),n.Black(),n.Black()],t.Vector2=[o.Zero(),o.Zero(),o.Zero()],t.Vector3=[e.Zero(),e.Zero(),e.Zero(),e.Zero(),e.Zero(),e.Zero(),e.Zero(),e.Zero(),e.Zero()],t.Vector4=[s.Zero(),s.Zero(),s.Zero()],t.Quaternion=[new a(0,0,0,0)],t.Matrix=[u.Zero(),u.Zero(),u.Zero(),u.Zero(),u.Zero(),u.Zero(),u.Zero(),u.Zero()],t}();t.Tmp=M}(BABYLON||(BABYLON={}));',
	("undefined" != typeof window && window.module || "undefined" != typeof module) && "undefined" != typeof module.exports && (module.exports = BABYLON);
var _SETTINGS = {
	API: {
		Enabled: !1,
		Log: {
			Events: {
				InitializeGame: !0,
				EndGame: !0,
				Level: {
					Begin: !0,
					End: !0,
					Win: !0,
					Lose: !0,
					Draw: !0
				}
			}
		}
	},
	Ad: {
		Mobile: {
			Preroll: {
				Enabled: !1,
				Duration: 5,
				Width: 300,
				Height: 250,
				Rotation: {
					Enabled: !1,
					Weight: {
						MobileAdInGamePreroll: 40,
						MobileAdInGamePreroll2: 40,
						MobileAdInGamePreroll3: 20
					}
				}
			},
			Header: {
				Enabled: !1,
				Duration: 5,
				Width: 320,
				Height: 50,
				Rotation: {
					Enabled: !1,
					Weight: {
						MobileAdInGameHeader: 40,
						MobileAdInGameHeader2: 40,
						MobileAdInGameHeader3: 20
					}
				}
			},
			Footer: {
				Enabled: !1,
				Duration: 5,
				Width: 320,
				Height: 50,
				Rotation: {
					Enabled: !1,
					Weight: {
						MobileAdInGameFooter: 40,
						MobileAdInGameFooter2: 40,
						MobileAdInGameFooter3: 20
					}
				}
			},
			End: {
				Enabled: !1,
				Duration: 1,
				Width: 300,
				Height: 250,
				Rotation: {
					Enabled: !1,
					Weight: {
						MobileAdInGameEnd: 40,
						MobileAdInGameEnd2: 40,
						MobileAdInGameEnd3: 20
					}
				}
			}
		}
	},
	Language: {
		Default: "en"
	},
	DeveloperBranding: {
		Splash: {
			Enabled: !1
		},
		Logo: {
			Enabled: !1,
			Link: "http://google.com",
			LinkEnabled: !1,
			NewWindow: !0,
			Width: 166,
			Height: 61
		}
	},
	Branding: {
		Splash: {
			Enabled: !1
		},
		Logo: {
			Enabled: !0,
			Link: "http://google.com",
			LinkEnabled: !1,
			NewWindow: !0,
			Width: 166,
			Height: 61
		}
	},
	MoreGames: {
		Enabled: !1,
		Link: "http://www.marketjs.com/game/links/mobile",
		NewWindow: !0
	}
};
var _STRINGS = {
	Ad: {
		Mobile: {
			Preroll: {
				ReadyIn: "The game is ready in ",
				Loading: "Your game is loading...",
				Close: "Close"
			},
			Header: {
				ReadyIn: "The game is ready in ",
				Loading: "Your game is loading...",
				Close: "Close"
			},
			End: {
				ReadyIn: "Advertisement ends in ",
				Loading: "Please wait ...",
				Close: "Close"
			}
		}
	},
	Splash: {
		Loading: "Loading ...",
		LogoLine1: "Some text here",
		LogoLine2: "powered by MarketJS",
		LogoLine3: "none",
		TapToStart: "TAP TO START"
	},
	Game: {
		Play: "PLAY",
		Settings: "SETTINGS",
		More: "MORE GAMES",
		LevelSelect: "LEVEL SELECT",
		Win: "LEVEL COMPLETE",
		Pause: "PAUSE",
		Ok: "OK",
		Level: "LEVEL : ",
		Timeout: "TIME OUT",
		Accuracy: "Accuracy : ",
		Best: "Best Time : ",
		Time: "Time : ",
		ReadyShoot: "READY",
		Shootfired: "Shot Fired : ",
		Shootmissed: "Shot Missed : ",
		TutorialD1: "Drag left mouse button to aim for your target",
		TutorialD2: "Release the mouse button to shoot",
		TutorialM1: "Drag the screen to aim for your target",
		TutorialM2: "Tap the Fire button to shoot"
	},
	Results: {
		Title: "High score"
	}
};
var MobileAdInGamePreroll = {
	ad_duration: _SETTINGS.Ad.Mobile.Preroll.Duration,
	ad_width: _SETTINGS.Ad.Mobile.Preroll.Width,
	ad_height: _SETTINGS.Ad.Mobile.Preroll.Height,
	ready_in: _STRINGS.Ad.Mobile.Preroll.ReadyIn,
	loading: _STRINGS.Ad.Mobile.Preroll.Loading,
	close: _STRINGS.Ad.Mobile.Preroll.Close + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",
	Initialize: function() {
		if (_SETTINGS.Ad.Mobile.Preroll.Rotation.Enabled) {
			var c = _SETTINGS.Ad.Mobile.Preroll.Rotation.Weight,
				b = c.MobileAdInGamePreroll,
				e =
				b + c.MobileAdInGamePreroll2,
				c = e + c.MobileAdInGamePreroll3,
				d = Math.floor(100 * Math.random());
			console.log("seed: ", d);
			d <= b ? this.selectedOverlayName = "MobileAdInGamePreroll" : d <= e ? this.selectedOverlayName = "MobileAdInGamePreroll2" : d <= c && (this.selectedOverlayName = "MobileAdInGamePreroll3");
			console.log("Ad rotating preroll enabled")
		} else this.selectedOverlayName = "MobileAdInGamePreroll", console.log("Ad rotating preroll disabled");
		console.log("selected:", this.selectedOverlayName);
		this.overlay = $("#" + this.selectedOverlayName);
		this.box = $("#" + this.selectedOverlayName + "-Box");
		this.game = $("#game");
		this.boxContents = {
			footer: $("#" + this.selectedOverlayName + "-Box-Footer"),
			header: $("#" + this.selectedOverlayName + "-Box-Header"),
			close: $("#" + this.selectedOverlayName + "-Box-Close"),
			body: $("#" + this.selectedOverlayName + "-Box-Body")
		};
		this.box.width(this.ad_width);
		this.box.height(this.ad_height);
		this.box.css("left", (this.overlay.width() - this.box.width()) / 2);
		this.box.css("top", (this.overlay.height() - this.box.height() - this.boxContents.header.height() -
			this.boxContents.footer.height()) / 2);
		this.overlay.show(this.Timer(this.ad_duration))
	},
	Timer: function(c) {
		var b = c,
			e = setInterval(function() {
				MobileAdInGamePreroll.boxContents.header.text(MobileAdInGamePreroll.ready_in + b + "...");
				MobileAdInGamePreroll.boxContents.footer.text(MobileAdInGamePreroll.loading);
				b--;
				0 > b && (clearInterval(e), MobileAdInGamePreroll.boxContents.close.css("left", MobileAdInGamePreroll.boxContents.body.width() - 23), MobileAdInGamePreroll.boxContents.close.show(), MobileAdInGamePreroll.boxContents.header.html(MobileAdInGamePreroll.close),
					MobileAdInGamePreroll.boxContents.footer.text(""))
			}, 1E3)
	},
	Close: function() {
		this.boxContents.close.hide();
		this.overlay.hide()
	}
};
var MobileAdInGameHeader = {
	ad_duration: _SETTINGS.Ad.Mobile.Header.Duration,
	ad_width: _SETTINGS.Ad.Mobile.Header.Width,
	ad_height: _SETTINGS.Ad.Mobile.Header.Height,
	Initialize: function() {
		if (_SETTINGS.Ad.Mobile.Header.Rotation.Enabled) {
			var c = _SETTINGS.Ad.Mobile.Header.Rotation.Weight,
				b = c.MobileAdInGameHeader,
				e = b + c.MobileAdInGameHeader2,
				c = e + c.MobileAdInGameHeader3,
				d = Math.floor(100 * Math.random());
			console.log("seed: ", d);
			d <= b ? this.selectedOverlayName = "MobileAdInGameHeader" : d <= e ? this.selectedOverlayName = "MobileAdInGameHeader2" :
				d <= c && (this.selectedOverlayName = "MobileAdInGameHeader3");
			console.log("Ad rotating header enabled")
		} else this.selectedOverlayName = "MobileAdInGameHeader", console.log("Ad rotating header disabled");
		this.div = $("#" + this.selectedOverlayName);
		this.game = $("#game");
		this.div.width(this.ad_width);
		this.div.height(this.ad_height);
		this.div.css("left", this.game.position().left + (this.game.width() - this.div.width()) / 2);
		this.div.css("top", 0);
		this.div.show(this.Timer(this.ad_duration))
	},
	Timer: function(c) {
		var b = setInterval(function() {
			c--;
			0 > c && (MobileAdInGameHeader.div.hide(), clearInterval(b))
		}, 1E3)
	}
};
var MobileAdInGameFooter = {
	ad_duration: _SETTINGS.Ad.Mobile.Footer.Duration,
	ad_width: _SETTINGS.Ad.Mobile.Footer.Width,
	ad_height: _SETTINGS.Ad.Mobile.Footer.Height,
	Initialize: function() {
		if (_SETTINGS.Ad.Mobile.Footer.Rotation.Enabled) {
			var c = _SETTINGS.Ad.Mobile.Footer.Rotation.Weight,
				b = c.MobileAdInGameFooter,
				e = b + c.MobileAdInGameFooter2,
				c = e + c.MobileAdInGameFooter3,
				d = Math.floor(100 * Math.random());
			console.log("seed: ", d);
			d <= b ? this.selectedOverlayName = "MobileAdInGameFooter" : d <= e ? this.selectedOverlayName = "MobileAdInGameFooter2" :
				d <= c && (this.selectedOverlayName = "MobileAdInGameFooter3");
			console.log("Ad rotating footer enabled")
		} else this.selectedOverlayName = "MobileAdInGameFooter", console.log("Ad rotating footer disabled");
		this.div = $("#" + this.selectedOverlayName);
		this.game = $("#game");
		this.div.width(this.ad_width);
		this.div.height(this.ad_height);
		this.div.css("left", this.game.position().left + (this.game.width() - this.div.width()) / 2);
		this.div.css("top", this.game.height() - this.div.height() - 5);
		this.div.show(this.Timer(this.ad_duration))
	},
	Timer: function(c) {
		var b = setInterval(function() {
			c--;
			0 > c && (MobileAdInGameFooter.div.hide(), clearInterval(b))
		}, 1E3)
	}
};
var MobileAdInGameEnd = {
	ad_duration: _SETTINGS.Ad.Mobile.End.Duration,
	ad_width: _SETTINGS.Ad.Mobile.End.Width,
	ad_height: _SETTINGS.Ad.Mobile.End.Height,
	ready_in: _STRINGS.Ad.Mobile.End.ReadyIn,
	loading: _STRINGS.Ad.Mobile.End.Loading,
	close: _STRINGS.Ad.Mobile.End.Close + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",
	Initialize: function() {
		if (_SETTINGS.Ad.Mobile.End.Rotation.Enabled) {
			var c = _SETTINGS.Ad.Mobile.End.Rotation.Weight,
				b = c.MobileAdInGameEnd,
				e = b + c.MobileAdInGameEnd2,
				c = e + c.MobileAdInGameEnd3,
				d = Math.floor(100 * Math.random());
			console.log("seed: ", d);
			d <= b ? this.selectedOverlayName = "MobileAdInGameEnd" : d <= e ? this.selectedOverlayName = "MobileAdInGameEnd2" : d <= c && (this.selectedOverlayName = "MobileAdInGameEnd3");
			console.log("Ad rotating end enabled")
		} else this.selectedOverlayName = "MobileAdInGameEnd", console.log("Ad rotating end disabled");
		console.log("selected:", this.selectedOverlayName);
		this.overlay = $("#" + this.selectedOverlayName);
		this.box = $("#" + this.selectedOverlayName + "-Box");
		this.game = $("#game");
		this.boxContents = {
			footer: $("#" + this.selectedOverlayName + "-Box-Footer"),
			header: $("#" + this.selectedOverlayName + "-Box-Header"),
			close: $("#" + this.selectedOverlayName + "-Box-Close"),
			body: $("#" + this.selectedOverlayName + "-Box-Body")
		};
		this.box.width(this.ad_width);
		this.box.height(this.ad_height);
		this.box.css("left", (this.overlay.width() - this.box.width()) / 2);
		this.box.css("top", (this.overlay.height() - this.box.height() - this.boxContents.header.height() - this.boxContents.footer.height()) / 2);
		this.overlay.show(this.Timer(this.ad_duration))
	},
	Timer: function(c) {
		var b = c,
			e = setInterval(function() {
				MobileAdInGameEnd.boxContents.header.text(MobileAdInGameEnd.ready_in + b + "...");
				MobileAdInGameEnd.boxContents.footer.text(MobileAdInGameEnd.loading);
				b--;
				0 > b && (clearInterval(e), MobileAdInGameEnd.boxContents.close.css("left", MobileAdInGameEnd.boxContents.body.width() - 23), MobileAdInGameEnd.boxContents.close.show(), MobileAdInGameEnd.boxContents.header.html(MobileAdInGameEnd.close), MobileAdInGameEnd.boxContents.footer.text(""))
			}, 1E3)
	},
	Close: function() {
		this.boxContents.close.hide();
		this.overlay.hide()
	}
};
var HANDJS = HANDJS || {};
(function() {
	function c() {
		y = !0;
		clearTimeout(A);
		A = setTimeout(function() {
			y = !1
		}, 700)
	}

	function b(c) {
		var b = [];
		if (c)
			for (b.unshift(c); c.parentNode;) b.unshift(c.parentNode), c = c.parentNode;
		return b
	}

	function e(c, d) {
		for (var j = b(c), f = b(d), e = null; 0 < j.length && j[0] == f.shift();) e = j.shift();
		return e
	}

	function d(c, b, d) {
		b = e(c, b);
		for (var j = []; c && c != b;) c.__handjsGlobalRegisteredEvents && c.__handjsGlobalRegisteredEvents.pointerenter && j.push(c), c = c.parentNode;
		for (; 0 < j.length;) d(j.pop())
	}

	function f(c, b, d) {
		for (b = e(c, b); c && c !=
			b;) c.__handjsGlobalRegisteredEvents && c.__handjsGlobalRegisteredEvents.pointerleave && d(c), c = c.parentNode
	}

	function g(c, b) {
		["pointerdown", "pointermove", "pointerup", "pointerover", "pointerout"].forEach(function(d) {
			window.addEventListener(c(d), function(c) {
				!y && s(c.target, d) && b(c, d, !0)
			})
		});
		void 0 === window["on" + c("pointerenter").toLowerCase()] && window.addEventListener(c("pointerover"), function(c) {
			if (!y) {
				var j = s(c.target, "pointerenter");
				j && j !== window && (j.contains(c.relatedTarget) || d(j, c.relatedTarget, function(d) {
					b(c,
						"pointerenter", !1, d)
				}))
			}
		});
		void 0 === window["on" + c("pointerleave").toLowerCase()] && window.addEventListener(c("pointerout"), function(c) {
			if (!y) {
				var d = s(c.target, "pointerleave");
				d && d !== window && (d.contains(c.relatedTarget) || f(d, c.relatedTarget, function(d) {
					b(c, "pointerleave", !1, d)
				}))
			}
		})
	}
	if (!window.PointerEvent) {
		Array.prototype.indexOf || (Array.prototype.indexOf = function(c) {
			var b = Object(this),
				d = b.length >>> 0;
			if (0 === d) return -1;
			var j = 0;
			0 < arguments.length && (j = Number(arguments[1]), j != j ? j = 0 : 0 != j && (Infinity != j &&
				-Infinity != j) && (j = (0 < j || -1) * Math.floor(Math.abs(j))));
			if (j >= d) return -1;
			for (j = 0 <= j ? j : Math.max(d - Math.abs(j), 0); j < d; j++)
				if (j in b && b[j] === c) return j;
			return -1
		});
		String.prototype.trim || (String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/, "")
		});
		var q = "pointerdown pointerup pointermove pointerover pointerout pointercancel pointerenter pointerleave".split(" "),
			m = "PointerDown PointerUp PointerMove PointerOver PointerOut PointerCancel PointerEnter PointerLeave".split(" "),
			j = {},
			l = function(c, b,
				d, j) {
				var f;
				document.createEvent ? (f = document.createEvent("MouseEvents"), f.initMouseEvent(b, d, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, c.ctrlKey, c.altKey, c.shiftKey, c.metaKey, c.button, null)) : (f = document.createEventObject(), f.screenX = c.screenX, f.screenY = c.screenY, f.clientX = c.clientX, f.clientY = c.clientY, f.ctrlKey = c.ctrlKey, f.altKey = c.altKey, f.shiftKey = c.shiftKey, f.metaKey = c.metaKey, f.button = c.button);
				void 0 === f.offsetX && (void 0 !== c.offsetX ? (Object && void 0 !== Object.defineProperty && (Object.defineProperty(f,
					"offsetX", {
						writable: !0
					}), Object.defineProperty(f, "offsetY", {
					writable: !0
				})), f.offsetX = c.offsetX, f.offsetY = c.offsetY) : Object && void 0 !== Object.defineProperty ? (Object.defineProperty(f, "offsetX", {
					get: function() {
						return this.currentTarget && this.currentTarget.offsetLeft ? c.clientX - this.currentTarget.offsetLeft : c.clientX
					}
				}), Object.defineProperty(f, "offsetY", {
					get: function() {
						return this.currentTarget && this.currentTarget.offsetTop ? c.clientY - this.currentTarget.offsetTop : c.clientY
					}
				})) : void 0 !== c.layerX && (f.offsetX =
					c.layerX - c.currentTarget.offsetLeft, f.offsetY = c.layerY - c.currentTarget.offsetTop));
				f.isPrimary = void 0 !== c.isPrimary ? c.isPrimary : !0;
				c.pressure ? f.pressure = c.pressure : (d = 0, void 0 !== c.which ? d = c.which : void 0 !== c.button && (d = c.button), f.pressure = 0 == d ? 0 : 0.5);
				f.rotation = c.rotation ? c.rotation : 0;
				f.hwTimestamp = c.hwTimestamp ? c.hwTimestamp : 0;
				f.tiltX = c.tiltX ? c.tiltX : 0;
				f.tiltY = c.tiltY ? c.tiltY : 0;
				f.height = c.height ? c.height : 0;
				f.width = c.width ? c.width : 0;
				f.preventDefault = function() {
					void 0 !== c.preventDefault && c.preventDefault()
				};
				if (void 0 !== f.stopPropagation) {
					var e = f.stopPropagation;
					f.stopPropagation = function() {
						void 0 !== c.stopPropagation && c.stopPropagation();
						e.call(this)
					}
				}
				f.pointerId = c.pointerId;
				f.pointerType = c.pointerType;
				switch (f.pointerType) {
					case 2:
						f.pointerType = "touch";
						break;
					case 3:
						f.pointerType = "pen";
						break;
					case 4:
						f.pointerType = "mouse"
				}
				j ? j.dispatchEvent(f) : c.target ? c.target.dispatchEvent(f) : c.srcElement.fireEvent("on" + u(b), f)
			},
			p = function(c, b, d, j) {
				c.pointerId = 1;
				c.pointerType = "mouse";
				l(c, b, d, j)
			},
			r = function(c, b, d, j, f) {
				b.pointerId =
					b.identifier + 2;
				b.pointerType = "touch";
				b.currentTarget = d;
				void 0 !== j.preventDefault && (b.preventDefault = function() {
					j.preventDefault()
				});
				l(b, c, f, d)
			},
			s = function(c, b) {
				for (; c && (!c.__handjsGlobalRegisteredEvents || !c.__handjsGlobalRegisteredEvents[b]);) c = c.parentNode;
				if (c) return c;
				if (window.__handjsGlobalRegisteredEvents && window.__handjsGlobalRegisteredEvents[b]) return window
			},
			t = function(c, b, d, j, f) {
				s(d, c) && r(c, b, d, j, f)
			},
			u = function(c) {
				return c.toLowerCase().replace("pointer", "mouse")
			},
			x = function(c, b, d, j) {
				void 0 ===
					c.__handjsRegisteredEvents && (c.__handjsRegisteredEvents = []);
				if (j) void 0 !== c.__handjsRegisteredEvents[b] ? c.__handjsRegisteredEvents[b]++ : (c.__handjsRegisteredEvents[b] = 1, c.addEventListener(b, d, !1));
				else {
					if (-1 !== c.__handjsRegisteredEvents.indexOf(b) && (c.__handjsRegisteredEvents[b]--, 0 != c.__handjsRegisteredEvents[b])) return;
					c.removeEventListener(b, d);
					c.__handjsRegisteredEvents[b] = 0
				}
			},
			z = function(c, b, d) {
				c.__handjsGlobalRegisteredEvents || (c.__handjsGlobalRegisteredEvents = []);
				if (d) {
					if (void 0 !== c.__handjsGlobalRegisteredEvents[b]) {
						c.__handjsGlobalRegisteredEvents[b]++;
						return
					}
					c.__handjsGlobalRegisteredEvents[b] = 1
				} else void 0 !== c.__handjsGlobalRegisteredEvents[b] && (c.__handjsGlobalRegisteredEvents[b]--, 0 > c.__handjsGlobalRegisteredEvents[b] && (c.__handjsGlobalRegisteredEvents[b] = 0));
				if (!window.MSPointerEvent) switch (b) {
					case "pointerenter":
						void 0 !== c.onmouseenter && x(c, "mouseenter", function(c) {
							p(c, b)
						}, d);
						break;
					case "pointerleave":
						void 0 !== c.onmouseleave && x(c, "mouseleave", function(c) {
							p(c, b)
						}, d)
				}
			},
			v = function(c) {
				var b = c.prototype ? c.prototype.addEventListener : c.addEventListener,
					d = function(c, d, j) {
						-1 != q.indexOf(c) && z(this, c, !0);
						void 0 === b ? this.attachEvent("on" + u(c), d) : b.call(this, c, d, j)
					};
				c.prototype ? c.prototype.addEventListener = d : c.addEventListener = d
			},
			B = function(c) {
				var b = c.prototype ? c.prototype.removeEventListener : c.removeEventListener,
					d = function(c, d, j) {
						-1 != q.indexOf(c) && z(this, c, !1);
						void 0 === b ? this.detachEvent(u(c), d) : b.call(this, c, d, j)
					};
				c.prototype ? c.prototype.removeEventListener = d : c.removeEventListener = d
			};
		v(window);
		v(window.HTMLElement || window.Element);
		v(document);
		v(HTMLBodyElement);
		v(HTMLDivElement);
		v(HTMLImageElement);
		v(HTMLUListElement);
		v(HTMLAnchorElement);
		v(HTMLLIElement);
		v(HTMLTableElement);
		window.HTMLSpanElement && v(HTMLSpanElement);
		window.HTMLCanvasElement && v(HTMLCanvasElement);
		window.SVGElement && v(SVGElement);
		B(window);
		B(window.HTMLElement || window.Element);
		B(document);
		B(HTMLBodyElement);
		B(HTMLDivElement);
		B(HTMLImageElement);
		B(HTMLUListElement);
		B(HTMLAnchorElement);
		B(HTMLLIElement);
		B(HTMLTableElement);
		window.HTMLSpanElement && B(HTMLSpanElement);
		window.HTMLCanvasElement &&
			B(HTMLCanvasElement);
		window.SVGElement && B(SVGElement);
		var y = !1,
			A = -1;
		window.MSPointerEvent ? g(function(c) {
			c = q.indexOf(c);
			return "MS" + m[c]
		}, l) : (g(u, p), void 0 !== window.ontouchstart && (window.addEventListener("touchstart", function(b) {
			for (var f = 0; f < b.changedTouches.length; ++f) {
				var e = b.changedTouches[f];
				j[e.identifier] = e.target;
				t("pointerover", e, e.target, b, !0);
				d(e.target, null, function(c) {
					r("pointerenter", e, c, b, !1)
				});
				t("pointerdown", e, e.target, b, !0)
			}
			c()
		}), window.addEventListener("touchend", function(b) {
			for (var d =
					0; d < b.changedTouches.length; ++d) {
				var e = b.changedTouches[d],
					l = j[e.identifier];
				t("pointerup", e, l, b, !0);
				t("pointerout", e, l, b, !0);
				f(l, null, function(c) {
					r("pointerleave", e, c, b, !1)
				})
			}
			c()
		}), window.addEventListener("touchmove", function(b) {
			for (var e = 0; e < b.changedTouches.length; ++e) {
				var l = b.changedTouches[e],
					g = document.elementFromPoint(l.clientX, l.clientY),
					p = j[l.identifier],
					m;
				if (m = p) {
					for (m = p; m && !m.handjs_forcePreventDefault;) m = m.parentNode;
					m = !0 === (!!m || window.handjs_forcePreventDefault)
				}
				m && b.preventDefault();
				t("pointermove", l, p, b, !0);
				p !== g && (p && (t("pointerout", l, p, b, !0), p.contains(g) || f(p, g, function(c) {
					r("pointerleave", l, c, b, !1)
				})), g && (t("pointerover", l, g, b, !0), g.contains(p) || d(g, p, function(c) {
					r("pointerenter", l, c, b, !1)
				})), j[l.identifier] = g)
			}
			c()
		}), window.addEventListener("touchcancel", function(c) {
			for (var b = 0; b < c.changedTouches.length; ++b) {
				var d = c.changedTouches[b];
				t("pointercancel", d, j[d.identifier], c, !0)
			}
		})));
		void 0 === navigator.pointerEnabled && (navigator.pointerEnabled = !0, navigator.msPointerEnabled &&
			(navigator.maxTouchPoints = navigator.msMaxTouchPoints));
		document.styleSheets && document.addEventListener && document.addEventListener("DOMContentLoaded", function() {
			if (!(HANDJS.doNotProcessCSS || void 0 !== document.body.style.touchAction)) {
				var c = /.+?{.*?}/m,
					b = /.+?{/m,
					d = function(d) {
						var j = c.exec(d);
						if (j) {
							j = j[0];
							d = d.replace(j, "").trim();
							var f = b.exec(j)[0].replace("{", "").trim();
							if (-1 != j.replace(/\s/g, "").indexOf("touch-action:none")) {
								j = document.querySelectorAll(f);
								for (f = 0; f < j.length; f++) {
									var e = j[f];
									void 0 !==
										e.style.msTouchAction ? e.style.msTouchAction = "none" : e.handjs_forcePreventDefault = !0
								}
							}
							return d
						}
					},
					j = function(c) {
						if (window.setImmediate) c && setImmediate(j, d(c));
						else
							for (; c;) c = d(c)
					};
				try {
					for (var f = 0; f < document.styleSheets.length; f++) {
						var e = document.styleSheets[f];
						if (void 0 != e.href) {
							var l = new XMLHttpRequest;
							l.open("get", e.href, !1);
							l.send();
							var g = l.responseText.replace(/(\n|\r)/g, "");
							j(g)
						}
					}
				} catch (p) {}
				e = document.getElementsByTagName("style");
				for (f = 0; f < e.length; f++) l = e[f].innerHTML.replace(/(\n|\r)/g, "").trim(),
					j(l)
			}
		}, !1)
	}
})();
window.wgl = {
	modules: {}
};
! function(c) {
	if ("object" == typeof exports && "undefined" != typeof module) module.exports = c();
	else {
		var b;
		"undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self);
		b.CANNON = c()
	}
}(function() {
	return function b(e, d, f) {
		function g(j, l) {
			if (!d[j]) {
				if (!e[j]) {
					var p = "function" == typeof require && require;
					if (!l && p) return p(j, !0);
					if (q) return q(j, !0);
					throw Error("Cannot find module '" + j + "'");
				}
				p = d[j] = {
					exports: {}
				};
				e[j][0].call(p.exports, function(b) {
					var d = e[j][1][b];
					return g(d ?
						d : b)
				}, p, p.exports, b, e, d, f)
			}
			return d[j].exports
		}
		for (var q = "function" == typeof require && require, m = 0; m < f.length; m++) g(f[m]);
		return g
	}({
		1: [function(b, e) {
			e.exports = {
				name: "cannon",
				version: "0.6.2",
				description: "A lightweight 3D physics engine written in JavaScript.",
				homepage: "https://github.com/schteppe/cannon.js",
				author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
				keywords: ["cannon.js", "cannon", "physics", "engine", "3d"],
				main: "./build/cannon.js",
				engines: {
					node: "*"
				},
				repository: {
					type: "git",
					url: "https://github.com/schteppe/cannon.js.git"
				},
				bugs: {
					url: "https://github.com/schteppe/cannon.js/issues"
				},
				licenses: [{
					type: "MIT"
				}],
				devDependencies: {
					jshint: "latest",
					"uglify-js": "latest",
					nodeunit: "^0.9.0",
					grunt: "~0.4.0",
					"grunt-contrib-jshint": "~0.1.1",
					"grunt-contrib-nodeunit": "^0.4.1",
					"grunt-contrib-concat": "~0.1.3",
					"grunt-contrib-uglify": "^0.5.1",
					"grunt-browserify": "^2.1.4",
					"grunt-contrib-yuidoc": "^0.5.2",
					browserify: "*"
				},
				dependencies: {}
			}
		}, {}],
		2: [function(b, e) {
			e.exports = {
				version: b("../package.json").version,
				AABB: b("./collision/AABB"),
				ArrayCollisionMatrix: b("./collision/ArrayCollisionMatrix"),
				Body: b("./objects/Body"),
				Box: b("./shapes/Box"),
				Broadphase: b("./collision/Broadphase"),
				Constraint: b("./constraints/Constraint"),
				ContactEquation: b("./equations/ContactEquation"),
				Narrowphase: b("./world/Narrowphase"),
				ConeTwistConstraint: b("./constraints/ConeTwistConstraint"),
				ContactMaterial: b("./material/ContactMaterial"),
				ConvexPolyhedron: b("./shapes/ConvexPolyhedron"),
				Cylinder: b("./shapes/Cylinder"),
				DistanceConstraint: b("./constraints/DistanceConstraint"),
				Equation: b("./equations/Equation"),
				EventTarget: b("./utils/EventTarget"),
				FrictionEquation: b("./equations/FrictionEquation"),
				GSSolver: b("./solver/GSSolver"),
				GridBroadphase: b("./collision/GridBroadphase"),
				Heightfield: b("./shapes/Heightfield"),
				HingeConstraint: b("./constraints/HingeConstraint"),
				LockConstraint: b("./constraints/LockConstraint"),
				Mat3: b("./math/Mat3"),
				Material: b("./material/Material"),
				NaiveBroadphase: b("./collision/NaiveBroadphase"),
				ObjectCollisionMatrix: b("./collision/ObjectCollisionMatrix"),
				Pool: b("./utils/Pool"),
				Particle: b("./shapes/Particle"),
				Plane: b("./shapes/Plane"),
				PointToPointConstraint: b("./constraints/PointToPointConstraint"),
				Quaternion: b("./math/Quaternion"),
				Ray: b("./collision/Ray"),
				RaycastVehicle: b("./objects/RaycastVehicle"),
				RaycastResult: b("./collision/RaycastResult"),
				RigidVehicle: b("./objects/RigidVehicle"),
				RotationalEquation: b("./equations/RotationalEquation"),
				RotationalMotorEquation: b("./equations/RotationalMotorEquation"),
				SAPBroadphase: b("./collision/SAPBroadphase"),
				SPHSystem: b("./objects/SPHSystem"),
				Shape: b("./shapes/Shape"),
				Solver: b("./solver/Solver"),
				Sphere: b("./shapes/Sphere"),
				SplitSolver: b("./solver/SplitSolver"),
				Spring: b("./objects/Spring"),
				Trimesh: b("./shapes/Trimesh"),
				Vec3: b("./math/Vec3"),
				Vec3Pool: b("./utils/Vec3Pool"),
				World: b("./world/World")
			}
		}, {
			"../package.json": 1,
			"./collision/AABB": 3,
			"./collision/ArrayCollisionMatrix": 4,
			"./collision/Broadphase": 5,
			"./collision/GridBroadphase": 6,
			"./collision/NaiveBroadphase": 7,
			"./collision/ObjectCollisionMatrix": 8,
			"./collision/Ray": 9,
			"./collision/RaycastResult": 10,
			"./collision/SAPBroadphase": 11,
			"./constraints/ConeTwistConstraint": 12,
			"./constraints/Constraint": 13,
			"./constraints/DistanceConstraint": 14,
			"./constraints/HingeConstraint": 15,
			"./constraints/LockConstraint": 16,
			"./constraints/PointToPointConstraint": 17,
			"./equations/ContactEquation": 19,
			"./equations/Equation": 20,
			"./equations/FrictionEquation": 21,
			"./equations/RotationalEquation": 22,
			"./equations/RotationalMotorEquation": 23,
			"./material/ContactMaterial": 24,
			"./material/Material": 25,
			"./math/Mat3": 27,
			"./math/Quaternion": 28,
			"./math/Vec3": 30,
			"./objects/Body": 31,
			"./objects/RaycastVehicle": 32,
			"./objects/RigidVehicle": 33,
			"./objects/SPHSystem": 34,
			"./objects/Spring": 35,
			"./shapes/Box": 37,
			"./shapes/ConvexPolyhedron": 38,
			"./shapes/Cylinder": 39,
			"./shapes/Heightfield": 40,
			"./shapes/Particle": 41,
			"./shapes/Plane": 42,
			"./shapes/Shape": 43,
			"./shapes/Sphere": 44,
			"./shapes/Trimesh": 45,
			"./solver/GSSolver": 46,
			"./solver/Solver": 47,
			"./solver/SplitSolver": 48,
			"./utils/EventTarget": 49,
			"./utils/Pool": 51,
			"./utils/Vec3Pool": 54,
			"./world/Narrowphase": 55,
			"./world/World": 56
		}],
		3: [function(b, e) {
			function d(b) {
				b = b || {};
				this.lowerBound =
					new f;
				b.lowerBound && this.lowerBound.copy(b.lowerBound);
				this.upperBound = new f;
				b.upperBound && this.upperBound.copy(b.upperBound)
			}
			var f = b("../math/Vec3");
			b("../utils/Utils");
			e.exports = d;
			var g = new f;
			d.prototype.setFromPoints = function(b, d, f, e) {
				var r = this.lowerBound,
					s = this.upperBound;
				r.copy(b[0]);
				f && f.vmult(r, r);
				s.copy(r);
				for (var q = 1; q < b.length; q++) {
					var u = b[q];
					f && (f.vmult(u, g), u = g);
					u.x > s.x && (s.x = u.x);
					u.x < r.x && (r.x = u.x);
					u.y > s.y && (s.y = u.y);
					u.y < r.y && (r.y = u.y);
					u.z > s.z && (s.z = u.z);
					u.z < r.z && (r.z = u.z)
				}
				d && (d.vadd(r,
					r), d.vadd(s, s));
				e && (r.x -= e, r.y -= e, r.z -= e, s.x += e, s.y += e, s.z += e);
				return this
			};
			d.prototype.copy = function(b) {
				this.lowerBound.copy(b.lowerBound);
				this.upperBound.copy(b.upperBound);
				return this
			};
			d.prototype.clone = function() {
				return (new d).copy(this)
			};
			d.prototype.extend = function(b) {
				var d = b.lowerBound.x;
				this.lowerBound.x > d && (this.lowerBound.x = d);
				d = b.upperBound.x;
				this.upperBound.x < d && (this.upperBound.x = d);
				d = b.lowerBound.y;
				this.lowerBound.y > d && (this.lowerBound.y = d);
				d = b.upperBound.y;
				this.upperBound.y < d && (this.upperBound.y =
					d);
				d = b.lowerBound.z;
				this.lowerBound.z > d && (this.lowerBound.z = d);
				d = b.upperBound.z;
				this.upperBound.z < d && (this.upperBound.z = d)
			};
			d.prototype.overlaps = function(b) {
				var d = this.lowerBound,
					f = this.upperBound,
					e = b.lowerBound;
				b = b.upperBound;
				return (e.x <= f.x && f.x <= b.x || d.x <= b.x && b.x <= f.x) && (e.y <= f.y && f.y <= b.y || d.y <= b.y && b.y <= f.y) && (e.z <= f.z && f.z <= b.z || d.z <= b.z && b.z <= f.z)
			};
			d.prototype.contains = function(b) {
				var d = this.lowerBound,
					f = this.upperBound,
					e = b.lowerBound;
				b = b.upperBound;
				return d.x <= e.x && f.x >= b.x && d.y <= e.y && f.y >=
					b.y && d.z <= e.z && f.z >= b.z
			};
			d.prototype.getCorners = function(b, d, f, e, g, s, q, u) {
				var x = this.lowerBound,
					z = this.upperBound;
				b.copy(x);
				d.set(z.x, x.y, x.z);
				f.set(z.x, z.y, x.z);
				e.set(x.x, z.y, z.z);
				g.set(z.x, x.y, x.z);
				s.set(x.x, z.y, x.z);
				q.set(x.x, x.y, z.z);
				u.copy(z)
			};
			var q = [new f, new f, new f, new f, new f, new f, new f, new f];
			d.prototype.toLocalFrame = function(b, d) {
				this.getCorners(q[0], q[1], q[2], q[3], q[4], q[5], q[6], q[7]);
				for (var f = 0; 8 !== f; f++) {
					var e = q[f];
					b.pointToLocal(e, e)
				}
				return d.setFromPoints(q)
			};
			d.prototype.toWorldFrame =
				function(b, d) {
					this.getCorners(q[0], q[1], q[2], q[3], q[4], q[5], q[6], q[7]);
					for (var f = 0; 8 !== f; f++) {
						var e = q[f];
						b.pointToWorld(e, e)
					}
					return d.setFromPoints(q)
				}
		}, {
			"../math/Vec3": 30,
			"../utils/Utils": 53
		}],
		4: [function(b, e) {
			function d() {
				this.matrix = []
			}
			e.exports = d;
			d.prototype.get = function(b, d) {
				b = b.index;
				d = d.index;
				if (d > b) {
					var e = d;
					d = b;
					b = e
				}
				return this.matrix[(b * (b + 1) >> 1) + d - 1]
			};
			d.prototype.set = function(b, d, e) {
				b = b.index;
				d = d.index;
				if (d > b) {
					var m = d;
					d = b;
					b = m
				}
				this.matrix[(b * (b + 1) >> 1) + d - 1] = e ? 1 : 0
			};
			d.prototype.reset = function() {
				for (var b =
						0, d = this.matrix.length; b !== d; b++) this.matrix[b] = 0
			};
			d.prototype.setNumObjects = function(b) {
				this.matrix.length = b * (b - 1) >> 1
			}
		}, {}],
		5: [function(b, e) {
			function d() {
				this.world = null;
				this.useBoundingBoxes = !1;
				this.dirty = !0
			}
			var f = b("../objects/Body"),
				g = b("../math/Vec3"),
				q = b("../math/Quaternion");
			b("../shapes/Shape");
			b("../shapes/Plane");
			e.exports = d;
			d.prototype.collisionPairs = function() {
				throw Error("collisionPairs not implemented for this BroadPhase class!");
			};
			var m = f.STATIC | f.KINEMATIC;
			d.prototype.needBroadphaseCollision =
				function(b, d) {
					return 0 === (b.collisionFilterGroup & d.collisionFilterMask) || 0 === (d.collisionFilterGroup & b.collisionFilterMask) || (0 !== (b.type & m) || b.sleepState === f.SLEEPING) && (0 !== (d.type & m) || d.sleepState === f.SLEEPING) ? !1 : !0
				};
			d.prototype.intersectionTest = function(b, d, j, f) {
				this.useBoundingBoxes ? this.doBoundingBoxBroadphase(b, d, j, f) : this.doBoundingSphereBroadphase(b, d, j, f)
			};
			var j = new g;
			new g;
			new q;
			new g;
			d.prototype.doBoundingSphereBroadphase = function(b, d, f, e) {
				d.position.vsub(b.position, j);
				var l = Math.pow(b.boundingRadius +
					d.boundingRadius, 2);
				j.norm2() < l && (f.push(b), e.push(d))
			};
			d.prototype.doBoundingBoxBroadphase = function(b, d, f, j) {
				b.aabbNeedsUpdate && b.computeAABB();
				d.aabbNeedsUpdate && d.computeAABB();
				b.aabb.overlaps(d.aabb) && (f.push(b), j.push(d))
			};
			var l = {
					keys: []
				},
				p = [],
				r = [];
			d.prototype.makePairsUnique = function(b, d) {
				for (var f = b.length, j = 0; j !== f; j++) p[j] = b[j], r[j] = d[j];
				b.length = 0;
				for (j = d.length = 0; j !== f; j++) {
					var e = p[j].id,
						g = r[j].id,
						e = e < g ? e + "," + g : g + "," + e;
					l[e] = j;
					l.keys.push(e)
				}
				for (j = 0; j !== l.keys.length; j++) e = l.keys.pop(),
					f = l[e], b.push(p[f]), d.push(r[f]), delete l[e]
			};
			d.prototype.setWorld = function() {};
			var s = new g;
			d.boundingSphereCheck = function(b, d) {
				b.position.vsub(d.position, s);
				return Math.pow(b.shape.boundingSphereRadius + d.shape.boundingSphereRadius, 2) > s.norm2()
			};
			d.prototype.aabbQuery = function() {
				console.warn(".aabbQuery is not implemented in this Broadphase subclass.");
				return []
			}
		}, {
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"../objects/Body": 31,
			"../shapes/Plane": 42,
			"../shapes/Shape": 43
		}],
		6: [function(b, e) {
			function d(b,
				d, e, m, s) {
				f.apply(this);
				this.nx = e || 10;
				this.ny = m || 10;
				this.nz = s || 10;
				this.aabbMin = b || new g(100, 100, 100);
				this.aabbMax = d || new g(-100, -100, -100);
				b = this.nx * this.ny * this.nz;
				if (0 >= b) throw "GridBroadphase: Each dimension's n must be >0";
				this.bins = [];
				this.binLengths = [];
				this.bins.length = b;
				this.binLengths.length = b;
				for (d = 0; d < b; d++) this.bins[d] = [], this.binLengths[d] = 0
			}
			e.exports = d;
			var f = b("./Broadphase"),
				g = b("../math/Vec3"),
				q = b("../shapes/Shape");
			d.prototype = new f;
			d.prototype.constructor = d;
			var m = new g;
			new g;
			d.prototype.collisionPairs =
				function(b, d, f) {
					function e(b, d, f, j, l, g, p) {
						b = (b - I) * O | 0;
						d = (d - N) * H | 0;
						f = (f - K) * W | 0;
						j = oa((j - I) * O);
						l = oa((l - N) * H);
						g = oa((g - K) * W);
						0 > b ? b = 0 : b >= x && (b = x - 1);
						0 > d ? d = 0 : d >= z && (d = z - 1);
						0 > f ? f = 0 : f >= v && (f = v - 1);
						0 > j ? j = 0 : j >= x && (j = x - 1);
						0 > l ? l = 0 : l >= z && (l = z - 1);
						0 > g ? g = 0 : g >= v && (g = v - 1);
						b *= B;
						d *= y;
						f *= A;
						j *= B;
						l *= y;
						for (g *= A; b <= j; b += B)
							for (var m = d; m <= l; m += y)
								for (var r = f; r <= g; r += A) {
									var s = b + m + r;
									Q[s][ca[s]++] = p
								}
					}
					var g = b.numObjects();
					b = b.bodies;
					for (var t = this.aabbMax, u = this.aabbMin, x = this.nx, z = this.ny, v = this.nz, B = z * v, y = v, A = 1, F = t.x, C = t.y, D = t.z,
							I = u.x, N = u.y, K = u.z, O = x / (F - I), H = z / (C - N), W = v / (D - K), F = (F - I) / x, aa = (C - N) / z, D = (D - K) / v, E = 0.5 * Math.sqrt(F * F + aa * aa + D * D), C = q.types, G = C.SPHERE, ba = C.PLANE, Q = this.bins, ca = this.binLengths, C = this.bins.length, u = 0; u !== C; u++) ca[u] = 0;
					for (var oa = Math.ceil, u = Math.min, t = Math.max, u = 0; u !== g; u++) {
						var t = b[u],
							T = t.shape;
						switch (T.type) {
							case G:
								var ha = t.position.x,
									Y = t.position.y,
									la = t.position.z,
									T = T.radius;
								e(ha - T, Y - T, la - T, ha + T, Y + T, la + T, t);
								break;
							case ba:
								T.worldNormalNeedsUpdate && T.computeWorldNormal(t.quaternion);
								var la = T.worldNormal,
									T = N + 0.5 * aa - t.position.y,
									ra = K + 0.5 * D - t.position.z,
									da = m;
								da.set(I + 0.5 * F - t.position.x, T, ra);
								for (var ma = ha = 0; ha !== x; ha++, ma += B, da.y = T, da.x += F)
									for (var ya = Y = 0; Y !== z; Y++, ya += y, da.z = ra, da.y += aa)
										for (var ka = 0, pa = 0; ka !== v; ka++, pa += A, da.z += D)
											if (da.dot(la) < E) {
												var J = ma + ya + pa;
												Q[J][ca[J]++] = t
											}
								break;
							default:
								t.aabbNeedsUpdate && t.computeAABB(), e(t.aabb.lowerBound.x, t.aabb.lowerBound.y, t.aabb.lowerBound.z, t.aabb.upperBound.x, t.aabb.upperBound.y, t.aabb.upperBound.z, t)
						}
					}
					for (u = 0; u !== C; u++)
						if (g = ca[u], 1 < g) {
							b = Q[u];
							for (ha = 0; ha !==
								g; ha++) {
								t = b[ha];
								for (Y = 0; Y !== ha; Y++) F = b[Y], this.needBroadphaseCollision(t, F) && this.intersectionTest(t, F, d, f)
							}
						}
					this.makePairsUnique(d, f)
				}
		}, {
			"../math/Vec3": 30,
			"../shapes/Shape": 43,
			"./Broadphase": 5
		}],
		7: [function(b, e) {
			function d() {
				f.apply(this)
			}
			e.exports = d;
			var f = b("./Broadphase"),
				g = b("./AABB");
			d.prototype = new f;
			d.prototype.constructor = d;
			d.prototype.collisionPairs = function(b, d, f) {
				b = b.bodies;
				var e = b.length,
					g, r, s, t;
				for (g = 0; g !== e; g++)
					for (r = 0; r !== g; r++) s = b[g], t = b[r], this.needBroadphaseCollision(s, t) && this.intersectionTest(s,
						t, d, f)
			};
			new g;
			d.prototype.aabbQuery = function(b, d, f) {
				f = f || [];
				for (var e = 0; e < b.bodies.length; e++) {
					var g = b.bodies[e];
					g.aabbNeedsUpdate && g.computeAABB();
					g.aabb.overlaps(d) && f.push(g)
				}
				return f
			}
		}, {
			"./AABB": 3,
			"./Broadphase": 5
		}],
		8: [function(b, e) {
			function d() {
				this.matrix = {}
			}
			e.exports = d;
			d.prototype.get = function(b, d) {
				b = b.id;
				d = d.id;
				if (d > b) {
					var e = d;
					d = b;
					b = e
				}
				return b + "-" + d in this.matrix
			};
			d.prototype.set = function(b, d, e) {
				b = b.id;
				d = d.id;
				if (d > b) {
					var m = d;
					d = b;
					b = m
				}
				e ? this.matrix[b + "-" + d] = !0 : delete this.matrix[b + "-" + d]
			};
			d.prototype.reset = function() {
				this.matrix = {}
			};
			d.prototype.setNumObjects = function() {}
		}, {}],
		9: [function(b, e) {
			function d(b, f) {
				this.from = b ? b.clone() : new g;
				this.to = f ? f.clone() : new g;
				this._direction = new g;
				this.precision = 1E-4;
				this.checkCollisionResponse = !0;
				this.skipBackfaces = !1;
				this.collisionFilterGroup = this.collisionFilterMask = -1;
				this.mode = d.ANY;
				this.result = new j;
				this.hasHit = !1;
				this.callback = function() {}
			}

			function f(b, d, f, j) {
				j.vsub(d, Q);
				f.vsub(d, t);
				b.vsub(d, u);
				b = Q.dot(Q);
				d = Q.dot(t);
				f = Q.dot(u);
				j = t.dot(t);
				var e = t.dot(u),
					l, g;
				return 0 <= (l = j * f - d * e) && 0 <= (g = b * e - d * f) && l + g < b * j - d * d
			}
			e.exports = d;
			var g = b("../math/Vec3"),
				q = b("../math/Quaternion"),
				m = b("../math/Transform");
			b("../shapes/ConvexPolyhedron");
			b("../shapes/Box");
			var j = b("../collision/RaycastResult"),
				l = b("../shapes/Shape"),
				p = b("../collision/AABB");
			d.prototype.constructor = d;
			d.CLOSEST = 1;
			d.ANY = 2;
			d.ALL = 4;
			var r = new p,
				s = [];
			d.prototype.intersectWorld = function(b, f) {
				this.mode = f.mode || d.ANY;
				this.result = f.result || new j;
				this.skipBackfaces = !!f.skipBackfaces;
				this.collisionFilterMask =
					"undefined" !== typeof f.collisionFilterMask ? f.collisionFilterMask : -1;
				this.collisionFilterGroup = "undefined" !== typeof f.collisionFilterGroup ? f.collisionFilterGroup : -1;
				f.from && this.from.copy(f.from);
				f.to && this.to.copy(f.to);
				this.callback = f.callback || function() {};
				this.hasHit = !1;
				this.result.reset();
				this._updateDirection();
				this.getAABB(r);
				s.length = 0;
				b.broadphase.aabbQuery(b, r, s);
				this.intersectBodies(s);
				return this.hasHit
			};
			var t = new g,
				u = new g;
			d.pointInTriangle = f;
			var x = new g,
				z = new q;
			d.prototype.intersectBody =
				function(b, d) {
					d && (this.result = d, this._updateDirection());
					var f = this.checkCollisionResponse;
					if (!f || b.collisionResponse)
						if (!(0 === (this.collisionFilterGroup & b.collisionFilterMask) || 0 === (b.collisionFilterGroup & this.collisionFilterMask)))
							for (var j = 0, e = b.shapes.length; j < e; j++) {
								var l = b.shapes[j];
								if (!f || l.collisionResponse)
									if (b.quaternion.mult(b.shapeOrientations[j], z), b.quaternion.vmult(b.shapeOffsets[j], x), x.vadd(b.position, x), this.intersectShape(l, z, x, b), this.result._shouldStop) break
							}
				};
			d.prototype.intersectBodies =
				function(b, d) {
					d && (this.result = d, this._updateDirection());
					for (var f = 0, j = b.length; !this.result._shouldStop && f < j; f++) this.intersectBody(b[f])
				};
			d.prototype._updateDirection = function() {
				this.to.vsub(this.from, this._direction);
				this._direction.normalize()
			};
			d.prototype.intersectShape = function(b, d, f, j) {
				var e = this.from,
					l = this._direction;
				f.vsub(e, Q);
				var g = Q.dot(l);
				l.mult(g, ca);
				ca.vadd(e, ca);
				f.distanceTo(ca) > b.boundingSphereRadius || (e = this[b.type]) && e.call(this, b, d, f, j)
			};
			new g;
			new g;
			var v = new g,
				B = new g,
				y = new g,
				A = new g;
			new g;
			new j;
			d.prototype.intersectBox = function(b, d, f, j) {
				return this.intersectConvex(b.convexPolyhedronRepresentation, d, f, j)
			};
			d.prototype[l.types.BOX] = d.prototype.intersectBox;
			d.prototype.intersectPlane = function(b, d, f, j) {
				var e = this.from,
					l = this.to,
					p = this._direction,
					m = new g(0, 0, 1);
				d.vmult(m, m);
				var r = new g;
				e.vsub(f, r);
				d = r.dot(m);
				l.vsub(f, r);
				r = r.dot(m);
				if (!(0 < d * r) && !(e.distanceTo(l) < d) && (r = m.dot(p), !(Math.abs(r) < this.precision))) {
					var s = new g,
						l = new g;
					d = new g;
					e.vsub(f, s);
					f = -m.dot(s) / r;
					p.scale(f, l);
					e.vadd(l, d);
					this.reportIntersection(m, d, b, j, -1)
				}
			};
			d.prototype[l.types.PLANE] = d.prototype.intersectPlane;
			d.prototype.getAABB = function(b) {
				var d = this.to,
					f = this.from;
				b.lowerBound.x = Math.min(d.x, f.x);
				b.lowerBound.y = Math.min(d.y, f.y);
				b.lowerBound.z = Math.min(d.z, f.z);
				b.upperBound.x = Math.max(d.x, f.x);
				b.upperBound.y = Math.max(d.y, f.y);
				b.upperBound.z = Math.max(d.z, f.z)
			};
			var F = {
				faceList: [0]
			};
			d.prototype.intersectHeightfield = function(b, f, j, e) {
				var l = new g,
					p = new d(this.from, this.to);
				m.pointToLocalFrame(j, f, p.from,
					p.from);
				m.pointToLocalFrame(j, f, p.to, p.to);
				var r = [],
					s = null,
					q = null,
					t = null,
					u = null,
					x = b.getIndexOfPosition(p.from.x, p.from.y, r, !1);
				x && (s = r[0], q = r[1], t = r[0], u = r[1]);
				if (x = b.getIndexOfPosition(p.to.x, p.to.y, r, !1)) {
					if (null === s || r[0] < s) s = r[0];
					if (null === t || r[0] > t) t = r[0];
					if (null === q || r[1] < q) q = r[1];
					if (null === u || r[1] > u) u = r[1]
				}
				if (null !== s) {
					b.getRectMinMax(s, q, t, u, []);
					for (p = s; p <= t; p++)
						for (r = q; r <= u; r++) {
							if (this.result._shouldStop) return;
							b.getConvexTrianglePillar(p, r, !1);
							m.pointToWorldFrame(j, f, b.pillarOffset, l);
							this.intersectConvex(b.pillarConvex, f, l, e, F);
							if (this.result._shouldStop) return;
							b.getConvexTrianglePillar(p, r, !0);
							m.pointToWorldFrame(j, f, b.pillarOffset, l);
							this.intersectConvex(b.pillarConvex, f, l, e, F)
						}
				}
			};
			d.prototype[l.types.HEIGHTFIELD] = d.prototype.intersectHeightfield;
			var C = new g,
				D = new g;
			d.prototype.intersectSphere = function(b, d, f, j) {
				d = this.from;
				var e = this.to,
					l = b.radius,
					g = Math.pow(e.x - d.x, 2) + Math.pow(e.y - d.y, 2) + Math.pow(e.z - d.z, 2),
					p = 2 * ((e.x - d.x) * (d.x - f.x) + (e.y - d.y) * (d.y - f.y) + (e.z - d.z) * (d.z - f.z)),
					l =
					Math.pow(d.x - f.x, 2) + Math.pow(d.y - f.y, 2) + Math.pow(d.z - f.z, 2) - Math.pow(l, 2),
					m = Math.pow(p, 2) - 4 * g * l;
				0 > m || (0 === m ? (d.lerp(e, m, C), C.vsub(f, D), D.normalize(), this.reportIntersection(D, C, b, j, -1)) : (l = (-p - Math.sqrt(m)) / (2 * g), g = (-p + Math.sqrt(m)) / (2 * g), 0 <= l && 1 >= l && (d.lerp(e, l, C), C.vsub(f, D), D.normalize(), this.reportIntersection(D, C, b, j, -1)), !this.result._shouldStop && (0 <= g && 1 >= g) && (d.lerp(e, g, C), C.vsub(f, D), D.normalize(), this.reportIntersection(D, C, b, j, -1))))
			};
			d.prototype[l.types.SPHERE] = d.prototype.intersectSphere;
			var I = new g;
			new g;
			new g;
			var N = new g;
			d.prototype.intersectConvex = function(b, d, j, e, l) {
				l = l && l.faceList || null;
				for (var g = b.faces, p = b.vertices, m = b.faceNormals, r = this._direction, s = this.from, q = s.distanceTo(this.to), t = l ? l.length : g.length, u = this.result, x = 0; !u._shouldStop && x < t; x++) {
					var z = l ? l[x] : x,
						ca = g[z],
						H = m[z],
						C = d,
						G = j;
					N.copy(p[ca[0]]);
					C.vmult(N, N);
					N.vadd(G, N);
					N.vsub(s, N);
					C.vmult(H, I);
					H = r.dot(I);
					if (!(Math.abs(H) < this.precision) && (H = I.dot(N) / H, !(0 > H))) {
						r.mult(H, v);
						v.vadd(s, v);
						B.copy(p[ca[0]]);
						C.vmult(B, B);
						G.vadd(B,
							B);
						for (H = 1; !u._shouldStop && H < ca.length - 1; H++) {
							y.copy(p[ca[H]]);
							A.copy(p[ca[H + 1]]);
							C.vmult(y, y);
							C.vmult(A, A);
							G.vadd(y, y);
							G.vadd(A, A);
							var E = v.distanceTo(s);
							!f(v, B, y, A) && !f(v, y, B, A) || E > q || this.reportIntersection(I, v, b, e, z)
						}
					}
				}
			};
			d.prototype[l.types.CONVEXPOLYHEDRON] = d.prototype.intersectConvex;
			var K = new g,
				O = new g,
				H = new g,
				W = new g,
				aa = new g,
				E = new g;
			new p;
			var G = [],
				ba = new m;
			d.prototype.intersectTrimesh = function(b, d, j, e) {
				var l = b.indices,
					g = this.from,
					p = this.to,
					r = this._direction;
				ba.position.copy(j);
				ba.quaternion.copy(d);
				m.vectorToLocalFrame(j, d, r, O);
				m.pointToLocalFrame(j, d, g, H);
				m.pointToLocalFrame(j, d, p, W);
				g = H.distanceSquared(W);
				b.tree.rayQuery(this, ba, G);
				p = 0;
				for (r = G.length; !this.result._shouldStop && p !== r; p++) {
					var s = G[p];
					b.getNormal(s, K);
					b.getVertex(l[3 * s], B);
					B.vsub(H, N);
					var q = O.dot(K),
						q = K.dot(N) / q;
					0 > q || (O.scale(q, v), v.vadd(H, v), b.getVertex(l[3 * s + 1], y), b.getVertex(l[3 * s + 2], A), q = v.distanceSquared(H), !f(v, y, B, A) && !f(v, B, y, A) || q > g || (m.vectorToWorldFrame(d, K, aa), m.pointToWorldFrame(j, d, v, E), this.reportIntersection(aa,
						E, b, e, s)))
				}
				G.length = 0
			};
			d.prototype[l.types.TRIMESH] = d.prototype.intersectTrimesh;
			d.prototype.reportIntersection = function(b, f, j, e, l) {
				var g = this.from,
					p = this.to,
					m = g.distanceTo(f),
					r = this.result;
				if (!(this.skipBackfaces && 0 < b.dot(this._direction))) switch (r.hitFaceIndex = "undefined" !== typeof l ? l : -1, this.mode) {
					case d.ALL:
						this.hasHit = !0;
						r.set(g, p, b, f, j, e, m);
						r.hasHit = !0;
						this.callback(r);
						break;
					case d.CLOSEST:
						if (m < r.distance || !r.hasHit) this.hasHit = !0, r.hasHit = !0, r.set(g, p, b, f, j, e, m);
						break;
					case d.ANY:
						this.hasHit = !0, r.hasHit = !0, r.set(g, p, b, f, j, e, m), r._shouldStop = !0
				}
			};
			var Q = new g,
				ca = new g
		}, {
			"../collision/AABB": 3,
			"../collision/RaycastResult": 10,
			"../math/Quaternion": 28,
			"../math/Transform": 29,
			"../math/Vec3": 30,
			"../shapes/Box": 37,
			"../shapes/ConvexPolyhedron": 38,
			"../shapes/Shape": 43
		}],
		10: [function(b, e) {
			function d() {
				this.rayFromWorld = new f;
				this.rayToWorld = new f;
				this.hitNormalWorld = new f;
				this.hitPointWorld = new f;
				this.hasHit = !1;
				this.body = this.shape = null;
				this.distance = this.hitFaceIndex = -1;
				this._shouldStop = !1
			}
			var f =
				b("../math/Vec3");
			e.exports = d;
			d.prototype.reset = function() {
				this.rayFromWorld.setZero();
				this.rayToWorld.setZero();
				this.hitNormalWorld.setZero();
				this.hitPointWorld.setZero();
				this.hasHit = !1;
				this.body = this.shape = null;
				this.distance = this.hitFaceIndex = -1;
				this._shouldStop = !1
			};
			d.prototype.abort = function() {
				this._shouldStop = !0
			};
			d.prototype.set = function(b, d, f, j, e, p, r) {
				this.rayFromWorld.copy(b);
				this.rayToWorld.copy(d);
				this.hitNormalWorld.copy(f);
				this.hitPointWorld.copy(j);
				this.shape = e;
				this.body = p;
				this.distance =
					r
			}
		}, {
			"../math/Vec3": 30
		}],
		11: [function(b, e) {
			function d(b) {
				f.apply(this);
				this.axisList = [];
				this.world = null;
				this.axisIndex = 0;
				var d = this.axisList;
				this._addBodyHandler = function(b) {
					d.push(b.body)
				};
				this._removeBodyHandler = function(b) {
					b = d.indexOf(b.body); - 1 !== b && d.splice(b, 1)
				};
				b && this.setWorld(b)
			}
			b("../shapes/Shape");
			var f = b("../collision/Broadphase");
			e.exports = d;
			d.prototype = new f;
			d.prototype.setWorld = function(b) {
				for (var d = this.axisList.length = 0; d < b.bodies.length; d++) this.axisList.push(b.bodies[d]);
				b.removeEventListener("addBody",
					this._addBodyHandler);
				b.removeEventListener("removeBody", this._removeBodyHandler);
				b.addEventListener("addBody", this._addBodyHandler);
				b.addEventListener("removeBody", this._removeBodyHandler);
				this.world = b;
				this.dirty = !0
			};
			d.insertionSortX = function(b) {
				for (var d = 1, f = b.length; d < f; d++) {
					for (var j = b[d], e = d - 1; 0 <= e && !(b[e].aabb.lowerBound.x <= j.aabb.lowerBound.x); e--) b[e + 1] = b[e];
					b[e + 1] = j
				}
				return b
			};
			d.insertionSortY = function(b) {
				for (var d = 1, f = b.length; d < f; d++) {
					for (var j = b[d], e = d - 1; 0 <= e && !(b[e].aabb.lowerBound.y <=
							j.aabb.lowerBound.y); e--) b[e + 1] = b[e];
					b[e + 1] = j
				}
				return b
			};
			d.insertionSortZ = function(b) {
				for (var d = 1, f = b.length; d < f; d++) {
					for (var j = b[d], e = d - 1; 0 <= e && !(b[e].aabb.lowerBound.z <= j.aabb.lowerBound.z); e--) b[e + 1] = b[e];
					b[e + 1] = j
				}
				return b
			};
			d.prototype.collisionPairs = function(b, f, e) {
				b = this.axisList;
				var j = b.length,
					l = this.axisIndex,
					p, r;
				this.dirty && (this.sortList(), this.dirty = !1);
				for (p = 0; p !== j; p++) {
					var s = b[p];
					for (r = p + 1; r < j; r++) {
						var t = b[r];
						if (this.needBroadphaseCollision(s, t)) {
							if (!d.checkBounds(s, t, l)) break;
							this.intersectionTest(s,
								t, f, e)
						}
					}
				}
			};
			d.prototype.sortList = function() {
				for (var b = this.axisList, f = this.axisIndex, e = b.length, j = 0; j !== e; j++) {
					var l = b[j];
					l.aabbNeedsUpdate && l.computeAABB()
				}
				0 === f ? d.insertionSortX(b) : 1 === f ? d.insertionSortY(b) : 2 === f && d.insertionSortZ(b)
			};
			d.checkBounds = function(b, d, f) {
				var j, e;
				0 === f ? (j = b.position.x, e = d.position.x) : 1 === f ? (j = b.position.y, e = d.position.y) : 2 === f && (j = b.position.z, e = d.position.z);
				return e - d.boundingRadius < j + b.boundingRadius
			};
			d.prototype.autoDetectAxis = function() {
				for (var b = 0, d = 0, f = 0, j = 0, e = 0,
						p = 0, r = this.axisList, s = r.length, t = 1 / s, u = 0; u !== s; u++) var x = r[u],
					z = x.position.x,
					b = b + z,
					d = d + z * z,
					z = x.position.y,
					f = f + z,
					j = j + z * z,
					x = x.position.z,
					e = e + x,
					p = p + x * x;
				b = d - b * b * t;
				f = j - f * f * t;
				e = p - e * e * t;
				this.axisIndex = b > f ? b > e ? 0 : 2 : f > e ? 1 : 2
			};
			d.prototype.aabbQuery = function(b, d, f) {
				f = f || [];
				this.dirty && (this.sortList(), this.dirty = !1);
				b = this.axisList;
				for (var j = 0; j < b.length; j++) {
					var e = b[j];
					e.aabbNeedsUpdate && e.computeAABB();
					e.aabb.overlaps(d) && f.push(e)
				}
				return f
			}
		}, {
			"../collision/Broadphase": 5,
			"../shapes/Shape": 43
		}],
		12: [function(b,
			e) {
			function d(b, d, e) {
				e = e || {};
				var r = "undefined" !== typeof e.maxForce ? e.maxForce : 1E6,
					s = e.pivotA ? e.pivotA.clone() : new m,
					t = e.pivotB ? e.pivotB.clone() : new m;
				this.axisA = e.axisA ? e.axisA.clone() : new m;
				this.axisB = e.axisB ? e.axisB.clone() : new m;
				f.call(this, b, s, d, t, r);
				this.collideConnected = !!e.collideConnected;
				this.angle = "undefined" !== typeof e.angle ? e.angle : 0;
				s = this.coneEquation = new g(b, d, e);
				b = this.twistEquation = new q(b, d, e);
				this.twistAngle = "undefined" !== typeof e.twistAngle ? e.twistAngle : 0;
				s.maxForce = 0;
				s.minForce = -r;
				b.maxForce = 0;
				b.minForce = -r;
				this.equations.push(s, b)
			}
			e.exports = d;
			b("./Constraint");
			var f = b("./PointToPointConstraint"),
				g = b("../equations/ConeEquation"),
				q = b("../equations/RotationalEquation");
			b("../equations/ContactEquation");
			var m = b("../math/Vec3");
			d.prototype = new f;
			d.constructor = d;
			new m;
			new m;
			d.prototype.update = function() {
				var b = this.bodyA,
					d = this.bodyB,
					e = this.coneEquation,
					g = this.twistEquation;
				f.prototype.update.call(this);
				b.vectorToWorldFrame(this.axisA, e.axisA);
				d.vectorToWorldFrame(this.axisB,
					e.axisB);
				this.axisA.tangents(g.axisA, g.axisA);
				b.vectorToWorldFrame(g.axisA, g.axisA);
				this.axisB.tangents(g.axisB, g.axisB);
				d.vectorToWorldFrame(g.axisB, g.axisB);
				e.angle = this.angle;
				g.maxAngle = this.twistAngle
			}
		}, {
			"../equations/ConeEquation": 18,
			"../equations/ContactEquation": 19,
			"../equations/RotationalEquation": 22,
			"../math/Vec3": 30,
			"./Constraint": 13,
			"./PointToPointConstraint": 17
		}],
		13: [function(b, e) {
			function d(b, e, m) {
				m = f.defaults(m, {
					collideConnected: !0,
					wakeUpBodies: !0
				});
				this.equations = [];
				this.bodyA = b;
				this.bodyB =
					e;
				this.id = d.idCounter++;
				this.collideConnected = m.collideConnected;
				m.wakeUpBodies && (b && b.wakeUp(), e && e.wakeUp())
			}
			e.exports = d;
			var f = b("../utils/Utils");
			d.prototype.update = function() {
				throw Error("method update() not implmemented in this Constraint subclass!");
			};
			d.prototype.enable = function() {
				for (var b = this.equations, d = 0; d < b.length; d++) b[d].enabled = !0
			};
			d.prototype.disable = function() {
				for (var b = this.equations, d = 0; d < b.length; d++) b[d].enabled = !1
			};
			d.idCounter = 0
		}, {
			"../utils/Utils": 53
		}],
		14: [function(b, e) {
			function d(b,
				d, j, e) {
				f.call(this, b, d);
				"undefined" === typeof j && (j = b.position.distanceTo(d.position));
				"undefined" === typeof e && (e = 1E6);
				this.distance = j;
				b = this.distanceEquation = new g(b, d);
				this.equations.push(b);
				b.minForce = -e;
				b.maxForce = e
			}
			e.exports = d;
			var f = b("./Constraint"),
				g = b("../equations/ContactEquation");
			d.prototype = new f;
			d.prototype.update = function() {
				var b = this.distanceEquation,
					d = 0.5 * this.distance,
					f = b.ni;
				this.bodyB.position.vsub(this.bodyA.position, f);
				f.normalize();
				f.mult(d, b.ri);
				f.mult(-d, b.rj)
			}
		}, {
			"../equations/ContactEquation": 19,
			"./Constraint": 13
		}],
		15: [function(b, e) {
			function d(b, d, j) {
				j = j || {};
				var e = "undefined" !== typeof j.maxForce ? j.maxForce : 1E6,
					l = j.pivotA ? j.pivotA.clone() : new m,
					x = j.pivotB ? j.pivotB.clone() : new m;
				f.call(this, b, l, d, x, e);
				(this.axisA = j.axisA ? j.axisA.clone() : new m(1, 0, 0)).normalize();
				(this.axisB = j.axisB ? j.axisB.clone() : new m(1, 0, 0)).normalize();
				l = this.rotationalEquation1 = new g(b, d, j);
				j = this.rotationalEquation2 = new g(b, d, j);
				b = this.motorEquation = new q(b, d, e);
				b.enabled = !1;
				this.equations.push(l, j, b)
			}
			e.exports = d;
			b("./Constraint");
			var f = b("./PointToPointConstraint"),
				g = b("../equations/RotationalEquation"),
				q = b("../equations/RotationalMotorEquation");
			b("../equations/ContactEquation");
			var m = b("../math/Vec3");
			d.prototype = new f;
			d.constructor = d;
			d.prototype.enableMotor = function() {
				this.motorEquation.enabled = !0
			};
			d.prototype.disableMotor = function() {
				this.motorEquation.enabled = !1
			};
			d.prototype.setMotorSpeed = function(b) {
				this.motorEquation.targetVelocity = b
			};
			d.prototype.setMotorMaxForce = function(b) {
				this.motorEquation.maxForce = b;
				this.motorEquation.minForce = -b
			};
			var j = new m,
				l = new m;
			d.prototype.update = function() {
				var b = this.bodyA,
					d = this.bodyB,
					e = this.motorEquation,
					g = this.rotationalEquation1,
					m = this.rotationalEquation2,
					q = this.axisA,
					z = this.axisB;
				f.prototype.update.call(this);
				b.quaternion.vmult(q, j);
				d.quaternion.vmult(z, l);
				j.tangents(g.axisA, m.axisA);
				g.axisB.copy(l);
				m.axisB.copy(l);
				this.motorEquation.enabled && (b.quaternion.vmult(this.axisA, e.axisA), d.quaternion.vmult(this.axisB, e.axisB))
			}
		}, {
			"../equations/ContactEquation": 19,
			"../equations/RotationalEquation": 22,
			"../equations/RotationalMotorEquation": 23,
			"../math/Vec3": 30,
			"./Constraint": 13,
			"./PointToPointConstraint": 17
		}],
		16: [function(b, e) {
			function d(b, d, e) {
				e = e || {};
				var p = "undefined" !== typeof e.maxForce ? e.maxForce : 1E6,
					r = new q,
					s = new q,
					t = new q;
				b.position.vadd(d.position, t);
				t.scale(0.5, t);
				d.pointToLocalFrame(t, s);
				b.pointToLocalFrame(t, r);
				f.call(this, b, r, d, s, p);
				p = this.rotationalEquation1 = new g(b, d, e);
				r = this.rotationalEquation2 = new g(b, d, e);
				b = this.rotationalEquation3 = new g(b, d, e);
				this.equations.push(p, r, b)
			}
			e.exports =
				d;
			b("./Constraint");
			var f = b("./PointToPointConstraint"),
				g = b("../equations/RotationalEquation");
			b("../equations/RotationalMotorEquation");
			b("../equations/ContactEquation");
			var q = b("../math/Vec3");
			d.prototype = new f;
			d.constructor = d;
			new q;
			new q;
			d.prototype.update = function() {
				var b = this.bodyA,
					d = this.bodyB,
					e = this.rotationalEquation1,
					g = this.rotationalEquation2,
					r = this.rotationalEquation3;
				f.prototype.update.call(this);
				b.vectorToWorldFrame(q.UNIT_X, e.axisA);
				d.vectorToWorldFrame(q.UNIT_Y, e.axisB);
				b.vectorToWorldFrame(q.UNIT_Y,
					g.axisA);
				d.vectorToWorldFrame(q.UNIT_Z, g.axisB);
				b.vectorToWorldFrame(q.UNIT_Z, r.axisA);
				d.vectorToWorldFrame(q.UNIT_X, r.axisB)
			}
		}, {
			"../equations/ContactEquation": 19,
			"../equations/RotationalEquation": 22,
			"../equations/RotationalMotorEquation": 23,
			"../math/Vec3": 30,
			"./Constraint": 13,
			"./PointToPointConstraint": 17
		}],
		17: [function(b, e) {
			function d(b, d, e, p, r) {
				f.call(this, b, e);
				r = "undefined" !== typeof r ? r : 1E6;
				this.pivotA = d ? d.clone() : new q;
				this.pivotB = p ? p.clone() : new q;
				d = this.equationX = new g(b, e);
				p = this.equationY =
					new g(b, e);
				b = this.equationZ = new g(b, e);
				this.equations.push(d, p, b);
				d.minForce = p.minForce = b.minForce = -r;
				d.maxForce = p.maxForce = b.maxForce = r;
				d.ni.set(1, 0, 0);
				p.ni.set(0, 1, 0);
				b.ni.set(0, 0, 1)
			}
			e.exports = d;
			var f = b("./Constraint"),
				g = b("../equations/ContactEquation"),
				q = b("../math/Vec3");
			d.prototype = new f;
			d.prototype.update = function() {
				var b = this.bodyB,
					d = this.equationX,
					f = this.equationY,
					e = this.equationZ;
				this.bodyA.quaternion.vmult(this.pivotA, d.ri);
				b.quaternion.vmult(this.pivotB, d.rj);
				f.ri.copy(d.ri);
				f.rj.copy(d.rj);
				e.ri.copy(d.ri);
				e.rj.copy(d.rj)
			}
		}, {
			"../equations/ContactEquation": 19,
			"../math/Vec3": 30,
			"./Constraint": 13
		}],
		18: [function(b, e) {
			function d(b, d, e) {
				e = e || {};
				var r = "undefined" !== typeof e.maxForce ? e.maxForce : 1E6;
				g.call(this, b, d, -r, r);
				this.axisA = e.axisA ? e.axisA.clone() : new f(1, 0, 0);
				this.axisB = e.axisB ? e.axisB.clone() : new f(0, 1, 0);
				this.angle = "undefined" !== typeof e.angle ? e.angle : 0
			}
			e.exports = d;
			var f = b("../math/Vec3");
			b("../math/Mat3");
			var g = b("./Equation");
			d.prototype = new g;
			d.prototype.constructor = d;
			var q = new f,
				m = new f;
			d.prototype.computeB = function(b) {
				var d = this.a,
					f = this.b,
					e = this.axisA,
					g = this.axisB,
					t = this.jacobianElementA,
					u = this.jacobianElementB;
				e.cross(g, q);
				g.cross(e, m);
				t.rotational.copy(m);
				u.rotational.copy(q);
				e = Math.cos(this.angle) - e.dot(g);
				g = this.computeGW();
				t = this.computeGiMf();
				return -e * d - g * f - b * t
			}
		}, {
			"../math/Mat3": 27,
			"../math/Vec3": 30,
			"./Equation": 20
		}],
		19: [function(b, e) {
			function d(b, d, e) {
				f.call(this, b, d, 0, "undefined" !== typeof e ? e : 1E6);
				this.restitution = 0;
				this.ri = new g;
				this.rj = new g;
				this.ni = new g
			}
			e.exports =
				d;
			var f = b("./Equation"),
				g = b("../math/Vec3");
			b("../math/Mat3");
			d.prototype = new f;
			d.prototype.constructor = d;
			var q = new g,
				m = new g,
				j = new g;
			d.prototype.computeB = function(b) {
				var d = this.a,
					f = this.b,
					e = this.bi,
					l = this.bj,
					g = this.ri,
					p = this.rj,
					r = e.velocity,
					s = e.angularVelocity,
					t = l.velocity,
					I = l.angularVelocity,
					N = this.jacobianElementA,
					K = this.jacobianElementB,
					O = this.ni;
				g.cross(O, q);
				p.cross(O, m);
				O.negate(N.spatial);
				q.negate(N.rotational);
				K.spatial.copy(O);
				K.rotational.copy(m);
				j.copy(l.position);
				j.vadd(p, j);
				j.vsub(e.position,
					j);
				j.vsub(g, j);
				e = O.dot(j);
				l = this.restitution + 1;
				r = l * t.dot(O) - l * r.dot(O) + I.dot(m) - s.dot(q);
				s = this.computeGiMf();
				return -e * d - r * f - b * s
			};
			var l = new g,
				p = new g,
				r = new g,
				s = new g,
				t = new g;
			d.prototype.getImpactVelocityAlongNormal = function() {
				this.bi.position.vadd(this.ri, r);
				this.bj.position.vadd(this.rj, s);
				this.bi.getVelocityAtWorldPoint(r, l);
				this.bj.getVelocityAtWorldPoint(s, p);
				l.vsub(p, t);
				return this.ni.dot(t)
			}
		}, {
			"../math/Mat3": 27,
			"../math/Vec3": 30,
			"./Equation": 20
		}],
		20: [function(b, e) {
			function d(b, e, j, l) {
				this.id =
					d.id++;
				this.minForce = "undefined" === typeof j ? -1E6 : j;
				this.maxForce = "undefined" === typeof l ? 1E6 : l;
				this.bi = b;
				this.bj = e;
				this.eps = this.b = this.a = 0;
				this.jacobianElementA = new f;
				this.jacobianElementB = new f;
				this.enabled = !0;
				this.setSpookParams(1E7, 4, 1 / 60)
			}
			e.exports = d;
			var f = b("../math/JacobianElement"),
				g = b("../math/Vec3");
			d.prototype.constructor = d;
			d.id = 0;
			d.prototype.setSpookParams = function(b, d, f) {
				this.a = 4 / (f * (1 + 4 * d));
				this.b = 4 * d / (1 + 4 * d);
				this.eps = 4 / (f * f * b * (1 + 4 * d))
			};
			d.prototype.computeB = function(b, d, f) {
				var e = this.computeGW(),
					j = this.computeGq(),
					l = this.computeGiMf();
				return -j * b - e * d - l * f
			};
			d.prototype.computeGq = function() {
				var b = this.jacobianElementB,
					d = this.bj.position;
				return this.jacobianElementA.spatial.dot(this.bi.position) + b.spatial.dot(d)
			};
			var q = new g;
			d.prototype.computeGW = function() {
				var b = this.jacobianElementB,
					d = this.bi,
					f = this.bj,
					e = f.velocity,
					f = f.angularVelocity || q;
				return this.jacobianElementA.multiplyVectors(d.velocity, d.angularVelocity || q) + b.multiplyVectors(e, f)
			};
			d.prototype.computeGWlambda = function() {
				var b = this.jacobianElementB,
					d = this.bi,
					f = this.bj,
					e = f.vlambda,
					f = f.wlambda || q;
				return this.jacobianElementA.multiplyVectors(d.vlambda, d.wlambda || q) + b.multiplyVectors(e, f)
			};
			var m = new g,
				j = new g,
				l = new g,
				p = new g;
			d.prototype.computeGiMf = function() {
				var b = this.jacobianElementA,
					d = this.jacobianElementB,
					f = this.bi,
					e = this.bj,
					g = f.force,
					r = f.torque,
					s = e.force,
					q = e.torque,
					F = f.invMassSolve,
					C = e.invMassSolve;
				f.invInertiaWorldSolve ? f.invInertiaWorldSolve.vmult(r, l) : l.set(0, 0, 0);
				e.invInertiaWorldSolve ? e.invInertiaWorldSolve.vmult(q, p) : p.set(0, 0, 0);
				g.mult(F,
					m);
				s.mult(C, j);
				return b.multiplyVectors(m, l) + d.multiplyVectors(j, p)
			};
			var r = new g;
			d.prototype.computeGiMGt = function() {
				var b = this.jacobianElementA,
					d = this.jacobianElementB,
					f = this.bi,
					e = this.bj,
					j = f.invInertiaWorldSolve,
					l = e.invInertiaWorldSolve,
					f = f.invMassSolve + e.invMassSolve;
				j && (j.vmult(b.rotational, r), f += r.dot(b.rotational));
				l && (l.vmult(d.rotational, r), f += r.dot(d.rotational));
				return f
			};
			var s = new g;
			new g;
			new g;
			new g;
			new g;
			new g;
			d.prototype.addToWlambda = function(b) {
				var d = this.jacobianElementA,
					f = this.jacobianElementB,
					e = this.bi,
					j = this.bj;
				d.spatial.mult(e.invMassSolve * b, s);
				e.vlambda.vadd(s, e.vlambda);
				f.spatial.mult(j.invMassSolve * b, s);
				j.vlambda.vadd(s, j.vlambda);
				e.invInertiaWorldSolve && (e.invInertiaWorldSolve.vmult(d.rotational, s), s.mult(b, s), e.wlambda.vadd(s, e.wlambda));
				j.invInertiaWorldSolve && (j.invInertiaWorldSolve.vmult(f.rotational, s), s.mult(b, s), j.wlambda.vadd(s, j.wlambda))
			};
			d.prototype.computeC = function() {
				return this.computeGiMGt() + this.eps
			}
		}, {
			"../math/JacobianElement": 26,
			"../math/Vec3": 30
		}],
		21: [function(b,
			e) {
			function d(b, d, e) {
				f.call(this, b, d, -e, e);
				this.ri = new g;
				this.rj = new g;
				this.t = new g
			}
			e.exports = d;
			var f = b("./Equation"),
				g = b("../math/Vec3");
			b("../math/Mat3");
			d.prototype = new f;
			d.prototype.constructor = d;
			var q = new g,
				m = new g;
			d.prototype.computeB = function(b) {
				var d = this.b,
					f = this.rj,
					e = this.t;
				this.ri.cross(e, q);
				f.cross(e, m);
				var f = this.jacobianElementA,
					g = this.jacobianElementB;
				e.negate(f.spatial);
				q.negate(f.rotational);
				g.spatial.copy(e);
				g.rotational.copy(m);
				e = this.computeGW();
				f = this.computeGiMf();
				return -e * d -
					b * f
			}
		}, {
			"../math/Mat3": 27,
			"../math/Vec3": 30,
			"./Equation": 20
		}],
		22: [function(b, e) {
			function d(b, d, e) {
				e = e || {};
				var r = "undefined" !== typeof e.maxForce ? e.maxForce : 1E6;
				g.call(this, b, d, -r, r);
				this.axisA = e.axisA ? e.axisA.clone() : new f(1, 0, 0);
				this.axisB = e.axisB ? e.axisB.clone() : new f(0, 1, 0);
				this.maxAngle = Math.PI / 2
			}
			e.exports = d;
			var f = b("../math/Vec3");
			b("../math/Mat3");
			var g = b("./Equation");
			d.prototype = new g;
			d.prototype.constructor = d;
			var q = new f,
				m = new f;
			d.prototype.computeB = function(b) {
				var d = this.a,
					f = this.b,
					e = this.axisA,
					g = this.axisB,
					t = this.jacobianElementA,
					u = this.jacobianElementB;
				e.cross(g, q);
				g.cross(e, m);
				t.rotational.copy(m);
				u.rotational.copy(q);
				e = Math.cos(this.maxAngle) - e.dot(g);
				g = this.computeGW();
				t = this.computeGiMf();
				return -e * d - g * f - b * t
			}
		}, {
			"../math/Mat3": 27,
			"../math/Vec3": 30,
			"./Equation": 20
		}],
		23: [function(b, e) {
			function d(b, d, e) {
				e = "undefined" !== typeof e ? e : 1E6;
				g.call(this, b, d, -e, e);
				this.axisA = new f;
				this.axisB = new f;
				this.targetVelocity = 0
			}
			e.exports = d;
			var f = b("../math/Vec3");
			b("../math/Mat3");
			var g = b("./Equation");
			d.prototype = new g;
			d.prototype.constructor = d;
			d.prototype.computeB = function(b) {
				var d = this.b,
					f = this.axisB,
					e = this.jacobianElementB;
				this.jacobianElementA.rotational.copy(this.axisA);
				f.negate(e.rotational);
				f = this.computeGW() - this.targetVelocity;
				e = this.computeGiMf();
				return -f * d - b * e
			}
		}, {
			"../math/Mat3": 27,
			"../math/Vec3": 30,
			"./Equation": 20
		}],
		24: [function(b, e) {
			function d(b, e, m) {
				m = f.defaults(m, {
					friction: 0.3,
					restitution: 0.3,
					contactEquationStiffness: 1E7,
					contactEquationRelaxation: 3,
					frictionEquationStiffness: 1E7,
					frictionEquationRelaxation: 3
				});
				this.id = d.idCounter++;
				this.materials = [b, e];
				this.friction = m.friction;
				this.restitution = m.restitution;
				this.contactEquationStiffness = m.contactEquationStiffness;
				this.contactEquationRelaxation = m.contactEquationRelaxation;
				this.frictionEquationStiffness = m.frictionEquationStiffness;
				this.frictionEquationRelaxation = m.frictionEquationRelaxation
			}
			var f = b("../utils/Utils");
			e.exports = d;
			d.idCounter = 0
		}, {
			"../utils/Utils": 53
		}],
		25: [function(b, e) {
			function d(b) {
				var e = "";
				b = b || {};
				"string" === typeof b ? (e = b, b = {}) : "object" ===
					typeof b && (e = "");
				this.name = e;
				this.id = d.idCounter++;
				this.friction = "undefined" !== typeof b.friction ? b.friction : -1;
				this.restitution = "undefined" !== typeof b.restitution ? b.restitution : -1
			}
			e.exports = d;
			d.idCounter = 0
		}, {}],
		26: [function(b, e) {
			function d() {
				this.spatial = new f;
				this.rotational = new f
			}
			e.exports = d;
			var f = b("./Vec3");
			d.prototype.multiplyElement = function(b) {
				return b.spatial.dot(this.spatial) + b.rotational.dot(this.rotational)
			};
			d.prototype.multiplyVectors = function(b, d) {
				return b.dot(this.spatial) + d.dot(this.rotational)
			}
		}, {
			"./Vec3": 30
		}],
		27: [function(b, e) {
			function d(b) {
				this.elements = b ? b : [0, 0, 0, 0, 0, 0, 0, 0, 0]
			}
			e.exports = d;
			var f = b("./Vec3");
			d.prototype.identity = function() {
				var b = this.elements;
				b[0] = 1;
				b[1] = 0;
				b[2] = 0;
				b[3] = 0;
				b[4] = 1;
				b[5] = 0;
				b[6] = 0;
				b[7] = 0;
				b[8] = 1
			};
			d.prototype.setZero = function() {
				var b = this.elements;
				b[0] = 0;
				b[1] = 0;
				b[2] = 0;
				b[3] = 0;
				b[4] = 0;
				b[5] = 0;
				b[6] = 0;
				b[7] = 0;
				b[8] = 0
			};
			d.prototype.setTrace = function(b) {
				var d = this.elements;
				d[0] = b.x;
				d[4] = b.y;
				d[8] = b.z
			};
			d.prototype.getTrace = function(b) {
				b = b || new f;
				var d = this.elements;
				b.x = d[0];
				b.y =
					d[4];
				b.z = d[8]
			};
			d.prototype.vmult = function(b, d) {
				d = d || new f;
				var e = this.elements,
					j = b.x,
					l = b.y,
					p = b.z;
				d.x = e[0] * j + e[1] * l + e[2] * p;
				d.y = e[3] * j + e[4] * l + e[5] * p;
				d.z = e[6] * j + e[7] * l + e[8] * p;
				return d
			};
			d.prototype.smult = function(b) {
				for (var d = 0; d < this.elements.length; d++) this.elements[d] *= b
			};
			d.prototype.mmult = function(b, f) {
				for (var e = f || new d, j = 0; 3 > j; j++)
					for (var l = 0; 3 > l; l++) {
						for (var p = 0, r = 0; 3 > r; r++) p += b.elements[j + 3 * r] * this.elements[r + 3 * l];
						e.elements[j + 3 * l] = p
					}
				return e
			};
			d.prototype.scale = function(b, f) {
				f = f || new d;
				for (var e =
						this.elements, j = f.elements, l = 0; 3 !== l; l++) j[3 * l + 0] = b.x * e[3 * l + 0], j[3 * l + 1] = b.y * e[3 * l + 1], j[3 * l + 2] = b.z * e[3 * l + 2];
				return f
			};
			d.prototype.solve = function(b, d) {
				d = d || new f;
				for (var e = [], j = 0; 12 > j; j++) e.push(0);
				for (var l, j = 0; 3 > j; j++)
					for (l = 0; 3 > l; l++) e[j + 4 * l] = this.elements[j + 3 * l];
				e[3] = b.x;
				e[7] = b.y;
				e[11] = b.z;
				var p = 3,
					r = p,
					s, t;
				do {
					j = r - p;
					if (0 === e[j + 4 * j])
						for (l = j + 1; l < r; l++)
							if (0 !== e[j + 4 * l]) {
								s = 4;
								do t = 4 - s, e[t + 4 * j] += e[t + 4 * l]; while (--s);
								break
							}
					if (0 !== e[j + 4 * j])
						for (l = j + 1; l < r; l++) {
							var u = e[j + 4 * l] / e[j + 4 * j];
							s = 4;
							do t = 4 - s, e[t + 4 * l] = t <=
								j ? 0 : e[t + 4 * l] - e[t + 4 * j] * u; while (--s)
						}
				} while (--p);
				d.z = e[11] / e[10];
				d.y = (e[7] - e[6] * d.z) / e[5];
				d.x = (e[3] - e[2] * d.z - e[1] * d.y) / e[0];
				if (isNaN(d.x) || isNaN(d.y) || isNaN(d.z) || Infinity === d.x || Infinity === d.y || Infinity === d.z) throw "Could not solve equation! Got x=[" + d.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
				return d
			};
			d.prototype.e = function(b, d, e) {
				if (void 0 === e) return this.elements[d + 3 * b];
				this.elements[d + 3 * b] = e
			};
			d.prototype.copy = function(b) {
				for (var d = 0; d < b.elements.length; d++) this.elements[d] =
					b.elements[d];
				return this
			};
			d.prototype.toString = function() {
				for (var b = "", d = 0; 9 > d; d++) b += this.elements[d] + ",";
				return b
			};
			d.prototype.reverse = function(b) {
				b = b || new d;
				for (var e = [], f = 0; 18 > f; f++) e.push(0);
				for (var j, f = 0; 3 > f; f++)
					for (j = 0; 3 > j; j++) e[f + 6 * j] = this.elements[f + 3 * j];
				e[3] = 1;
				e[9] = 0;
				e[15] = 0;
				e[4] = 0;
				e[10] = 1;
				e[16] = 0;
				e[5] = 0;
				e[11] = 0;
				e[17] = 1;
				var l = 3,
					p = l,
					r, s;
				do {
					f = p - l;
					if (0 === e[f + 6 * f])
						for (j = f + 1; j < p; j++)
							if (0 !== e[f + 6 * j]) {
								r = 6;
								do s = 6 - r, e[s + 6 * f] += e[s + 6 * j]; while (--r);
								break
							}
					if (0 !== e[f + 6 * f])
						for (j = f + 1; j < p; j++) {
							var t = e[f +
								6 * j] / e[f + 6 * f];
							r = 6;
							do s = 6 - r, e[s + 6 * j] = s <= f ? 0 : e[s + 6 * j] - e[s + 6 * f] * t; while (--r)
						}
				} while (--l);
				f = 2;
				do {
					j = f - 1;
					do {
						t = e[f + 6 * j] / e[f + 6 * f];
						r = 6;
						do s = 6 - r, e[s + 6 * j] -= e[s + 6 * f] * t; while (--r)
					} while (j--)
				} while (--f);
				f = 2;
				do {
					t = 1 / e[f + 6 * f];
					r = 6;
					do s = 6 - r, e[s + 6 * f] *= t; while (--r)
				} while (f--);
				f = 2;
				do {
					j = 2;
					do {
						s = e[3 + j + 6 * f];
						if (isNaN(s) || Infinity === s) throw "Could not reverse! A=[" + this.toString() + "]";
						b.e(f, j, s)
					} while (j--)
				} while (f--);
				return b
			};
			d.prototype.setRotationFromQuaternion = function(b) {
				var d = b.x,
					e = b.y,
					f = b.z,
					l = b.w,
					p = d + d,
					r = e + e,
					s = f + f;
				b = d *
					p;
				var t = d * r,
					d = d * s,
					u = e * r,
					e = e * s,
					f = f * s,
					p = l * p,
					r = l * r,
					l = l * s,
					s = this.elements;
				s[0] = 1 - (u + f);
				s[1] = t - l;
				s[2] = d + r;
				s[3] = t + l;
				s[4] = 1 - (b + f);
				s[5] = e - p;
				s[6] = d - r;
				s[7] = e + p;
				s[8] = 1 - (b + u);
				return this
			};
			d.prototype.transpose = function(b) {
				b = b || new d;
				for (var e = b.elements, f = this.elements, j = 0; 3 !== j; j++)
					for (var l = 0; 3 !== l; l++) e[3 * j + l] = f[3 * l + j];
				return b
			}
		}, {
			"./Vec3": 30
		}],
		28: [function(b, e) {
			function d(b, d, e, f) {
				this.x = void 0 !== b ? b : 0;
				this.y = void 0 !== d ? d : 0;
				this.z = void 0 !== e ? e : 0;
				this.w = void 0 !== f ? f : 1
			}
			e.exports = d;
			var f = b("./Vec3");
			d.prototype.set =
				function(b, d, e, f) {
					this.x = b;
					this.y = d;
					this.z = e;
					this.w = f
				};
			d.prototype.toString = function() {
				return this.x + "," + this.y + "," + this.z + "," + this.w
			};
			d.prototype.toArray = function() {
				return [this.x, this.y, this.z, this.w]
			};
			d.prototype.setFromAxisAngle = function(b, d) {
				var e = Math.sin(0.5 * d);
				this.x = b.x * e;
				this.y = b.y * e;
				this.z = b.z * e;
				this.w = Math.cos(0.5 * d)
			};
			d.prototype.toAxisAngle = function(b) {
				b = b || new f;
				this.normalize();
				var d = 2 * Math.acos(this.w),
					e = Math.sqrt(1 - this.w * this.w);
				0.001 > e ? (b.x = this.x, b.y = this.y, b.z = this.z) : (b.x = this.x /
					e, b.y = this.y / e, b.z = this.z / e);
				return [b, d]
			};
			var g = new f,
				q = new f;
			d.prototype.setFromVectors = function(b, d) {
				if (b.isAntiparallelTo(d)) b.tangents(g, q), this.setFromAxisAngle(g, Math.PI);
				else {
					var e = b.cross(d);
					this.x = e.x;
					this.y = e.y;
					this.z = e.z;
					this.w = Math.sqrt(Math.pow(b.norm(), 2) * Math.pow(d.norm(), 2)) + b.dot(d);
					this.normalize()
				}
			};
			var m = new f,
				j = new f,
				l = new f;
			d.prototype.mult = function(b, e) {
				e = e || new d;
				var f = this.w;
				m.set(this.x, this.y, this.z);
				j.set(b.x, b.y, b.z);
				e.w = f * b.w - m.dot(j);
				m.cross(j, l);
				e.x = f * j.x + b.w * m.x + l.x;
				e.y = f * j.y + b.w * m.y + l.y;
				e.z = f * j.z + b.w * m.z + l.z;
				return e
			};
			d.prototype.inverse = function(b) {
				var e = this.x,
					f = this.y,
					j = this.z,
					l = this.w;
				b = b || new d;
				this.conjugate(b);
				e = 1 / (e * e + f * f + j * j + l * l);
				b.x *= e;
				b.y *= e;
				b.z *= e;
				b.w *= e;
				return b
			};
			d.prototype.conjugate = function(b) {
				b = b || new d;
				b.x = -this.x;
				b.y = -this.y;
				b.z = -this.z;
				b.w = this.w;
				return b
			};
			d.prototype.normalize = function() {
				var b = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
				0 === b ? this.w = this.z = this.y = this.x = 0 : (b = 1 / b, this.x *= b, this.y *= b, this.z *= b, this.w *=
					b)
			};
			d.prototype.normalizeFast = function() {
				var b = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
				0 === b ? this.w = this.z = this.y = this.x = 0 : (this.x *= b, this.y *= b, this.z *= b, this.w *= b)
			};
			d.prototype.vmult = function(b, d) {
				d = d || new f;
				var e = b.x,
					j = b.y,
					l = b.z,
					g = this.x,
					m = this.y,
					q = this.z,
					B = this.w,
					y = B * e + m * l - q * j,
					A = B * j + q * e - g * l,
					F = B * l + g * j - m * e,
					e = -g * e - m * j - q * l;
				d.x = y * B + e * -g + A * -q - F * -m;
				d.y = A * B + e * -m + F * -g - y * -q;
				d.z = F * B + e * -q + y * -m - A * -g;
				return d
			};
			d.prototype.copy = function(b) {
				this.x = b.x;
				this.y = b.y;
				this.z = b.z;
				this.w = b.w;
				return this
			};
			d.prototype.toEuler = function(b, d) {
				d = d || "YZX";
				var e, f, j, l = this.x,
					g = this.y,
					m = this.z,
					q = this.w;
				switch (d) {
					case "YZX":
						var y = l * g + m * q;
						0.499 < y && (e = 2 * Math.atan2(l, q), f = Math.PI / 2, j = 0); - 0.499 > y && (e = -2 * Math.atan2(l, q), f = -Math.PI / 2, j = 0);
						if (isNaN(e)) {
							j = l * l;
							var A = m * m;
							e = Math.atan2(2 * g * q - 2 * l * m, 1 - 2 * g * g - 2 * A);
							f = Math.asin(2 * y);
							j = Math.atan2(2 * l * q - 2 * g * m, 1 - 2 * j - 2 * A)
						}
						break;
					default:
						throw Error("Euler order " + d + " not supported yet.");
				}
				b.y = e;
				b.z = f;
				b.x = j
			};
			d.prototype.setFromEuler = function(b, d, e, f) {
				f = f || "XYZ";
				var j = Math.cos(b / 2),
					l = Math.cos(d / 2),
					g = Math.cos(e / 2);
				b = Math.sin(b / 2);
				d = Math.sin(d / 2);
				e = Math.sin(e / 2);
				"XYZ" === f ? (this.x = b * l * g + j * d * e, this.y = j * d * g - b * l * e, this.z = j * l * e + b * d * g, this.w = j * l * g - b * d * e) : "YXZ" === f ? (this.x = b * l * g + j * d * e, this.y = j * d * g - b * l * e, this.z = j * l * e - b * d * g, this.w = j * l * g + b * d * e) : "ZXY" === f ? (this.x = b * l * g - j * d * e, this.y = j * d * g + b * l * e, this.z = j * l * e + b * d * g, this.w = j * l * g - b * d * e) : "ZYX" === f ? (this.x = b * l * g - j * d * e, this.y = j * d * g + b * l * e, this.z = j * l * e - b * d * g, this.w = j * l * g + b * d * e) : "YZX" === f ? (this.x = b * l * g + j * d * e, this.y = j * d * g + b * l * e, this.z = j * l * e - b * d * g, this.w =
					j * l * g - b * d * e) : "XZY" === f && (this.x = b * l * g - j * d * e, this.y = j * d * g - b * l * e, this.z = j * l * e + b * d * g, this.w = j * l * g + b * d * e);
				return this
			};
			d.prototype.clone = function() {
				return new d(this.x, this.y, this.z, this.w)
			}
		}, {
			"./Vec3": 30
		}],
		29: [function(b, e) {
			function d(b) {
				b = b || {};
				this.position = new f;
				b.position && this.position.copy(b.position);
				this.quaternion = new g;
				b.quaternion && this.quaternion.copy(b.quaternion)
			}
			var f = b("./Vec3"),
				g = b("./Quaternion");
			e.exports = d;
			var q = new g;
			d.pointToLocalFrame = function(b, d, e, g) {
				g = g || new f;
				e.vsub(b, g);
				d.conjugate(q);
				q.vmult(g, g);
				return g
			};
			d.prototype.pointToLocal = function(b, e) {
				return d.pointToLocalFrame(this.position, this.quaternion, b, e)
			};
			d.pointToWorldFrame = function(b, d, e, g) {
				g = g || new f;
				d.vmult(e, g);
				g.vadd(b, g);
				return g
			};
			d.prototype.pointToWorld = function(b, e) {
				return d.pointToWorldFrame(this.position, this.quaternion, b, e)
			};
			d.prototype.vectorToWorldFrame = function(b, d) {
				d = d || new f;
				this.quaternion.vmult(b, d);
				return d
			};
			d.vectorToWorldFrame = function(b, d, e) {
				b.vmult(d, e);
				return e
			};
			d.vectorToLocalFrame = function(b, d, e, g) {
				g =
					g || new f;
				d.w *= -1;
				d.vmult(e, g);
				d.w *= -1;
				return g
			}
		}, {
			"./Quaternion": 28,
			"./Vec3": 30
		}],
		30: [function(b, e) {
			function d(b, d, e) {
				this.x = b || 0;
				this.y = d || 0;
				this.z = e || 0
			}
			e.exports = d;
			var f = b("./Mat3");
			d.ZERO = new d(0, 0, 0);
			d.UNIT_X = new d(1, 0, 0);
			d.UNIT_Y = new d(0, 1, 0);
			d.UNIT_Z = new d(0, 0, 1);
			d.prototype.cross = function(b, e) {
				var f = b.x,
					g = b.y,
					m = b.z,
					t = this.x,
					q = this.y,
					x = this.z;
				e = e || new d;
				e.x = q * m - x * g;
				e.y = x * f - t * m;
				e.z = t * g - q * f;
				return e
			};
			d.prototype.set = function(b, d, e) {
				this.x = b;
				this.y = d;
				this.z = e;
				return this
			};
			d.prototype.setZero = function() {
				this.x =
					this.y = this.z = 0
			};
			d.prototype.vadd = function(b, e) {
				if (e) e.x = b.x + this.x, e.y = b.y + this.y, e.z = b.z + this.z;
				else return new d(this.x + b.x, this.y + b.y, this.z + b.z)
			};
			d.prototype.vsub = function(b, e) {
				if (e) e.x = this.x - b.x, e.y = this.y - b.y, e.z = this.z - b.z;
				else return new d(this.x - b.x, this.y - b.y, this.z - b.z)
			};
			d.prototype.crossmat = function() {
				return new f([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0])
			};
			d.prototype.normalize = function() {
				var b = this.x,
					d = this.y,
					e = this.z,
					b = Math.sqrt(b * b + d * d + e * e);
				0 < b ? (d = 1 / b, this.x *= d, this.y *=
					d, this.z *= d) : this.z = this.y = this.x = 0;
				return b
			};
			d.prototype.unit = function(b) {
				b = b || new d;
				var e = this.x,
					f = this.y,
					g = this.z,
					m = Math.sqrt(e * e + f * f + g * g);
				0 < m ? (m = 1 / m, b.x = e * m, b.y = f * m, b.z = g * m) : (b.x = 1, b.y = 0, b.z = 0);
				return b
			};
			d.prototype.norm = function() {
				var b = this.x,
					d = this.y,
					e = this.z;
				return Math.sqrt(b * b + d * d + e * e)
			};
			d.prototype.length = d.prototype.norm;
			d.prototype.norm2 = function() {
				return this.dot(this)
			};
			d.prototype.lengthSquared = d.prototype.norm2;
			d.prototype.distanceTo = function(b) {
				var d = this.x,
					e = this.y,
					f = this.z,
					g = b.x,
					m = b.y;
				b = b.z;
				return Math.sqrt((g - d) * (g - d) + (m - e) * (m - e) + (b - f) * (b - f))
			};
			d.prototype.distanceSquared = function(b) {
				var d = this.x,
					e = this.y,
					f = this.z,
					g = b.x,
					m = b.y;
				b = b.z;
				return (g - d) * (g - d) + (m - e) * (m - e) + (b - f) * (b - f)
			};
			d.prototype.mult = function(b, e) {
				e = e || new d;
				var f = this.y,
					g = this.z;
				e.x = b * this.x;
				e.y = b * f;
				e.z = b * g;
				return e
			};
			d.prototype.scale = d.prototype.mult;
			d.prototype.dot = function(b) {
				return this.x * b.x + this.y * b.y + this.z * b.z
			};
			d.prototype.isZero = function() {
				return 0 === this.x && 0 === this.y && 0 === this.z
			};
			d.prototype.negate = function(b) {
				b =
					b || new d;
				b.x = -this.x;
				b.y = -this.y;
				b.z = -this.z;
				return b
			};
			var g = new d,
				q = new d;
			d.prototype.tangents = function(b, d) {
				var e = this.norm();
				0 < e ? (e = 1 / e, g.set(this.x * e, this.y * e, this.z * e), 0.9 > Math.abs(g.x) ? q.set(1, 0, 0) : q.set(0, 1, 0), g.cross(q, b), g.cross(b, d)) : (b.set(1, 0, 0), d.set(0, 1, 0))
			};
			d.prototype.toString = function() {
				return this.x + "," + this.y + "," + this.z
			};
			d.prototype.toArray = function() {
				return [this.x, this.y, this.z]
			};
			d.prototype.copy = function(b) {
				this.x = b.x;
				this.y = b.y;
				this.z = b.z;
				return this
			};
			d.prototype.lerp = function(b,
				d, e) {
				var f = this.x,
					g = this.y,
					m = this.z;
				e.x = f + (b.x - f) * d;
				e.y = g + (b.y - g) * d;
				e.z = m + (b.z - m) * d
			};
			d.prototype.almostEquals = function(b, d) {
				void 0 === d && (d = 1E-6);
				return Math.abs(this.x - b.x) > d || Math.abs(this.y - b.y) > d || Math.abs(this.z - b.z) > d ? !1 : !0
			};
			d.prototype.almostZero = function(b) {
				void 0 === b && (b = 1E-6);
				return Math.abs(this.x) > b || Math.abs(this.y) > b || Math.abs(this.z) > b ? !1 : !0
			};
			var m = new d;
			d.prototype.isAntiparallelTo = function(b, d) {
				this.negate(m);
				return m.almostEquals(b, d)
			};
			d.prototype.clone = function() {
				return new d(this.x,
					this.y, this.z)
			}
		}, {
			"./Mat3": 27
		}],
		31: [function(b, e) {
			function d(b) {
				b = b || {};
				f.apply(this);
				this.id = d.idCounter++;
				this.postStep = this.preStep = this.world = null;
				this.vlambda = new g;
				this.collisionFilterGroup = "number" === typeof b.collisionFilterGroup ? b.collisionFilterGroup : 1;
				this.collisionFilterMask = "number" === typeof b.collisionFilterMask ? b.collisionFilterMask : 1;
				this.collisionResponse = !0;
				this.position = new g;
				b.position && this.position.copy(b.position);
				this.previousPosition = new g;
				this.initPosition = new g;
				this.velocity =
					new g;
				b.velocity && this.velocity.copy(b.velocity);
				this.initVelocity = new g;
				this.force = new g;
				var e = "number" === typeof b.mass ? b.mass : 0;
				this.mass = e;
				this.invMass = 0 < e ? 1 / e : 0;
				this.material = b.material || null;
				this.linearDamping = "number" === typeof b.linearDamping ? b.linearDamping : 0.01;
				this.type = 0 >= e ? d.STATIC : d.DYNAMIC;
				typeof b.type === typeof d.STATIC && (this.type = b.type);
				this.allowSleep = "undefined" !== typeof b.allowSleep ? b.allowSleep : !0;
				this.sleepState = 0;
				this.sleepSpeedLimit = "undefined" !== typeof b.sleepSpeedLimit ? b.sleepSpeedLimit :
					0.1;
				this.sleepTimeLimit = "undefined" !== typeof b.sleepTimeLimit ? b.sleepTimeLimit : 1;
				this.timeLastSleepy = 0;
				this._wakeUpAfterNarrowphase = !1;
				this.torque = new g;
				this.quaternion = new m;
				b.quaternion && this.quaternion.copy(b.quaternion);
				this.initQuaternion = new m;
				this.angularVelocity = new g;
				b.angularVelocity && this.angularVelocity.copy(b.angularVelocity);
				this.initAngularVelocity = new g;
				this.interpolatedPosition = new g;
				this.interpolatedQuaternion = new m;
				this.shapes = [];
				this.shapeOffsets = [];
				this.shapeOrientations = [];
				this.inertia =
					new g;
				this.invInertia = new g;
				this.invInertiaWorld = new q;
				this.invMassSolve = 0;
				this.invInertiaSolve = new g;
				this.invInertiaWorldSolve = new q;
				this.fixedRotation = "undefined" !== typeof b.fixedRotation ? b.fixedRotation : !1;
				this.angularDamping = "undefined" !== typeof b.angularDamping ? b.angularDamping : 0.01;
				this.aabb = new j;
				this.aabbNeedsUpdate = !0;
				this.wlambda = new g;
				b.shape && this.addShape(b.shape);
				this.updateMassProperties()
			}
			e.exports = d;
			var f = b("../utils/EventTarget");
			b("../shapes/Shape");
			var g = b("../math/Vec3"),
				q = b("../math/Mat3"),
				m = b("../math/Quaternion");
			b("../material/Material");
			var j = b("../collision/AABB"),
				l = b("../shapes/Box");
			d.prototype = new f;
			d.prototype.constructor = d;
			d.DYNAMIC = 1;
			d.STATIC = 2;
			d.KINEMATIC = 4;
			d.AWAKE = 0;
			d.SLEEPY = 1;
			d.SLEEPING = 2;
			d.idCounter = 0;
			d.prototype.wakeUp = function() {
				var b = this.sleepState;
				this.sleepState = 0;
				b === d.SLEEPING && this.dispatchEvent({
					type: "wakeup"
				})
			};
			d.prototype.sleep = function() {
				this.sleepState = d.SLEEPING;
				this.velocity.set(0, 0, 0);
				this.angularVelocity.set(0, 0, 0)
			};
			d.sleepyEvent = {
				type: "sleepy"
			};
			d.sleepEvent = {
				type: "sleep"
			};
			d.prototype.sleepTick = function(b) {
				if (this.allowSleep) {
					var e = this.sleepState,
						f = this.velocity.norm2() + this.angularVelocity.norm2(),
						j = Math.pow(this.sleepSpeedLimit, 2);
					e === d.AWAKE && f < j ? (this.sleepState = d.SLEEPY, this.timeLastSleepy = b, this.dispatchEvent(d.sleepyEvent)) : e === d.SLEEPY && f > j ? this.wakeUp() : e === d.SLEEPY && b - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(d.sleepEvent))
				}
			};
			d.prototype.updateSolveMassProperties = function() {
				this.sleepState === d.SLEEPING || this.type ===
					d.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld))
			};
			d.prototype.pointToLocalFrame = function(b, d) {
				d = d || new g;
				b.vsub(this.position, d);
				this.quaternion.conjugate().vmult(d, d);
				return d
			};
			d.prototype.vectorToLocalFrame = function(b, d) {
				d = d || new g;
				this.quaternion.conjugate().vmult(b, d);
				return d
			};
			d.prototype.pointToWorldFrame = function(b,
				d) {
				d = d || new g;
				this.quaternion.vmult(b, d);
				d.vadd(this.position, d);
				return d
			};
			d.prototype.vectorToWorldFrame = function(b, d) {
				d = d || new g;
				this.quaternion.vmult(b, d);
				return d
			};
			var p = new g,
				r = new m;
			d.prototype.addShape = function(b, d, e) {
				var f = new g,
					j = new m;
				d && f.copy(d);
				e && j.copy(e);
				this.shapes.push(b);
				this.shapeOffsets.push(f);
				this.shapeOrientations.push(j);
				this.updateMassProperties();
				this.updateBoundingRadius();
				this.aabbNeedsUpdate = !0;
				return this
			};
			d.prototype.updateBoundingRadius = function() {
				for (var b = this.shapes,
						d = this.shapeOffsets, e = b.length, f = 0, j = 0; j !== e; j++) {
					var l = b[j];
					l.updateBoundingSphereRadius();
					var g = d[j].norm(),
						l = l.boundingSphereRadius;
					g + l > f && (f = g + l)
				}
				this.boundingRadius = f
			};
			var s = new j;
			d.prototype.computeAABB = function() {
				for (var b = this.shapes, d = this.shapeOffsets, e = this.shapeOrientations, f = b.length, j = this.quaternion, l = this.aabb, g = 0; g !== f; g++) {
					var m = b[g];
					e[g].mult(j, r);
					r.vmult(d[g], p);
					p.vadd(this.position, p);
					m.calculateWorldAABB(p, r, s.lowerBound, s.upperBound);
					0 === g ? l.copy(s) : l.extend(s)
				}
				this.aabbNeedsUpdate = !1
			};
			var t = new q,
				u = new q;
			new q;
			d.prototype.updateInertiaWorld = function(b) {
				var d = this.invInertia;
				d.x === d.y && d.y === d.z && !b || (t.setRotationFromQuaternion(this.quaternion), t.transpose(u), t.scale(d, t), t.mmult(u, this.invInertiaWorld))
			};
			var x = new g,
				z = new g;
			d.prototype.applyForce = function(b, e) {
				this.type === d.DYNAMIC && (e.vsub(this.position, x), x.cross(b, z), this.force.vadd(b, this.force), this.torque.vadd(z, this.torque))
			};
			var v = new g,
				B = new g;
			d.prototype.applyLocalForce = function(b, e) {
				this.type === d.DYNAMIC && (this.vectorToWorldFrame(b,
					v), this.pointToWorldFrame(e, B), this.applyForce(v, B))
			};
			var y = new g,
				A = new g,
				F = new g;
			d.prototype.applyImpulse = function(b, e) {
				this.type === d.DYNAMIC && (e.vsub(this.position, y), A.copy(b), A.mult(this.invMass, A), this.velocity.vadd(A, this.velocity), y.cross(b, F), this.invInertiaWorld.vmult(F, F), this.angularVelocity.vadd(F, this.angularVelocity))
			};
			var C = new g,
				D = new g;
			d.prototype.applyLocalImpulse = function(b, e) {
				this.type === d.DYNAMIC && (this.vectorToWorldFrame(b, C), this.pointToWorldFrame(e, D), this.applyImpulse(C, D))
			};
			var I = new g;
			d.prototype.updateMassProperties = function() {
				this.invMass = 0 < this.mass ? 1 / this.mass : 0;
				var b = this.inertia,
					d = this.fixedRotation;
				this.computeAABB();
				I.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
				l.calculateInertia(I, this.mass, b);
				this.invInertia.set(0 < b.x && !d ? 1 / b.x : 0, 0 < b.y && !d ? 1 / b.y : 0, 0 < b.z && !d ? 1 / b.z : 0);
				this.updateInertiaWorld(!0)
			};
			d.prototype.getVelocityAtWorldPoint = function(b, d) {
				var e =
					new g;
				b.vsub(this.position, e);
				this.angularVelocity.cross(e, d);
				this.velocity.vadd(d, d);
				return d
			}
		}, {
			"../collision/AABB": 3,
			"../material/Material": 25,
			"../math/Mat3": 27,
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"../shapes/Box": 37,
			"../shapes/Shape": 43,
			"../utils/EventTarget": 49
		}],
		32: [function(b, e) {
			function d(b) {
				this.chassisBody = b.chassisBody;
				this.wheelInfos = [];
				this.sliding = !1;
				this.world = null;
				this.indexRightAxis = "undefined" !== typeof b.indexRightAxis ? b.indexRightAxis : 1;
				this.indexForwardAxis = "undefined" !==
					typeof b.indexForwardAxis ? b.indexForwardAxis : 0;
				this.indexUpAxis = "undefined" !== typeof b.indexUpAxis ? b.indexUpAxis : 2
			}

			function f(b, d, e) {
				var f = F,
					j = C,
					l = D,
					g = I;
				d.vsub(b.position, f);
				f.cross(e, j);
				b.invInertiaWorld.vmult(j, g);
				g.cross(f, l);
				return b.invMass + e.dot(l)
			}
			b("./Body");
			var g = b("../math/Vec3"),
				q = b("../math/Quaternion");
			b("../collision/RaycastResult");
			var m = b("../collision/Ray"),
				j = b("../objects/WheelInfo");
			e.exports = d;
			new g;
			new g;
			new g;
			var l = new g,
				p = new g,
				r = new g;
			new m;
			d.prototype.addWheel = function(b) {
				b =
					b || {};
				b = new j(b);
				var d = this.wheelInfos.length;
				this.wheelInfos.push(b);
				return d
			};
			d.prototype.setSteeringValue = function(b, d) {
				this.wheelInfos[d].steering = b
			};
			new g;
			d.prototype.applyEngineForce = function(b, d) {
				this.wheelInfos[d].engineForce = b
			};
			d.prototype.setBrake = function(b, d) {
				this.wheelInfos[d].brake = b
			};
			d.prototype.addToWorld = function(b) {
				b.add(this.chassisBody);
				var d = this;
				this.preStepCallback = function() {
					d.updateVehicle(b.dt)
				};
				b.addEventListener("preStep", this.preStepCallback);
				this.world = b
			};
			d.prototype.getVehicleAxisWorld =
				function(b, d) {
					d.set(0 === b ? 1 : 0, 1 === b ? 1 : 0, 2 === b ? 1 : 0);
					this.chassisBody.vectorToWorldFrame(d, d)
				};
			d.prototype.updateVehicle = function(b) {
				for (var d = this.wheelInfos, e = d.length, f = this.chassisBody, j = 0; j < e; j++) this.updateWheelTransform(j);
				this.currentVehicleSpeedKmHour = 3.6 * f.velocity.norm();
				j = new g;
				this.getVehicleAxisWorld(this.indexForwardAxis, j);
				0 > j.dot(f.velocity) && (this.currentVehicleSpeedKmHour *= -1);
				for (j = 0; j < e; j++) this.castRay(d[j]);
				this.updateSuspension(b);
				for (var l = new g, r = new g, j = 0; j < e; j++) {
					var p = d[j],
						m = p.suspensionForce;
					m > p.maxSuspensionForce && (m = p.maxSuspensionForce);
					p.raycastResult.hitNormalWorld.scale(m * b, l);
					p.raycastResult.hitPointWorld.vsub(f.position, r);
					f.applyImpulse(l, p.raycastResult.hitPointWorld)
				}
				this.updateFriction(b);
				l = new g;
				r = new g;
				m = new g;
				for (j = 0; j < e; j++) {
					p = d[j];
					f.getVelocityAtWorldPoint(p.chassisConnectionPointWorld, m);
					var s = 1;
					switch (this.indexUpAxis) {
						case 1:
							s = -1
					}
					if (p.isInContact) {
						this.getVehicleAxisWorld(this.indexForwardAxis, r);
						var t = r.dot(p.raycastResult.hitNormalWorld);
						p.raycastResult.hitNormalWorld.scale(t,
							l);
						r.vsub(l, r);
						t = r.dot(m);
						p.deltaRotation = s * t * b / p.radius
					}
					if ((p.sliding || !p.isInContact) && 0 !== p.engineForce && p.useCustomSlidingRotationalSpeed) p.deltaRotation = (0 < p.engineForce ? 1 : -1) * p.customSlidingRotationalSpeed * b;
					Math.abs(p.brake) > Math.abs(p.engineForce) && (p.deltaRotation = 0);
					p.rotation += p.deltaRotation;
					p.deltaRotation *= 0.99
				}
			};
			d.prototype.updateSuspension = function() {
				for (var b = this.chassisBody.mass, d = this.wheelInfos, e = d.length, f = 0; f < e; f++) {
					var j = d[f];
					if (j.isInContact) {
						var l;
						l = j.suspensionStiffness *
							(j.suspensionRestLength - j.suspensionLength) * j.clippedInvContactDotSuspension;
						var g = j.suspensionRelativeVelocity;
						l -= (0 > g ? j.dampingCompression : j.dampingRelaxation) * g;
						j.suspensionForce = l * b;
						0 > j.suspensionForce && (j.suspensionForce = 0)
					} else j.suspensionForce = 0
				}
			};
			d.prototype.removeFromWorld = function(b) {
				b.remove(this.chassisBody);
				b.removeEventListener("preStep", this.preStepCallback);
				this.world = null
			};
			var s = new g,
				t = new g;
			d.prototype.castRay = function(b) {
				this.updateWheelTransformWorld(b);
				var d = this.chassisBody,
					e = -1;
				b.directionWorld.scale(b.suspensionRestLength + b.radius, s);
				var f = b.chassisConnectionPointWorld;
				f.vadd(s, t);
				var j = b.raycastResult;
				j.reset();
				var l = d.collisionResponse;
				d.collisionResponse = !1;
				this.world.rayTest(f, t, j);
				d.collisionResponse = l;
				f = j.body;
				b.raycastResult.groundObject = 0;
				f ? (e = j.distance, b.raycastResult.hitNormalWorld = j.hitNormalWorld, b.isInContact = !0, b.suspensionLength = j.distance - b.radius, j = b.suspensionRestLength - b.maxSuspensionTravel, f = b.suspensionRestLength + b.maxSuspensionTravel, b.suspensionLength <
					j && (b.suspensionLength = j), b.suspensionLength > f && (b.suspensionLength = f, b.raycastResult.reset()), j = b.raycastResult.hitNormalWorld.dot(b.directionWorld), f = new g, d.getVelocityAtWorldPoint(b.raycastResult.hitPointWorld, f), d = b.raycastResult.hitNormalWorld.dot(f), -0.1 <= j ? (b.suspensionRelativeVelocity = 0, b.clippedInvContactDotSuspension = 10) : (j = -1 / j, b.suspensionRelativeVelocity = d * j, b.clippedInvContactDotSuspension = j)) : (b.suspensionLength = b.suspensionRestLength + 0 * b.maxSuspensionTravel, b.suspensionRelativeVelocity =
					0, b.directionWorld.scale(-1, b.raycastResult.hitNormalWorld), b.clippedInvContactDotSuspension = 1);
				return e
			};
			d.prototype.updateWheelTransformWorld = function(b) {
				b.isInContact = !1;
				var d = this.chassisBody;
				d.pointToWorldFrame(b.chassisConnectionPointLocal, b.chassisConnectionPointWorld);
				d.vectorToWorldFrame(b.directionLocal, b.directionWorld);
				d.vectorToWorldFrame(b.axleLocal, b.axleWorld)
			};
			d.prototype.updateWheelTransform = function(b) {
				b = this.wheelInfos[b];
				this.updateWheelTransformWorld(b);
				b.directionLocal.scale(-1,
					l);
				p.copy(b.axleLocal);
				l.cross(p, r);
				r.normalize();
				p.normalize();
				var d = b.steering,
					e = new q;
				e.setFromAxisAngle(l, d);
				d = new q;
				d.setFromAxisAngle(p, b.rotation);
				var f = b.worldTransform.quaternion;
				this.chassisBody.quaternion.mult(e, f);
				f.mult(d, f);
				f.normalize();
				e = b.worldTransform.position;
				e.copy(b.directionWorld);
				e.scale(b.suspensionLength, e);
				e.vadd(b.chassisConnectionPointWorld, e)
			};
			var u = [new g(1, 0, 0), new g(0, 1, 0), new g(0, 0, 1)];
			d.prototype.getWheelTransformWorld = function(b) {
				return this.wheelInfos[b].worldTransform
			};
			var x = new g,
				z = [],
				v = [];
			d.prototype.updateFriction = function(b) {
				for (var d = this.wheelInfos, e = d.length, j = this.chassisBody, l = 0, p = 0; p < e; p++) {
					var r = d[p],
						m = r.raycastResult.body;
					m && l++;
					r.sideImpulse = 0;
					r.forwardImpulse = 0;
					v[p] || (v[p] = new g);
					z[p] || (z[p] = new g)
				}
				for (p = 0; p < e; p++)
					if (r = d[p], m = r.raycastResult.body) {
						var s = z[p];
						this.getWheelTransformWorld(p).vectorToWorldFrame(u[this.indexRightAxis], s);
						var l = r.raycastResult.hitNormalWorld,
							t = s.dot(l);
						l.scale(t, x);
						s.vsub(x, s);
						s.normalize();
						l.cross(s, v[p]);
						v[p].normalize();
						l = r;
						var t = j,
							q = r.raycastResult.hitPointWorld,
							C = r.raycastResult.hitPointWorld,
							D = void 0;
						if (1.1 < s.norm2()) m = 0;
						else {
							var D = N,
								I = K,
								da = O;
							t.getVelocityAtWorldPoint(q, D);
							m.getVelocityAtWorldPoint(C, I);
							D.vsub(I, da);
							m = D = -0.2 * s.dot(da) * (1 / (t.invMass + m.invMass))
						}
						l.sideImpulse = m;
						r.sideImpulse *= 1
					}
				this.sliding = !1;
				for (p = 0; p < e; p++) {
					r = d[p];
					m = r.raycastResult.body;
					t = 0;
					r.slipInfo = 1;
					if (m) {
						var l = r.brake ? r.brake : 0,
							D = j,
							q = m,
							C = r.raycastResult.hitPointWorld,
							s = v[p],
							t = l,
							I = 0,
							I = C,
							da = B,
							ma = y,
							ya = A;
						D.getVelocityAtWorldPoint(I, da);
						q.getVelocityAtWorldPoint(I,
							ma);
						da.vsub(ma, ya);
						I = s.dot(ya);
						D = f(D, C, s);
						q = f(q, C, s);
						I = -I * (1 / (D + q));
						t < I && (I = t);
						I < -t && (I = -t);
						t = I;
						t += r.engineForce * b;
						l /= t;
						r.slipInfo *= l
					}
					r.forwardImpulse = 0;
					r.skidInfo = 1;
					m && (r.skidInfo = 1, m = r.suspensionForce * b * r.frictionSlip, l = m * m, r.forwardImpulse = t, t = 0.5 * r.forwardImpulse, q = 1 * r.sideImpulse, t = t * t + q * q, r.sliding = !1, t > l && (this.sliding = !0, r.sliding = !0, l = m / Math.sqrt(t), r.skidInfo *= l))
				}
				if (this.sliding)
					for (p = 0; p < e; p++) r = d[p], 0 !== r.sideImpulse && 1 > r.skidInfo && (r.forwardImpulse *= r.skidInfo, r.sideImpulse *= r.skidInfo);
				for (p = 0; p < e; p++) r = d[p], b = new g, b.copy(r.raycastResult.hitPointWorld), 0 !== r.forwardImpulse && (m = new g, v[p].scale(r.forwardImpulse, m), j.applyImpulse(m, b)), 0 !== r.sideImpulse && (m = r.raycastResult.body, l = new g, l.copy(r.raycastResult.hitPointWorld), t = new g, z[p].scale(r.sideImpulse, t), j.pointToLocalFrame(b, b), b["xyz" [this.indexUpAxis]] *= r.rollInfluence, j.pointToWorldFrame(b, b), j.applyImpulse(t, b), t.scale(-1, t), m.applyImpulse(t, l))
			};
			var B = new g,
				y = new g,
				A = new g,
				F = new g,
				C = new g,
				D = new g,
				I = new g,
				N = new g,
				K = new g,
				O = new g
		}, {
			"../collision/Ray": 9,
			"../collision/RaycastResult": 10,
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"../objects/WheelInfo": 36,
			"./Body": 31
		}],
		33: [function(b, e) {
			function d(b) {
				this.wheelBodies = [];
				this.coordinateSystem = "undefined" === typeof b.coordinateSystem ? new m(1, 2, 3) : b.coordinateSystem.clone();
				this.chassisBody = b.chassisBody;
				this.chassisBody || (b = new q(new m(5, 2, 0.5)), this.chassisBody = new f(1, b));
				this.constraints = [];
				this.wheelAxes = [];
				this.wheelForces = []
			}
			var f = b("./Body"),
				g = b("../shapes/Sphere"),
				q = b("../shapes/Box"),
				m = b("../math/Vec3"),
				j = b("../constraints/HingeConstraint");
			e.exports = d;
			d.prototype.addWheel = function(b) {
				b = b || {};
				var d = b.body;
				d || (d = new f(1, new g(1.2)));
				this.wheelBodies.push(d);
				this.wheelForces.push(0);
				new m;
				var e = "undefined" !== typeof b.position ? b.position.clone() : new m,
					l = new m;
				this.chassisBody.pointToWorldFrame(e, l);
				d.position.set(l.x, l.y, l.z);
				b = "undefined" !== typeof b.axis ? b.axis.clone() : new m(0, 1, 0);
				this.wheelAxes.push(b);
				d = new j(this.chassisBody, d, {
					pivotA: e,
					axisA: b,
					pivotB: m.ZERO,
					axisB: b,
					collideConnected: !1
				});
				this.constraints.push(d);
				return this.wheelBodies.length - 1
			};
			d.prototype.setSteeringValue = function(b, d) {
				var e = this.wheelAxes[d],
					f = Math.cos(b),
					j = Math.sin(b),
					l = e.x,
					e = e.y;
				this.constraints[d].axisA.set(f * l - j * e, j * l + f * e, 0)
			};
			d.prototype.setMotorSpeed = function(b, d) {
				var e = this.constraints[d];
				e.enableMotor();
				e.motorTargetVelocity = b
			};
			d.prototype.disableMotor = function(b) {
				this.constraints[b].disableMotor()
			};
			var l = new m;
			d.prototype.setWheelForce = function(b, d) {
				this.wheelForces[d] = b
			};
			d.prototype.applyWheelForce = function(b, d) {
				var e = this.wheelBodies[d],
					f = e.torque;
				this.wheelAxes[d].scale(b, l);
				e.vectorToWorldFrame(l, l);
				f.vadd(l, f)
			};
			d.prototype.addToWorld = function(b) {
				for (var d = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), f = 0; f < e.length; f++) b.add(e[f]);
				for (f = 0; f < d.length; f++) b.addConstraint(d[f]);
				b.addEventListener("preStep", this._update.bind(this))
			};
			d.prototype._update = function() {
				for (var b = this.wheelForces, d = 0; d < b.length; d++) this.applyWheelForce(b[d], d)
			};
			d.prototype.removeFromWorld =
				function(b) {
					for (var d = this.constraints, e = this.wheelBodies.concat([this.chassisBody]), f = 0; f < e.length; f++) b.remove(e[f]);
					for (f = 0; f < d.length; f++) b.removeConstraint(d[f])
				};
			var p = new m;
			d.prototype.getWheelSpeed = function(b) {
				var d = this.wheelBodies[b].angularVelocity;
				this.chassisBody.vectorToWorldFrame(this.wheelAxes[b], p);
				return d.dot(p)
			}
		}, {
			"../constraints/HingeConstraint": 15,
			"../math/Vec3": 30,
			"../shapes/Box": 37,
			"../shapes/Sphere": 44,
			"./Body": 31
		}],
		34: [function(b, e) {
			function d() {
				this.particles = [];
				this.speedOfSound =
					this.smoothingRadius = this.density = 1;
				this.viscosity = 0.01;
				this.eps = 1E-6;
				this.pressures = [];
				this.densities = [];
				this.neighbors = []
			}
			e.exports = d;
			b("../shapes/Shape");
			var f = b("../math/Vec3");
			b("../math/Quaternion");
			b("../shapes/Particle");
			b("../objects/Body");
			b("../material/Material");
			d.prototype.add = function(b) {
				this.particles.push(b);
				this.neighbors.length < this.particles.length && this.neighbors.push([])
			};
			d.prototype.remove = function(b) {
				b = this.particles.indexOf(b); - 1 !== b && (this.particles.splice(b, 1), this.neighbors.length >
					this.particles.length && this.neighbors.pop())
			};
			var g = new f;
			d.prototype.getNeighbors = function(b, d) {
				for (var e = this.particles.length, f = b.id, j = this.smoothingRadius * this.smoothingRadius, l = 0; l !== e; l++) {
					var p = this.particles[l];
					p.position.vsub(b.position, g);
					f !== p.id && g.norm2() < j && d.push(p)
				}
			};
			var q = new f,
				m = new f,
				j = new f,
				l = new f,
				p = new f,
				r = new f;
			d.prototype.update = function() {
				for (var b = this.particles.length, d = this.speedOfSound, e = this.eps, f = 0; f !== b; f++) {
					var g = this.particles[f],
						v = this.neighbors[f];
					v.length = 0;
					this.getNeighbors(g,
						v);
					v.push(this.particles[f]);
					for (var B = v.length, y = 0, A = 0; A !== B; A++) {
						g.position.vsub(v[A].position, q);
						var F = q.norm(),
							F = this.w(F),
							y = y + v[A].mass * F
					}
					this.densities[f] = y;
					this.pressures[f] = d * d * (this.densities[f] - this.density)
				}
				for (f = 0; f !== b; f++) {
					d = this.particles[f];
					m.set(0, 0, 0);
					j.set(0, 0, 0);
					v = this.neighbors[f];
					B = v.length;
					for (A = 0; A !== B; A++) y = v[A], d.position.vsub(y.position, p), F = p.norm(), g = -y.mass * (this.pressures[f] / (this.densities[f] * this.densities[f] + e) + this.pressures[A] / (this.densities[A] * this.densities[A] +
						e)), this.gradw(p, l), l.mult(g, l), m.vadd(l, m), y.velocity.vsub(d.velocity, r), r.mult(1 / (1E-4 + this.densities[f] * this.densities[A]) * this.viscosity * y.mass, r), g = this.nablaw(F), r.mult(g, r), j.vadd(r, j);
					j.mult(d.mass, j);
					m.mult(d.mass, m);
					d.force.vadd(j, d.force);
					d.force.vadd(m, d.force)
				}
			};
			d.prototype.w = function(b) {
				var d = this.smoothingRadius;
				return 315 / (64 * Math.PI * Math.pow(d, 9)) * Math.pow(d * d - b * b, 3)
			};
			d.prototype.gradw = function(b, d) {
				var e = b.norm(),
					f = this.smoothingRadius;
				b.mult(945 / (32 * Math.PI * Math.pow(f, 9)) * Math.pow(f *
					f - e * e, 2), d)
			};
			d.prototype.nablaw = function(b) {
				var d = this.smoothingRadius;
				return 945 / (32 * Math.PI * Math.pow(d, 9)) * (d * d - b * b) * (7 * b * b - 3 * d * d)
			}
		}, {
			"../material/Material": 25,
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"../objects/Body": 31,
			"../shapes/Particle": 41,
			"../shapes/Shape": 43
		}],
		35: [function(b, e) {
			function d(b, d, e) {
				e = e || {};
				this.restLength = "number" === typeof e.restLength ? e.restLength : 1;
				this.stiffness = e.stiffness || 100;
				this.damping = e.damping || 1;
				this.bodyA = b;
				this.bodyB = d;
				this.localAnchorA = new f;
				this.localAnchorB =
					new f;
				e.localAnchorA && this.localAnchorA.copy(e.localAnchorA);
				e.localAnchorB && this.localAnchorB.copy(e.localAnchorB);
				e.worldAnchorA && this.setWorldAnchorA(e.worldAnchorA);
				e.worldAnchorB && this.setWorldAnchorB(e.worldAnchorB)
			}
			var f = b("../math/Vec3");
			e.exports = d;
			d.prototype.setWorldAnchorA = function(b) {
				this.bodyA.pointToLocalFrame(b, this.localAnchorA)
			};
			d.prototype.setWorldAnchorB = function(b) {
				this.bodyB.pointToLocalFrame(b, this.localAnchorB)
			};
			d.prototype.getWorldAnchorA = function(b) {
				this.bodyA.pointToWorldFrame(this.localAnchorA,
					b)
			};
			d.prototype.getWorldAnchorB = function(b) {
				this.bodyB.pointToWorldFrame(this.localAnchorB, b)
			};
			var g = new f,
				q = new f,
				m = new f,
				j = new f,
				l = new f,
				p = new f,
				r = new f,
				s = new f,
				t = new f,
				u = new f,
				x = new f;
			d.prototype.applyForce = function() {
				var b = this.stiffness,
					d = this.damping,
					e = this.restLength,
					f = this.bodyA,
					A = this.bodyB;
				this.getWorldAnchorA(l);
				this.getWorldAnchorB(p);
				l.vsub(f.position, r);
				p.vsub(A.position, s);
				p.vsub(l, g);
				var F = g.norm();
				q.copy(g);
				q.normalize();
				A.velocity.vsub(f.velocity, m);
				A.angularVelocity.cross(s, x);
				m.vadd(x, m);
				f.angularVelocity.cross(r, x);
				m.vsub(x, m);
				q.mult(-b * (F - e) - d * m.dot(q), j);
				f.force.vsub(j, f.force);
				A.force.vadd(j, A.force);
				r.cross(j, t);
				s.cross(j, u);
				f.torque.vsub(t, f.torque);
				A.torque.vadd(u, A.torque)
			}
		}, {
			"../math/Vec3": 30
		}],
		36: [function(b, e) {
			function d(b) {
				b = m.defaults(b, {
					chassisConnectionPointLocal: new f,
					chassisConnectionPointWorld: new f,
					directionLocal: new f,
					directionWorld: new f,
					axleLocal: new f,
					axleWorld: new f,
					suspensionRestLength: 1,
					suspensionMaxLength: 2,
					radius: 1,
					suspensionStiffness: 100,
					dampingCompression: 10,
					dampingRelaxation: 10,
					frictionSlip: 1E4,
					steering: 0,
					rotation: 0,
					deltaRotation: 0,
					rollInfluence: 0.01,
					maxSuspensionForce: Number.MAX_VALUE,
					isFrontWheel: !0,
					clippedInvContactDotSuspension: 1,
					suspensionRelativeVelocity: 0,
					suspensionForce: 0,
					skidInfo: 0,
					suspensionLength: 0,
					maxSuspensionTravel: 1,
					useCustomSlidingRotationalSpeed: !1,
					customSlidingRotationalSpeed: -0.1
				});
				this.maxSuspensionTravel = b.maxSuspensionTravel;
				this.customSlidingRotationalSpeed = b.customSlidingRotationalSpeed;
				this.useCustomSlidingRotationalSpeed = b.useCustomSlidingRotationalSpeed;
				this.sliding = !1;
				this.chassisConnectionPointLocal = b.chassisConnectionPointLocal.clone();
				this.chassisConnectionPointWorld = b.chassisConnectionPointWorld.clone();
				this.directionLocal = b.directionLocal.clone();
				this.directionWorld = b.directionWorld.clone();
				this.axleLocal = b.axleLocal.clone();
				this.axleWorld = b.axleWorld.clone();
				this.suspensionRestLength = b.suspensionRestLength;
				this.suspensionMaxLength = b.suspensionMaxLength;
				this.radius = b.radius;
				this.suspensionStiffness = b.suspensionStiffness;
				this.dampingCompression =
					b.dampingCompression;
				this.dampingRelaxation = b.dampingRelaxation;
				this.frictionSlip = b.frictionSlip;
				this.deltaRotation = this.rotation = this.steering = 0;
				this.rollInfluence = b.rollInfluence;
				this.maxSuspensionForce = b.maxSuspensionForce;
				this.brake = this.engineForce = 0;
				this.isFrontWheel = b.isFrontWheel;
				this.clippedInvContactDotSuspension = 1;
				this.forwardImpulse = this.sideImpulse = this.suspensionLength = this.skidInfo = this.suspensionForce = this.suspensionRelativeVelocity = 0;
				this.raycastResult = new q;
				this.worldTransform = new g;
				this.isInContact = !1
			}
			var f = b("../math/Vec3"),
				g = b("../math/Transform"),
				q = b("../collision/RaycastResult"),
				m = b("../utils/Utils");
			e.exports = d;
			var j = new f,
				l = new f,
				j = new f;
			d.prototype.updateWheel = function(b) {
				var d = this.raycastResult;
				if (this.isInContact) {
					var e = d.hitNormalWorld.dot(d.directionWorld);
					d.hitPointWorld.vsub(b.position, l);
					b.getVelocityAtWorldPoint(l, j);
					b = d.hitNormalWorld.dot(j); - 0.1 <= e ? (this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10) : (e = -1 / e, this.suspensionRelativeVelocity =
						b * e, this.clippedInvContactDotSuspension = e)
				} else d.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, d.directionWorld.scale(-1, d.hitNormalWorld), this.clippedInvContactDotSuspension = 1
			}
		}, {
			"../collision/RaycastResult": 10,
			"../math/Transform": 29,
			"../math/Vec3": 30,
			"../utils/Utils": 53
		}],
		37: [function(b, e) {
			function d(b) {
				f.call(this);
				this.type = f.types.BOX;
				this.halfExtents = b;
				this.convexPolyhedronRepresentation = null;
				this.updateConvexPolyhedronRepresentation();
				this.updateBoundingSphereRadius()
			}
			e.exports = d;
			var f = b("./Shape"),
				g = b("../math/Vec3"),
				q = b("./ConvexPolyhedron");
			d.prototype = new f;
			d.prototype.constructor = d;
			d.prototype.updateConvexPolyhedronRepresentation = function() {
				var b = this.halfExtents.x,
					d = this.halfExtents.y,
					e = this.halfExtents.z,
					b = [new g(-b, -d, -e), new g(b, -d, -e), new g(b, d, -e), new g(-b, d, -e), new g(-b, -d, e), new g(b, -d, e), new g(b, d, e), new g(-b, d, e)];
				new g(0, 0, 1);
				new g(0, 1, 0);
				new g(1, 0, 0);
				this.convexPolyhedronRepresentation = b = new q(b, [
					[3, 2, 1, 0],
					[4, 5, 6, 7],
					[5, 4, 0, 1],
					[2, 3, 7, 6],
					[0, 4, 7,
						3
					],
					[1, 2, 6, 5]
				]);
				b.material = this.material
			};
			d.prototype.calculateLocalInertia = function(b, e) {
				e = e || new g;
				d.calculateInertia(this.halfExtents, b, e);
				return e
			};
			d.calculateInertia = function(b, d, e) {
				e.x = 1 / 12 * d * (4 * b.y * b.y + 4 * b.z * b.z);
				e.y = 1 / 12 * d * (4 * b.x * b.x + 4 * b.z * b.z);
				e.z = 1 / 12 * d * (4 * b.y * b.y + 4 * b.x * b.x)
			};
			d.prototype.getSideNormals = function(b, d) {
				var e = this.halfExtents;
				b[0].set(e.x, 0, 0);
				b[1].set(0, e.y, 0);
				b[2].set(0, 0, e.z);
				b[3].set(-e.x, 0, 0);
				b[4].set(0, -e.y, 0);
				b[5].set(0, 0, -e.z);
				if (void 0 !== d)
					for (e = 0; e !== b.length; e++) d.vmult(b[e],
						b[e]);
				return b
			};
			d.prototype.volume = function() {
				return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z
			};
			d.prototype.updateBoundingSphereRadius = function() {
				this.boundingSphereRadius = this.halfExtents.norm()
			};
			var m = new g;
			new g;
			d.prototype.forEachWorldCorner = function(b, d, e) {
				for (var f = this.halfExtents, f = [
						[f.x, f.y, f.z],
						[-f.x, f.y, f.z],
						[-f.x, -f.y, f.z],
						[-f.x, -f.y, -f.z],
						[f.x, -f.y, -f.z],
						[f.x, f.y, -f.z],
						[-f.x, f.y, -f.z],
						[f.x, -f.y, f.z]
					], j = 0; j < f.length; j++) m.set(f[j][0], f[j][1], f[j][2]), d.vmult(m, m), b.vadd(m,
					m), e(m.x, m.y, m.z)
			};
			var j = [new g, new g, new g, new g, new g, new g, new g, new g];
			d.prototype.calculateWorldAABB = function(b, d, e, f) {
				var g = this.halfExtents;
				j[0].set(g.x, g.y, g.z);
				j[1].set(-g.x, g.y, g.z);
				j[2].set(-g.x, -g.y, g.z);
				j[3].set(-g.x, -g.y, -g.z);
				j[4].set(g.x, -g.y, -g.z);
				j[5].set(g.x, g.y, -g.z);
				j[6].set(-g.x, g.y, -g.z);
				j[7].set(g.x, -g.y, g.z);
				var m = j[0];
				d.vmult(m, m);
				b.vadd(m, m);
				f.copy(m);
				e.copy(m);
				for (g = 1; 8 > g; g++) {
					m = j[g];
					d.vmult(m, m);
					b.vadd(m, m);
					var q = m.x,
						z = m.y,
						m = m.z;
					q > f.x && (f.x = q);
					z > f.y && (f.y = z);
					m > f.z && (f.z =
						m);
					q < e.x && (e.x = q);
					z < e.y && (e.y = z);
					m < e.z && (e.z = m)
				}
			}
		}, {
			"../math/Vec3": 30,
			"./ConvexPolyhedron": 38,
			"./Shape": 43
		}],
		38: [function(b, e) {
			function d(b, d, e) {
				f.call(this);
				this.type = f.types.CONVEXPOLYHEDRON;
				this.vertices = b || [];
				this.worldVertices = [];
				this.worldVerticesNeedsUpdate = !0;
				this.faces = d || [];
				this.faceNormals = [];
				this.computeNormals();
				this.worldFaceNormalsNeedsUpdate = !0;
				this.worldFaceNormals = [];
				this.uniqueEdges = [];
				this.uniqueAxes = e ? e.slice() : null;
				this.computeEdges();
				this.updateBoundingSphereRadius()
			}
			e.exports =
				d;
			var f = b("./Shape"),
				g = b("../math/Vec3");
			b("../math/Quaternion");
			var q = b("../math/Transform");
			d.prototype = new f;
			d.prototype.constructor = d;
			var m = new g;
			d.prototype.computeEdges = function() {
				for (var b = this.faces, d = this.vertices, e = this.uniqueEdges, f = e.length = 0; f !== b.length; f++)
					for (var j = b[f], g = j.length, l = 0; l !== g; l++) {
						d[j[l]].vsub(d[j[(l + 1) % g]], m);
						m.normalize();
						for (var p = !1, r = 0; r !== e.length; r++)
							if (e[r].almostEquals(m) || e[r].almostEquals(m)) {
								p = !0;
								break
							}
						p || e.push(m.clone())
					}
			};
			d.prototype.computeNormals = function() {
				this.faceNormals.length =
					this.faces.length;
				for (var b = 0; b < this.faces.length; b++) {
					for (var d = 0; d < this.faces[b].length; d++)
						if (!this.vertices[this.faces[b][d]]) throw Error("Vertex " + this.faces[b][d] + " not found!");
					d = this.faceNormals[b] || new g;
					this.getFaceNormal(b, d);
					d.negate(d);
					this.faceNormals[b] = d;
					if (0 > d.dot(this.vertices[this.faces[b][0]])) {
						console.error(".faceNormals[" + b + "] = Vec3(" + d.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
						for (d = 0; d < this.faces[b].length; d++) console.warn(".vertices[" + this.faces[b][d] + "] = Vec3(" + this.vertices[this.faces[b][d]].toString() + ")")
					}
				}
			};
			var j = new g,
				l = new g;
			d.computeNormal = function(b, d, e, f) {
				d.vsub(b, l);
				e.vsub(d, j);
				j.cross(l, f);
				f.isZero() || f.normalize()
			};
			d.prototype.getFaceNormal = function(b, e) {
				var f = this.faces[b];
				return d.computeNormal(this.vertices[f[0]], this.vertices[f[1]], this.vertices[f[2]], e)
			};
			var p = new g;
			d.prototype.clipAgainstHull = function(b, d, e, f, j, l, m, r, s) {
				for (var q = -1, t = -Number.MAX_VALUE,
						u = 0; u < e.faces.length; u++) {
					p.copy(e.faceNormals[u]);
					j.vmult(p, p);
					var x = p.dot(l);
					x > t && (t = x, q = u)
				}
				for (var t = [], u = e.faces[q], x = u.length, C = 0; C < x; C++) {
					var z = e.vertices[u[C]],
						v = new g;
					v.copy(z);
					j.vmult(v, v);
					f.vadd(v, v);
					t.push(v)
				}
				0 <= q && this.clipFaceAgainstHull(l, b, d, t, m, r, s)
			};
			var r = new g,
				s = new g,
				t = new g,
				u = new g,
				x = new g,
				z = new g;
			d.prototype.findSeparatingAxis = function(b, d, e, f, j, g, l, m) {
				var p = Number.MAX_VALUE,
					q = 0;
				if (this.uniqueAxes)
					for (v = 0; v !== this.uniqueAxes.length; v++) {
						e.vmult(this.uniqueAxes[v], r);
						D = this.testSepAxis(r,
							b, d, e, f, j);
						if (!1 === D) return !1;
						D < p && (p = D, g.copy(r))
					} else
						for (var C = l ? l.length : this.faces.length, v = 0; v < C; v++) {
							D = l ? l[v] : v;
							r.copy(this.faceNormals[D]);
							e.vmult(r, r);
							var D = this.testSepAxis(r, b, d, e, f, j);
							if (!1 === D) return !1;
							D < p && (p = D, g.copy(r))
						}
				if (b.uniqueAxes)
					for (v = 0; v !== b.uniqueAxes.length; v++) {
						j.vmult(b.uniqueAxes[v], s);
						q++;
						D = this.testSepAxis(s, b, d, e, f, j);
						if (!1 === D) return !1;
						D < p && (p = D, g.copy(s))
					} else {
						l = m ? m.length : b.faces.length;
						for (v = 0; v < l; v++) {
							D = m ? m[v] : v;
							s.copy(b.faceNormals[D]);
							j.vmult(s, s);
							q++;
							D = this.testSepAxis(s,
								b, d, e, f, j);
							if (!1 === D) return !1;
							D < p && (p = D, g.copy(s))
						}
					}
				for (m = 0; m !== this.uniqueEdges.length; m++) {
					e.vmult(this.uniqueEdges[m], u);
					for (q = 0; q !== b.uniqueEdges.length; q++)
						if (j.vmult(b.uniqueEdges[q], x), u.cross(x, z), !z.almostZero()) {
							z.normalize();
							v = this.testSepAxis(z, b, d, e, f, j);
							if (!1 === v) return !1;
							v < p && (p = v, g.copy(z))
						}
				}
				f.vsub(d, t);
				0 < t.dot(g) && g.negate(g);
				return !0
			};
			var v = [],
				B = [];
			d.prototype.testSepAxis = function(b, e, f, j, g, l) {
				d.project(this, b, f, j, v);
				d.project(e, b, g, l, B);
				f = v[0];
				b = v[1];
				e = B[0];
				j = B[1];
				if (f < j || e < b) return !1;
				f -= j;
				b = e - b;
				return f < b ? f : b
			};
			var y = new g,
				A = new g;
			d.prototype.calculateLocalInertia = function(b, d) {
				this.computeLocalAABB(y, A);
				var e = A.x - y.x,
					f = A.y - y.y,
					j = A.z - y.z;
				d.x = 1 / 12 * b * (4 * f * f + 4 * j * j);
				d.y = 1 / 12 * b * (4 * e * e + 4 * j * j);
				d.z = 1 / 12 * b * (4 * f * f + 4 * e * e)
			};
			d.prototype.getPlaneConstantOfFace = function(b) {
				return -this.faceNormals[b].dot(this.vertices[this.faces[b][0]])
			};
			var F = new g,
				C = new g,
				D = new g,
				I = new g,
				N = new g,
				K = new g,
				O = new g,
				H = new g;
			d.prototype.clipFaceAgainstHull = function(b, d, e, f, j, g, l) {
				for (var m = [], p = -1, r = Number.MAX_VALUE,
						s = 0; s < this.faces.length; s++) {
					F.copy(this.faceNormals[s]);
					e.vmult(F, F);
					var q = F.dot(b);
					q < r && (r = q, p = s)
				}
				if (!(0 > p)) {
					b = this.faces[p];
					b.connectedFaces = [];
					for (r = 0; r < this.faces.length; r++)
						for (s = 0; s < this.faces[r].length; s++) - 1 !== b.indexOf(this.faces[r][s]) && (r !== p && -1 === b.connectedFaces.indexOf(r)) && b.connectedFaces.push(r);
					r = b.length;
					for (s = 0; s < r; s++) {
						q = this.vertices[b[s]];
						q.vsub(this.vertices[b[(s + 1) % r]], C);
						D.copy(C);
						e.vmult(D, D);
						d.vadd(D, D);
						I.copy(this.faceNormals[p]);
						e.vmult(I, I);
						d.vadd(I, I);
						D.cross(I, N);
						N.negate(N);
						K.copy(q);
						e.vmult(K, K);
						d.vadd(K, K);
						K.dot(N);
						q = b.connectedFaces[s];
						O.copy(this.faceNormals[q]);
						q = this.getPlaneConstantOfFace(q);
						H.copy(O);
						e.vmult(H, H);
						q -= H.dot(d);
						for (this.clipFaceAgainstPlane(f, m, H, q); f.length;) f.shift();
						for (; m.length;) f.push(m.shift())
					}
					O.copy(this.faceNormals[p]);
					q = this.getPlaneConstantOfFace(p);
					H.copy(O);
					e.vmult(H, H);
					q -= H.dot(d);
					for (r = 0; r < f.length; r++) d = H.dot(f[r]) + q, d <= j && (console.log("clamped: depth=" + d + " to minDist=" + (j + "")), d = j), d <= g && (e = f[r], 0 >= d && l.push({
						point: e,
						normal: H,
						depth: d
					}))
				}
			};
			d.prototype.clipFaceAgainstPlane = function(b, d, e, f) {
				var j, l, m = b.length;
				if (2 > m) return d;
				var p = b[b.length - 1],
					r = b[0];
				j = e.dot(p) + f;
				for (var s = 0; s < m; s++) {
					r = b[s];
					l = e.dot(r) + f;
					if (0 > j) {
						if (0 > l) {
							var q = new g;
							q.copy(r)
						} else q = new g, p.lerp(r, j / (j - l), q);
						d.push(q)
					} else 0 > l && (q = new g, p.lerp(r, j / (j - l), q), d.push(q), d.push(r));
					p = r;
					j = l
				}
				return d
			};
			d.prototype.computeWorldVertices = function(b, d) {
				for (var e = this.vertices.length; this.worldVertices.length < e;) this.worldVertices.push(new g);
				for (var f = this.vertices,
						j = this.worldVertices, l = 0; l !== e; l++) d.vmult(f[l], j[l]), b.vadd(j[l], j[l]);
				this.worldVerticesNeedsUpdate = !1
			};
			new g;
			d.prototype.computeLocalAABB = function(b, d) {
				var e = this.vertices.length,
					f = this.vertices;
				b.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
				d.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
				for (var j = 0; j < e; j++) {
					var g = f[j];
					g.x < b.x ? b.x = g.x : g.x > d.x && (d.x = g.x);
					g.y < b.y ? b.y = g.y : g.y > d.y && (d.y = g.y);
					g.z < b.z ? b.z = g.z : g.z > d.z && (d.z = g.z)
				}
			};
			d.prototype.computeWorldFaceNormals = function(b) {
				for (var d =
						this.faceNormals.length; this.worldFaceNormals.length < d;) this.worldFaceNormals.push(new g);
				for (var e = this.faceNormals, f = this.worldFaceNormals, j = 0; j !== d; j++) b.vmult(e[j], f[j]);
				this.worldFaceNormalsNeedsUpdate = !1
			};
			d.prototype.updateBoundingSphereRadius = function() {
				for (var b = 0, d = this.vertices, e = 0, f = d.length; e !== f; e++) {
					var j = d[e].norm2();
					j > b && (b = j)
				}
				this.boundingSphereRadius = Math.sqrt(b)
			};
			var W = new g;
			d.prototype.calculateWorldAABB = function(b, d, e, f) {
				for (var j = this.vertices.length, g = this.vertices, l, m, p, r,
						s, q, t = 0; t < j; t++) {
					W.copy(g[t]);
					d.vmult(W, W);
					b.vadd(W, W);
					var u = W;
					if (u.x < l || void 0 === l) l = u.x;
					else if (u.x > r || void 0 === r) r = u.x;
					if (u.y < m || void 0 === m) m = u.y;
					else if (u.y > s || void 0 === s) s = u.y;
					if (u.z < p || void 0 === p) p = u.z;
					else if (u.z > q || void 0 === q) q = u.z
				}
				e.set(l, m, p);
				f.set(r, s, q)
			};
			d.prototype.volume = function() {
				return 4 * Math.PI * this.boundingSphereRadius / 3
			};
			d.prototype.getAveragePointLocal = function(b) {
				b = b || new g;
				for (var d = this.vertices.length, e = this.vertices, f = 0; f < d; f++) b.vadd(e[f], b);
				b.mult(1 / d, b);
				return b
			};
			d.prototype.transformAllPoints =
				function(b, d) {
					var e = this.vertices.length,
						f = this.vertices;
					if (d) {
						for (var j = 0; j < e; j++) {
							var g = f[j];
							d.vmult(g, g)
						}
						for (j = 0; j < this.faceNormals.length; j++) g = this.faceNormals[j], d.vmult(g, g)
					}
					if (b)
						for (j = 0; j < e; j++) g = f[j], g.vadd(b, g)
				};
			var aa = new g,
				E = new g,
				G = new g;
			d.prototype.pointIsInside = function(b) {
				var d = this.vertices.length,
					e = this.vertices,
					f = this.faces,
					j = this.faceNormals,
					g = this.faces.length;
				this.getAveragePointLocal(aa);
				for (var l = 0; l < g; l++) {
					var d = j[l],
						m = e[f[l][0]],
						p = E;
					b.vsub(m, p);
					var p = d.dot(p),
						r = G;
					aa.vsub(m,
						r);
					d = d.dot(r);
					if (0 > p && 0 < d || 0 < p && 0 > d) return !1
				}
				return -1
			};
			new g;
			var ba = new g,
				Q = new g;
			d.project = function(b, d, e, f, j) {
				var g = b.vertices.length,
					l = 0,
					m = 0;
				b = b.vertices;
				Q.setZero();
				q.vectorToLocalFrame(e, f, d, ba);
				q.pointToLocalFrame(e, f, Q, Q);
				d = Q.dot(ba);
				m = l = b[0].dot(ba);
				for (e = 1; e < g; e++) f = b[e].dot(ba), f > l && (l = f), f < m && (m = f);
				m -= d;
				l -= d;
				m > l && (g = m, m = l, l = g);
				j[0] = l;
				j[1] = m
			}
		}, {
			"../math/Quaternion": 28,
			"../math/Transform": 29,
			"../math/Vec3": 30,
			"./Shape": 43
		}],
		39: [function(b, e) {
			function d(b, d, e, p) {
				var r = [],
					s = [],
					t = [],
					u = [],
					x =
					[],
					z = Math.cos,
					v = Math.sin;
				r.push(new g(d * z(0), d * v(0), 0.5 * -e));
				u.push(0);
				r.push(new g(b * z(0), b * v(0), 0.5 * e));
				x.push(1);
				for (var B = 0; B < p; B++) {
					var y = 2 * Math.PI / p * (B + 1),
						A = 2 * Math.PI / p * (B + 0.5);
					B < p - 1 ? (r.push(new g(d * z(y), d * v(y), 0.5 * -e)), u.push(2 * B + 2), r.push(new g(b * z(y), b * v(y), 0.5 * e)), x.push(2 * B + 3), t.push([2 * B + 2, 2 * B + 3, 2 * B + 1, 2 * B])) : t.push([0, 1, 2 * B + 1, 2 * B]);
					(1 === p % 2 || B < p / 2) && s.push(new g(z(A), v(A), 0))
				}
				t.push(x);
				s.push(new g(0, 0, 1));
				b = [];
				for (B = 0; B < u.length; B++) b.push(u[u.length - B - 1]);
				t.push(b);
				this.type = f.types.CONVEXPOLYHEDRON;
				q.call(this, r, t, s)
			}
			e.exports = d;
			var f = b("./Shape"),
				g = b("../math/Vec3");
			b("../math/Quaternion");
			var q = b("./ConvexPolyhedron");
			d.prototype = new q
		}, {
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"./ConvexPolyhedron": 38,
			"./Shape": 43
		}],
		40: [function(b, e) {
			function d(b, d) {
				d = m.defaults(d, {
					maxValue: null,
					minValue: null,
					elementSize: 1
				});
				this.data = b;
				this.maxValue = d.maxValue;
				this.minValue = d.minValue;
				this.elementSize = d.elementSize;
				null === d.minValue && this.updateMinValue();
				null === d.maxValue && this.updateMaxValue();
				this.cacheEnabled = !0;
				f.call(this);
				this.pillarConvex = new g;
				this.pillarOffset = new q;
				this.type = f.types.HEIGHTFIELD;
				this.updateBoundingSphereRadius();
				this._cachedPillars = {}
			}
			var f = b("./Shape"),
				g = b("./ConvexPolyhedron"),
				q = b("../math/Vec3"),
				m = b("../utils/Utils");
			e.exports = d;
			d.prototype = new f;
			d.prototype.update = function() {
				this._cachedPillars = {}
			};
			d.prototype.updateMinValue = function() {
				for (var b = this.data, d = b[0][0], e = 0; e !== b.length; e++)
					for (var f = 0; f !== b[e].length; f++) {
						var g = b[e][f];
						g < d && (d = g)
					}
				this.minValue = d
			};
			d.prototype.updateMaxValue =
				function() {
					for (var b = this.data, d = b[0][0], e = 0; e !== b.length; e++)
						for (var f = 0; f !== b[e].length; f++) {
							var g = b[e][f];
							g > d && (d = g)
						}
					this.maxValue = d
				};
			d.prototype.setHeightValueAtIndex = function(b, d, e) {
				this.data[b][d] = e;
				this.clearCachedConvexTrianglePillar(b, d, !1);
				0 < b && (this.clearCachedConvexTrianglePillar(b - 1, d, !0), this.clearCachedConvexTrianglePillar(b - 1, d, !1));
				0 < d && (this.clearCachedConvexTrianglePillar(b, d - 1, !0), this.clearCachedConvexTrianglePillar(b, d - 1, !1));
				0 < d && 0 < b && this.clearCachedConvexTrianglePillar(b -
					1, d - 1, !0)
			};
			d.prototype.getRectMinMax = function(b, d, e, f, g) {
				g = g || [];
				for (var m = this.data, q = this.minValue; b <= e; b++)
					for (var x = d; x <= f; x++) {
						var z = m[b][x];
						z > q && (q = z)
					}
				g[0] = this.minValue;
				g[1] = q
			};
			d.prototype.getIndexOfPosition = function(b, d, e, f) {
				var g = this.elementSize,
					m = this.data;
				b = Math.floor(b / g);
				d = Math.floor(d / g);
				e[0] = b;
				e[1] = d;
				f && (0 > b && (b = 0), 0 > d && (d = 0), b >= m.length - 1 && (b = m.length - 1), d >= m[0].length - 1 && (d = m[0].length - 1));
				return 0 > b || 0 > d || b >= m.length - 1 || d >= m[0].length - 1 ? !1 : !0
			};
			d.prototype.getHeightAt = function(b,
				d, e) {
				var f = [];
				this.getIndexOfPosition(b, d, f, e);
				b = [];
				this.getRectMinMax(f[0], f[1] + 1, f[0], f[1] + 1, b);
				return (b[0] + b[1]) / 2
			};
			d.prototype.getCacheConvexTrianglePillarKey = function(b, d, e) {
				return b + "_" + d + "_" + (e ? 1 : 0)
			};
			d.prototype.getCachedConvexTrianglePillar = function(b, d, e) {
				return this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, d, e)]
			};
			d.prototype.setCachedConvexTrianglePillar = function(b, d, e, f, g) {
				this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, d, e)] = {
					convex: f,
					offset: g
				}
			};
			d.prototype.clearCachedConvexTrianglePillar =
				function(b, d, e) {
					delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(b, d, e)]
				};
			d.prototype.getConvexTrianglePillar = function(b, d, e) {
				var f = this.pillarConvex,
					m = this.pillarOffset;
				if (this.cacheEnabled) {
					var t = this.getCachedConvexTrianglePillar(b, d, e);
					if (t) {
						this.pillarConvex = t.convex;
						this.pillarOffset = t.offset;
						return
					}
					f = new g;
					m = new q;
					this.pillarConvex = f;
					this.pillarOffset = m
				}
				var t = this.data,
					u = this.elementSize,
					x = f.faces;
				f.vertices.length = 6;
				for (var z = 0; 6 > z; z++) f.vertices[z] || (f.vertices[z] = new q);
				x.length =
					5;
				for (z = 0; 5 > z; z++) x[z] || (x[z] = []);
				var z = f.vertices,
					v = (Math.min(t[b][d], t[b + 1][d], t[b][d + 1], t[b + 1][d + 1]) - this.minValue) / 2 + this.minValue;
				e ? (m.set((b + 0.75) * u, (d + 0.75) * u, v), z[0].set(0.25 * u, 0.25 * u, t[b + 1][d + 1] - v), z[1].set(-0.75 * u, 0.25 * u, t[b][d + 1] - v), z[2].set(0.25 * u, -0.75 * u, t[b + 1][d] - v), z[3].set(0.25 * u, 0.25 * u, -v - 1), z[4].set(-0.75 * u, 0.25 * u, -v - 1), z[5].set(0.25 * u, -0.75 * u, -v - 1), x[0][0] = 0, x[0][1] = 1, x[0][2] = 2, x[1][0] = 5, x[1][1] = 4, x[1][2] = 3, x[2][0] = 2, x[2][1] = 5, x[2][2] = 3, x[2][3] = 0, x[3][0] = 3, x[3][1] = 4, x[3][2] = 1, x[3][3] =
					0, x[4][0] = 1, x[4][1] = 4, x[4][2] = 5, x[4][3] = 2) : (m.set((b + 0.25) * u, (d + 0.25) * u, v), z[0].set(-0.25 * u, -0.25 * u, t[b][d] - v), z[1].set(0.75 * u, -0.25 * u, t[b + 1][d] - v), z[2].set(-0.25 * u, 0.75 * u, t[b][d + 1] - v), z[3].set(-0.25 * u, -0.25 * u, -v - 1), z[4].set(0.75 * u, -0.25 * u, -v - 1), z[5].set(-0.25 * u, 0.75 * u, -v - 1), x[0][0] = 0, x[0][1] = 1, x[0][2] = 2, x[1][0] = 5, x[1][1] = 4, x[1][2] = 3, x[2][0] = 0, x[2][1] = 2, x[2][2] = 5, x[2][3] = 3, x[3][0] = 1, x[3][1] = 0, x[3][2] = 3, x[3][3] = 4, x[4][0] = 4, x[4][1] = 5, x[4][2] = 2, x[4][3] = 1);
				f.computeNormals();
				f.computeEdges();
				f.updateBoundingSphereRadius();
				this.setCachedConvexTrianglePillar(b, d, e, f, m)
			};
			d.prototype.calculateLocalInertia = function(b, d) {
				d = d || new q;
				d.set(0, 0, 0);
				return d
			};
			d.prototype.volume = function() {
				return Number.MAX_VALUE
			};
			d.prototype.calculateWorldAABB = function(b, d, e, f) {
				e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
				f.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
			};
			d.prototype.updateBoundingSphereRadius = function() {
				var b = this.data,
					d = this.elementSize;
				this.boundingSphereRadius = (new q(b.length * d, b[0].length * d, Math.max(Math.abs(this.maxValue),
					Math.abs(this.minValue)))).norm()
			}
		}, {
			"../math/Vec3": 30,
			"../utils/Utils": 53,
			"./ConvexPolyhedron": 38,
			"./Shape": 43
		}],
		41: [function(b, e) {
			function d() {
				f.call(this);
				this.type = f.types.PARTICLE
			}
			e.exports = d;
			var f = b("./Shape"),
				g = b("../math/Vec3");
			d.prototype = new f;
			d.prototype.constructor = d;
			d.prototype.calculateLocalInertia = function(b, d) {
				d = d || new g;
				d.set(0, 0, 0);
				return d
			};
			d.prototype.volume = function() {
				return 0
			};
			d.prototype.updateBoundingSphereRadius = function() {
				this.boundingSphereRadius = 0
			};
			d.prototype.calculateWorldAABB =
				function(b, d, e, f) {
					e.copy(b);
					f.copy(b)
				}
		}, {
			"../math/Vec3": 30,
			"./Shape": 43
		}],
		42: [function(b, e) {
			function d() {
				f.call(this);
				this.type = f.types.PLANE;
				this.worldNormal = new g;
				this.worldNormalNeedsUpdate = !0;
				this.boundingSphereRadius = Number.MAX_VALUE
			}
			e.exports = d;
			var f = b("./Shape"),
				g = b("../math/Vec3");
			d.prototype = new f;
			d.prototype.constructor = d;
			d.prototype.computeWorldNormal = function(b) {
				var d = this.worldNormal;
				d.set(0, 0, 1);
				b.vmult(d, d);
				this.worldNormalNeedsUpdate = !1
			};
			d.prototype.calculateLocalInertia = function(b,
				d) {
				return d = d || new g
			};
			d.prototype.volume = function() {
				return Number.MAX_VALUE
			};
			var q = new g;
			d.prototype.calculateWorldAABB = function(b, d, e, f) {
				q.set(0, 0, 1);
				d.vmult(q, q);
				d = Number.MAX_VALUE;
				e.set(-d, -d, -d);
				f.set(d, d, d);
				1 === q.x && (f.x = b.x);
				1 === q.y && (f.y = b.y);
				1 === q.z && (f.z = b.z); - 1 === q.x && (e.x = b.x); - 1 === q.y && (e.y = b.y); - 1 === q.z && (e.z = b.z)
			};
			d.prototype.updateBoundingSphereRadius = function() {
				this.boundingSphereRadius = Number.MAX_VALUE
			}
		}, {
			"../math/Vec3": 30,
			"./Shape": 43
		}],
		43: [function(b, e) {
			function d() {
				this.id = d.idCounter++;
				this.boundingSphereRadius = this.type = 0;
				this.collisionResponse = !0;
				this.material = null
			}
			e.exports = d;
			d = b("./Shape");
			b("../math/Vec3");
			b("../math/Quaternion");
			b("../material/Material");
			d.prototype.constructor = d;
			d.prototype.updateBoundingSphereRadius = function() {
				throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
			};
			d.prototype.volume = function() {
				throw "volume() not implemented for shape type " + this.type;
			};
			d.prototype.calculateLocalInertia = function() {
				throw "calculateLocalInertia() not implemented for shape type " +
					this.type;
			};
			d.idCounter = 0;
			d.types = {
				SPHERE: 1,
				PLANE: 2,
				BOX: 4,
				COMPOUND: 8,
				CONVEXPOLYHEDRON: 16,
				HEIGHTFIELD: 32,
				PARTICLE: 64,
				CYLINDER: 128,
				TRIMESH: 256
			}
		}, {
			"../material/Material": 25,
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"./Shape": 43
		}],
		44: [function(b, e) {
			function d(b) {
				f.call(this);
				this.radius = void 0 !== b ? Number(b) : 1;
				this.type = f.types.SPHERE;
				if (0 > this.radius) throw Error("The sphere radius cannot be negative.");
				this.updateBoundingSphereRadius()
			}
			e.exports = d;
			var f = b("./Shape"),
				g = b("../math/Vec3");
			d.prototype = new f;
			d.prototype.constructor = d;
			d.prototype.calculateLocalInertia = function(b, d) {
				d = d || new g;
				var e = 2 * b * this.radius * this.radius / 5;
				d.x = e;
				d.y = e;
				d.z = e;
				return d
			};
			d.prototype.volume = function() {
				return 4 * Math.PI * this.radius / 3
			};
			d.prototype.updateBoundingSphereRadius = function() {
				this.boundingSphereRadius = this.radius
			};
			d.prototype.calculateWorldAABB = function(b, d, e, f) {
				d = this.radius;
				for (var g = ["x", "y", "z"], r = 0; r < g.length; r++) {
					var s = g[r];
					e[s] = b[s] - d;
					f[s] = b[s] + d
				}
			}
		}, {
			"../math/Vec3": 30,
			"./Shape": 43
		}],
		45: [function(b, e) {
			function d(b,
				d) {
				f.call(this);
				this.type = f.types.TRIMESH;
				this.vertices = new Float32Array(b);
				this.indices = new Int16Array(d);
				this.normals = new Float32Array(d.length);
				this.aabb = new m;
				this.edges = null;
				this.scale = new g(1, 1, 1);
				this.tree = new j;
				this.updateEdges();
				this.updateNormals();
				this.updateAABB();
				this.updateBoundingSphereRadius();
				this.updateTree()
			}
			e.exports = d;
			var f = b("./Shape"),
				g = b("../math/Vec3");
			b("../math/Quaternion");
			var q = b("../math/Transform"),
				m = b("../collision/AABB"),
				j = b("../utils/Octree");
			d.prototype = new f;
			d.prototype.constructor =
				d;
			var l = new g;
			d.prototype.updateTree = function() {
				var b = this.tree;
				b.reset();
				b.aabb.copy(this.aabb);
				var d = this.scale;
				b.aabb.lowerBound.x *= 1 / d.x;
				b.aabb.lowerBound.y *= 1 / d.y;
				b.aabb.lowerBound.z *= 1 / d.z;
				b.aabb.upperBound.x *= 1 / d.x;
				b.aabb.upperBound.y *= 1 / d.y;
				b.aabb.upperBound.z *= 1 / d.z;
				for (var d = new m, e = new g, f = new g, j = new g, l = [e, f, j], p = 0; p < this.indices.length / 3; p++) {
					var r = 3 * p;
					this._getUnscaledVertex(this.indices[r], e);
					this._getUnscaledVertex(this.indices[r + 1], f);
					this._getUnscaledVertex(this.indices[r + 2], j);
					d.setFromPoints(l);
					b.insert(d, p)
				}
				b.removeEmptyNodes()
			};
			var p = new m;
			d.prototype.getTrianglesInAABB = function(b, d) {
				p.copy(b);
				var e = this.scale,
					f = e.x,
					j = e.y,
					e = e.z,
					g = p.lowerBound,
					l = p.upperBound;
				g.x /= f;
				g.y /= j;
				g.z /= e;
				l.x /= f;
				l.y /= j;
				l.z /= e;
				return this.tree.aabbQuery(p, d)
			};
			d.prototype.setScale = function(b) {
				var d = b.x === b.y === b.z;
				this.scale.x === this.scale.y === this.scale.z && d || this.updateNormals();
				this.scale.copy(b);
				this.updateAABB();
				this.updateBoundingSphereRadius()
			};
			d.prototype.updateNormals = function() {
				for (var b =
						this.normals, e = 0; e < this.indices.length / 3; e++) {
					var f = 3 * e,
						j = this.indices[f + 1],
						g = this.indices[f + 2];
					this.getVertex(this.indices[f], x);
					this.getVertex(j, z);
					this.getVertex(g, v);
					d.computeNormal(z, x, v, l);
					b[f] = l.x;
					b[f + 1] = l.y;
					b[f + 2] = l.z
				}
			};
			d.prototype.updateEdges = function() {
				for (var b = {}, d = function() {
						b[j < g ? j + "_" + g : g + "_" + j] = !0
					}, e = 0; e < this.indices.length / 3; e++) {
					var f = 3 * e,
						j = this.indices[f],
						g = this.indices[f + 1],
						f = this.indices[f + 2];
					d(j, g);
					d(g, f);
					d(f, j)
				}
				d = Object.keys(b);
				this.edges = new Int16Array(2 * d.length);
				for (e = 0; e <
					d.length; e++) f = d[e].split("_"), this.edges[2 * e] = parseInt(f[0], 10), this.edges[2 * e + 1] = parseInt(f[1], 10)
			};
			d.prototype.getEdgeVertex = function(b, d, e) {
				this.getVertex(this.edges[2 * b + (d ? 1 : 0)], e)
			};
			var r = new g,
				s = new g;
			d.prototype.getEdgeVector = function(b, d) {
				this.getEdgeVertex(b, 0, r);
				this.getEdgeVertex(b, 1, s);
				s.vsub(r, d)
			};
			var t = new g,
				u = new g;
			d.computeNormal = function(b, d, e, f) {
				d.vsub(b, u);
				e.vsub(d, t);
				t.cross(u, f);
				f.isZero() || f.normalize()
			};
			var x = new g,
				z = new g,
				v = new g;
			d.prototype.getVertex = function(b, d) {
				var e = this.scale;
				this._getUnscaledVertex(b, d);
				d.x *= e.x;
				d.y *= e.y;
				d.z *= e.z;
				return d
			};
			d.prototype._getUnscaledVertex = function(b, d) {
				var e = 3 * b,
					f = this.vertices;
				return d.set(f[e], f[e + 1], f[e + 2])
			};
			d.prototype.getWorldVertex = function(b, d, e, f) {
				this.getVertex(b, f);
				q.pointToWorldFrame(d, e, f, f);
				return f
			};
			d.prototype.getTriangleVertices = function(b, d, e, f) {
				b *= 3;
				this.getVertex(this.indices[b], d);
				this.getVertex(this.indices[b + 1], e);
				this.getVertex(this.indices[b + 2], f)
			};
			d.prototype.getNormal = function(b, d) {
				var e = 3 * b;
				return d.set(this.normals[e],
					this.normals[e + 1], this.normals[e + 2])
			};
			var B = new m;
			d.prototype.calculateLocalInertia = function(b, d) {
				this.computeLocalAABB(B);
				var e = B.upperBound.x - B.lowerBound.x,
					f = B.upperBound.y - B.lowerBound.y,
					j = B.upperBound.z - B.lowerBound.z;
				return d.set(1 / 12 * b * (4 * f * f + 4 * j * j), 1 / 12 * b * (4 * e * e + 4 * j * j), 1 / 12 * b * (4 * f * f + 4 * e * e))
			};
			var y = new g;
			d.prototype.computeLocalAABB = function(b) {
				var d = b.lowerBound;
				b = b.upperBound;
				var e = this.vertices.length;
				this.getVertex(0, y);
				d.copy(y);
				b.copy(y);
				for (var f = 0; f !== e; f++) this.getVertex(f, y), y.x <
					d.x ? d.x = y.x : y.x > b.x && (b.x = y.x), y.y < d.y ? d.y = y.y : y.y > b.y && (b.y = y.y), y.z < d.z ? d.z = y.z : y.z > b.z && (b.z = y.z)
			};
			d.prototype.updateAABB = function() {
				this.computeLocalAABB(this.aabb)
			};
			d.prototype.updateBoundingSphereRadius = function() {
				for (var b = 0, d = this.vertices, e = new g, f = 0, d = d.length / 3; f !== d; f++) {
					this.getVertex(f, e);
					var j = e.norm2();
					j > b && (b = j)
				}
				this.boundingSphereRadius = Math.sqrt(b)
			};
			new g;
			var A = new q,
				F = new m;
			d.prototype.calculateWorldAABB = function(b, d, e, f) {
				A.position = b;
				A.quaternion = d;
				this.aabb.toWorldFrame(A, F);
				e.copy(F.lowerBound);
				f.copy(F.upperBound)
			};
			d.prototype.volume = function() {
				return 4 * Math.PI * this.boundingSphereRadius / 3
			};
			d.createTorus = function(b, e, f, j, g) {
				b = b || 1;
				e = e || 0.5;
				f = f || 8;
				j = j || 6;
				g = g || 2 * Math.PI;
				for (var l = [], m = [], p = 0; p <= f; p++)
					for (var r = 0; r <= j; r++) {
						var s = r / j * g,
							q = 2 * p / f * Math.PI,
							t = (b + e * Math.cos(q)) * Math.cos(s),
							s = (b + e * Math.cos(q)) * Math.sin(s),
							q = e * Math.sin(q);
						l.push(t, s, q)
					}
				for (p = 1; p <= f; p++)
					for (r = 1; r <= j; r++) b = (j + 1) * (p - 1) + r - 1, e = (j + 1) * (p - 1) + r, g = (j + 1) * p + r, m.push((j + 1) * p + r - 1, b, g), m.push(b, e, g);
				return new d(l,
					m)
			}
		}, {
			"../collision/AABB": 3,
			"../math/Quaternion": 28,
			"../math/Transform": 29,
			"../math/Vec3": 30,
			"../utils/Octree": 50,
			"./Shape": 43
		}],
		46: [function(b, e) {
			function d() {
				f.call(this);
				this.iterations = 10;
				this.tolerance = 1E-7
			}
			e.exports = d;
			b("../math/Vec3");
			b("../math/Quaternion");
			var f = b("./Solver");
			d.prototype = new f;
			var g = [],
				q = [],
				m = [];
			d.prototype.solve = function(b, d) {
				var e = 0,
					f = this.iterations,
					s = this.tolerance * this.tolerance,
					t = this.equations,
					u = t.length,
					x = d.bodies,
					z = x.length,
					v, B, y, A, F;
				if (0 !== u)
					for (y = 0; y !== z; y++) x[y].updateSolveMassProperties();
				q.length = u;
				m.length = u;
				g.length = u;
				for (y = 0; y !== u; y++) {
					var C = t[y];
					g[y] = 0;
					m[y] = C.computeB(b);
					q[y] = 1 / C.computeC()
				}
				if (0 !== u) {
					for (y = 0; y !== z; y++) C = x[y], e = C.wlambda, C.vlambda.set(0, 0, 0), e && e.set(0, 0, 0);
					for (e = 0; e !== f; e++) {
						for (var D = y = 0; D !== u; D++) C = t[D], v = m[D], B = q[D], F = g[D], A = C.computeGWlambda(), v = B * (v - A - C.eps * F), F + v < C.minForce ? v = C.minForce - F : F + v > C.maxForce && (v = C.maxForce - F), g[D] += v, y += 0 < v ? v : -v, C.addToWlambda(v);
						if (y * y < s) break
					}
					for (y = 0; y !== z; y++) C = x[y], f = C.velocity, s = C.angularVelocity, f.vadd(C.vlambda, f), s &&
						s.vadd(C.wlambda, s)
				}
				return e
			}
		}, {
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"./Solver": 47
		}],
		47: [function(b, e) {
			function d() {
				this.equations = []
			}
			e.exports = d;
			d.prototype.solve = function() {
				return 0
			};
			d.prototype.addEquation = function(b) {
				b.enabled && this.equations.push(b)
			};
			d.prototype.removeEquation = function(b) {
				var d = this.equations;
				b = d.indexOf(b); - 1 !== b && d.splice(b, 1)
			};
			d.prototype.removeAllEquations = function() {
				this.equations.length = 0
			}
		}, {}],
		48: [function(b, e) {
			function d(b) {
				m.call(this);
				this.iterations = 10;
				this.tolerance =
					1E-7;
				this.subsolver = b;
				this.nodes = [];
				for (this.nodePool = []; 128 > this.nodePool.length;) this.nodePool.push(this.createNode())
			}

			function f(b) {
				for (var d = b.length, e = 0; e !== d; e++) {
					var f = b[e];
					if (!f.visited && !(f.body.type & s)) return f
				}
				return !1
			}

			function g(b, d, e) {
				d.push(b.body);
				d = b.eqs.length;
				for (var f = 0; f !== d; f++) {
					var j = b.eqs[f]; - 1 === e.indexOf(j) && e.push(j)
				}
			}

			function q(b, d) {
				return d.id - b.id
			}
			e.exports = d;
			b("../math/Vec3");
			b("../math/Quaternion");
			var m = b("./Solver"),
				j = b("../objects/Body");
			d.prototype = new m;
			var l = [],
				p = [],
				r = {
					bodies: []
				},
				s = j.STATIC,
				t = [];
			d.prototype.createNode = function() {
				return {
					body: null,
					children: [],
					eqs: [],
					visited: !1
				}
			};
			d.prototype.solve = function(b, d) {
				for (var e = this.nodePool, j = d.bodies, m = this.equations, s = m.length, A = j.length, F = this.subsolver; e.length < A;) e.push(this.createNode());
				l.length = A;
				for (var C = 0; C < A; C++) l[C] = e[C];
				for (C = 0; C !== A; C++) e = l[C], e.body = j[C], e.children.length = 0, e.eqs.length = 0, e.visited = !1;
				for (A = 0; A !== s; A++) {
					var e = m[A],
						C = j.indexOf(e.bi),
						D = j.indexOf(e.bj),
						C = l[C],
						D = l[D];
					C.children.push(D);
					C.eqs.push(e);
					D.children.push(C);
					D.eqs.push(e)
				}
				j = 0;
				m = p;
				F.tolerance = this.tolerance;
				for (F.iterations = this.iterations; C = f(l);) {
					m.length = 0;
					r.bodies.length = 0;
					e = C;
					C = g;
					s = r.bodies;
					A = m;
					t.push(e);
					e.visited = !0;
					for (C(e, s, A); t.length;)
						for (e = t.pop(); D = f(e.children);) D.visited = !0, C(D, s, A), t.push(D);
					s = m.length;
					m = m.sort(q);
					for (C = 0; C !== s; C++) F.addEquation(m[C]);
					F.solve(b, r);
					F.removeAllEquations();
					j++
				}
				return j
			}
		}, {
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"../objects/Body": 31,
			"./Solver": 47
		}],
		49: [function(b, e) {
			var d =
				function() {};
			e.exports = d;
			d.prototype = {
				constructor: d,
				addEventListener: function(b, d) {
					void 0 === this._listeners && (this._listeners = {});
					var e = this._listeners;
					void 0 === e[b] && (e[b] = []); - 1 === e[b].indexOf(d) && e[b].push(d);
					return this
				},
				hasEventListener: function(b, d) {
					if (void 0 === this._listeners) return !1;
					var e = this._listeners;
					return void 0 !== e[b] && -1 !== e[b].indexOf(d) ? !0 : !1
				},
				removeEventListener: function(b, d) {
					if (void 0 === this._listeners) return this;
					var e = this._listeners;
					if (void 0 === e[b]) return this;
					var m = e[b].indexOf(d); -
					1 !== m && e[b].splice(m, 1);
					return this
				},
				dispatchEvent: function(b) {
					if (void 0 === this._listeners) return this;
					var d = this._listeners[b.type];
					if (void 0 !== d) {
						b.target = this;
						for (var e = 0, m = d.length; e < m; e++) d[e].call(this, b)
					}
					return this
				}
			}
		}, {}],
		50: [function(b, e) {
			function d(b) {
				b = b || {};
				this.root = b.root || null;
				this.aabb = b.aabb ? b.aabb.clone() : new g;
				this.data = [];
				this.children = []
			}

			function f(b, e) {
				e = e || {};
				e.root = null;
				e.aabb = b;
				d.call(this, e);
				this.maxDepth = "undefined" !== typeof e.maxDepth ? e.maxDepth : 8
			}
			var g = b("../collision/AABB"),
				q = b("../math/Vec3");
			e.exports = f;
			f.prototype = new d;
			d.prototype.reset = function() {
				this.children.length = this.data.length = 0
			};
			d.prototype.insert = function(b, d, e) {
				var f = this.data;
				e = e || 0;
				if (!this.aabb.contains(b)) return !1;
				var j = this.children;
				if (e < (this.maxDepth || this.root.maxDepth)) {
					var g = !1;
					j.length || (this.subdivide(), g = !0);
					for (var m = 0; 8 !== m; m++)
						if (j[m].insert(b, d, e + 1)) return !0;
					g && (j.length = 0)
				}
				f.push(d);
				return !0
			};
			var m = new q;
			d.prototype.subdivide = function() {
				var b = this.aabb,
					e = b.lowerBound,
					f = b.upperBound,
					b =
					this.children;
				b.push(new d({
					aabb: new g({
						lowerBound: new q(0, 0, 0)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(1, 0, 0)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(1, 1, 0)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(1, 1, 1)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(0, 1, 1)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(0, 0, 1)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(1, 0, 1)
					})
				}), new d({
					aabb: new g({
						lowerBound: new q(0, 1, 0)
					})
				}));
				f.vsub(e, m);
				m.scale(0.5, m);
				for (var f = this.root || this, j = 0; 8 !== j; j++) {
					var t = b[j];
					t.root = f;
					var u = t.aabb.lowerBound;
					u.x *= m.x;
					u.y *= m.y;
					u.z *= m.z;
					u.vadd(e, u);
					u.vadd(m, t.aabb.upperBound)
				}
			};
			d.prototype.aabbQuery = function(b, d) {
				for (var e = [this]; e.length;) {
					var f = e.pop();
					f.aabb.overlaps(b) && Array.prototype.push.apply(d, f.data);
					Array.prototype.push.apply(e, f.children)
				}
				return d
			};
			var j = new g;
			d.prototype.rayQuery = function(b, d, e) {
				b.getAABB(j);
				j.toLocalFrame(d, j);
				this.aabbQuery(j, e);
				return e
			};
			d.prototype.removeEmptyNodes = function() {
				for (var b = [this]; b.length;) {
					for (var d = b.pop(), e = d.children.length - 1; 0 <= e; e--) d.children[e].data.length ||
						d.children.splice(e, 1);
					Array.prototype.push.apply(b, d.children)
				}
			}
		}, {
			"../collision/AABB": 3,
			"../math/Vec3": 30
		}],
		51: [function(b, e) {
			function d() {
				this.objects = [];
				this.type = Object
			}
			e.exports = d;
			d.prototype.release = function() {
				for (var b = arguments.length, d = 0; d !== b; d++) this.objects.push(arguments[d])
			};
			d.prototype.get = function() {
				return 0 === this.objects.length ? this.constructObject() : this.objects.pop()
			};
			d.prototype.constructObject = function() {
				throw Error("constructObject() not implemented in this Pool subclass yet!");
			}
		}, {}],
		52: [function(b, e) {
			function d() {
				this.data = {
					keys: []
				}
			}
			e.exports = d;
			d.prototype.get = function(b, d) {
				if (b > d) {
					var e = d;
					d = b;
					b = e
				}
				return this.data[b + "-" + d]
			};
			d.prototype.set = function(b, d, e) {
				if (b > d) {
					var m = d;
					d = b;
					b = m
				}
				m = b + "-" + d;
				this.get(b, d) || this.data.keys.push(m);
				this.data[m] = e
			};
			d.prototype.reset = function() {
				for (var b = this.data, d = b.keys; 0 < d.length;) {
					var e = d.pop();
					delete b[e]
				}
			}
		}, {}],
		53: [function(b, e) {
			function d() {}
			e.exports = d;
			d.defaults = function(b, d) {
				b = b || {};
				for (var e in d) e in b || (b[e] = d[e]);
				return b
			}
		}, {}],
		54: [function(b, e) {
			function d() {
				g.call(this);
				this.type = f
			}
			e.exports = d;
			var f = b("../math/Vec3"),
				g = b("./Pool");
			d.prototype = new g;
			d.prototype.constructObject = function() {
				return new f
			}
		}, {
			"../math/Vec3": 30,
			"./Pool": 51
		}],
		55: [function(b, e) {
			function d(b) {
				this.contactPointPool = [];
				this.frictionEquationPool = [];
				this.result = [];
				this.frictionResult = [];
				this.v3pool = new p;
				this.world = b;
				this.currentContactMaterial = null;
				this.enableFrictionReduction = !1
			}
			e.exports = d;
			var f = b("../collision/AABB"),
				g = b("../shapes/Shape"),
				q = b("../collision/Ray"),
				m = b("../math/Vec3"),
				j = b("../math/Transform");
			b("../shapes/ConvexPolyhedron");
			var l = b("../math/Quaternion");
			b("../solver/Solver");
			var p = b("../utils/Vec3Pool"),
				r = b("../equations/ContactEquation"),
				s = b("../equations/FrictionEquation");
			d.prototype.createContactEquation = function(b, d, e, f, j, g) {
				var l;
				this.contactPointPool.length ? (l = this.contactPointPool.pop(), l.bi = b, l.bj = d) : l = new r(b, d);
				l.enabled = b.collisionResponse && d.collisionResponse && e.collisionResponse && f.collisionResponse;
				var m = this.currentContactMaterial;
				l.restitution = m.restitution;
				l.setSpookParams(m.contactEquationStiffness, m.contactEquationRelaxation, this.world.dt);
				b = e.material || b.material;
				d = f.material || d.material;
				b && (d && 0 <= b.restitution && 0 <= d.restitution) && (l.restitution = b.restitution * d.restitution);
				l.si = j || e;
				l.sj = g || f;
				return l
			};
			d.prototype.createFrictionEquationsFromContact = function(b, d) {
				var e = b.bi,
					f = b.bj,
					j = this.world,
					g = this.currentContactMaterial,
					l = g.friction,
					m = b.si.material || e.material,
					p = b.sj.material || f.material;
				m && (p && 0 <= m.friction && 0 <= p.friction) &&
					(l = m.friction * p.friction);
				if (0 < l) {
					l *= j.gravity.length();
					m = e.invMass + f.invMass;
					0 < m && (m = 1 / m);
					var r = this.frictionEquationPool,
						p = r.length ? r.pop() : new s(e, f, l * m),
						r = r.length ? r.pop() : new s(e, f, l * m);
					p.bi = r.bi = e;
					p.bj = r.bj = f;
					p.minForce = r.minForce = -l * m;
					p.maxForce = r.maxForce = l * m;
					p.ri.copy(b.ri);
					p.rj.copy(b.rj);
					r.ri.copy(b.ri);
					r.rj.copy(b.rj);
					b.ni.tangents(p.t, r.t);
					p.setSpookParams(g.frictionEquationStiffness, g.frictionEquationRelaxation, j.dt);
					r.setSpookParams(g.frictionEquationStiffness, g.frictionEquationRelaxation,
						j.dt);
					p.enabled = r.enabled = b.enabled;
					d.push(p, r);
					return !0
				}
				return !1
			};
			var t = new m,
				u = new m,
				x = new m;
			d.prototype.createFrictionFromAverage = function(b) {
				var d = this.result[this.result.length - 1];
				if (this.createFrictionEquationsFromContact(d, this.frictionResult) && 1 !== b) {
					var e = this.frictionResult[this.frictionResult.length - 2],
						f = this.frictionResult[this.frictionResult.length - 1];
					t.setZero();
					u.setZero();
					x.setZero();
					for (var j = d.bi, g = 0; g !== b; g++) d = this.result[this.result.length - 1 - g], d.bodyA !== j ? (t.vadd(d.ni, t), u.vadd(d.ri,
						u), x.vadd(d.rj, x)) : (t.vsub(d.ni, t), u.vadd(d.rj, u), x.vadd(d.ri, x));
					b = 1 / b;
					u.scale(b, e.ri);
					x.scale(b, e.rj);
					f.ri.copy(e.ri);
					f.rj.copy(e.rj);
					t.normalize();
					t.tangents(e.t, f.t)
				}
			};
			var z = new m,
				v = new m,
				B = new l,
				y = new l;
			d.prototype.getContacts = function(b, d, e, f, j, g, l) {
				this.contactPointPool = j;
				this.frictionEquationPool = l;
				this.result = f;
				this.frictionResult = g;
				f = 0;
				for (j = b.length; f !== j; f++) {
					g = b[f];
					l = d[f];
					var m = null;
					g.material && l.material && (m = e.getContactMaterial(g.material, l.material) || null);
					for (var p = 0; p < g.shapes.length; p++) {
						g.quaternion.mult(g.shapeOrientations[p],
							B);
						g.quaternion.vmult(g.shapeOffsets[p], z);
						z.vadd(g.position, z);
						for (var r = g.shapes[p], n = 0; n < l.shapes.length; n++) {
							l.quaternion.mult(l.shapeOrientations[n], y);
							l.quaternion.vmult(l.shapeOffsets[n], v);
							v.vadd(l.position, v);
							var s = l.shapes[n];
							if (!(z.distanceTo(v) > r.boundingSphereRadius + s.boundingSphereRadius)) {
								var q = null;
								r.material && s.material && (q = e.getContactMaterial(r.material, s.material) || null);
								this.currentContactMaterial = q || m || e.defaultContactMaterial;
								(q = this[r.type | s.type]) && (r.type < s.type ? q.call(this,
									r, s, z, v, B, y, g, l, r, s) : q.call(this, s, r, v, z, y, B, l, g, r, s))
							}
						}
					}
				}
			};
			d.prototype[g.types.BOX | g.types.BOX] = d.prototype.boxBox = function(b, d, e, f, j, g, l, m) {
				b.convexPolyhedronRepresentation.material = b.material;
				d.convexPolyhedronRepresentation.material = d.material;
				b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
				d.convexPolyhedronRepresentation.collisionResponse = d.collisionResponse;
				this.convexConvex(b.convexPolyhedronRepresentation, d.convexPolyhedronRepresentation, e, f, j, g, l, m, b, d)
			};
			d.prototype[g.types.BOX |
				g.types.CONVEXPOLYHEDRON] = d.prototype.boxConvex = function(b, d, e, f, j, g, l, m) {
				b.convexPolyhedronRepresentation.material = b.material;
				b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
				this.convexConvex(b.convexPolyhedronRepresentation, d, e, f, j, g, l, m, b, d)
			};
			d.prototype[g.types.BOX | g.types.PARTICLE] = d.prototype.boxParticle = function(b, d, e, f, j, g, l, m) {
				b.convexPolyhedronRepresentation.material = b.material;
				b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
				this.convexParticle(b.convexPolyhedronRepresentation,
					d, e, f, j, g, l, m, b, d)
			};
			d.prototype[g.types.SPHERE] = d.prototype.sphereSphere = function(b, d, e, f, j, g, l, m) {
				j = this.createContactEquation(l, m, b, d);
				f.vsub(e, j.ni);
				j.ni.normalize();
				j.ri.copy(j.ni);
				j.rj.copy(j.ni);
				j.ri.mult(b.radius, j.ri);
				j.rj.mult(-d.radius, j.rj);
				j.ri.vadd(e, j.ri);
				j.ri.vsub(l.position, j.ri);
				j.rj.vadd(f, j.rj);
				j.rj.vsub(m.position, j.rj);
				this.result.push(j);
				this.createFrictionEquationsFromContact(j, this.frictionResult)
			};
			var A = new m,
				F = new m,
				C = new m;
			d.prototype[g.types.PLANE | g.types.TRIMESH] = d.prototype.planeTrimesh =
				function(b, d, e, f, g, l, p, r) {
					var n = new m;
					A.set(0, 0, 1);
					g.vmult(A, A);
					for (g = 0; g < d.vertices.length / 3; g++) {
						d.getVertex(g, n);
						var s = new m;
						s.copy(n);
						j.pointToWorldFrame(f, l, s, n);
						s = F;
						n.vsub(e, s);
						if (0 >= A.dot(s)) {
							var q = this.createContactEquation(p, r, b, d);
							q.ni.copy(A);
							var t = C;
							A.scale(s.dot(A), t);
							n.vsub(t, t);
							q.ri.copy(t);
							q.ri.vsub(p.position, q.ri);
							q.rj.copy(n);
							q.rj.vsub(r.position, q.rj);
							this.result.push(q);
							this.createFrictionEquationsFromContact(q, this.frictionResult)
						}
					}
				};
			var D = new m,
				I = new m;
			new m;
			var N = new m,
				K = new m,
				O = new m,
				H = new m,
				W = new m,
				aa = new m,
				E = new m,
				G = new m,
				ba = new m,
				Q = new m,
				ca = new m,
				oa = new f,
				T = [];
			d.prototype[g.types.SPHERE | g.types.TRIMESH] = d.prototype.sphereTrimesh = function(b, d, e, f, g, l, m, p) {
				j.pointToLocalFrame(f, l, e, E);
				g = b.radius;
				oa.lowerBound.set(E.x - g, E.y - g, E.z - g);
				oa.upperBound.set(E.x + g, E.y + g, E.z + g);
				d.getTrianglesInAABB(oa, T);
				var r = b.radius * b.radius;
				for (g = 0; g < T.length; g++)
					for (var n = 0; 3 > n; n++)
						if (d.getVertex(d.indices[3 * T[g] + n], N), N.vsub(E, I), I.norm2() <= r) {
							K.copy(N);
							j.pointToWorldFrame(f, l, K, N);
							N.vsub(e,
								I);
							var s = this.createContactEquation(m, p, b, d);
							s.ni.copy(I);
							s.ni.normalize();
							s.ri.copy(s.ni);
							s.ri.scale(b.radius, s.ri);
							s.ri.vadd(e, s.ri);
							s.ri.vsub(m.position, s.ri);
							s.rj.copy(N);
							s.rj.vsub(p.position, s.rj);
							this.result.push(s);
							this.createFrictionEquationsFromContact(s, this.frictionResult)
						}
				for (g = 0; g < T.length; g++)
					for (n = 0; 3 > n; n++) d.getVertex(d.indices[3 * T[g] + n], O), d.getVertex(d.indices[3 * T[g] + (n + 1) % 3], H), H.vsub(O, W), E.vsub(H, G), e = G.dot(W), E.vsub(O, G), s = G.dot(W), 0 < s && 0 > e && (E.vsub(O, G), aa.copy(W), aa.normalize(),
						s = G.dot(aa), aa.scale(s, G), G.vadd(O, G), e = G.distanceTo(E), e < b.radius && (s = this.createContactEquation(m, p, b, d), G.vsub(E, s.ni), s.ni.normalize(), s.ni.scale(b.radius, s.ri), j.pointToWorldFrame(f, l, G, G), G.vsub(p.position, s.rj), j.vectorToWorldFrame(l, s.ni, s.ni), j.vectorToWorldFrame(l, s.ri, s.ri), this.result.push(s), this.createFrictionEquationsFromContact(s, this.frictionResult)));
				g = 0;
				for (n = T.length; g !== n; g++) d.getTriangleVertices(T[g], ba, Q, ca), d.getNormal(T[g], D), E.vsub(ba, G), e = G.dot(D), D.scale(e, G), E.vsub(G,
					G), e = G.distanceTo(E), q.pointInTriangle(G, ba, Q, ca) && e < b.radius && (s = this.createContactEquation(m, p, b, d), G.vsub(E, s.ni), s.ni.normalize(), s.ni.scale(b.radius, s.ri), j.pointToWorldFrame(f, l, G, G), G.vsub(p.position, s.rj), j.vectorToWorldFrame(l, s.ni, s.ni), j.vectorToWorldFrame(l, s.ri, s.ri), this.result.push(s), this.createFrictionEquationsFromContact(s, this.frictionResult));
				T.length = 0
			};
			var ha = new m,
				Y = new m;
			d.prototype[g.types.SPHERE | g.types.PLANE] = d.prototype.spherePlane = function(b, d, e, f, j, g, l, m) {
				d = this.createContactEquation(l,
					m, b, d);
				d.ni.set(0, 0, 1);
				g.vmult(d.ni, d.ni);
				d.ni.negate(d.ni);
				d.ni.normalize();
				d.ni.mult(b.radius, d.ri);
				e.vsub(f, ha);
				d.ni.mult(d.ni.dot(ha), Y);
				ha.vsub(Y, d.rj); - ha.dot(d.ni) <= b.radius && (b = d.ri, g = d.rj, b.vadd(e, b), b.vsub(l.position, b), g.vadd(f, g), g.vsub(m.position, g), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult))
			};
			var la = new m,
				ra = new m,
				da = new m,
				ma = new m,
				ya = new m,
				ka = new m,
				pa = new m,
				J = [new m, new m, new m, new m, new m, new m],
				Va = new m,
				ja = new m,
				Ia = new m,
				Oa = new m;
			d.prototype[g.types.SPHERE |
				g.types.BOX] = d.prototype.sphereBox = function(b, d, e, f, j, g, l, m) {
				j = this.v3pool;
				e.vsub(f, ma);
				d.getSideNormals(J, g);
				g = b.radius;
				for (var p = !1, r = null, n = 0, s = 0, q = 0, t = null, u = 0, x = J.length; u !== x && !1 === p; u++) {
					var v = ya;
					v.copy(J[u]);
					var z = v.norm();
					v.normalize();
					var y = ma.dot(v);
					if (y < z + g && 0 < y) {
						var E = ka,
							B = pa;
						E.copy(J[(u + 1) % 3]);
						B.copy(J[(u + 2) % 3]);
						var C = E.norm(),
							A = B.norm();
						E.normalize();
						B.normalize();
						var D = ma.dot(E),
							G = ma.dot(B);
						if (D < C && (D > -C && G < A && G > -A) && (y = Math.abs(y - z - g), null === t || y < t)) t = y, s = D, q = G, r = z, ja.copy(v), Ia.copy(E),
							Oa.copy(B), n++
					}
				}
				n && (p = !0, n = this.createContactEquation(l, m, b, d), ja.mult(-g, n.ri), n.ni.copy(ja), n.ni.negate(n.ni), ja.mult(r, ja), Ia.mult(s, Ia), ja.vadd(Ia, ja), Oa.mult(q, Oa), ja.vadd(Oa, n.rj), n.ri.vadd(e, n.ri), n.ri.vsub(l.position, n.ri), n.rj.vadd(f, n.rj), n.rj.vsub(m.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult));
				y = j.get();
				for (r = 0; 2 !== r && !p; r++)
					for (s = 0; 2 !== s && !p; s++)
						for (q = 0; 2 !== q && !p; q++) y.set(0, 0, 0), r ? y.vadd(J[0], y) : y.vsub(J[0], y), s ? y.vadd(J[1], y) : y.vsub(J[1],
							y), q ? y.vadd(J[2], y) : y.vsub(J[2], y), f.vadd(y, Va), Va.vsub(e, Va), Va.norm2() < g * g && (p = !0, n = this.createContactEquation(l, m, b, d), n.ri.copy(Va), n.ri.normalize(), n.ni.copy(n.ri), n.ri.mult(g, n.ri), n.rj.copy(y), n.ri.vadd(e, n.ri), n.ri.vsub(l.position, n.ri), n.rj.vadd(f, n.rj), n.rj.vsub(m.position, n.rj), this.result.push(n), this.createFrictionEquationsFromContact(n, this.frictionResult));
				j.release(y);
				t = j.get();
				u = j.get();
				n = j.get();
				x = j.get();
				y = j.get();
				v = J.length;
				for (r = 0; r !== v && !p; r++)
					for (s = 0; s !== v && !p; s++)
						if (r % 3 !==
							s % 3) {
							J[s].cross(J[r], t);
							t.normalize();
							J[r].vadd(J[s], u);
							n.copy(e);
							n.vsub(u, n);
							n.vsub(f, n);
							z = n.dot(t);
							t.mult(z, x);
							for (q = 0; q === r % 3 || q === s % 3;) q++;
							y.copy(e);
							y.vsub(x, y);
							y.vsub(u, y);
							y.vsub(f, y);
							z = Math.abs(z);
							E = y.norm();
							z < J[q].norm() && E < g && (p = !0, q = this.createContactEquation(l, m, b, d), u.vadd(x, q.rj), q.rj.copy(q.rj), y.negate(q.ni), q.ni.normalize(), q.ri.copy(q.rj), q.ri.vadd(f, q.ri), q.ri.vsub(e, q.ri), q.ri.normalize(), q.ri.mult(g, q.ri), q.ri.vadd(e, q.ri), q.ri.vsub(l.position, q.ri), q.rj.vadd(f, q.rj), q.rj.vsub(m.position,
								q.rj), this.result.push(q), this.createFrictionEquationsFromContact(q, this.frictionResult))
						}
				j.release(t, u, n, x, y)
			};
			var Wa = new m,
				cb = new m,
				sb = new m,
				db = new m,
				tb = new m,
				Kb = new m,
				V = new m,
				n = new m,
				Ob = new m,
				Pb = new m;
			d.prototype[g.types.SPHERE | g.types.CONVEXPOLYHEDRON] = d.prototype.sphereConvex = function(b, d, e, f, j, g, l, m) {
				j = this.v3pool;
				e.vsub(f, Wa);
				for (var p = d.faceNormals, r = d.faces, s = d.vertices, q = b.radius, t = 0; t !== s.length; t++) {
					var u = tb;
					g.vmult(s[t], u);
					f.vadd(u, u);
					var x = db;
					u.vsub(e, x);
					if (x.norm2() < q * q) {
						b = this.createContactEquation(l,
							m, b, d);
						b.ri.copy(x);
						b.ri.normalize();
						b.ni.copy(b.ri);
						b.ri.mult(q, b.ri);
						u.vsub(f, b.rj);
						b.ri.vadd(e, b.ri);
						b.ri.vsub(l.position, b.ri);
						b.rj.vadd(f, b.rj);
						b.rj.vsub(m.position, b.rj);
						this.result.push(b);
						this.createFrictionEquationsFromContact(b, this.frictionResult);
						return
					}
				}
				t = 0;
				for (u = r.length; t !== u; t++) {
					var x = r[t],
						v = Kb;
					g.vmult(p[t], v);
					var y = V;
					g.vmult(s[x[0]], y);
					y.vadd(f, y);
					var z = n;
					v.mult(-q, z);
					e.vadd(z, z);
					var E = Ob;
					z.vsub(y, E);
					z = E.dot(v);
					E = Pb;
					e.vsub(y, E);
					if (0 > z && 0 < E.dot(v)) {
						for (var y = [], E = 0, B = x.length; E !==
							B; E++) {
							var C = j.get();
							g.vmult(s[x[E]], C);
							f.vadd(C, C);
							y.push(C)
						}
						a: {
							for (var E = y, B = v, C = e, A = null, D = E.length, G = 0; G !== D; G++) {
								var ka = E[G],
									ba = la;
								E[(G + 1) % D].vsub(ka, ba);
								var oa = ra;
								ba.cross(B, oa);
								ba = da;
								C.vsub(ka, ba);
								ka = oa.dot(ba);
								if (null === A || 0 < ka && !0 === A || 0 >= ka && !1 === A) null === A && (A = 0 < ka);
								else {
									E = !1;
									break a
								}
							}
							E = !0
						}
						if (E) {
							b = this.createContactEquation(l, m, b, d);
							v.mult(-q, b.ri);
							v.negate(b.ni);
							d = j.get();
							v.mult(-z, d);
							g = j.get();
							v.mult(-q, g);
							e.vsub(f, b.rj);
							b.rj.vadd(g, b.rj);
							b.rj.vadd(d, b.rj);
							b.rj.vadd(f, b.rj);
							b.rj.vsub(m.position,
								b.rj);
							b.ri.vadd(e, b.ri);
							b.ri.vsub(l.position, b.ri);
							j.release(d);
							j.release(g);
							this.result.push(b);
							this.createFrictionEquationsFromContact(b, this.frictionResult);
							E = 0;
							for (x = y.length; E !== x; E++) j.release(y[E]);
							break
						} else
							for (E = 0; E !== x.length; E++) {
								v = j.get();
								z = j.get();
								g.vmult(s[x[(E + 1) % x.length]], v);
								g.vmult(s[x[(E + 2) % x.length]], z);
								f.vadd(v, v);
								f.vadd(z, z);
								D = cb;
								z.vsub(v, D);
								A = sb;
								D.unit(A);
								B = j.get();
								C = j.get();
								e.vsub(v, C);
								G = C.dot(A);
								A.mult(G, B);
								B.vadd(v, B);
								A = j.get();
								B.vsub(e, A);
								if (0 < G && G * G < D.norm2() && A.norm2() <
									q * q) {
									b = this.createContactEquation(l, m, b, d);
									B.vsub(f, b.rj);
									B.vsub(e, b.ni);
									b.ni.normalize();
									b.ni.mult(q, b.ri);
									b.rj.vadd(f, b.rj);
									b.rj.vsub(m.position, b.rj);
									b.ri.vadd(e, b.ri);
									b.ri.vsub(l.position, b.ri);
									this.result.push(b);
									this.createFrictionEquationsFromContact(b, this.frictionResult);
									E = 0;
									for (x = y.length; E !== x; E++) j.release(y[E]);
									j.release(v);
									j.release(z);
									j.release(B);
									j.release(A);
									j.release(C);
									return
								}
								j.release(v);
								j.release(z);
								j.release(B);
								j.release(A);
								j.release(C)
							}
						E = 0;
						for (x = y.length; E !== x; E++) j.release(y[E])
					}
				}
			};
			new m;
			new m;
			d.prototype[g.types.PLANE | g.types.BOX] = d.prototype.planeBox = function(b, d, e, f, j, g, l, m) {
				d.convexPolyhedronRepresentation.material = d.material;
				d.convexPolyhedronRepresentation.collisionResponse = d.collisionResponse;
				this.planeConvex(b, d.convexPolyhedronRepresentation, e, f, j, g, l, m)
			};
			var Ea = new m,
				Ja = new m,
				va = new m,
				mb = new m;
			d.prototype[g.types.PLANE | g.types.CONVEXPOLYHEDRON] = d.prototype.planeConvex = function(b, d, e, f, j, g, l, m) {
				Ja.set(0, 0, 1);
				j.vmult(Ja, Ja);
				for (var p = j = 0; p !== d.vertices.length; p++)
					if (Ea.copy(d.vertices[p]),
						g.vmult(Ea, Ea), f.vadd(Ea, Ea), Ea.vsub(e, va), 0 >= Ja.dot(va)) {
						var r = this.createContactEquation(l, m, b, d),
							n = mb;
						Ja.mult(Ja.dot(va), n);
						Ea.vsub(n, n);
						n.vsub(e, r.ri);
						r.ni.copy(Ja);
						Ea.vsub(f, r.rj);
						r.ri.vadd(e, r.ri);
						r.ri.vsub(l.position, r.ri);
						r.rj.vadd(f, r.rj);
						r.rj.vsub(m.position, r.rj);
						this.result.push(r);
						j++;
						this.enableFrictionReduction || this.createFrictionEquationsFromContact(r, this.frictionResult)
					}
				this.enableFrictionReduction && j && this.createFrictionFromAverage(j)
			};
			var U = new m,
				Ra = new m;
			d.prototype[g.types.CONVEXPOLYHEDRON] =
				d.prototype.convexConvex = function(b, d, e, f, j, g, l, m, r, p, n, s) {
					if (!(e.distanceTo(f) > b.boundingSphereRadius + d.boundingSphereRadius) && b.findSeparatingAxis(d, e, j, f, g, U, n, s)) {
						n = [];
						b.clipAgainstHull(e, j, d, f, g, U, -100, 100, n);
						for (g = j = 0; g !== n.length; g++) {
							s = this.createContactEquation(l, m, b, d, r, p);
							var q = s.ri,
								t = s.rj;
							U.negate(s.ni);
							n[g].normal.negate(Ra);
							Ra.mult(n[g].depth, Ra);
							n[g].point.vadd(Ra, q);
							t.copy(n[g].point);
							q.vsub(e, q);
							t.vsub(f, t);
							q.vadd(e, q);
							q.vsub(l.position, q);
							t.vadd(f, t);
							t.vsub(m.position, t);
							this.result.push(s);
							j++;
							this.enableFrictionReduction || this.createFrictionEquationsFromContact(s, this.frictionResult)
						}
						this.enableFrictionReduction && j && this.createFrictionFromAverage(j)
					}
				};
			var ea = new m,
				qa = new m,
				Sa = new m;
			d.prototype[g.types.PLANE | g.types.PARTICLE] = d.prototype.planeParticle = function(b, d, e, f, j, g, l, m) {
				ea.set(0, 0, 1);
				l.quaternion.vmult(ea, ea);
				f.vsub(l.position, qa);
				0 >= ea.dot(qa) && (b = this.createContactEquation(m, l, d, b), b.ni.copy(ea), b.ni.negate(b.ni), b.ri.set(0, 0, 0), ea.mult(ea.dot(f), Sa), f.vsub(Sa, Sa), b.rj.copy(Sa),
					this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult))
			};
			var Ka = new m;
			d.prototype[g.types.PARTICLE | g.types.SPHERE] = d.prototype.sphereParticle = function(b, d, e, f, j, g, l, m) {
				Ka.set(0, 0, 1);
				f.vsub(e, Ka);
				Ka.norm2() <= b.radius * b.radius && (d = this.createContactEquation(m, l, d, b), Ka.normalize(), d.rj.copy(Ka), d.rj.mult(b.radius, d.rj), d.ni.copy(Ka), d.ni.negate(d.ni), d.ri.set(0, 0, 0), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult))
			};
			var xb = new l,
				Ta = new m;
			new m;
			var gb = new m,
				Fa = new m,
				Ga = new m;
			d.prototype[g.types.PARTICLE | g.types.CONVEXPOLYHEDRON] = d.prototype.convexParticle = function(b, d, e, f, j, g, l, m) {
				var r = -1;
				g = null;
				var p = 0;
				Ta.copy(f);
				Ta.vsub(e, Ta);
				j.conjugate(xb);
				xb.vmult(Ta, Ta);
				if (b.pointIsInside(Ta)) {
					b.worldVerticesNeedsUpdate && b.computeWorldVertices(e, j);
					b.worldFaceNormalsNeedsUpdate && b.computeWorldFaceNormals(j);
					j = 0;
					for (var n = b.faces.length; j !== n; j++) {
						var s = b.worldFaceNormals[j];
						f.vsub(b.worldVertices[b.faces[j][0]], Fa);
						var q = -s.dot(Fa);
						if (null ===
							g || Math.abs(q) < Math.abs(g)) g = q, r = j, gb.copy(s), p++
					} - 1 !== r ? (b = this.createContactEquation(m, l, d, b), gb.mult(g, Ga), Ga.vadd(f, Ga), Ga.vsub(e, Ga), b.rj.copy(Ga), gb.negate(b.ni), b.ri.set(0, 0, 0), d = b.ri, g = b.rj, d.vadd(f, d), d.vsub(m.position, d), g.vadd(e, g), g.vsub(l.position, g), this.result.push(b), this.createFrictionEquationsFromContact(b, this.frictionResult)) : console.warn("Point found inside convex, but did not find penetrating face!")
				}
			};
			d.prototype[g.types.BOX | g.types.HEIGHTFIELD] = d.prototype.boxHeightfield = function(b,
				d, e, f, j, g, l, m) {
				b.convexPolyhedronRepresentation.material = b.material;
				b.convexPolyhedronRepresentation.collisionResponse = b.collisionResponse;
				this.convexHeightfield(b.convexPolyhedronRepresentation, d, e, f, j, g, l, m)
			};
			var Ha = new m,
				za = new m,
				Ya = [0];
			d.prototype[g.types.CONVEXPOLYHEDRON | g.types.HEIGHTFIELD] = d.prototype.convexHeightfield = function(b, d, e, f, g, l, m, r) {
				var p = d.data,
					n = d.elementSize,
					s = b.boundingSphereRadius;
				j.pointToLocalFrame(f, l, e, Ha);
				var q = Math.floor((Ha.x - s) / n) - 1,
					t = Math.ceil((Ha.x + s) / n) + 1,
					u = Math.floor((Ha.y -
						s) / n) - 1,
					n = Math.ceil((Ha.y + s) / n) + 1;
				if (!(0 > t || 0 > n || q > p.length || u > p[0].length)) {
					0 > q && (q = 0);
					0 > t && (t = 0);
					0 > u && (u = 0);
					0 > n && (n = 0);
					q >= p.length && (q = p.length - 1);
					t >= p.length && (t = p.length - 1);
					n >= p[0].length && (n = p[0].length - 1);
					u >= p[0].length && (u = p[0].length - 1);
					p = [];
					d.getRectMinMax(q, u, t, n, p);
					var x = p[0];
					if (!(Ha.z - s > p[1] || Ha.z + s < x))
						for (s = q; s < t; s++)
							for (q = u; q < n; q++) d.getConvexTrianglePillar(s, q, !1), j.pointToWorldFrame(f, l, d.pillarOffset, za), e.distanceTo(za) < d.pillarConvex.boundingSphereRadius + b.boundingSphereRadius &&
								this.convexConvex(b, d.pillarConvex, e, za, g, l, m, r, null, null, Ya, null), d.getConvexTrianglePillar(s, q, !0), j.pointToWorldFrame(f, l, d.pillarOffset, za), e.distanceTo(za) < d.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.convexConvex(b, d.pillarConvex, e, za, g, l, m, r, null, null, Ya, null)
				}
			};
			var Aa = new m,
				Ba = new m;
			d.prototype[g.types.SPHERE | g.types.HEIGHTFIELD] = d.prototype.sphereHeightfield = function(b, d, e, f, g, l, m, p) {
				var r = d.data,
					n = b.radius,
					s = d.elementSize;
				j.pointToLocalFrame(f, l, e, Aa);
				var q = Math.floor((Aa.x -
						n) / s) - 1,
					t = Math.ceil((Aa.x + n) / s) + 1,
					u = Math.floor((Aa.y - n) / s) - 1,
					s = Math.ceil((Aa.y + n) / s) + 1;
				if (!(0 > t || 0 > s || q > r.length || s > r[0].length)) {
					0 > q && (q = 0);
					0 > t && (t = 0);
					0 > u && (u = 0);
					0 > s && (s = 0);
					q >= r.length && (q = r.length - 1);
					t >= r.length && (t = r.length - 1);
					s >= r[0].length && (s = r[0].length - 1);
					u >= r[0].length && (u = r[0].length - 1);
					r = [];
					d.getRectMinMax(q, u, t, s, r);
					var x = r[0];
					if (!(Aa.z - n > r[1] || Aa.z + n < x))
						for (n = this.result; q < t; q++)
							for (r = u; r < s; r++)
								if (x = n.length, d.getConvexTrianglePillar(q, r, !1), j.pointToWorldFrame(f, l, d.pillarOffset, Ba),
									e.distanceTo(Ba) < d.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, d.pillarConvex, e, Ba, g, l, m, p), d.getConvexTrianglePillar(q, r, !0), j.pointToWorldFrame(f, l, d.pillarOffset, Ba), e.distanceTo(Ba) < d.pillarConvex.boundingSphereRadius + b.boundingSphereRadius && this.sphereConvex(b, d.pillarConvex, e, Ba, g, l, m, p), 2 < n.length - x) return
				}
			}
		}, {
			"../collision/AABB": 3,
			"../collision/Ray": 9,
			"../equations/ContactEquation": 19,
			"../equations/FrictionEquation": 21,
			"../math/Quaternion": 28,
			"../math/Transform": 29,
			"../math/Vec3": 30,
			"../shapes/ConvexPolyhedron": 38,
			"../shapes/Shape": 43,
			"../solver/Solver": 47,
			"../utils/Vec3Pool": 54
		}],
		56: [function(b, e) {
			function d() {
				j.apply(this);
				this.dt = -1;
				this.allowSleep = !1;
				this.contacts = [];
				this.frictionEquations = [];
				this.quatNormalizeSkip = 0;
				this.quatNormalizeFast = !1;
				this.stepnumber = this.time = 0;
				this.default_dt = 1 / 60;
				this.nextId = 0;
				this.gravity = new f;
				this.broadphase = new v;
				this.bodies = [];
				this.solver = new q;
				this.constraints = [];
				this.narrowphase = new m(this);
				this.collisionMatrix = new l;
				this.collisionMatrixPrevious =
					new l;
				this.materials = [];
				this.contactmaterials = [];
				this.contactMaterialTable = new t;
				this.defaultMaterial = new p("default");
				this.defaultContactMaterial = new r(this.defaultMaterial, this.defaultMaterial, {
					friction: 0.3,
					restitution: 0
				});
				this.doProfiling = !1;
				this.profile = {
					solve: 0,
					makeContactConstraints: 0,
					broadphase: 0,
					integrate: 0,
					narrowphase: 0
				};
				this.subsystems = [];
				this.addBodyEvent = {
					type: "addBody",
					body: null
				};
				this.removeBodyEvent = {
					type: "removeBody",
					body: null
				}
			}
			e.exports = d;
			b("../shapes/Shape");
			var f = b("../math/Vec3"),
				g = b("../math/Quaternion"),
				q = b("../solver/GSSolver");
			b("../utils/Vec3Pool");
			b("../equations/ContactEquation");
			b("../equations/FrictionEquation");
			var m = b("./Narrowphase"),
				j = b("../utils/EventTarget"),
				l = b("../collision/ArrayCollisionMatrix"),
				p = b("../material/Material"),
				r = b("../material/ContactMaterial"),
				s = b("../objects/Body"),
				t = b("../utils/TupleDictionary"),
				u = b("../collision/RaycastResult"),
				x = b("../collision/AABB"),
				z = b("../collision/Ray"),
				v = b("../collision/NaiveBroadphase");
			d.prototype = new j;
			new x;
			var B =
				new z;
			d.prototype.getContactMaterial = function(b, d) {
				return this.contactMaterialTable.get(b.id, d.id)
			};
			d.prototype.numObjects = function() {
				return this.bodies.length
			};
			d.prototype.collisionMatrixTick = function() {
				var b = this.collisionMatrixPrevious;
				this.collisionMatrixPrevious = this.collisionMatrix;
				this.collisionMatrix = b;
				this.collisionMatrix.reset()
			};
			d.prototype.add = d.prototype.addBody = function(b) {
				-1 === this.bodies.indexOf(b) && (b.index = this.bodies.length, this.bodies.push(b), b.world = this, b.initPosition.copy(b.position),
					b.initVelocity.copy(b.velocity), b.timeLastSleepy = this.time, b instanceof s && (b.initAngularVelocity.copy(b.angularVelocity), b.initQuaternion.copy(b.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = b, this.dispatchEvent(this.addBodyEvent))
			};
			d.prototype.addConstraint = function(b) {
				this.constraints.push(b)
			};
			d.prototype.removeConstraint = function(b) {
				b = this.constraints.indexOf(b); - 1 !== b && this.constraints.splice(b, 1)
			};
			d.prototype.rayTest = function(b, d, e) {
				e instanceof u ?
					this.raycastClosest(b, d, {
						skipBackfaces: !0
					}, e) : this.raycastAll(b, d, {
						skipBackfaces: !0
					}, e)
			};
			d.prototype.raycastAll = function(b, d, e, f) {
				e.mode = z.ALL;
				e.from = b;
				e.to = d;
				e.callback = f;
				return B.intersectWorld(this, e)
			};
			d.prototype.raycastAny = function(b, d, e, f) {
				e.mode = z.ANY;
				e.from = b;
				e.to = d;
				e.result = f;
				return B.intersectWorld(this, e)
			};
			d.prototype.raycastClosest = function(b, d, e, f) {
				e.mode = z.CLOSEST;
				e.from = b;
				e.to = d;
				e.result = f;
				return B.intersectWorld(this, e)
			};
			d.prototype.remove = function(b) {
				b.world = null;
				var d = this.bodies.length -
					1,
					e = this.bodies,
					f = e.indexOf(b);
				if (-1 !== f) {
					e.splice(f, 1);
					for (f = 0; f !== e.length; f++) e[f].index = f;
					this.collisionMatrix.setNumObjects(d);
					this.removeBodyEvent.body = b;
					this.dispatchEvent(this.removeBodyEvent)
				}
			};
			d.prototype.removeBody = d.prototype.remove;
			d.prototype.addMaterial = function(b) {
				this.materials.push(b)
			};
			d.prototype.addContactMaterial = function(b) {
				this.contactmaterials.push(b);
				this.contactMaterialTable.set(b.materials[0].id, b.materials[1].id, b)
			};
			"undefined" === typeof performance && (performance = {});
			if (!performance.now) {
				var y =
					Date.now();
				performance.timing && performance.timing.navigationStart && (y = performance.timing.navigationStart);
				performance.now = function() {
					return Date.now() - y
				}
			}
			var A = new f;
			d.prototype.step = function(b, d, e) {
				e = e || 10;
				d = d || 0;
				if (0 === d) this.internalStep(b), this.time += b;
				else {
					var f = Math.floor((this.time + d) / b) - Math.floor(this.time / b),
						f = Math.min(f, e);
					e = performance.now();
					for (var j = 0; j !== f && !(this.internalStep(b), performance.now() - e > 1E3 * b); j++);
					this.time += d;
					b = this.time % b / b;
					d = this.bodies;
					for (f = 0; f !== d.length; f++) e = d[f],
						e.type !== s.STATIC && e.sleepState !== s.SLEEPING ? (e.position.vsub(e.previousPosition, A), A.scale(b, A), e.position.vadd(A, e.interpolatedPosition)) : (e.interpolatedPosition.copy(e.position), e.interpolatedQuaternion.copy(e.quaternion))
				}
			};
			var F = {
					type: "postStep"
				},
				C = {
					type: "preStep"
				},
				D = {
					type: "collide",
					body: null,
					contact: null
				},
				I = [],
				N = [],
				K = [],
				O = [];
			new f;
			new f;
			new f;
			new f;
			new f;
			new f;
			new f;
			new f;
			new f;
			new g;
			var H = new g,
				W = new g,
				aa = new f;
			d.prototype.internalStep = function(b) {
				this.dt = b;
				var d = this.contacts,
					e = this.numObjects(),
					f = this.bodies,
					j = this.solver,
					g = this.gravity,
					l = this.doProfiling,
					m = this.profile,
					r = s.DYNAMIC,
					p, q = this.constraints;
				g.norm();
				var t = g.x,
					u = g.y,
					x = g.z,
					g = 0;
				l && (p = performance.now());
				for (g = 0; g !== e; g++) {
					var v = f[g];
					if (v.type & r) {
						var y = v.force,
							v = v.mass;
						y.x += v * t;
						y.y += v * u;
						y.z += v * x
					}
				}
				g = 0;
				for (v = this.subsystems.length; g !== v; g++) this.subsystems[g].update();
				l && (p = performance.now());
				K.length = 0;
				O.length = 0;
				this.broadphase.collisionPairs(this, K, O);
				l && (m.broadphase = performance.now() - p);
				v = q.length;
				for (g = 0; g !== v; g++)
					if (t = q[g], !t.collideConnected)
						for (u =
							K.length - 1; 0 <= u; u -= 1)
							if (t.bodyA === K[u] && t.bodyB === O[u] || t.bodyB === K[u] && t.bodyA === O[u]) K.splice(u, 1), O.splice(u, 1);
				this.collisionMatrixTick();
				l && (p = performance.now());
				v = d.length;
				for (g = 0; g !== v; g++) I.push(d[g]);
				d.length = 0;
				v = this.frictionEquations.length;
				for (g = 0; g !== v; g++) N.push(this.frictionEquations[g]);
				this.frictionEquations.length = 0;
				this.narrowphase.getContacts(K, O, this, d, I, this.frictionEquations, N);
				l && (m.narrowphase = performance.now() - p);
				l && (p = performance.now());
				for (g = 0; g < this.frictionEquations.length; g++) j.addEquation(this.frictionEquations[g]);
				g = d.length;
				for (u = 0; u !== g; u++) {
					t = d[u];
					v = t.bi;
					x = t.bj;
					v.material && x.material && this.getContactMaterial(v.material, x.material);
					v.material && x.material && (0 <= v.material.restitution && 0 <= x.material.restitution) && (t.restitution = v.material.restitution * x.material.restitution);
					j.addEquation(t);
					if (v.allowSleep && v.type === s.DYNAMIC && v.sleepState === s.SLEEPING && x.sleepState === s.AWAKE && x.type !== s.STATIC) {
						var y = x.velocity.norm2() + x.angularVelocity.norm2(),
							z = Math.pow(x.sleepSpeedLimit, 2);
						y >= 2 * z && (v._wakeUpAfterNarrowphase = !0)
					}
					x.allowSleep && (x.type === s.DYNAMIC && x.sleepState === s.SLEEPING && v.sleepState === s.AWAKE && v.type !== s.STATIC) && (y = v.velocity.norm2() + v.angularVelocity.norm2(), z = Math.pow(v.sleepSpeedLimit, 2), y >= 2 * z && (x._wakeUpAfterNarrowphase = !0));
					this.collisionMatrix.set(v, x, !0);
					this.collisionMatrixPrevious.get(v, x) || (D.body = x, D.contact = t, v.dispatchEvent(D), D.body = v, x.dispatchEvent(D))
				}
				l && (m.makeContactConstraints = performance.now() - p, p = performance.now());
				for (g = 0; g !== e; g++) v = f[g], v._wakeUpAfterNarrowphase && (v.wakeUp(),
					v._wakeUpAfterNarrowphase = !1);
				v = q.length;
				for (g = 0; g !== v; g++) {
					t = q[g];
					t.update();
					u = 0;
					for (d = t.equations.length; u !== d; u++) j.addEquation(t.equations[u])
				}
				j.solve(b, this);
				l && (m.solve = performance.now() - p);
				j.removeAllEquations();
				j = Math.pow;
				for (g = 0; g !== e; g++)
					if (v = f[g], v.type & r && (q = j(1 - v.linearDamping, b), d = v.velocity, d.mult(q, d), q = v.angularVelocity)) d = j(1 - v.angularDamping, b), q.mult(d, q);
				this.dispatchEvent(C);
				for (g = 0; g !== e; g++) v = f[g], v.preStep && v.preStep.call(v);
				l && (p = performance.now());
				r = s.DYNAMIC | s.KINEMATIC;
				j = 0 === this.stepnumber % (this.quatNormalizeSkip + 1);
				q = this.quatNormalizeFast;
				d = 0.5 * b;
				for (g = 0; g !== e; g++)
					if (v = f[g], t = v.force, u = v.torque, v.type & r && v.sleepState !== s.SLEEPING) {
						var x = v.velocity,
							y = v.angularVelocity,
							z = v.position,
							B = v.quaternion,
							A = v.invMass,
							Ia = v.invInertiaWorld;
						x.x += t.x * A * b;
						x.y += t.y * A * b;
						x.z += t.z * A * b;
						v.angularVelocity && (Ia.vmult(u, aa), aa.mult(b, aa), aa.vadd(y, y));
						z.x += x.x * b;
						z.y += x.y * b;
						z.z += x.z * b;
						v.angularVelocity && (H.set(y.x, y.y, y.z, 0), H.mult(B, W), B.x += d * W.x, B.y += d * W.y, B.z += d * W.z, B.w += d * W.w, j &&
							(q ? B.normalizeFast() : B.normalize()));
						v.aabb && (v.aabbNeedsUpdate = !0);
						v.updateInertiaWorld && v.updateInertiaWorld()
					}
				this.clearForces();
				this.broadphase.dirty = !0;
				l && (m.integrate = performance.now() - p);
				this.time += b;
				this.stepnumber += 1;
				this.dispatchEvent(F);
				for (g = 0; g !== e; g++) v = f[g], (b = v.postStep) && b.call(v);
				if (this.allowSleep)
					for (g = 0; g !== e; g++) f[g].sleepTick(this.time)
			};
			d.prototype.clearForces = function() {
				for (var b = this.bodies, d = b.length, e = 0; e !== d; e++) {
					var f = b[e];
					f.force.set(0, 0, 0);
					f.torque.set(0, 0, 0)
				}
			}
		}, {
			"../collision/AABB": 3,
			"../collision/ArrayCollisionMatrix": 4,
			"../collision/NaiveBroadphase": 7,
			"../collision/Ray": 9,
			"../collision/RaycastResult": 10,
			"../equations/ContactEquation": 19,
			"../equations/FrictionEquation": 21,
			"../material/ContactMaterial": 24,
			"../material/Material": 25,
			"../math/Quaternion": 28,
			"../math/Vec3": 30,
			"../objects/Body": 31,
			"../shapes/Shape": 43,
			"../solver/GSSolver": 46,
			"../utils/EventTarget": 49,
			"../utils/TupleDictionary": 52,
			"../utils/Vec3Pool": 54,
			"./Narrowphase": 55
		}]
	}, {}, [2])(2)
});
! function(c, b) {
	"object" == typeof module && "object" == typeof module.exports ? module.exports = c.document ? b(c, !0) : function(c) {
		if (!c.document) throw Error("jQuery requires a window with a document");
		return b(c)
	} : b(c)
}("undefined" != typeof window ? window : this, function(c, b) {
	function e(b, c) {
		c = c || J;
		var d = c.createElement("script");
		d.text = b;
		c.head.appendChild(d).parentNode.removeChild(d)
	}

	function d(b) {
		var c = !!b && "length" in b && b.length,
			d = n.type(b);
		return "function" !== d && !n.isWindow(b) && ("array" === d || 0 === c || "number" ==
			typeof c && 0 < c && c - 1 in b)
	}

	function f(b, c) {
		return b.nodeName && b.nodeName.toLowerCase() === c.toLowerCase()
	}

	function g(b, c, d) {
		return n.isFunction(c) ? n.grep(b, function(b, e) {
			return !!c.call(b, e, b) !== d
		}) : c.nodeType ? n.grep(b, function(b) {
			return b === c !== d
		}) : "string" != typeof c ? n.grep(b, function(b) {
			return -1 < Wa.call(c, b) !== d
		}) : Kc.test(c) ? n.filter(c, b, d) : (c = n.filter(c, b), n.grep(b, function(b) {
			return -1 < Wa.call(c, b) !== d && 1 === b.nodeType
		}))
	}

	function q(b, c) {
		for (;
			(b = b[c]) && 1 !== b.nodeType;);
		return b
	}

	function m(b) {
		return b
	}

	function j(b) {
		throw b;
	}

	function l(b, c, d, e) {
		var f;
		try {
			b && n.isFunction(f = b.promise) ? f.call(b).done(c).fail(d) : b && n.isFunction(f = b.then) ? f.call(b, c, d) : c.apply(void 0, [b].slice(e))
		} catch (j) {
			d.apply(void 0, [j])
		}
	}

	function p() {
		J.removeEventListener("DOMContentLoaded", p);
		c.removeEventListener("load", p);
		n.ready()
	}

	function r() {
		this.expando = n.expando + r.uid++
	}

	function s(b, c, d) {
		var e;
		if (void 0 === d && 1 === b.nodeType)
			if (e = "data-" + c.replace(Lc, "-$&").toLowerCase(), d = b.getAttribute(e), "string" == typeof d) {
				try {
					d = "true" ===
						d || "false" !== d && ("null" === d ? null : d === +d + "" ? +d : Mc.test(d) ? JSON.parse(d) : d)
				} catch (f) {}
				na.set(b, c, d)
			} else d = void 0;
		return d
	}

	function t(b, c, d, e) {
		var f, j = 1,
			g = 20,
			l = e ? function() {
				return e.cur()
			} : function() {
				return n.css(b, c, "")
			},
			m = l(),
			r = d && d[3] || (n.cssNumber[c] ? "" : "px"),
			p = (n.cssNumber[c] || "px" !== r && +m) && nb.exec(n.css(b, c));
		if (p && p[3] !== r) {
			r = r || p[3];
			d = d || [];
			p = +m || 1;
			do j = j || ".5", p /= j, n.style(b, c, p + r); while (j !== (j = l() / m) && 1 !== j && --g)
		}
		return d && (p = +p || +m || 0, f = d[1] ? p + (d[1] + 1) * d[2] : +d[2], e && (e.unit = r, e.start = p,
			e.end = f)), f
	}

	function u(b, c) {
		for (var d, e, f = [], j = 0, g = b.length; j < g; j++)
			if (e = b[j], e.style)
				if (d = e.style.display, c) {
					if ("none" === d && (f[j] = L.get(e, "display") || null, f[j] || (e.style.display = "")), "" === e.style.display && yb(e)) {
						d = f;
						var l = j,
							m, p = void 0;
						m = e.ownerDocument;
						var r = e.nodeName;
						m = (e = cc[r]) ? e : (p = m.body.appendChild(m.createElement(r)), e = n.css(p, "display"), p.parentNode.removeChild(p), "none" === e && (e = "block"), cc[r] = e, e);
						d[l] = m
					}
				} else "none" !== d && (f[j] = "none", L.set(e, "display", d));
		for (j = 0; j < g; j++) null != f[j] && (b[j].style.display =
			f[j]);
		return b
	}

	function x(b, c) {
		var d;
		return d = "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(c || "*") : "undefined" != typeof b.querySelectorAll ? b.querySelectorAll(c || "*") : [], void 0 === c || c && f(b, c) ? n.merge([b], d) : d
	}

	function z(b, c) {
		for (var d = 0, e = b.length; d < e; d++) L.set(b[d], "globalEval", !c || L.get(c[d], "globalEval"))
	}

	function v(b, c, d, e, f) {
		for (var j, g, l, m, p = c.createDocumentFragment(), r = [], s = 0, q = b.length; s < q; s++)
			if (j = b[s], j || 0 === j)
				if ("object" === n.type(j)) n.merge(r, j.nodeType ? [j] : j);
				else if (Nc.test(j)) {
			g =
				g || p.appendChild(c.createElement("div"));
			l = (dc.exec(j) || ["", ""])[1].toLowerCase();
			l = wa[l] || wa._default;
			g.innerHTML = l[1] + n.htmlPrefilter(j) + l[2];
			for (l = l[0]; l--;) g = g.lastChild;
			n.merge(r, g.childNodes);
			g = p.firstChild;
			g.textContent = ""
		} else r.push(c.createTextNode(j));
		p.textContent = "";
		for (s = 0; j = r[s++];)
			if (e && -1 < n.inArray(j, e)) f && f.push(j);
			else if (m = n.contains(j.ownerDocument, j), g = x(p.appendChild(j), "script"), m && z(g), d)
			for (l = 0; j = g[l++];) ec.test(j.type || "") && d.push(j);
		return p
	}

	function B() {
		return !0
	}

	function y() {
		return !1
	}

	function A() {
		try {
			return J.activeElement
		} catch (b) {}
	}

	function F(b, c, d, e, f, j) {
		var g, l;
		if ("object" == typeof c) {
			"string" != typeof d && (e = e || d, d = void 0);
			for (l in c) F(b, l, d, e, c[l], j);
			return b
		}
		if (null == e && null == f ? (f = d, e = d = void 0) : null == f && ("string" == typeof d ? (f = e, e = void 0) : (f = e, e = d, d = void 0)), !1 === f) f = y;
		else if (!f) return b;
		return 1 === j && (g = f, f = function(b) {
			return n().off(b), g.apply(this, arguments)
		}, f.guid = g.guid || (g.guid = n.guid++)), b.each(function() {
			n.event.add(this, c, f, e, d)
		})
	}

	function C(b, c) {
		return f(b, "table") &&
			f(11 !== c.nodeType ? c : c.firstChild, "tr") ? n(">tbody", b)[0] || b : b
	}

	function D(b) {
		return b.type = (null !== b.getAttribute("type")) + "/" + b.type, b
	}

	function I(b) {
		var c = Oc.exec(b.type);
		return c ? b.type = c[1] : b.removeAttribute("type"), b
	}

	function N(b, c) {
		var d, e, f, j, g, l;
		if (1 === c.nodeType) {
			if (L.hasData(b) && (d = L.access(b), e = L.set(c, d), l = d.events))
				for (f in delete e.handle, e.events = {}, l) {
					d = 0;
					for (e = l[f].length; d < e; d++) n.event.add(c, f, l[f][d])
				}
			na.hasData(b) && (j = na.access(b), g = n.extend({}, j), na.set(c, g))
		}
	}

	function K(b, c, d,
		f) {
		c = Ia.apply([], c);
		var j, g, l, m, p = 0,
			r = b.length,
			s = r - 1,
			q = c[0],
			t = n.isFunction(q);
		if (t || 1 < r && "string" == typeof q && !V.checkClone && Pc.test(q)) return b.each(function(e) {
			var j = b.eq(e);
			t && (c[0] = q.call(this, e, j.html()));
			K(j, c, d, f)
		});
		if (r && (j = v(c, b[0].ownerDocument, !1, b, f), g = j.firstChild, 1 === j.childNodes.length && (j = g), g || f)) {
			g = n.map(x(j, "script"), D);
			for (l = g.length; p < r; p++) m = j, p !== s && (m = n.clone(m, !0, !0), l && n.merge(g, x(m, "script"))), d.call(b[p], m, p);
			if (l) {
				j = g[g.length - 1].ownerDocument;
				n.map(g, I);
				for (p = 0; p < l; p++) m =
					g[p], ec.test(m.type || "") && !L.access(m, "globalEval") && n.contains(j, m) && (m.src ? n._evalUrl && n._evalUrl(m.src) : e(m.textContent.replace(Rc, ""), j))
			}
		}
		return b
	}

	function O(b, c, d) {
		for (var e = c ? n.filter(c, b) : b, f = 0; null != (c = e[f]); f++) d || 1 !== c.nodeType || n.cleanData(x(c)), c.parentNode && (d && n.contains(c.ownerDocument, c) && z(x(c, "script")), c.parentNode.removeChild(c));
		return b
	}

	function H(b, c, d) {
		var e, f, j, g, l = b.style;
		return d = d || zb(b), d && (g = d.getPropertyValue(c) || d[c], "" !== g || n.contains(b.ownerDocument, b) || (g = n.style(b,
			c)), !V.pixelMarginRight() && Qb.test(g) && fc.test(c) && (e = l.width, f = l.minWidth, j = l.maxWidth, l.minWidth = l.maxWidth = l.width = g, g = d.width, l.width = e, l.minWidth = f, l.maxWidth = j)), void 0 !== g ? g + "" : g
	}

	function W(b, c) {
		return {
			get: function() {
				return b() ? void delete this.get : (this.get = c).apply(this, arguments)
			}
		}
	}

	function aa(b) {
		var c = n.cssProps[b];
		if (!c) {
			var c = n.cssProps,
				d;
			a: if (d = b, !(d in gc)) {
				for (var e = d[0].toUpperCase() + d.slice(1), f = hc.length; f--;)
					if (d = hc[f] + e, d in gc) break a;
				d = void 0
			}
			c = c[b] = d || b
		}
		return c
	}

	function E(b,
		c, d) {
		return (b = nb.exec(c)) ? Math.max(0, b[2] - (d || 0)) + (b[3] || "px") : c
	}

	function G(b, c, d, e, f) {
		var j = 0;
		for (c = d === (e ? "border" : "content") ? 4 : "width" === c ? 1 : 0; 4 > c; c += 2) "margin" === d && (j += n.css(b, d + $a[c], !0, f)), e ? ("content" === d && (j -= n.css(b, "padding" + $a[c], !0, f)), "margin" !== d && (j -= n.css(b, "border" + $a[c] + "Width", !0, f))) : (j += n.css(b, "padding" + $a[c], !0, f), "padding" !== d && (j += n.css(b, "border" + $a[c] + "Width", !0, f)));
		return j
	}

	function ba(b, c, d) {
		var e, f = zb(b),
			j = H(b, c, f),
			g = "border-box" === n.css(b, "boxSizing", !1, f);
		return Qb.test(j) ?
			j : (e = g && (V.boxSizingReliable() || j === b.style[c]), "auto" === j && (j = b["offset" + c[0].toUpperCase() + c.slice(1)]), j = parseFloat(j) || 0, j + G(b, c, d || (g ? "border" : "content"), e, f) + "px")
	}

	function Q(b, c, d, e, f) {
		return new Q.prototype.init(b, c, d, e, f)
	}

	function ca() {
		Ab && (!1 === J.hidden && c.requestAnimationFrame ? c.requestAnimationFrame(ca) : c.setTimeout(ca, n.fx.interval), n.fx.tick())
	}

	function oa() {
		return c.setTimeout(function() {
			hb = void 0
		}), hb = n.now()
	}

	function T(b, c) {
		var d, e = 0,
			f = {
				height: b
			};
		for (c = c ? 1 : 0; 4 > e; e += 2 - c) d = $a[e], f["margin" +
			d] = f["padding" + d] = b;
		return c && (f.opacity = f.width = b), f
	}

	function ha(b, c, d) {
		for (var e, f = (Y.tweeners[c] || []).concat(Y.tweeners["*"]), j = 0, g = f.length; j < g; j++)
			if (e = f[j].call(d, c, b)) return e
	}

	function Y(b, c, d) {
		var e, f, j = 0,
			g = Y.prefilters.length,
			l = n.Deferred().always(function() {
				delete m.elem
			}),
			m = function() {
				if (f) return !1;
				for (var c = hb || oa(), c = Math.max(0, p.startTime + p.duration - c), d = 1 - (c / p.duration || 0), e = 0, j = p.tweens.length; e < j; e++) p.tweens[e].run(d);
				return l.notifyWith(b, [p, d, c]), 1 > d && j ? c : (j || l.notifyWith(b, [p,
					1, 0
				]), l.resolveWith(b, [p]), !1)
			},
			p = l.promise({
				elem: b,
				props: n.extend({}, c),
				opts: n.extend(!0, {
					specialEasing: {},
					easing: n.easing._default
				}, d),
				originalProperties: c,
				originalOptions: d,
				startTime: hb || oa(),
				duration: d.duration,
				tweens: [],
				createTween: function(c, d) {
					var e = n.Tween(b, p.opts, c, d, p.opts.specialEasing[c] || p.opts.easing);
					return p.tweens.push(e), e
				},
				stop: function(c) {
					var d = 0,
						e = c ? p.tweens.length : 0;
					if (f) return this;
					for (f = !0; d < e; d++) p.tweens[d].run(1);
					return c ? (l.notifyWith(b, [p, 1, 0]), l.resolveWith(b, [p, c])) :
						l.rejectWith(b, [p, c]), this
				}
			});
		c = p.props;
		d = p.opts.specialEasing;
		var r, s, q, t;
		for (e in c)
			if (r = n.camelCase(e), s = d[r], q = c[e], Array.isArray(q) && (s = q[1], q = c[e] = q[0]), e !== r && (c[r] = q, delete c[e]), t = n.cssHooks[r], t && "expand" in t)
				for (e in q = t.expand(q), delete c[r], q) e in c || (c[e] = q[e], d[e] = s);
			else d[r] = s;
		for (; j < g; j++)
			if (e = Y.prefilters[j].call(p, b, c, p.opts)) return n.isFunction(e.stop) && (n._queueHooks(p.elem, p.opts.queue).stop = n.proxy(e.stop, e)), e;
		return n.map(c, ha, p), n.isFunction(p.opts.start) && p.opts.start.call(b,
			p), p.progress(p.opts.progress).done(p.opts.done, p.opts.complete).fail(p.opts.fail).always(p.opts.always), n.fx.timer(n.extend(m, {
			elem: b,
			anim: p,
			queue: p.opts.queue
		})), p
	}

	function la(b) {
		return (b.match(xa) || []).join(" ")
	}

	function ra(b) {
		return b.getAttribute && b.getAttribute("class") || ""
	}

	function da(b, c, d, e) {
		var f;
		if (Array.isArray(c)) n.each(c, function(c, f) {
			d || Sc.test(b) ? e(b, f) : da(b + "[" + ("object" == typeof f && null != f ? c : "") + "]", f, d, e)
		});
		else if (d || "object" !== n.type(c)) e(b, c);
		else
			for (f in c) da(b + "[" + f + "]", c[f],
				d, e)
	}

	function ma(b) {
		return function(c, d) {
			"string" != typeof c && (d = c, c = "*");
			var e, f = 0,
				j = c.toLowerCase().match(xa) || [];
			if (n.isFunction(d))
				for (; e = j[f++];) "+" === e[0] ? (e = e.slice(1) || "*", (b[e] = b[e] || []).unshift(d)) : (b[e] = b[e] || []).push(d)
		}
	}

	function ya(b, c, d, e) {
		function f(l) {
			var m;
			return j[l] = !0, n.each(b[l] || [], function(b, P) {
				var l = P(c, d, e);
				return "string" != typeof l || g || j[l] ? g ? !(m = l) : void 0 : (c.dataTypes.unshift(l), f(l), !1)
			}), m
		}
		var j = {},
			g = b === Rb;
		return f(c.dataTypes[0]) || !j["*"] && f("*")
	}

	function ka(b, c) {
		var d,
			e, f = n.ajaxSettings.flatOptions || {};
		for (d in c) void 0 !== c[d] && ((f[d] ? b : e || (e = {}))[d] = c[d]);
		return e && n.extend(!0, b, e), b
	}
	var pa = [],
		J = c.document,
		Va = Object.getPrototypeOf,
		ja = pa.slice,
		Ia = pa.concat,
		Oa = pa.push,
		Wa = pa.indexOf,
		cb = {},
		sb = cb.toString,
		db = cb.hasOwnProperty,
		tb = db.toString,
		Kb = tb.call(Object),
		V = {},
		n = function(b, c) {
			return new n.fn.init(b, c)
		},
		Ob = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
		Pb = /^-ms-/,
		Ea = /-([a-z])/g,
		Ja = function(b, c) {
			return c.toUpperCase()
		};
	n.fn = n.prototype = {
		jquery: "3.2.1",
		constructor: n,
		length: 0,
		toArray: function() {
			return ja.call(this)
		},
		get: function(b) {
			return null == b ? ja.call(this) : 0 > b ? this[b + this.length] : this[b]
		},
		pushStack: function(b) {
			b = n.merge(this.constructor(), b);
			return b.prevObject = this, b
		},
		each: function(b) {
			return n.each(this, b)
		},
		map: function(b) {
			return this.pushStack(n.map(this, function(c, d) {
				return b.call(c, d, c)
			}))
		},
		slice: function() {
			return this.pushStack(ja.apply(this, arguments))
		},
		first: function() {
			return this.eq(0)
		},
		last: function() {
			return this.eq(-1)
		},
		eq: function(b) {
			var c = this.length;
			b = +b + (0 > b ? c : 0);
			return this.pushStack(0 <= b && b < c ? [this[b]] : [])
		},
		end: function() {
			return this.prevObject || this.constructor()
		},
		push: Oa,
		sort: pa.sort,
		splice: pa.splice
	};
	n.extend = n.fn.extend = function() {
		var b, c, d, e, f, j, g = arguments[0] || {},
			l = 1,
			m = arguments.length,
			p = !1;
		"boolean" == typeof g && (p = g, g = arguments[l] || {}, l++);
		"object" == typeof g || n.isFunction(g) || (g = {});
		for (l === m && (g = this, l--); l < m; l++)
			if (null != (b = arguments[l]))
				for (c in b) d = g[c], e = b[c], g !== e && (p && e && (n.isPlainObject(e) || (f = Array.isArray(e))) ? (f ? (f = !1, j = d &&
					Array.isArray(d) ? d : []) : j = d && n.isPlainObject(d) ? d : {}, g[c] = n.extend(p, j, e)) : void 0 !== e && (g[c] = e));
		return g
	};
	n.extend({
		expando: "jQuery" + ("3.2.1" + Math.random()).replace(/\D/g, ""),
		isReady: !0,
		error: function(b) {
			throw Error(b);
		},
		noop: function() {},
		isFunction: function(b) {
			return "function" === n.type(b)
		},
		isWindow: function(b) {
			return null != b && b === b.window
		},
		isNumeric: function(b) {
			var c = n.type(b);
			return ("number" === c || "string" === c) && !isNaN(b - parseFloat(b))
		},
		isPlainObject: function(b) {
			var c, d;
			return !(!b || "[object Object]" !==
				sb.call(b)) && (!(c = Va(b)) || (d = db.call(c, "constructor") && c.constructor, "function" == typeof d && tb.call(d) === Kb))
		},
		isEmptyObject: function(b) {
			for (var c in b) return !1;
			return !0
		},
		type: function(b) {
			return null == b ? b + "" : "object" == typeof b || "function" == typeof b ? cb[sb.call(b)] || "object" : typeof b
		},
		globalEval: function(b) {
			e(b)
		},
		camelCase: function(b) {
			return b.replace(Pb, "ms-").replace(Ea, Ja)
		},
		each: function(b, c) {
			var e, f = 0;
			if (d(b))
				for (e = b.length; f < e && !1 !== c.call(b[f], f, b[f]); f++);
			else
				for (f in b)
					if (!1 === c.call(b[f], f,
							b[f])) break;
			return b
		},
		trim: function(b) {
			return null == b ? "" : (b + "").replace(Ob, "")
		},
		makeArray: function(b, c) {
			var e = c || [];
			return null != b && (d(Object(b)) ? n.merge(e, "string" == typeof b ? [b] : b) : Oa.call(e, b)), e
		},
		inArray: function(b, c, d) {
			return null == c ? -1 : Wa.call(c, b, d)
		},
		merge: function(b, c) {
			for (var d = +c.length, e = 0, f = b.length; e < d; e++) b[f++] = c[e];
			return b.length = f, b
		},
		grep: function(b, c, d) {
			for (var e = [], f = 0, j = b.length, g = !d; f < j; f++) d = !c(b[f], f), d !== g && e.push(b[f]);
			return e
		},
		map: function(b, c, e) {
			var f, j, g = 0,
				l = [];
			if (d(b))
				for (f =
					b.length; g < f; g++) j = c(b[g], g, e), null != j && l.push(j);
			else
				for (g in b) j = c(b[g], g, e), null != j && l.push(j);
			return Ia.apply([], l)
		},
		guid: 1,
		proxy: function(b, c) {
			var d, e, f;
			if ("string" == typeof c && (d = b[c], c = b, b = d), n.isFunction(b)) return e = ja.call(arguments, 2), f = function() {
				return b.apply(c || this, e.concat(ja.call(arguments)))
			}, f.guid = b.guid = b.guid || n.guid++, f
		},
		now: Date.now,
		support: V
	});
	"function" == typeof Symbol && (n.fn[Symbol.iterator] = pa[Symbol.iterator]);
	n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
		function(b, c) {
			cb["[object " + c + "]"] = c.toLowerCase()
		});
	var va, mb = c,
		U = function(b, c, d, e) {
			var f, j, g, l, m, p = c && c.ownerDocument,
				r = c ? c.nodeType : 9;
			if (d = d || [], "string" != typeof b || !b || 1 !== r && 9 !== r && 11 !== r) return d;
			if (!e && ((c ? c.ownerDocument || c : ua) !== S && Qa(c), c = c || S, ta)) {
				if (11 !== r && (l = Tc.exec(b)))
					if (f = l[1])
						if (9 === r) {
							if (!(j = c.getElementById(f))) return d;
							if (j.id === f) return d.push(j), d
						} else {
							if (p && (j = p.getElementById(f)) && lb(c, j) && j.id === f) return d.push(j), d
						}
				else {
					if (l[2]) return Ua.apply(d, c.getElementsByTagName(b)),
						d;
					if ((f = l[3]) && Z.getElementsByClassName && c.getElementsByClassName) return Ua.apply(d, c.getElementsByClassName(f)), d
				}
				if (Z.qsa && !Bb[b + " "] && (!ia || !ia.test(b))) {
					if (1 !== r) p = c, m = b;
					else if ("object" !== c.nodeName.toLowerCase()) {
						(g = c.getAttribute("id")) ? g = g.replace(ic, jc): c.setAttribute("id", g = X);
						j = kb(b);
						for (f = j.length; f--;) j[f] = "#" + g + " " + za(j[f]);
						m = j.join(",");
						p = Sb.test(b) && Ga(c.parentNode) || c
					}
					if (m) try {
						return Ua.apply(d, p.querySelectorAll(m)), d
					} catch (n) {} finally {
						g === X && c.removeAttribute("id")
					}
				}
			}
			return Zb(b.replace(Cb,
				"$1"), c, d, e)
		},
		Ra = function() {
			function b(d, e) {
				return c.push(d + " ") > R.cacheLength && delete b[c.shift()], b[d + " "] = e
			}
			var c = [];
			return b
		},
		ea = function(b) {
			return b[X] = !0, b
		},
		qa = function(b) {
			var c = S.createElement("fieldset");
			try {
				return !!b(c)
			} catch (d) {
				return !1
			} finally {
				c.parentNode && c.parentNode.removeChild(c)
			}
		},
		Sa = function(b, c) {
			for (var d = b.split("|"), e = d.length; e--;) R.attrHandle[d[e]] = c
		},
		Ka = function(b, c) {
			var d = c && b,
				e = d && 1 === b.nodeType && 1 === c.nodeType && b.sourceIndex - c.sourceIndex;
			if (e) return e;
			if (d)
				for (; d = d.nextSibling;)
					if (d ===
						c) return -1;
			return b ? 1 : -1
		},
		xb = function(b) {
			return function(c) {
				return "input" === c.nodeName.toLowerCase() && c.type === b
			}
		},
		Ta = function(b) {
			return function(c) {
				var d = c.nodeName.toLowerCase();
				return ("input" === d || "button" === d) && c.type === b
			}
		},
		gb = function(b) {
			return function(c) {
				return "form" in c ? c.parentNode && !1 === c.disabled ? "label" in c ? "label" in c.parentNode ? c.parentNode.disabled === b : c.disabled === b : c.isDisabled === b || c.isDisabled !== !b && Uc(c) === b : c.disabled === b : "label" in c && c.disabled === b
			}
		},
		Fa = function(b) {
			return ea(function(c) {
				return c = +c, ea(function(d, e) {
					for (var f, j = b([], d.length, c), g = j.length; g--;) d[f = j[g]] && (d[f] = !(e[f] = d[f]))
				})
			})
		},
		Ga = function(b) {
			return b && "undefined" != typeof b.getElementsByTagName && b
		},
		Ha = function() {},
		za = function(b) {
			for (var c = 0, d = b.length, e = ""; c < d; c++) e += b[c].value;
			return e
		},
		Ya = function(b, c, d) {
			var e = c.dir,
				f = c.next,
				j = f || e,
				g = d && "parentNode" === j,
				l = Jc++;
			return c.first ? function(c, d, f) {
				for (; c = c[e];)
					if (1 === c.nodeType || g) return b(c, d, f);
				return !1
			} : function(c, d, m) {
				var p, r, M, n = [Da, l];
				if (m)
					for (; c = c[e];) {
						if ((1 === c.nodeType ||
								g) && b(c, d, m)) return !0
					} else
						for (; c = c[e];)
							if (1 === c.nodeType || g)
								if (M = c[X] || (c[X] = {}), r = M[c.uniqueID] || (M[c.uniqueID] = {}), f && f === c.nodeName.toLowerCase()) c = c[e] || c;
								else {
									if ((p = r[j]) && p[0] === Da && p[1] === l) return n[2] = p[2];
									if (r[j] = n, n[2] = b(c, d, m)) return !0
								}
				return !1
			}
		},
		Aa = function(b) {
			return 1 < b.length ? function(c, d, e) {
				for (var f = b.length; f--;)
					if (!b[f](c, d, e)) return !1;
				return !0
			} : b[0]
		},
		Ba = function(b, c, d, e, f) {
			for (var j, g = [], l = 0, m = b.length, p = null != c; l < m; l++)(j = b[l]) && (d && !d(j, e, f) || (g.push(j), p && c.push(l)));
			return g
		},
		Lb = function(b, c, d, e, f, j) {
			return e && !e[X] && (e = Lb(e)), f && !f[X] && (f = Lb(f, j)), ea(function(j, g, l, m) {
				var p, r, n = [],
					s = [],
					q = g.length,
					t;
				if (!(t = j)) {
					t = c || "*";
					for (var u = l.nodeType ? [l] : l, bc = [], x = 0, v = u.length; x < v; x++) U(t, u[x], bc);
					t = bc
				}
				t = !b || !j && c ? t : Ba(t, n, b, l, m);
				u = d ? f || (j ? b : q || e) ? [] : g : t;
				if (d && d(t, u, l, m), e) {
					p = Ba(u, s);
					e(p, [], l, m);
					for (l = p.length; l--;)(r = p[l]) && (u[s[l]] = !(t[s[l]] = r))
				}
				if (j) {
					if (f || b) {
						if (f) {
							p = [];
							for (l = u.length; l--;)(r = u[l]) && p.push(t[l] = r);
							f(null, u = [], p, m)
						}
						for (l = u.length; l--;)(r = u[l]) && -1 < (p = f ? ab(j, r) :
							n[l]) && (j[p] = !(g[p] = r))
					}
				} else u = Ba(u === g ? u.splice(q, u.length) : u), f ? f(null, g, u, m) : Ua.apply(g, u)
			})
		},
		Mb = function(b) {
			var c, d, e, f = b.length,
				j = R.relative[b[0].type];
			d = j || R.relative[" "];
			for (var g = j ? 1 : 0, l = Ya(function(b) {
					return b === c
				}, d, !0), m = Ya(function(b) {
					return -1 < ab(c, b)
				}, d, !0), p = [function(b, d, e) {
					b = !j && (e || d !== vb) || ((c = d).nodeType ? l(b, d, e) : m(b, d, e));
					return c = null, b
				}]; g < f; g++)
				if (d = R.relative[b[g].type]) p = [Ya(Aa(p), d)];
				else {
					if (d = R.filter[b[g].type].apply(null, b[g].matches), d[X]) {
						for (e = ++g; e < f && !R.relative[b[e].type]; e++);
						return Lb(1 < g && Aa(p), 1 < g && za(b.slice(0, g - 1).concat({
							value: " " === b[g - 2].type ? "*" : ""
						})).replace(Cb, "$1"), d, g < e && Mb(b.slice(g, e)), e < f && Mb(b = b.slice(e)), e < f && za(b))
					}
					p.push(d)
				}
			return Aa(p)
		},
		eb, Z, R, ub, Yb, kb, Nb, Zb, vb, Pa, fb, Qa, S, sa, ta, ia, Xa, wb, lb, X = "sizzle" + 1 * new Date,
		ua = mb.document,
		Da = 0,
		Jc = 0,
		$b = Ra(),
		ac = Ra(),
		Bb = Ra(),
		Tb = function(b, c) {
			return b === c && (fb = !0), 0
		},
		Vc = {}.hasOwnProperty,
		bb = [],
		Wc = bb.pop,
		Xc = bb.push,
		Ua = bb.push,
		kc = bb.slice,
		ab = function(b, c) {
			for (var d = 0, e = b.length; d < e; d++)
				if (b[d] === c) return d;
			return -1
		},
		Yc = /[\x20\t\r\n\f]+/g,
		Cb = /^[\x20\t\r\n\f]+|((?:^|[^\\])(?:\\.)*)[\x20\t\r\n\f]+$/g,
		Zc = /^[\x20\t\r\n\f]*,[\x20\t\r\n\f]*/,
		$c = /^[\x20\t\r\n\f]*([>+~]|[\x20\t\r\n\f])[\x20\t\r\n\f]*/,
		ad = /=[\x20\t\r\n\f]*([^\]'"]*?)[\x20\t\r\n\f]*\]/g,
		bd = RegExp(":((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|\\[[\\x20\\t\\r\\n\\f]*((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:[\\x20\\t\\r\\n\\f]*([*^$|!~]?=)[\\x20\\t\\r\\n\\f]*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|((?:\\\\.|[\\w-]|[^\x00-\\xa0])+))|)[\\x20\\t\\r\\n\\f]*\\])*)|.*)\\)|)"),
		cd = /^(?:\\.|[\w-]|[^\x00-\xa0])+$/,
		Db = {
			ID: /^#((?:\\.|[\w-]|[^\x00-\xa0])+)/,
			CLASS: /^\.((?:\\.|[\w-]|[^\x00-\xa0])+)/,
			TAG: /^((?:\\.|[\w-]|[^\x00-\xa0])+|[*])/,
			ATTR: RegExp("^\\[[\\x20\\t\\r\\n\\f]*((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:[\\x20\\t\\r\\n\\f]*([*^$|!~]?=)[\\x20\\t\\r\\n\\f]*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|((?:\\\\.|[\\w-]|[^\x00-\\xa0])+))|)[\\x20\\t\\r\\n\\f]*\\]"),
			PSEUDO: RegExp("^:((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|\\[[\\x20\\t\\r\\n\\f]*((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:[\\x20\\t\\r\\n\\f]*([*^$|!~]?=)[\\x20\\t\\r\\n\\f]*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|((?:\\\\.|[\\w-]|[^\x00-\\xa0])+))|)[\\x20\\t\\r\\n\\f]*\\])*)|.*)\\)|)"),
			CHILD: RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)", "i"),
			bool: RegExp("^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$", "i"),
			needsContext: RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)",
				"i")
		},
		dd = /^(?:input|select|textarea|button)$/i,
		ed = /^h\d$/i,
		ob = /^[^{]+\{\s*\[native \w/,
		Tc = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		Sb = /[+~]/,
		La = /\\([\da-f]{1,6}[\x20\t\r\n\f]?|([\x20\t\r\n\f])|.)/ig,
		Ma = function(b, c, d) {
			b = "0x" + c - 65536;
			return b !== b || d ? c : 0 > b ? String.fromCharCode(b + 65536) : String.fromCharCode(b >> 10 | 55296, 1023 & b | 56320)
		},
		ic = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		jc = function(b, c) {
			return c ? "\x00" === b ? "\ufffd" : b.slice(0, -1) + "\\" + b.charCodeAt(b.length - 1).toString(16) + " " : "\\" + b
		},
		lc = function() {
			Qa()
		},
		Uc = Ya(function(b) {
			return !0 === b.disabled && ("form" in b || "label" in b)
		}, {
			dir: "parentNode",
			next: "legend"
		});
	try {
		Ua.apply(bb = kc.call(ua.childNodes), ua.childNodes), bb[ua.childNodes.length].nodeType
	} catch (Hd) {
		Ua = {
			apply: bb.length ? function(b, c) {
				Xc.apply(b, kc.call(c))
			} : function(b, c) {
				for (var d = b.length, e = 0; b[d++] = c[e++];);
				b.length = d - 1
			}
		}
	}
	Z = U.support = {};
	Yb = U.isXML = function(b) {
		b = b && (b.ownerDocument || b).documentElement;
		return !!b && "HTML" !== b.nodeName
	};
	Qa = U.setDocument = function(b) {
		var c, d;
		b = b ? b.ownerDocument || b : ua;
		return b !== S && 9 === b.nodeType && b.documentElement ? (S = b, sa = S.documentElement, ta = !Yb(S), ua !== S && (d = S.defaultView) && d.top !== d && (d.addEventListener ? d.addEventListener("unload", lc, !1) : d.attachEvent && d.attachEvent("onunload", lc)), Z.attributes = qa(function(b) {
				return b.className = "i", !b.getAttribute("className")
			}), Z.getElementsByTagName = qa(function(b) {
				return b.appendChild(S.createComment("")), !b.getElementsByTagName("*").length
			}), Z.getElementsByClassName = ob.test(S.getElementsByClassName), Z.getById = qa(function(b) {
				return sa.appendChild(b).id =
					X, !S.getElementsByName || !S.getElementsByName(X).length
			}), Z.getById ? (R.filter.ID = function(b) {
				var c = b.replace(La, Ma);
				return function(b) {
					return b.getAttribute("id") === c
				}
			}, R.find.ID = function(b, c) {
				if ("undefined" != typeof c.getElementById && ta) {
					var d = c.getElementById(b);
					return d ? [d] : []
				}
			}) : (R.filter.ID = function(b) {
				var c = b.replace(La, Ma);
				return function(b) {
					return (b = "undefined" != typeof b.getAttributeNode && b.getAttributeNode("id")) && b.value === c
				}
			}, R.find.ID = function(b, c) {
				if ("undefined" != typeof c.getElementById &&
					ta) {
					var d, e, f, j = c.getElementById(b);
					if (j) {
						if (d = j.getAttributeNode("id"), d && d.value === b) return [j];
						f = c.getElementsByName(b);
						for (e = 0; j = f[e++];)
							if (d = j.getAttributeNode("id"), d && d.value === b) return [j]
					}
					return []
				}
			}), R.find.TAG = Z.getElementsByTagName ? function(b, c) {
				return "undefined" != typeof c.getElementsByTagName ? c.getElementsByTagName(b) : Z.qsa ? c.querySelectorAll(b) : void 0
			} : function(b, c) {
				var d, e = [],
					f = 0,
					j = c.getElementsByTagName(b);
				if ("*" === b) {
					for (; d = j[f++];) 1 === d.nodeType && e.push(d);
					return e
				}
				return j
			}, R.find.CLASS =
			Z.getElementsByClassName && function(b, c) {
				if ("undefined" != typeof c.getElementsByClassName && ta) return c.getElementsByClassName(b)
			}, Xa = [], ia = [], (Z.qsa = ob.test(S.querySelectorAll)) && (qa(function(b) {
				sa.appendChild(b).innerHTML = "<a id='" + X + "'></a><select id='" + X + "-\r\\' msallowcapture=''><option selected=''></option></select>";
				b.querySelectorAll("[msallowcapture^='']").length && ia.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")");
				b.querySelectorAll("[selected]").length || ia.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)");
				b.querySelectorAll("[id~=" + X + "-]").length || ia.push("~=");
				b.querySelectorAll(":checked").length || ia.push(":checked");
				b.querySelectorAll("a#" + X + "+*").length || ia.push(".#.+[+~]")
			}), qa(function(b) {
				b.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
				var c = S.createElement("input");
				c.setAttribute("type", "hidden");
				b.appendChild(c).setAttribute("name", "D");
				b.querySelectorAll("[name=d]").length && ia.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?=");
				2 !== b.querySelectorAll(":enabled").length &&
					ia.push(":enabled", ":disabled");
				sa.appendChild(b).disabled = !0;
				2 !== b.querySelectorAll(":disabled").length && ia.push(":enabled", ":disabled");
				b.querySelectorAll("*,:x");
				ia.push(",.*:")
			})), (Z.matchesSelector = ob.test(wb = sa.matches || sa.webkitMatchesSelector || sa.mozMatchesSelector || sa.oMatchesSelector || sa.msMatchesSelector)) && qa(function(b) {
				Z.disconnectedMatch = wb.call(b, "*");
				wb.call(b, "[s!='']:x");
				Xa.push("!=", ":((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|\\[[\\x20\\t\\r\\n\\f]*((?:\\\\.|[\\w-]|[^\x00-\\xa0])+)(?:[\\x20\\t\\r\\n\\f]*([*^$|!~]?=)[\\x20\\t\\r\\n\\f]*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|((?:\\\\.|[\\w-]|[^\x00-\\xa0])+))|)[\\x20\\t\\r\\n\\f]*\\])*)|.*)\\)|)")
			}),
			ia = ia.length && RegExp(ia.join("|")), Xa = Xa.length && RegExp(Xa.join("|")), c = ob.test(sa.compareDocumentPosition), lb = c || ob.test(sa.contains) ? function(b, c) {
				var d = 9 === b.nodeType ? b.documentElement : b,
					e = c && c.parentNode;
				return b === e || !(!e || 1 !== e.nodeType || !(d.contains ? d.contains(e) : b.compareDocumentPosition && 16 & b.compareDocumentPosition(e)))
			} : function(b, c) {
				if (c)
					for (; c = c.parentNode;)
						if (c === b) return !0;
				return !1
			}, Tb = c ? function(b, c) {
				if (b === c) return fb = !0, 0;
				var d = !b.compareDocumentPosition - !c.compareDocumentPosition;
				return d ? d : (d = (b.ownerDocument || b) === (c.ownerDocument || c) ? b.compareDocumentPosition(c) : 1, 1 & d || !Z.sortDetached && c.compareDocumentPosition(b) === d ? b === S || b.ownerDocument === ua && lb(ua, b) ? -1 : c === S || c.ownerDocument === ua && lb(ua, c) ? 1 : Pa ? ab(Pa, b) - ab(Pa, c) : 0 : 4 & d ? -1 : 1)
			} : function(b, c) {
				if (b === c) return fb = !0, 0;
				var d, e = 0;
				d = b.parentNode;
				var f = c.parentNode,
					j = [b],
					g = [c];
				if (!d || !f) return b === S ? -1 : c === S ? 1 : d ? -1 : f ? 1 : Pa ? ab(Pa, b) - ab(Pa, c) : 0;
				if (d === f) return Ka(b, c);
				for (d = b; d = d.parentNode;) j.unshift(d);
				for (d = c; d = d.parentNode;) g.unshift(d);
				for (; j[e] === g[e];) e++;
				return e ? Ka(j[e], g[e]) : j[e] === ua ? -1 : g[e] === ua ? 1 : 0
			}, S) : S
	};
	U.matches = function(b, c) {
		return U(b, null, null, c)
	};
	U.matchesSelector = function(b, c) {
		if ((b.ownerDocument || b) !== S && Qa(b), c = c.replace(ad, "='$1']"), Z.matchesSelector && ta && !Bb[c + " "] && (!Xa || !Xa.test(c)) && (!ia || !ia.test(c))) try {
			var d = wb.call(b, c);
			if (d || Z.disconnectedMatch || b.document && 11 !== b.document.nodeType) return d
		} catch (e) {}
		return 0 < U(c, S, null, [b]).length
	};
	U.contains = function(b, c) {
		return (b.ownerDocument || b) !== S && Qa(b), lb(b,
			c)
	};
	U.attr = function(b, c) {
		(b.ownerDocument || b) !== S && Qa(b);
		var d = R.attrHandle[c.toLowerCase()],
			d = d && Vc.call(R.attrHandle, c.toLowerCase()) ? d(b, c, !ta) : void 0;
		return void 0 !== d ? d : Z.attributes || !ta ? b.getAttribute(c) : (d = b.getAttributeNode(c)) && d.specified ? d.value : null
	};
	U.escape = function(b) {
		return (b + "").replace(ic, jc)
	};
	U.error = function(b) {
		throw Error("Syntax error, unrecognized expression: " + b);
	};
	U.uniqueSort = function(b) {
		var c, d = [],
			e = 0,
			f = 0;
		if (fb = !Z.detectDuplicates, Pa = !Z.sortStable && b.slice(0), b.sort(Tb),
			fb) {
			for (; c = b[f++];) c === b[f] && (e = d.push(f));
			for (; e--;) b.splice(d[e], 1)
		}
		return Pa = null, b
	};
	ub = U.getText = function(b) {
		var c, d = "",
			e = 0;
		if (c = b.nodeType)
			if (1 === c || 9 === c || 11 === c) {
				if ("string" == typeof b.textContent) return b.textContent;
				for (b = b.firstChild; b; b = b.nextSibling) d += ub(b)
			} else {
				if (3 === c || 4 === c) return b.nodeValue
			}
		else
			for (; c = b[e++];) d += ub(c);
		return d
	};
	R = U.selectors = {
		cacheLength: 50,
		createPseudo: ea,
		match: Db,
		attrHandle: {},
		find: {},
		relative: {
			">": {
				dir: "parentNode",
				first: !0
			},
			" ": {
				dir: "parentNode"
			},
			"+": {
				dir: "previousSibling",
				first: !0
			},
			"~": {
				dir: "previousSibling"
			}
		},
		preFilter: {
			ATTR: function(b) {
				return b[1] = b[1].replace(La, Ma), b[3] = (b[3] || b[4] || b[5] || "").replace(La, Ma), "~=" === b[2] && (b[3] = " " + b[3] + " "), b.slice(0, 4)
			},
			CHILD: function(b) {
				return b[1] = b[1].toLowerCase(), "nth" === b[1].slice(0, 3) ? (b[3] || U.error(b[0]), b[4] = +(b[4] ? b[5] + (b[6] || 1) : 2 * ("even" === b[3] || "odd" === b[3])), b[5] = +(b[7] + b[8] || "odd" === b[3])) : b[3] && U.error(b[0]), b
			},
			PSEUDO: function(b) {
				var c, d = !b[6] && b[2];
				return Db.CHILD.test(b[0]) ? null : (b[3] ? b[2] = b[4] || b[5] || "" : d && bd.test(d) &&
					(c = kb(d, !0)) && (c = d.indexOf(")", d.length - c) - d.length) && (b[0] = b[0].slice(0, c), b[2] = d.slice(0, c)), b.slice(0, 3))
			}
		},
		filter: {
			TAG: function(b) {
				var c = b.replace(La, Ma).toLowerCase();
				return "*" === b ? function() {
					return !0
				} : function(b) {
					return b.nodeName && b.nodeName.toLowerCase() === c
				}
			},
			CLASS: function(b) {
				var c = $b[b + " "];
				return c || (c = RegExp("(^|[\\x20\\t\\r\\n\\f])" + b + "([\\x20\\t\\r\\n\\f]|$)")) && $b(b, function(b) {
					return c.test("string" == typeof b.className && b.className || "undefined" != typeof b.getAttribute && b.getAttribute("class") ||
						"")
				})
			},
			ATTR: function(b, c, d) {
				return function(e) {
					e = U.attr(e, b);
					return null == e ? "!=" === c : !c || (e += "", "=" === c ? e === d : "!=" === c ? e !== d : "^=" === c ? d && 0 === e.indexOf(d) : "*=" === c ? d && -1 < e.indexOf(d) : "$=" === c ? d && e.slice(-d.length) === d : "~=" === c ? -1 < (" " + e.replace(Yc, " ") + " ").indexOf(d) : "|=" === c && (e === d || e.slice(0, d.length + 1) === d + "-"))
				}
			},
			CHILD: function(b, c, d, e, f) {
				var j = "nth" !== b.slice(0, 3),
					g = "last" !== b.slice(-4),
					l = "of-type" === c;
				return 1 === e && 0 === f ? function(b) {
					return !!b.parentNode
				} : function(c, d, m) {
					var p, r, n, M, s, q;
					d = j !==
						g ? "nextSibling" : "previousSibling";
					var fa = c.parentNode,
						t = l && c.nodeName.toLowerCase();
					m = !m && !l;
					var u = !1;
					if (fa) {
						if (j) {
							for (; d;) {
								for (M = c; M = M[d];)
									if (l ? M.nodeName.toLowerCase() === t : 1 === M.nodeType) return !1;
								q = d = "only" === b && !q && "nextSibling"
							}
							return !0
						}
						if (q = [g ? fa.firstChild : fa.lastChild], g && m) {
							M = fa;
							n = M[X] || (M[X] = {});
							r = n[M.uniqueID] || (n[M.uniqueID] = {});
							p = r[b] || [];
							u = (s = p[0] === Da && p[1]) && p[2];
							for (M = s && fa.childNodes[s]; M = ++s && M && M[d] || (u = s = 0) || q.pop();)
								if (1 === M.nodeType && ++u && M === c) {
									r[b] = [Da, s, u];
									break
								}
						} else if (m &&
							(M = c, n = M[X] || (M[X] = {}), r = n[M.uniqueID] || (n[M.uniqueID] = {}), p = r[b] || [], s = p[0] === Da && p[1], u = s), !1 === u)
							for (;
								(M = ++s && M && M[d] || (u = s = 0) || q.pop()) && (!(l ? M.nodeName.toLowerCase() === t : 1 === M.nodeType) || !++u || !(m && (n = M[X] || (M[X] = {}), r = n[M.uniqueID] || (n[M.uniqueID] = {}), r[b] = [Da, u]), M === c)););
						return u -= f, u === e || 0 === u % e && 0 <= u / e
					}
				}
			},
			PSEUDO: function(b, c) {
				var d, e = R.pseudos[b] || R.setFilters[b.toLowerCase()] || U.error("unsupported pseudo: " + b);
				return e[X] ? e(c) : 1 < e.length ? (d = [b, b, "", c], R.setFilters.hasOwnProperty(b.toLowerCase()) ?
					ea(function(b, d) {
						for (var f, j = e(b, c), g = j.length; g--;) f = ab(b, j[g]), b[f] = !(d[f] = j[g])
					}) : function(b) {
						return e(b, 0, d)
					}) : e
			}
		},
		pseudos: {
			not: ea(function(b) {
				var c = [],
					d = [],
					e = Nb(b.replace(Cb, "$1"));
				return e[X] ? ea(function(b, c, d, f) {
					var j;
					d = e(b, null, f, []);
					for (f = b.length; f--;)(j = d[f]) && (b[f] = !(c[f] = j))
				}) : function(b, f, j) {
					return c[0] = b, e(c, null, j, d), c[0] = null, !d.pop()
				}
			}),
			has: ea(function(b) {
				return function(c) {
					return 0 < U(b, c).length
				}
			}),
			contains: ea(function(b) {
				return b = b.replace(La, Ma),
					function(c) {
						return -1 < (c.textContent ||
							c.innerText || ub(c)).indexOf(b)
					}
			}),
			lang: ea(function(b) {
				return cd.test(b || "") || U.error("unsupported lang: " + b), b = b.replace(La, Ma).toLowerCase(),
					function(c) {
						var d;
						do
							if (d = ta ? c.lang : c.getAttribute("xml:lang") || c.getAttribute("lang")) return d = d.toLowerCase(), d === b || 0 === d.indexOf(b + "-"); while ((c = c.parentNode) && 1 === c.nodeType);
						return !1
					}
			}),
			target: function(b) {
				var c = mb.location && mb.location.hash;
				return c && c.slice(1) === b.id
			},
			root: function(b) {
				return b === sa
			},
			focus: function(b) {
				return b === S.activeElement && (!S.hasFocus ||
					S.hasFocus()) && !(!b.type && !b.href && !~b.tabIndex)
			},
			enabled: gb(!1),
			disabled: gb(!0),
			checked: function(b) {
				var c = b.nodeName.toLowerCase();
				return "input" === c && !!b.checked || "option" === c && !!b.selected
			},
			selected: function(b) {
				return b.parentNode && b.parentNode.selectedIndex, !0 === b.selected
			},
			empty: function(b) {
				for (b = b.firstChild; b; b = b.nextSibling)
					if (6 > b.nodeType) return !1;
				return !0
			},
			parent: function(b) {
				return !R.pseudos.empty(b)
			},
			header: function(b) {
				return ed.test(b.nodeName)
			},
			input: function(b) {
				return dd.test(b.nodeName)
			},
			button: function(b) {
				var c = b.nodeName.toLowerCase();
				return "input" === c && "button" === b.type || "button" === c
			},
			text: function(b) {
				var c;
				return "input" === b.nodeName.toLowerCase() && "text" === b.type && (null == (c = b.getAttribute("type")) || "text" === c.toLowerCase())
			},
			first: Fa(function() {
				return [0]
			}),
			last: Fa(function(b, c) {
				return [c - 1]
			}),
			eq: Fa(function(b, c, d) {
				return [0 > d ? d + c : d]
			}),
			even: Fa(function(b, c) {
				for (var d = 0; d < c; d += 2) b.push(d);
				return b
			}),
			odd: Fa(function(b, c) {
				for (var d = 1; d < c; d += 2) b.push(d);
				return b
			}),
			lt: Fa(function(b, c,
				d) {
				for (c = 0 > d ? d + c : d; 0 <= --c;) b.push(c);
				return b
			}),
			gt: Fa(function(b, c, d) {
				for (d = 0 > d ? d + c : d; ++d < c;) b.push(d);
				return b
			})
		}
	};
	R.pseudos.nth = R.pseudos.eq;
	for (eb in {
			radio: !0,
			checkbox: !0,
			file: !0,
			password: !0,
			image: !0
		}) R.pseudos[eb] = xb(eb);
	for (eb in {
			submit: !0,
			reset: !0
		}) R.pseudos[eb] = Ta(eb);
	Ha.prototype = R.filters = R.pseudos;
	R.setFilters = new Ha;
	kb = U.tokenize = function(b, c) {
		var d, e, f, j, g, l, m;
		if (g = ac[b + " "]) return c ? 0 : g.slice(0);
		g = b;
		l = [];
		for (m = R.preFilter; g;) {
			d && !(e = Zc.exec(g)) || (e && (g = g.slice(e[0].length) || g), l.push(f =
				[]));
			d = !1;
			(e = $c.exec(g)) && (d = e.shift(), f.push({
				value: d,
				type: e[0].replace(Cb, " ")
			}), g = g.slice(d.length));
			for (j in R.filter) !(e = Db[j].exec(g)) || m[j] && !(e = m[j](e)) || (d = e.shift(), f.push({
				value: d,
				type: j,
				matches: e
			}), g = g.slice(d.length));
			if (!d) break
		}
		return c ? g.length : g ? U.error(b) : ac(b, l).slice(0)
	};
	va = (Nb = U.compile = function(b, c) {
		var d, e = [],
			f = [],
			j = Bb[b + " "];
		if (!j) {
			c || (c = kb(b));
			for (d = c.length; d--;) j = Mb(c[d]), j[X] ? e.push(j) : f.push(j);
			d = Bb;
			var g = 0 < e.length,
				l = 0 < f.length,
				j = function(b, c, d, j, P) {
					var m, p, r, n = 0,
						s = "0",
						M = b && [],
						q = [],
						t = vb,
						fa = b || l && R.find.TAG("*", P),
						u = Da += null == t ? 1 : Math.random() || 0.1,
						x = fa.length;
					for (P && (vb = c === S || c || P); s !== x && null != (m = fa[s]); s++) {
						if (l && m) {
							p = 0;
							for (c || m.ownerDocument === S || (Qa(m), d = !ta); r = f[p++];)
								if (r(m, c || S, d)) {
									j.push(m);
									break
								}
							P && (Da = u)
						}
						g && ((m = !r && m) && n--, b && M.push(m))
					}
					if (n += s, g && s !== n) {
						for (p = 0; r = e[p++];) r(M, q, c, d);
						if (b) {
							if (0 < n)
								for (; s--;) M[s] || q[s] || (q[s] = Wc.call(j));
							q = Ba(q)
						}
						Ua.apply(j, q);
						P && !b && 0 < q.length && 1 < n + e.length && U.uniqueSort(j)
					}
					return P && (Da = u, vb = t), M
				},
				j = g ? ea(j) : j,
				j = d(b, j);
			j.selector = b
		}
		return j
	}, Zb = U.select = function(b, c, d, e) {
		var f, j, g, l, m, p = "function" == typeof b && b,
			r = !e && kb(b = p.selector || b);
		if (d = d || [], 1 === r.length) {
			if (j = r[0] = r[0].slice(0), 2 < j.length && "ID" === (g = j[0]).type && 9 === c.nodeType && ta && R.relative[j[1].type]) {
				if (c = (R.find.ID(g.matches[0].replace(La, Ma), c) || [])[0], !c) return d;
				p && (c = c.parentNode);
				b = b.slice(j.shift().value.length)
			}
			for (f = Db.needsContext.test(b) ? 0 : j.length; f-- && !(g = j[f], R.relative[l = g.type]);)
				if ((m = R.find[l]) && (e = m(g.matches[0].replace(La, Ma), Sb.test(j[0].type) &&
						Ga(c.parentNode) || c))) {
					if (j.splice(f, 1), b = e.length && za(j), !b) return Ua.apply(d, e), d;
					break
				}
		}
		return (p || Nb(b, r))(e, c, !ta, d, !c || Sb.test(b) && Ga(c.parentNode) || c), d
	}, Z.sortStable = X.split("").sort(Tb).join("") === X, Z.detectDuplicates = !!fb, Qa(), Z.sortDetached = qa(function(b) {
		return 1 & b.compareDocumentPosition(S.createElement("fieldset"))
	}), qa(function(b) {
		return b.innerHTML = "<a href='#'></a>", "#" === b.firstChild.getAttribute("href")
	}) || Sa("type|href|height|width", function(b, c, d) {
		if (!d) return b.getAttribute(c,
			"type" === c.toLowerCase() ? 1 : 2)
	}), Z.attributes && qa(function(b) {
		return b.innerHTML = "<input/>", b.firstChild.setAttribute("value", ""), "" === b.firstChild.getAttribute("value")
	}) || Sa("value", function(b, c, d) {
		if (!d && "input" === b.nodeName.toLowerCase()) return b.defaultValue
	}), qa(function(b) {
		return null == b.getAttribute("disabled")
	}) || Sa("checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", function(b, c, d) {
		var e;
		if (!d) return !0 === b[c] ? c.toLowerCase() :
			(e = b.getAttributeNode(c)) && e.specified ? e.value : null
	}), U);
	n.find = va;
	n.expr = va.selectors;
	n.expr[":"] = n.expr.pseudos;
	n.uniqueSort = n.unique = va.uniqueSort;
	n.text = va.getText;
	n.isXMLDoc = va.isXML;
	n.contains = va.contains;
	n.escapeSelector = va.escape;
	var ib = function(b, c, d) {
			for (var e = [], f = void 0 !== d;
				(b = b[c]) && 9 !== b.nodeType;)
				if (1 === b.nodeType) {
					if (f && n(b).is(d)) break;
					e.push(b)
				}
			return e
		},
		mc = function(b, c) {
			for (var d = []; b; b = b.nextSibling) 1 === b.nodeType && b !== c && d.push(b);
			return d
		},
		nc = n.expr.match.needsContext,
		oc = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,
		Kc = /^.[^:#\[\.,]*$/;
	n.filter = function(b, c, d) {
		var e = c[0];
		return d && (b = ":not(" + b + ")"), 1 === c.length && 1 === e.nodeType ? n.find.matchesSelector(e, b) ? [e] : [] : n.find.matches(b, n.grep(c, function(b) {
			return 1 === b.nodeType
		}))
	};
	n.fn.extend({
		find: function(b) {
			var c, d, e = this.length,
				f = this;
			if ("string" != typeof b) return this.pushStack(n(b).filter(function() {
				for (c = 0; c < e; c++)
					if (n.contains(f[c], this)) return !0
			}));
			d = this.pushStack([]);
			for (c = 0; c < e; c++) n.find(b, f[c], d);
			return 1 < e ? n.uniqueSort(d) : d
		},
		filter: function(b) {
			return this.pushStack(g(this,
				b || [], !1))
		},
		not: function(b) {
			return this.pushStack(g(this, b || [], !0))
		},
		is: function(b) {
			return !!g(this, "string" == typeof b && nc.test(b) ? n(b) : b || [], !1).length
		}
	});
	var pc, fd = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
	(n.fn.init = function(b, c, d) {
		var e, f;
		if (!b) return this;
		if (d = d || pc, "string" == typeof b) {
			if (e = "<" === b[0] && ">" === b[b.length - 1] && 3 <= b.length ? [null, b, null] : fd.exec(b), !e || !e[1] && c) return !c || c.jquery ? (c || d).find(b) : this.constructor(c).find(b);
			if (e[1]) {
				if (c = c instanceof n ? c[0] : c, n.merge(this, n.parseHTML(e[1],
						c && c.nodeType ? c.ownerDocument || c : J, !0)), oc.test(e[1]) && n.isPlainObject(c))
					for (e in c) n.isFunction(this[e]) ? this[e](c[e]) : this.attr(e, c[e]);
				return this
			}
			return f = J.getElementById(e[2]), f && (this[0] = f, this.length = 1), this
		}
		return b.nodeType ? (this[0] = b, this.length = 1, this) : n.isFunction(b) ? void 0 !== d.ready ? d.ready(b) : b(n) : n.makeArray(b, this)
	}).prototype = n.fn;
	pc = n(J);
	var gd = /^(?:parents|prev(?:Until|All))/,
		hd = {
			children: !0,
			contents: !0,
			next: !0,
			prev: !0
		};
	n.fn.extend({
		has: function(b) {
			var c = n(b, this),
				d = c.length;
			return this.filter(function() {
				for (var b = 0; b < d; b++)
					if (n.contains(this, c[b])) return !0
			})
		},
		closest: function(b, c) {
			var d, e = 0,
				f = this.length,
				j = [],
				g = "string" != typeof b && n(b);
			if (!nc.test(b))
				for (; e < f; e++)
					for (d = this[e]; d && d !== c; d = d.parentNode)
						if (11 > d.nodeType && (g ? -1 < g.index(d) : 1 === d.nodeType && n.find.matchesSelector(d, b))) {
							j.push(d);
							break
						}
			return this.pushStack(1 < j.length ? n.uniqueSort(j) : j)
		},
		index: function(b) {
			return b ? "string" == typeof b ? Wa.call(n(b), this[0]) : Wa.call(this, b.jquery ? b[0] : b) : this[0] && this[0].parentNode ?
				this.first().prevAll().length : -1
		},
		add: function(b, c) {
			return this.pushStack(n.uniqueSort(n.merge(this.get(), n(b, c))))
		},
		addBack: function(b) {
			return this.add(null == b ? this.prevObject : this.prevObject.filter(b))
		}
	});
	n.each({
		parent: function(b) {
			return (b = b.parentNode) && 11 !== b.nodeType ? b : null
		},
		parents: function(b) {
			return ib(b, "parentNode")
		},
		parentsUntil: function(b, c, d) {
			return ib(b, "parentNode", d)
		},
		next: function(b) {
			return q(b, "nextSibling")
		},
		prev: function(b) {
			return q(b, "previousSibling")
		},
		nextAll: function(b) {
			return ib(b,
				"nextSibling")
		},
		prevAll: function(b) {
			return ib(b, "previousSibling")
		},
		nextUntil: function(b, c, d) {
			return ib(b, "nextSibling", d)
		},
		prevUntil: function(b, c, d) {
			return ib(b, "previousSibling", d)
		},
		siblings: function(b) {
			return mc((b.parentNode || {}).firstChild, b)
		},
		children: function(b) {
			return mc(b.firstChild)
		},
		contents: function(b) {
			return f(b, "iframe") ? b.contentDocument : (f(b, "template") && (b = b.content || b), n.merge([], b.childNodes))
		}
	}, function(b, c) {
		n.fn[b] = function(d, e) {
			var f = n.map(this, c, d);
			return "Until" !== b.slice(-5) &&
				(e = d), e && "string" == typeof e && (f = n.filter(e, f)), 1 < this.length && (hd[b] || n.uniqueSort(f), gd.test(b) && f.reverse()), this.pushStack(f)
		}
	});
	var xa = /[^\x20\t\r\n\f]+/g;
	n.Callbacks = function(b) {
		var c;
		if ("string" == typeof b) {
			var d = {};
			c = (n.each(b.match(xa) || [], function(b, c) {
				d[c] = !0
			}), d)
		} else c = n.extend({}, b);
		b = c;
		var e, f, j, g, l = [],
			m = [],
			p = -1,
			r = function() {
				g = g || b.once;
				for (j = e = !0; m.length; p = -1)
					for (f = m.shift(); ++p < l.length;) !1 === l[p].apply(f[0], f[1]) && b.stopOnFalse && (p = l.length, f = !1);
				b.memory || (f = !1);
				e = !1;
				g && (l = f ? [] :
					"")
			},
			s = {
				add: function() {
					return l && (f && !e && (p = l.length - 1, m.push(f)), function Qc(c) {
						n.each(c, function(c, d) {
							n.isFunction(d) ? b.unique && s.has(d) || l.push(d) : d && d.length && "string" !== n.type(d) && Qc(d)
						})
					}(arguments), f && !e && r()), this
				},
				remove: function() {
					return n.each(arguments, function(b, c) {
						for (var d; - 1 < (d = n.inArray(c, l, d));) l.splice(d, 1), d <= p && p--
					}), this
				},
				has: function(b) {
					return b ? -1 < n.inArray(b, l) : 0 < l.length
				},
				empty: function() {
					return l && (l = []), this
				},
				disable: function() {
					return g = m = [], l = f = "", this
				},
				disabled: function() {
					return !l
				},
				lock: function() {
					return g = m = [], f || e || (l = f = ""), this
				},
				locked: function() {
					return !!g
				},
				fireWith: function(b, c) {
					return g || (c = c || [], c = [b, c.slice ? c.slice() : c], m.push(c), e || r()), this
				},
				fire: function() {
					return s.fireWith(this, arguments), this
				},
				fired: function() {
					return !!j
				}
			};
		return s
	};
	n.extend({
		Deferred: function(b) {
			var d = [
					["notify", "progress", n.Callbacks("memory"), n.Callbacks("memory"), 2],
					["resolve", "done", n.Callbacks("once memory"), n.Callbacks("once memory"), 0, "resolved"],
					["reject", "fail", n.Callbacks("once memory"),
						n.Callbacks("once memory"), 1, "rejected"
					]
				],
				e = "pending",
				f = {
					state: function() {
						return e
					},
					always: function() {
						return g.done(arguments).fail(arguments), this
					},
					"catch": function(b) {
						return f.then(null, b)
					},
					pipe: function() {
						var b = arguments;
						return n.Deferred(function(c) {
							n.each(d, function(d, e) {
								var f = n.isFunction(b[e[4]]) && b[e[4]];
								g[e[1]](function() {
									var b = f && f.apply(this, arguments);
									b && n.isFunction(b.promise) ? b.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[e[0] + "With"](this, f ? [b] : arguments)
								})
							});
							b = null
						}).promise()
					},
					then: function(b, e, f) {
						function g(b, d, e, f) {
							return function() {
								var p = this,
									r = arguments,
									P = function() {
										var c, P;
										if (!(b < l)) {
											if (c = e.apply(p, r), c === d.promise()) throw new TypeError("Thenable self-resolution");
											P = c && ("object" == typeof c || "function" == typeof c) && c.then;
											n.isFunction(P) ? f ? P.call(c, g(l, d, m, f), g(l, d, j, f)) : (l++, P.call(c, g(l, d, m, f), g(l, d, j, f), g(l, d, m, d.notifyWith))) : (e !== m && (p = void 0, r = [c]), (f || d.resolveWith)(p, r))
										}
									},
									s = f ? P : function() {
										try {
											P()
										} catch (c) {
											n.Deferred.exceptionHook && n.Deferred.exceptionHook(c,
												s.stackTrace), b + 1 >= l && (e !== j && (p = void 0, r = [c]), d.rejectWith(p, r))
										}
									};
								b ? s() : (n.Deferred.getStackHook && (s.stackTrace = n.Deferred.getStackHook()), c.setTimeout(s))
							}
						}
						var l = 0;
						return n.Deferred(function(c) {
							d[0][3].add(g(0, c, n.isFunction(f) ? f : m, c.notifyWith));
							d[1][3].add(g(0, c, n.isFunction(b) ? b : m));
							d[2][3].add(g(0, c, n.isFunction(e) ? e : j))
						}).promise()
					},
					promise: function(b) {
						return null != b ? n.extend(b, f) : f
					}
				},
				g = {};
			return n.each(d, function(b, c) {
				var j = c[2],
					l = c[5];
				f[c[1]] = j.add;
				l && j.add(function() {
						e = l
					}, d[3 - b][2].disable,
					d[0][2].lock);
				j.add(c[3].fire);
				g[c[0]] = function() {
					return g[c[0] + "With"](this === g ? void 0 : this, arguments), this
				};
				g[c[0] + "With"] = j.fireWith
			}), f.promise(g), b && b.call(g, g), g
		},
		when: function(b) {
			var c = arguments.length,
				d = c,
				e = Array(d),
				f = ja.call(arguments),
				j = n.Deferred(),
				g = function(b) {
					return function(d) {
						e[b] = this;
						f[b] = 1 < arguments.length ? ja.call(arguments) : d;
						--c || j.resolveWith(e, f)
					}
				};
			if (1 >= c && (l(b, j.done(g(d)).resolve, j.reject, !c), "pending" === j.state() || n.isFunction(f[d] && f[d].then))) return j.then();
			for (; d--;) l(f[d],
				g(d), j.reject);
			return j.promise()
		}
	});
	var id = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	n.Deferred.exceptionHook = function(b, d) {
		c.console && c.console.warn && b && id.test(b.name) && c.console.warn("jQuery.Deferred exception: " + b.message, b.stack, d)
	};
	n.readyException = function(b) {
		c.setTimeout(function() {
			throw b;
		})
	};
	var Ub = n.Deferred();
	n.fn.ready = function(b) {
		return Ub.then(b)["catch"](function(b) {
			n.readyException(b)
		}), this
	};
	n.extend({
		isReady: !1,
		readyWait: 1,
		ready: function(b) {
			(!0 === b ? --n.readyWait :
				n.isReady) || (n.isReady = !0, !0 !== b && 0 < --n.readyWait || Ub.resolveWith(J, [n]))
		}
	});
	n.ready.then = Ub.then;
	"complete" === J.readyState || "loading" !== J.readyState && !J.documentElement.doScroll ? c.setTimeout(n.ready) : (J.addEventListener("DOMContentLoaded", p), c.addEventListener("load", p));
	var Na = function(b, c, d, e, f, j, g) {
			var l = 0,
				m = b.length,
				p = null == d;
			if ("object" === n.type(d))
				for (l in f = !0, d) Na(b, c, l, d[l], !0, j, g);
			else if (void 0 !== e && (f = !0, n.isFunction(e) || (g = !0), p && (g ? (c.call(b, e), c = null) : (p = c, c = function(b, c, d) {
					return p.call(n(b),
						d)
				})), c))
				for (; l < m; l++) c(b[l], d, g ? e : e.call(b[l], l, c(b[l], d)));
			return f ? b : p ? c.call(b) : m ? c(b[0], d) : j
		},
		Eb = function(b) {
			return 1 === b.nodeType || 9 === b.nodeType || !+b.nodeType
		};
	r.uid = 1;
	r.prototype = {
		cache: function(b) {
			var c = b[this.expando];
			return c || (c = {}, Eb(b) && (b.nodeType ? b[this.expando] = c : Object.defineProperty(b, this.expando, {
				value: c,
				configurable: !0
			}))), c
		},
		set: function(b, c, d) {
			var e;
			b = this.cache(b);
			if ("string" == typeof c) b[n.camelCase(c)] = d;
			else
				for (e in c) b[n.camelCase(e)] = c[e];
			return b
		},
		get: function(b, c) {
			return void 0 ===
				c ? this.cache(b) : b[this.expando] && b[this.expando][n.camelCase(c)]
		},
		access: function(b, c, d) {
			return void 0 === c || c && "string" == typeof c && void 0 === d ? this.get(b, c) : (this.set(b, c, d), void 0 !== d ? d : c)
		},
		remove: function(b, c) {
			var d, e = b[this.expando];
			if (void 0 !== e) {
				if (void 0 !== c) {
					Array.isArray(c) ? c = c.map(n.camelCase) : (c = n.camelCase(c), c = c in e ? [c] : c.match(xa) || []);
					for (d = c.length; d--;) delete e[c[d]]
				}(void 0 === c || n.isEmptyObject(e)) && (b.nodeType ? b[this.expando] = void 0 : delete b[this.expando])
			}
		},
		hasData: function(b) {
			b =
				b[this.expando];
			return void 0 !== b && !n.isEmptyObject(b)
		}
	};
	var L = new r,
		na = new r,
		Mc = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		Lc = /[A-Z]/g;
	n.extend({
		hasData: function(b) {
			return na.hasData(b) || L.hasData(b)
		},
		data: function(b, c, d) {
			return na.access(b, c, d)
		},
		removeData: function(b, c) {
			na.remove(b, c)
		},
		_data: function(b, c, d) {
			return L.access(b, c, d)
		},
		_removeData: function(b, c) {
			L.remove(b, c)
		}
	});
	n.fn.extend({
		data: function(b, c) {
			var d, e, f, j = this[0],
				g = j && j.attributes;
			if (void 0 === b) {
				if (this.length && (f = na.get(j), 1 === j.nodeType && !L.get(j,
						"hasDataAttrs"))) {
					for (d = g.length; d--;) g[d] && (e = g[d].name, 0 === e.indexOf("data-") && (e = n.camelCase(e.slice(5)), s(j, e, f[e])));
					L.set(j, "hasDataAttrs", !0)
				}
				return f
			}
			return "object" == typeof b ? this.each(function() {
				na.set(this, b)
			}) : Na(this, function(c) {
				var d;
				if (j && void 0 === c) {
					if ((d = na.get(j, b), void 0 !== d) || (d = s(j, b), void 0 !== d)) return d
				} else this.each(function() {
					na.set(this, b, c)
				})
			}, null, c, 1 < arguments.length, null, !0)
		},
		removeData: function(b) {
			return this.each(function() {
				na.remove(this, b)
			})
		}
	});
	n.extend({
		queue: function(b,
			c, d) {
			var e;
			if (b) return c = (c || "fx") + "queue", e = L.get(b, c), d && (!e || Array.isArray(d) ? e = L.access(b, c, n.makeArray(d)) : e.push(d)), e || []
		},
		dequeue: function(b, c) {
			c = c || "fx";
			var d = n.queue(b, c),
				e = d.length,
				f = d.shift(),
				j = n._queueHooks(b, c),
				g = function() {
					n.dequeue(b, c)
				};
			"inprogress" === f && (f = d.shift(), e--);
			f && ("fx" === c && d.unshift("inprogress"), delete j.stop, f.call(b, g, j));
			!e && j && j.empty.fire()
		},
		_queueHooks: function(b, c) {
			var d = c + "queueHooks";
			return L.get(b, d) || L.access(b, d, {
				empty: n.Callbacks("once memory").add(function() {
					L.remove(b, [c + "queue", d])
				})
			})
		}
	});
	n.fn.extend({
		queue: function(b, c) {
			var d = 2;
			return "string" != typeof b && (c = b, b = "fx", d--), arguments.length < d ? n.queue(this[0], b) : void 0 === c ? this : this.each(function() {
				var d = n.queue(this, b, c);
				n._queueHooks(this, b);
				"fx" === b && "inprogress" !== d[0] && n.dequeue(this, b)
			})
		},
		dequeue: function(b) {
			return this.each(function() {
				n.dequeue(this, b)
			})
		},
		clearQueue: function(b) {
			return this.queue(b || "fx", [])
		},
		promise: function(b, c) {
			var d, e = 1,
				f = n.Deferred(),
				j = this,
				g = this.length,
				l = function() {
					--e || f.resolveWith(j, [j])
				};
			"string" != typeof b && (c = b, b = void 0);
			for (b = b || "fx"; g--;)(d = L.get(j[g], b + "queueHooks")) && d.empty && (e++, d.empty.add(l));
			return l(), f.promise(c)
		}
	});
	var qc = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
		nb = RegExp("^(?:([+-])=|)(" + qc + ")([a-z%]*)$", "i"),
		$a = ["Top", "Right", "Bottom", "Left"],
		yb = function(b, c) {
			return b = c || b, "none" === b.style.display || "" === b.style.display && n.contains(b.ownerDocument, b) && "none" === n.css(b, "display")
		},
		rc = function(b, c, d, e) {
			var f, j = {};
			for (f in c) j[f] = b.style[f], b.style[f] = c[f];
			d =
				d.apply(b, e || []);
			for (f in c) b.style[f] = j[f];
			return d
		},
		cc = {};
	n.fn.extend({
		show: function() {
			return u(this, !0)
		},
		hide: function() {
			return u(this)
		},
		toggle: function(b) {
			return "boolean" == typeof b ? b ? this.show() : this.hide() : this.each(function() {
				yb(this) ? n(this).show() : n(this).hide()
			})
		}
	});
	var sc = /^(?:checkbox|radio)$/i,
		dc = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i,
		ec = /^$|\/(?:java|ecma)script/i,
		wa = {
			option: [1, "<select multiple='multiple'>", "</select>"],
			thead: [1, "<table>", "</table>"],
			col: [2, "<table><colgroup>", "</colgroup></table>"],
			tr: [2, "<table><tbody>", "</tbody></table>"],
			td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
			_default: [0, "", ""]
		};
	wa.optgroup = wa.option;
	wa.tbody = wa.tfoot = wa.colgroup = wa.caption = wa.thead;
	wa.th = wa.td;
	var Nc = /<|&#?\w+;/,
		Fb = J.createDocumentFragment().appendChild(J.createElement("div")),
		Gb = J.createElement("input");
	Gb.setAttribute("type", "radio");
	Gb.setAttribute("checked", "checked");
	Gb.setAttribute("name", "t");
	Fb.appendChild(Gb);
	V.checkClone = Fb.cloneNode(!0).cloneNode(!0).lastChild.checked;
	Fb.innerHTML =
		"<textarea>x</textarea>";
	V.noCloneChecked = !!Fb.cloneNode(!0).lastChild.defaultValue;
	!0;
	var Hb = J.documentElement,
		jd = /^key/,
		kd = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		tc = /^([^.]*)(?:\.(.+)|)/;
	n.event = {
		global: {},
		add: function(b, c, d, e, f) {
			var j, g, l, m, p, r, s, q, t, u;
			if (p = L.get(b)) {
				d.handler && (j = d, d = j.handler, f = j.selector);
				f && n.find.matchesSelector(Hb, f);
				d.guid || (d.guid = n.guid++);
				(m = p.events) || (m = p.events = {});
				(g = p.handle) || (g = p.handle = function(c) {
					return "undefined" != typeof n && n.event.triggered !== c.type ?
						n.event.dispatch.apply(b, arguments) : void 0
				});
				c = (c || "").match(xa) || [""];
				for (p = c.length; p--;) l = tc.exec(c[p]) || [], t = u = l[1], l = (l[2] || "").split(".").sort(), t && (s = n.event.special[t] || {}, t = (f ? s.delegateType : s.bindType) || t, s = n.event.special[t] || {}, r = n.extend({
					type: t,
					origType: u,
					data: e,
					handler: d,
					guid: d.guid,
					selector: f,
					needsContext: f && n.expr.match.needsContext.test(f),
					namespace: l.join(".")
				}, j), (q = m[t]) || (q = m[t] = [], q.delegateCount = 0, s.setup && !1 !== s.setup.call(b, e, l, g) || b.addEventListener && b.addEventListener(t,
					g)), s.add && (s.add.call(b, r), r.handler.guid || (r.handler.guid = d.guid)), f ? q.splice(q.delegateCount++, 0, r) : q.push(r), n.event.global[t] = !0)
			}
		},
		remove: function(b, c, d, e, f) {
			var j, g, l, m, p, r, s, q, t, u, x, v = L.hasData(b) && L.get(b);
			if (v && (m = v.events)) {
				c = (c || "").match(xa) || [""];
				for (p = c.length; p--;)
					if (l = tc.exec(c[p]) || [], t = x = l[1], u = (l[2] || "").split(".").sort(), t) {
						s = n.event.special[t] || {};
						t = (e ? s.delegateType : s.bindType) || t;
						q = m[t] || [];
						l = l[2] && RegExp("(^|\\.)" + u.join("\\.(?:.*\\.|)") + "(\\.|$)");
						for (g = j = q.length; j--;) r =
							q[j], !f && x !== r.origType || d && d.guid !== r.guid || l && !l.test(r.namespace) || e && e !== r.selector && ("**" !== e || !r.selector) || (q.splice(j, 1), r.selector && q.delegateCount--, s.remove && s.remove.call(b, r));
						g && !q.length && (s.teardown && !1 !== s.teardown.call(b, u, v.handle) || n.removeEvent(b, t, v.handle), delete m[t])
					} else
						for (t in m) n.event.remove(b, t + c[p], d, e, !0);
				n.isEmptyObject(m) && L.remove(b, "handle events")
			}
		},
		dispatch: function(b) {
			var c = n.event.fix(b),
				d, e, f, j, g, l, m = Array(arguments.length);
			e = (L.get(this, "events") || {})[c.type] ||
				[];
			var p = n.event.special[c.type] || {};
			m[0] = c;
			for (d = 1; d < arguments.length; d++) m[d] = arguments[d];
			if (c.delegateTarget = this, !p.preDispatch || !1 !== p.preDispatch.call(this, c)) {
				l = n.event.handlers.call(this, c, e);
				for (d = 0;
					(j = l[d++]) && !c.isPropagationStopped();) {
					c.currentTarget = j.elem;
					for (e = 0;
						(g = j.handlers[e++]) && !c.isImmediatePropagationStopped();) c.rnamespace && !c.rnamespace.test(g.namespace) || (c.handleObj = g, c.data = g.data, f = ((n.event.special[g.origType] || {}).handle || g.handler).apply(j.elem, m), void 0 !== f && !1 ===
						(c.result = f) && (c.preventDefault(), c.stopPropagation()))
				}
				return p.postDispatch && p.postDispatch.call(this, c), c.result
			}
		},
		handlers: function(b, c) {
			var d, e, f, j, g, l = [],
				m = c.delegateCount,
				p = b.target;
			if (m && p.nodeType && !("click" === b.type && 1 <= b.button))
				for (; p !== this; p = p.parentNode || this)
					if (1 === p.nodeType && ("click" !== b.type || !0 !== p.disabled)) {
						j = [];
						g = {};
						for (d = 0; d < m; d++) e = c[d], f = e.selector + " ", void 0 === g[f] && (g[f] = e.needsContext ? -1 < n(f, this).index(p) : n.find(f, this, null, [p]).length), g[f] && j.push(e);
						j.length && l.push({
							elem: p,
							handlers: j
						})
					}
			return p = this, m < c.length && l.push({
				elem: p,
				handlers: c.slice(m)
			}), l
		},
		addProp: function(b, c) {
			Object.defineProperty(n.Event.prototype, b, {
				enumerable: !0,
				configurable: !0,
				get: n.isFunction(c) ? function() {
					if (this.originalEvent) return c(this.originalEvent)
				} : function() {
					if (this.originalEvent) return this.originalEvent[b]
				},
				set: function(c) {
					Object.defineProperty(this, b, {
						enumerable: !0,
						configurable: !0,
						writable: !0,
						value: c
					})
				}
			})
		},
		fix: function(b) {
			return b[n.expando] ? b : new n.Event(b)
		},
		special: {
			load: {
				noBubble: !0
			},
			focus: {
				trigger: function() {
					if (this !== A() && this.focus) return this.focus(), !1
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if (this === A() && this.blur) return this.blur(), !1
				},
				delegateType: "focusout"
			},
			click: {
				trigger: function() {
					if ("checkbox" === this.type && this.click && f(this, "input")) return this.click(), !1
				},
				_default: function(b) {
					return f(b.target, "a")
				}
			},
			beforeunload: {
				postDispatch: function(b) {
					void 0 !== b.result && b.originalEvent && (b.originalEvent.returnValue = b.result)
				}
			}
		}
	};
	n.removeEvent = function(b, c, d) {
		b.removeEventListener &&
			b.removeEventListener(c, d)
	};
	n.Event = function(b, c) {
		return this instanceof n.Event ? (b && b.type ? (this.originalEvent = b, this.type = b.type, this.isDefaultPrevented = b.defaultPrevented || void 0 === b.defaultPrevented && !1 === b.returnValue ? B : y, this.target = b.target && 3 === b.target.nodeType ? b.target.parentNode : b.target, this.currentTarget = b.currentTarget, this.relatedTarget = b.relatedTarget) : this.type = b, c && n.extend(this, c), this.timeStamp = b && b.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(b, c)
	};
	n.Event.prototype = {
		constructor: n.Event,
		isDefaultPrevented: y,
		isPropagationStopped: y,
		isImmediatePropagationStopped: y,
		isSimulated: !1,
		preventDefault: function() {
			var b = this.originalEvent;
			this.isDefaultPrevented = B;
			b && !this.isSimulated && b.preventDefault()
		},
		stopPropagation: function() {
			var b = this.originalEvent;
			this.isPropagationStopped = B;
			b && !this.isSimulated && b.stopPropagation()
		},
		stopImmediatePropagation: function() {
			var b = this.originalEvent;
			this.isImmediatePropagationStopped = B;
			b && !this.isSimulated && b.stopImmediatePropagation();
			this.stopPropagation()
		}
	};
	n.each({
		altKey: !0,
		bubbles: !0,
		cancelable: !0,
		changedTouches: !0,
		ctrlKey: !0,
		detail: !0,
		eventPhase: !0,
		metaKey: !0,
		pageX: !0,
		pageY: !0,
		shiftKey: !0,
		view: !0,
		"char": !0,
		charCode: !0,
		key: !0,
		keyCode: !0,
		button: !0,
		buttons: !0,
		clientX: !0,
		clientY: !0,
		offsetX: !0,
		offsetY: !0,
		pointerId: !0,
		pointerType: !0,
		screenX: !0,
		screenY: !0,
		targetTouches: !0,
		toElement: !0,
		touches: !0,
		which: function(b) {
			var c = b.button;
			return null == b.which && jd.test(b.type) ? null != b.charCode ? b.charCode : b.keyCode : !b.which && void 0 !== c && kd.test(b.type) ?
				1 & c ? 1 : 2 & c ? 3 : 4 & c ? 2 : 0 : b.which
		}
	}, n.event.addProp);
	n.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function(b, c) {
		n.event.special[b] = {
			delegateType: c,
			bindType: c,
			handle: function(b) {
				var d, e = b.relatedTarget,
					f = b.handleObj;
				return e && (e === this || n.contains(this, e)) || (b.type = f.origType, d = f.handler.apply(this, arguments), b.type = c), d
			}
		}
	});
	n.fn.extend({
		on: function(b, c, d, e) {
			return F(this, b, c, d, e)
		},
		one: function(b, c, d, e) {
			return F(this, b, c, d, e, 1)
		},
		off: function(b,
			c, d) {
			var e, f;
			if (b && b.preventDefault && b.handleObj) return e = b.handleObj, n(b.delegateTarget).off(e.namespace ? e.origType + "." + e.namespace : e.origType, e.selector, e.handler), this;
			if ("object" == typeof b) {
				for (f in b) this.off(f, c, b[f]);
				return this
			}
			return !1 !== c && "function" != typeof c || (d = c, c = void 0), !1 === d && (d = y), this.each(function() {
				n.event.remove(this, b, d, c)
			})
		}
	});
	var ld = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
		md = /<script|<style|<link/i,
		Pc = /checked\s*(?:[^=]|=\s*.checked.)/i,
		Oc = /^true\/(.*)/,
		Rc = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	n.extend({
		htmlPrefilter: function(b) {
			return b.replace(ld, "<$1></$2>")
		},
		clone: function(b, c, d) {
			var e, f, j, g, l = b.cloneNode(!0),
				m = n.contains(b.ownerDocument, b);
			if (!V.noCloneChecked && !(1 !== b.nodeType && 11 !== b.nodeType || n.isXMLDoc(b))) {
				g = x(l);
				j = x(b);
				e = 0;
				for (f = j.length; e < f; e++) {
					var p = j[e],
						r = g[e],
						s = r.nodeName.toLowerCase();
					"input" === s && sc.test(p.type) ? r.checked = p.checked : "input" !== s && "textarea" !== s || (r.defaultValue = p.defaultValue)
				}
			}
			if (c)
				if (d) {
					j =
						j || x(b);
					g = g || x(l);
					e = 0;
					for (f = j.length; e < f; e++) N(j[e], g[e])
				} else N(b, l);
			return g = x(l, "script"), 0 < g.length && z(g, !m && x(b, "script")), l
		},
		cleanData: function(b) {
			for (var c, d, e, f = n.event.special, j = 0; void 0 !== (d = b[j]); j++)
				if (Eb(d)) {
					if (c = d[L.expando]) {
						if (c.events)
							for (e in c.events) f[e] ? n.event.remove(d, e) : n.removeEvent(d, e, c.handle);
						d[L.expando] = void 0
					}
					d[na.expando] && (d[na.expando] = void 0)
				}
		}
	});
	n.fn.extend({
		detach: function(b) {
			return O(this, b, !0)
		},
		remove: function(b) {
			return O(this, b)
		},
		text: function(b) {
			return Na(this,
				function(b) {
					return void 0 === b ? n.text(this) : this.empty().each(function() {
						1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = b)
					})
				}, null, b, arguments.length)
		},
		append: function() {
			return K(this, arguments, function(b) {
				(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && C(this, b).appendChild(b)
			})
		},
		prepend: function() {
			return K(this, arguments, function(b) {
				if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
					var c = C(this, b);
					c.insertBefore(b, c.firstChild)
				}
			})
		},
		before: function() {
			return K(this,
				arguments,
				function(b) {
					this.parentNode && this.parentNode.insertBefore(b, this)
				})
		},
		after: function() {
			return K(this, arguments, function(b) {
				this.parentNode && this.parentNode.insertBefore(b, this.nextSibling)
			})
		},
		empty: function() {
			for (var b, c = 0; null != (b = this[c]); c++) 1 === b.nodeType && (n.cleanData(x(b, !1)), b.textContent = "");
			return this
		},
		clone: function(b, c) {
			return b = null != b && b, c = null == c ? b : c, this.map(function() {
				return n.clone(this, b, c)
			})
		},
		html: function(b) {
			return Na(this, function(b) {
				var c = this[0] || {},
					d = 0,
					e = this.length;
				if (void 0 === b && 1 === c.nodeType) return c.innerHTML;
				if ("string" == typeof b && !md.test(b) && !wa[(dc.exec(b) || ["", ""])[1].toLowerCase()]) {
					b = n.htmlPrefilter(b);
					try {
						for (; d < e; d++) c = this[d] || {}, 1 === c.nodeType && (n.cleanData(x(c, !1)), c.innerHTML = b);
						c = 0
					} catch (f) {}
				}
				c && this.empty().append(b)
			}, null, b, arguments.length)
		},
		replaceWith: function() {
			var b = [];
			return K(this, arguments, function(c) {
				var d = this.parentNode;
				0 > n.inArray(this, b) && (n.cleanData(x(this)), d && d.replaceChild(c, this))
			}, b)
		}
	});
	n.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function(b, c) {
		n.fn[b] = function(b) {
			for (var d = [], e = n(b), f = e.length - 1, j = 0; j <= f; j++) b = j === f ? this : this.clone(!0), n(e[j])[c](b), Oa.apply(d, b.get());
			return this.pushStack(d)
		}
	});
	var fc = /^margin/,
		Qb = RegExp("^(" + qc + ")(?!px)[a-z%]+$", "i"),
		zb = function(b) {
			var d = b.ownerDocument.defaultView;
			return d && d.opener || (d = c), d.getComputedStyle(b)
		},
		Jb = function() {
			if (Ca) {
				Ca.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%";
				Ca.innerHTML = "";
				Hb.appendChild(Ib);
				var b = c.getComputedStyle(Ca);
				uc = "1%" !== b.top;
				vc = "2px" === b.marginLeft;
				wc = "4px" === b.width;
				Ca.style.marginRight = "50%";
				xc = "4px" === b.marginRight;
				Hb.removeChild(Ib);
				Ca = null
			}
		},
		uc, wc, xc, vc, Ib = J.createElement("div"),
		Ca = J.createElement("div");
	Ca.style && (Ca.style.backgroundClip = "content-box", Ca.cloneNode(!0).style.backgroundClip = "", V.clearCloneStyle = "content-box" === Ca.style.backgroundClip, Ib.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",
		Ib.appendChild(Ca), n.extend(V, {
			pixelPosition: function() {
				return Jb(), uc
			},
			boxSizingReliable: function() {
				return Jb(), wc
			},
			pixelMarginRight: function() {
				return Jb(), xc
			},
			reliableMarginLeft: function() {
				return Jb(), vc
			}
		}));
	!0;
	var nd = /^(none|table(?!-c[ea]).+)/,
		yc = /^--/,
		od = {
			position: "absolute",
			visibility: "hidden",
			display: "block"
		},
		zc = {
			letterSpacing: "0",
			fontWeight: "400"
		},
		hc = ["Webkit", "Moz", "ms"],
		gc = J.createElement("div").style;
	n.extend({
		cssHooks: {
			opacity: {
				get: function(b, c) {
					if (c) {
						var d = H(b, "opacity");
						return "" === d ?
							"1" : d
					}
				}
			}
		},
		cssNumber: {
			animationIterationCount: !0,
			columnCount: !0,
			fillOpacity: !0,
			flexGrow: !0,
			flexShrink: !0,
			fontWeight: !0,
			lineHeight: !0,
			opacity: !0,
			order: !0,
			orphans: !0,
			widows: !0,
			zIndex: !0,
			zoom: !0
		},
		cssProps: {
			"float": "cssFloat"
		},
		style: function(b, c, d, e) {
			if (b && 3 !== b.nodeType && 8 !== b.nodeType && b.style) {
				var f, j, g, l = n.camelCase(c),
					m = yc.test(c),
					p = b.style;
				return m || (c = aa(l)), g = n.cssHooks[c] || n.cssHooks[l], void 0 === d ? g && "get" in g && void 0 !== (f = g.get(b, !1, e)) ? f : p[c] : (j = typeof d, "string" === j && (f = nb.exec(d)) && f[1] &&
					(d = t(b, c, f), j = "number"), null != d && d === d && ("number" === j && (d += f && f[3] || (n.cssNumber[l] ? "" : "px")), V.clearCloneStyle || "" !== d || 0 !== c.indexOf("background") || (p[c] = "inherit"), g && "set" in g && void 0 === (d = g.set(b, d, e)) || (m ? p.setProperty(c, d) : p[c] = d)), void 0)
			}
		},
		css: function(b, c, d, e) {
			var f, j, g, l = n.camelCase(c);
			return yc.test(c) || (c = aa(l)), g = n.cssHooks[c] || n.cssHooks[l], g && "get" in g && (f = g.get(b, !0, d)), void 0 === f && (f = H(b, c, e)), "normal" === f && c in zc && (f = zc[c]), "" === d || d ? (j = parseFloat(f), !0 === d || isFinite(j) ? j || 0 : f) :
				f
		}
	});
	n.each(["height", "width"], function(b, c) {
		n.cssHooks[c] = {
			get: function(b, d, e) {
				if (d) return !nd.test(n.css(b, "display")) || b.getClientRects().length && b.getBoundingClientRect().width ? ba(b, c, e) : rc(b, od, function() {
					return ba(b, c, e)
				})
			},
			set: function(b, d, e) {
				var f, j = e && zb(b);
				e = e && G(b, c, e, "border-box" === n.css(b, "boxSizing", !1, j), j);
				return e && (f = nb.exec(d)) && "px" !== (f[3] || "px") && (b.style[c] = d, d = n.css(b, c)), E(b, d, e)
			}
		}
	});
	n.cssHooks.marginLeft = W(V.reliableMarginLeft, function(b, c) {
		if (c) return (parseFloat(H(b, "marginLeft")) ||
			b.getBoundingClientRect().left - rc(b, {
				marginLeft: 0
			}, function() {
				return b.getBoundingClientRect().left
			})) + "px"
	});
	n.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function(b, c) {
		n.cssHooks[b + c] = {
			expand: function(d) {
				var e = 0,
					f = {};
				for (d = "string" == typeof d ? d.split(" ") : [d]; 4 > e; e++) f[b + $a[e] + c] = d[e] || d[e - 2] || d[0];
				return f
			}
		};
		fc.test(b) || (n.cssHooks[b + c].set = E)
	});
	n.fn.extend({
		css: function(b, c) {
			return Na(this, function(b, c, d) {
				var e, f = {},
					j = 0;
				if (Array.isArray(c)) {
					d = zb(b);
					for (e = c.length; j < e; j++) f[c[j]] = n.css(b, c[j], !1,
						d);
					return f
				}
				return void 0 !== d ? n.style(b, c, d) : n.css(b, c)
			}, b, c, 1 < arguments.length)
		}
	});
	n.Tween = Q;
	Q.prototype = {
		constructor: Q,
		init: function(b, c, d, e, f, j) {
			this.elem = b;
			this.prop = d;
			this.easing = f || n.easing._default;
			this.options = c;
			this.start = this.now = this.cur();
			this.end = e;
			this.unit = j || (n.cssNumber[d] ? "" : "px")
		},
		cur: function() {
			var b = Q.propHooks[this.prop];
			return b && b.get ? b.get(this) : Q.propHooks._default.get(this)
		},
		run: function(b) {
			var c, d = Q.propHooks[this.prop];
			return this.options.duration ? this.pos = c = n.easing[this.easing](b,
				this.options.duration * b, 0, 1, this.options.duration) : this.pos = c = b, this.now = (this.end - this.start) * c + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), d && d.set ? d.set(this) : Q.propHooks._default.set(this), this
		}
	};
	Q.prototype.init.prototype = Q.prototype;
	Q.propHooks = {
		_default: {
			get: function(b) {
				var c;
				return 1 !== b.elem.nodeType || null != b.elem[b.prop] && null == b.elem.style[b.prop] ? b.elem[b.prop] : (c = n.css(b.elem, b.prop, ""), c && "auto" !== c ? c : 0)
			},
			set: function(b) {
				n.fx.step[b.prop] ? n.fx.step[b.prop](b) :
					1 !== b.elem.nodeType || null == b.elem.style[n.cssProps[b.prop]] && !n.cssHooks[b.prop] ? b.elem[b.prop] = b.now : n.style(b.elem, b.prop, b.now + b.unit)
			}
		}
	};
	Q.propHooks.scrollTop = Q.propHooks.scrollLeft = {
		set: function(b) {
			b.elem.nodeType && b.elem.parentNode && (b.elem[b.prop] = b.now)
		}
	};
	n.easing = {
		linear: function(b) {
			return b
		},
		swing: function(b) {
			return 0.5 - Math.cos(b * Math.PI) / 2
		},
		_default: "swing"
	};
	n.fx = Q.prototype.init;
	n.fx.step = {};
	var hb, Ab, pd = /^(?:toggle|show|hide)$/,
		qd = /queueHooks$/;
	n.Animation = n.extend(Y, {
		tweeners: {
			"*": [function(b,
				c) {
				var d = this.createTween(b, c);
				return t(d.elem, b, nb.exec(c), d), d
			}]
		},
		tweener: function(b, c) {
			n.isFunction(b) ? (c = b, b = ["*"]) : b = b.match(xa);
			for (var d, e = 0, f = b.length; e < f; e++) d = b[e], Y.tweeners[d] = Y.tweeners[d] || [], Y.tweeners[d].unshift(c)
		},
		prefilters: [function(b, c, d) {
			var e, f, j, g, l, m, p, r, s = "width" in c || "height" in c,
				q = this,
				t = {},
				x = b.style,
				v = b.nodeType && yb(b),
				y = L.get(b, "fxshow");
			d.queue || (g = n._queueHooks(b, "fx"), null == g.unqueued && (g.unqueued = 0, l = g.empty.fire, g.empty.fire = function() {
					g.unqueued || l()
				}), g.unqueued++,
				q.always(function() {
					q.always(function() {
						g.unqueued--;
						n.queue(b, "fx").length || g.empty.fire()
					})
				}));
			for (e in c)
				if (f = c[e], pd.test(f)) {
					if (delete c[e], j = j || "toggle" === f, f === (v ? "hide" : "show")) {
						if ("show" !== f || !y || void 0 === y[e]) continue;
						v = !0
					}
					t[e] = y && y[e] || n.style(b, e)
				}
			if (m = !n.isEmptyObject(c), m || !n.isEmptyObject(t))
				for (e in s && 1 === b.nodeType && (d.overflow = [x.overflow, x.overflowX, x.overflowY], p = y && y.display, null == p && (p = L.get(b, "display")), r = n.css(b, "display"), "none" === r && (p ? r = p : (u([b], !0), p = b.style.display ||
						p, r = n.css(b, "display"), u([b]))), ("inline" === r || "inline-block" === r && null != p) && "none" === n.css(b, "float") && (m || (q.done(function() {
						x.display = p
					}), null == p && (r = x.display, p = "none" === r ? "" : r)), x.display = "inline-block")), d.overflow && (x.overflow = "hidden", q.always(function() {
						x.overflow = d.overflow[0];
						x.overflowX = d.overflow[1];
						x.overflowY = d.overflow[2]
					})), m = !1, t) m || (y ? "hidden" in y && (v = y.hidden) : y = L.access(b, "fxshow", {
					display: p
				}), j && (y.hidden = !v), v && u([b], !0), q.done(function() {
					v || u([b]);
					L.remove(b, "fxshow");
					for (e in t) n.style(b,
						e, t[e])
				})), m = ha(v ? y[e] : 0, e, q), e in y || (y[e] = m.start, v && (m.end = m.start, m.start = 0))
		}],
		prefilter: function(b, c) {
			c ? Y.prefilters.unshift(b) : Y.prefilters.push(b)
		}
	});
	n.speed = function(b, c, d) {
		var e = b && "object" == typeof b ? n.extend({}, b) : {
			complete: d || !d && c || n.isFunction(b) && b,
			duration: b,
			easing: d && c || c && !n.isFunction(c) && c
		};
		return n.fx.off ? e.duration = 0 : "number" != typeof e.duration && (e.duration in n.fx.speeds ? e.duration = n.fx.speeds[e.duration] : e.duration = n.fx.speeds._default), null != e.queue && !0 !== e.queue || (e.queue =
			"fx"), e.old = e.complete, e.complete = function() {
			n.isFunction(e.old) && e.old.call(this);
			e.queue && n.dequeue(this, e.queue)
		}, e
	};
	n.fn.extend({
		fadeTo: function(b, c, d, e) {
			return this.filter(yb).css("opacity", 0).show().end().animate({
				opacity: c
			}, b, d, e)
		},
		animate: function(b, c, d, e) {
			var f = n.isEmptyObject(b),
				j = n.speed(c, d, e);
			c = function() {
				var c = Y(this, n.extend({}, b), j);
				(f || L.get(this, "finish")) && c.stop(!0)
			};
			return c.finish = c, f || !1 === j.queue ? this.each(c) : this.queue(j.queue, c)
		},
		stop: function(b, c, d) {
			var e = function(b) {
				var c =
					b.stop;
				delete b.stop;
				c(d)
			};
			return "string" != typeof b && (d = c, c = b, b = void 0), c && !1 !== b && this.queue(b || "fx", []), this.each(function() {
				var c = !0,
					f = null != b && b + "queueHooks",
					j = n.timers,
					g = L.get(this);
				if (f) g[f] && g[f].stop && e(g[f]);
				else
					for (f in g) g[f] && g[f].stop && qd.test(f) && e(g[f]);
				for (f = j.length; f--;) j[f].elem !== this || null != b && j[f].queue !== b || (j[f].anim.stop(d), c = !1, j.splice(f, 1));
				!c && d || n.dequeue(this, b)
			})
		},
		finish: function(b) {
			return !1 !== b && (b = b || "fx"), this.each(function() {
				var c, d = L.get(this),
					e = d[b + "queue"];
				c = d[b + "queueHooks"];
				var f = n.timers,
					j = e ? e.length : 0;
				d.finish = !0;
				n.queue(this, b, []);
				c && c.stop && c.stop.call(this, !0);
				for (c = f.length; c--;) f[c].elem === this && f[c].queue === b && (f[c].anim.stop(!0), f.splice(c, 1));
				for (c = 0; c < j; c++) e[c] && e[c].finish && e[c].finish.call(this);
				delete d.finish
			})
		}
	});
	n.each(["toggle", "show", "hide"], function(b, c) {
		var d = n.fn[c];
		n.fn[c] = function(b, e, f) {
			return null == b || "boolean" == typeof b ? d.apply(this, arguments) : this.animate(T(c, !0), b, e, f)
		}
	});
	n.each({
		slideDown: T("show"),
		slideUp: T("hide"),
		slideToggle: T("toggle"),
		fadeIn: {
			opacity: "show"
		},
		fadeOut: {
			opacity: "hide"
		},
		fadeToggle: {
			opacity: "toggle"
		}
	}, function(b, c) {
		n.fn[b] = function(b, d, e) {
			return this.animate(c, b, d, e)
		}
	});
	n.timers = [];
	n.fx.tick = function() {
		var b, c = 0,
			d = n.timers;
		for (hb = n.now(); c < d.length; c++) b = d[c], b() || d[c] !== b || d.splice(c--, 1);
		d.length || n.fx.stop();
		hb = void 0
	};
	n.fx.timer = function(b) {
		n.timers.push(b);
		n.fx.start()
	};
	n.fx.interval = 13;
	n.fx.start = function() {
		Ab || (Ab = !0, ca())
	};
	n.fx.stop = function() {
		Ab = null
	};
	n.fx.speeds = {
		slow: 600,
		fast: 200,
		_default: 400
	};
	n.fn.delay = function(b, d) {
		return b = n.fx ? n.fx.speeds[b] || b : b, d = d || "fx", this.queue(d, function(d, e) {
			var f = c.setTimeout(d, b);
			e.stop = function() {
				c.clearTimeout(f)
			}
		})
	};
	var jb = J.createElement("input"),
		rd = J.createElement("select").appendChild(J.createElement("option"));
	jb.type = "checkbox";
	V.checkOn = "" !== jb.value;
	V.optSelected = rd.selected;
	jb = J.createElement("input");
	jb.value = "t";
	jb.type = "radio";
	V.radioValue = "t" === jb.value;
	var Ac, pb = n.expr.attrHandle;
	n.fn.extend({
		attr: function(b, c) {
			return Na(this,
				n.attr, b, c, 1 < arguments.length)
		},
		removeAttr: function(b) {
			return this.each(function() {
				n.removeAttr(this, b)
			})
		}
	});
	n.extend({
		attr: function(b, c, d) {
			var e, f, j = b.nodeType;
			if (3 !== j && 8 !== j && 2 !== j) return "undefined" == typeof b.getAttribute ? n.prop(b, c, d) : (1 === j && n.isXMLDoc(b) || (f = n.attrHooks[c.toLowerCase()] || (n.expr.match.bool.test(c) ? Ac : void 0)), void 0 !== d ? null === d ? void n.removeAttr(b, c) : f && "set" in f && void 0 !== (e = f.set(b, d, c)) ? e : (b.setAttribute(c, d + ""), d) : f && "get" in f && null !== (e = f.get(b, c)) ? e : (e = n.find.attr(b,
				c), null == e ? void 0 : e))
		},
		attrHooks: {
			type: {
				set: function(b, c) {
					if (!V.radioValue && "radio" === c && f(b, "input")) {
						var d = b.value;
						return b.setAttribute("type", c), d && (b.value = d), c
					}
				}
			}
		},
		removeAttr: function(b, c) {
			var d, e = 0,
				f = c && c.match(xa);
			if (f && 1 === b.nodeType)
				for (; d = f[e++];) b.removeAttribute(d)
		}
	});
	Ac = {
		set: function(b, c, d) {
			return !1 === c ? n.removeAttr(b, d) : b.setAttribute(d, d), d
		}
	};
	n.each(n.expr.match.bool.source.match(/\w+/g), function(b, c) {
		var d = pb[c] || n.find.attr;
		pb[c] = function(b, c, e) {
			var f, j, g = c.toLowerCase();
			return e ||
				(j = pb[g], pb[g] = f, f = null != d(b, c, e) ? g : null, pb[g] = j), f
		}
	});
	var sd = /^(?:input|select|textarea|button)$/i,
		td = /^(?:a|area)$/i;
	n.fn.extend({
		prop: function(b, c) {
			return Na(this, n.prop, b, c, 1 < arguments.length)
		},
		removeProp: function(b) {
			return this.each(function() {
				delete this[n.propFix[b] || b]
			})
		}
	});
	n.extend({
		prop: function(b, c, d) {
			var e, f, j = b.nodeType;
			if (3 !== j && 8 !== j && 2 !== j) return 1 === j && n.isXMLDoc(b) || (c = n.propFix[c] || c, f = n.propHooks[c]), void 0 !== d ? f && "set" in f && void 0 !== (e = f.set(b, d, c)) ? e : b[c] = d : f && "get" in f && null !==
				(e = f.get(b, c)) ? e : b[c]
		},
		propHooks: {
			tabIndex: {
				get: function(b) {
					var c = n.find.attr(b, "tabindex");
					return c ? parseInt(c, 10) : sd.test(b.nodeName) || td.test(b.nodeName) && b.href ? 0 : -1
				}
			}
		},
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	});
	V.optSelected || (n.propHooks.selected = {
		get: function(b) {
			b = b.parentNode;
			return b && b.parentNode && b.parentNode.selectedIndex, null
		},
		set: function(b) {
			b = b.parentNode;
			b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
		}
	});
	n.each("tabIndex readOnly maxLength cellSpacing cellPadding rowSpan colSpan useMap frameBorder contentEditable".split(" "),
		function() {
			n.propFix[this.toLowerCase()] = this
		});
	n.fn.extend({
		addClass: function(b) {
			var c, d, e, f, j, g, l = 0;
			if (n.isFunction(b)) return this.each(function(c) {
				n(this).addClass(b.call(this, c, ra(this)))
			});
			if ("string" == typeof b && b)
				for (c = b.match(xa) || []; d = this[l++];)
					if (f = ra(d), e = 1 === d.nodeType && " " + la(f) + " ") {
						for (g = 0; j = c[g++];) 0 > e.indexOf(" " + j + " ") && (e += j + " ");
						e = la(e);
						f !== e && d.setAttribute("class", e)
					}
			return this
		},
		removeClass: function(b) {
			var c, d, e, f, j, g, l = 0;
			if (n.isFunction(b)) return this.each(function(c) {
				n(this).removeClass(b.call(this,
					c, ra(this)))
			});
			if (!arguments.length) return this.attr("class", "");
			if ("string" == typeof b && b)
				for (c = b.match(xa) || []; d = this[l++];)
					if (f = ra(d), e = 1 === d.nodeType && " " + la(f) + " ") {
						for (g = 0; j = c[g++];)
							for (; - 1 < e.indexOf(" " + j + " ");) e = e.replace(" " + j + " ", " ");
						e = la(e);
						f !== e && d.setAttribute("class", e)
					}
			return this
		},
		toggleClass: function(b, c) {
			var d = typeof b;
			return "boolean" == typeof c && "string" === d ? c ? this.addClass(b) : this.removeClass(b) : n.isFunction(b) ? this.each(function(d) {
				n(this).toggleClass(b.call(this, d, ra(this), c),
					c)
			}) : this.each(function() {
				var c, e, f, j;
				if ("string" === d) {
					e = 0;
					f = n(this);
					for (j = b.match(xa) || []; c = j[e++];) f.hasClass(c) ? f.removeClass(c) : f.addClass(c)
				} else void 0 !== b && "boolean" !== d || (c = ra(this), c && L.set(this, "__className__", c), this.setAttribute && this.setAttribute("class", c || !1 === b ? "" : L.get(this, "__className__") || ""))
			})
		},
		hasClass: function(b) {
			var c, d = 0;
			for (b = " " + b + " "; c = this[d++];)
				if (1 === c.nodeType && -1 < (" " + la(ra(c)) + " ").indexOf(b)) return !0;
			return !1
		}
	});
	var ud = /\r/g;
	n.fn.extend({
		val: function(b) {
			var c, d,
				e, f = this[0];
			if (arguments.length) return e = n.isFunction(b), this.each(function(d) {
				var f;
				1 === this.nodeType && (f = e ? b.call(this, d, n(this).val()) : b, null == f ? f = "" : "number" == typeof f ? f += "" : Array.isArray(f) && (f = n.map(f, function(b) {
					return null == b ? "" : b + ""
				})), c = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], c && "set" in c && void 0 !== c.set(this, f, "value") || (this.value = f))
			});
			if (f) return c = n.valHooks[f.type] || n.valHooks[f.nodeName.toLowerCase()], c && "get" in c && void 0 !== (d = c.get(f, "value")) ? d : (d = f.value,
				"string" == typeof d ? d.replace(ud, "") : null == d ? "" : d)
		}
	});
	n.extend({
		valHooks: {
			option: {
				get: function(b) {
					var c = n.find.attr(b, "value");
					return null != c ? c : la(n.text(b))
				}
			},
			select: {
				get: function(b) {
					var c, d, e = b.options,
						j = b.selectedIndex,
						g = "select-one" === b.type,
						l = g ? null : [],
						m = g ? j + 1 : e.length;
					for (d = 0 > j ? m : g ? j : 0; d < m; d++)
						if (c = e[d], (c.selected || d === j) && !c.disabled && (!c.parentNode.disabled || !f(c.parentNode, "optgroup"))) {
							if (b = n(c).val(), g) return b;
							l.push(b)
						}
					return l
				},
				set: function(b, c) {
					for (var d, e, f = b.options, j = n.makeArray(c),
							g = f.length; g--;) e = f[g], (e.selected = -1 < n.inArray(n.valHooks.option.get(e), j)) && (d = !0);
					return d || (b.selectedIndex = -1), j
				}
			}
		}
	});
	n.each(["radio", "checkbox"], function() {
		n.valHooks[this] = {
			set: function(b, c) {
				if (Array.isArray(c)) return b.checked = -1 < n.inArray(n(b).val(), c)
			}
		};
		V.checkOn || (n.valHooks[this].get = function(b) {
			return null === b.getAttribute("value") ? "on" : b.value
		})
	});
	var Bc = /^(?:focusinfocus|focusoutblur)$/;
	n.extend(n.event, {
		trigger: function(b, d, e, f) {
			var j, g, l, m, p, r, s, q = [e || J],
				t = db.call(b, "type") ? b.type :
				b;
			j = db.call(b, "namespace") ? b.namespace.split(".") : [];
			if (g = l = e = e || J, 3 !== e.nodeType && 8 !== e.nodeType && !Bc.test(t + n.event.triggered) && (-1 < t.indexOf(".") && (j = t.split("."), t = j.shift(), j.sort()), p = 0 > t.indexOf(":") && "on" + t, b = b[n.expando] ? b : new n.Event(t, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = j.join("."), b.rnamespace = b.namespace ? RegExp("(^|\\.)" + j.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), d = null == d ? [b] : n.makeArray(d, [b]), s = n.event.special[t] || {}, f || !s.trigger ||
					!1 !== s.trigger.apply(e, d))) {
				if (!f && !s.noBubble && !n.isWindow(e)) {
					m = s.delegateType || t;
					for (Bc.test(m + t) || (g = g.parentNode); g; g = g.parentNode) q.push(g), l = g;
					l === (e.ownerDocument || J) && q.push(l.defaultView || l.parentWindow || c)
				}
				for (j = 0;
					(g = q[j++]) && !b.isPropagationStopped();) b.type = 1 < j ? m : s.bindType || t, (r = (L.get(g, "events") || {})[b.type] && L.get(g, "handle")) && r.apply(g, d), (r = p && g[p]) && r.apply && Eb(g) && (b.result = r.apply(g, d), !1 === b.result && b.preventDefault());
				return b.type = t, f || b.isDefaultPrevented() || s._default &&
					!1 !== s._default.apply(q.pop(), d) || !Eb(e) || p && n.isFunction(e[t]) && !n.isWindow(e) && (l = e[p], l && (e[p] = null), n.event.triggered = t, e[t](), n.event.triggered = void 0, l && (e[p] = l)), b.result
			}
		},
		simulate: function(b, c, d) {
			b = n.extend(new n.Event, d, {
				type: b,
				isSimulated: !0
			});
			n.event.trigger(b, null, c)
		}
	});
	n.fn.extend({
		trigger: function(b, c) {
			return this.each(function() {
				n.event.trigger(b, c, this)
			})
		},
		triggerHandler: function(b, c) {
			var d = this[0];
			if (d) return n.event.trigger(b, c, d, !0)
		}
	});
	n.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
		function(b, c) {
			n.fn[c] = function(b, d) {
				return 0 < arguments.length ? this.on(c, null, b, d) : this.trigger(c)
			}
		});
	n.fn.extend({
		hover: function(b, c) {
			return this.mouseenter(b).mouseleave(c || b)
		}
	});
	V.focusin = "onfocusin" in c;
	V.focusin || n.each({
		focus: "focusin",
		blur: "focusout"
	}, function(b, c) {
		var d = function(b) {
			n.event.simulate(c, b.target, n.event.fix(b))
		};
		n.event.special[c] = {
			setup: function() {
				var e = this.ownerDocument || this,
					f = L.access(e, c);
				f || e.addEventListener(b, d, !0);
				L.access(e, c, (f || 0) + 1)
			},
			teardown: function() {
				var e = this.ownerDocument ||
					this,
					f = L.access(e, c) - 1;
				f ? L.access(e, c, f) : (e.removeEventListener(b, d, !0), L.remove(e, c))
			}
		}
	});
	var qb = c.location,
		Cc = n.now(),
		Vb = /\?/;
	n.parseXML = function(b) {
		var d;
		if (!b || "string" != typeof b) return null;
		try {
			d = (new c.DOMParser).parseFromString(b, "text/xml")
		} catch (e) {
			d = void 0
		}
		return d && !d.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), d
	};
	var Sc = /\[\]$/,
		Dc = /\r?\n/g,
		vd = /^(?:submit|button|image|reset|file)$/i,
		wd = /^(?:input|select|textarea|keygen)/i;
	n.param = function(b, c) {
		var d, e = [],
			f = function(b,
				c) {
				var d = n.isFunction(c) ? c() : c;
				e[e.length] = encodeURIComponent(b) + "=" + encodeURIComponent(null == d ? "" : d)
			};
		if (Array.isArray(b) || b.jquery && !n.isPlainObject(b)) n.each(b, function() {
			f(this.name, this.value)
		});
		else
			for (d in b) da(d, b[d], c, f);
		return e.join("&")
	};
	n.fn.extend({
		serialize: function() {
			return n.param(this.serializeArray())
		},
		serializeArray: function() {
			return this.map(function() {
				var b = n.prop(this, "elements");
				return b ? n.makeArray(b) : this
			}).filter(function() {
				var b = this.type;
				return this.name && !n(this).is(":disabled") &&
					wd.test(this.nodeName) && !vd.test(b) && (this.checked || !sc.test(b))
			}).map(function(b, c) {
				var d = n(this).val();
				return null == d ? null : Array.isArray(d) ? n.map(d, function(b) {
					return {
						name: c.name,
						value: b.replace(Dc, "\r\n")
					}
				}) : {
					name: c.name,
					value: d.replace(Dc, "\r\n")
				}
			}).get()
		}
	});
	var xd = /%20/g,
		yd = /#.*$/,
		zd = /([?&])_=[^&]*/,
		Ad = /^(.*?):[ \t]*([^\r\n]*)$/gm,
		Bd = /^(?:GET|HEAD)$/,
		Cd = /^\/\//,
		Ec = {},
		Rb = {},
		Fc = "*/".concat("*"),
		Wb = J.createElement("a");
	Wb.href = qb.href;
	n.extend({
		active: 0,
		lastModified: {},
		etag: {},
		ajaxSettings: {
			url: qb.href,
			type: "GET",
			isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(qb.protocol),
			global: !0,
			processData: !0,
			async: !0,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			accepts: {
				"*": Fc,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
			converters: {
				"* text": String,
				"text html": !0,
				"text json": JSON.parse,
				"text xml": n.parseXML
			},
			flatOptions: {
				url: !0,
				context: !0
			}
		},
		ajaxSetup: function(b, c) {
			return c ? ka(ka(b, n.ajaxSettings), c) : ka(n.ajaxSettings, b)
		},
		ajaxPrefilter: ma(Ec),
		ajaxTransport: ma(Rb),
		ajax: function(b, d) {
			function e(b, d, l, p) {
				var q, t, P, M, A = d;
				if (!r) {
					r = !0;
					m && c.clearTimeout(m);
					f = void 0;
					g = p || "";
					E.readyState = 0 < b ? 4 : 0;
					p = 200 <= b && 300 > b || 304 === b;
					if (l) {
						P = u;
						for (var C = E, D, fa, F, G, J = P.contents, I = P.dataTypes;
							"*" === I[0];) I.shift(), void 0 === D && (D = P.mimeType || C.getResponseHeader("Content-Type"));
						if (D)
							for (fa in J)
								if (J[fa] &&
									J[fa].test(D)) {
									I.unshift(fa);
									break
								}
						if (I[0] in l) F = I[0];
						else {
							for (fa in l) {
								if (!I[0] || P.converters[fa + " " + I[0]]) {
									F = fa;
									break
								}
								G || (G = fa)
							}
							F = F || G
						}
						l = F ? (F !== I[0] && I.unshift(F), l[F]) : void 0;
						P = l
					}
					var Za;
					a: {
						l = u;D = P;fa = E;F = p;
						var H, L, K;P = {};C = l.dataTypes.slice();
						if (C[1])
							for (H in l.converters) P[H.toLowerCase()] = l.converters[H];
						for (G = C.shift(); G;)
							if (l.responseFields[G] && (fa[l.responseFields[G]] = D), !K && F && l.dataFilter && (D = l.dataFilter(D, l.dataType)), K = G, G = C.shift())
								if ("*" === G) G = K;
								else if ("*" !== K && K !== G) {
							if (H = P[K + " " +
									G] || P["* " + G], !H)
								for (Za in P)
									if (L = Za.split(" "), L[1] === G && (H = P[K + " " + L[0]] || P["* " + L[0]])) {
										!0 === H ? H = P[Za] : !0 !== P[Za] && (G = L[0], C.unshift(L[1]));
										break
									}
							if (!0 !== H)
								if (H && l["throws"]) D = H(D);
								else try {
									D = H(D)
								} catch (N) {
									Za = {
										state: "parsererror",
										error: H ? N : "No conversion from " + K + " to " + G
									};
									break a
								}
						}
						Za = {
							state: "success",
							data: D
						}
					}
					P = Za;
					p ? (u.ifModified && (M = E.getResponseHeader("Last-Modified"), M && (n.lastModified[j] = M), M = E.getResponseHeader("etag"), M && (n.etag[j] = M)), 204 === b || "HEAD" === u.type ? A = "nocontent" : 304 === b ? A = "notmodified" :
						(A = P.state, q = P.data, t = P.error, p = !t)) : (t = A, !b && A || (A = "error", 0 > b && (b = 0)));
					E.status = b;
					E.statusText = (d || A) + "";
					p ? y.resolveWith(x, [q, A, E]) : y.rejectWith(x, [E, A, t]);
					E.statusCode(B);
					B = void 0;
					s && v.trigger(p ? "ajaxSuccess" : "ajaxError", [E, u, p ? q : t]);
					z.fireWith(x, [E, A]);
					s && (v.trigger("ajaxComplete", [E, u]), --n.active || n.event.trigger("ajaxStop"))
				}
			}
			"object" == typeof b && (d = b, b = void 0);
			d = d || {};
			var f, j, g, l, m, p, r, s, q, t, u = n.ajaxSetup({}, d),
				x = u.context || u,
				v = u.context && (x.nodeType || x.jquery) ? n(x) : n.event,
				y = n.Deferred(),
				z = n.Callbacks("once memory"),
				B = u.statusCode || {},
				A = {},
				C = {},
				D = "canceled",
				E = {
					readyState: 0,
					getResponseHeader: function(b) {
						var c;
						if (r) {
							if (!l)
								for (l = {}; c = Ad.exec(g);) l[c[1].toLowerCase()] = c[2];
							c = l[b.toLowerCase()]
						}
						return null == c ? null : c
					},
					getAllResponseHeaders: function() {
						return r ? g : null
					},
					setRequestHeader: function(b, c) {
						return null == r && (b = C[b.toLowerCase()] = C[b.toLowerCase()] || b, A[b] = c), this
					},
					overrideMimeType: function(b) {
						return null == r && (u.mimeType = b), this
					},
					statusCode: function(b) {
						var c;
						if (b)
							if (r) E.always(b[E.status]);
							else
								for (c in b) B[c] = [B[c], b[c]];
						return this
					},
					abort: function(b) {
						b = b || D;
						return f && f.abort(b), e(0, b), this
					}
				};
			if (y.promise(E), u.url = ((b || u.url || qb.href) + "").replace(Cd, qb.protocol + "//"), u.type = d.method || d.type || u.method || u.type, u.dataTypes = (u.dataType || "*").toLowerCase().match(xa) || [""], null == u.crossDomain) {
				p = J.createElement("a");
				try {
					p.href = u.url, p.href = p.href, u.crossDomain = Wb.protocol + "//" + Wb.host != p.protocol + "//" + p.host
				} catch (F) {
					u.crossDomain = !0
				}
			}
			if (u.data && u.processData && "string" != typeof u.data && (u.data =
					n.param(u.data, u.traditional)), ya(Ec, u, d, E), r) return E;
			(s = n.event && u.global) && 0 === n.active++ && n.event.trigger("ajaxStart");
			u.type = u.type.toUpperCase();
			u.hasContent = !Bd.test(u.type);
			j = u.url.replace(yd, "");
			u.hasContent ? u.data && u.processData && 0 === (u.contentType || "").indexOf("application/x-www-form-urlencoded") && (u.data = u.data.replace(xd, "+")) : (t = u.url.slice(j.length), u.data && (j += (Vb.test(j) ? "&" : "?") + u.data, delete u.data), !1 === u.cache && (j = j.replace(zd, "$1"), t = (Vb.test(j) ? "&" : "?") + "_=" + Cc++ + t), u.url =
				j + t);
			u.ifModified && (n.lastModified[j] && E.setRequestHeader("If-Modified-Since", n.lastModified[j]), n.etag[j] && E.setRequestHeader("If-None-Match", n.etag[j]));
			(u.data && u.hasContent && !1 !== u.contentType || d.contentType) && E.setRequestHeader("Content-Type", u.contentType);
			E.setRequestHeader("Accept", u.dataTypes[0] && u.accepts[u.dataTypes[0]] ? u.accepts[u.dataTypes[0]] + ("*" !== u.dataTypes[0] ? ", " + Fc + "; q=0.01" : "") : u.accepts["*"]);
			for (q in u.headers) E.setRequestHeader(q, u.headers[q]);
			if (u.beforeSend && (!1 === u.beforeSend.call(x,
					E, u) || r)) return E.abort();
			if (D = "abort", z.add(u.complete), E.done(u.success), E.fail(u.error), f = ya(Rb, u, d, E)) {
				if (E.readyState = 1, s && v.trigger("ajaxSend", [E, u]), r) return E;
				u.async && 0 < u.timeout && (m = c.setTimeout(function() {
					E.abort("timeout")
				}, u.timeout));
				try {
					r = !1, f.send(A, e)
				} catch (G) {
					if (r) throw G;
					e(-1, G)
				}
			} else e(-1, "No Transport");
			return E
		},
		getJSON: function(b, c, d) {
			return n.get(b, c, d, "json")
		},
		getScript: function(b, c) {
			return n.get(b, void 0, c, "script")
		}
	});
	n.each(["get", "post"], function(b, c) {
		n[c] = function(b,
			d, e, f) {
			return n.isFunction(d) && (f = f || e, e = d, d = void 0), n.ajax(n.extend({
				url: b,
				type: c,
				dataType: f,
				data: d,
				success: e
			}, n.isPlainObject(b) && b))
		}
	});
	n._evalUrl = function(b) {
		return n.ajax({
			url: b,
			type: "GET",
			dataType: "script",
			cache: !0,
			async: !1,
			global: !1,
			"throws": !0
		})
	};
	n.fn.extend({
		wrapAll: function(b) {
			var c;
			return this[0] && (n.isFunction(b) && (b = b.call(this[0])), c = n(b, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && c.insertBefore(this[0]), c.map(function() {
				for (var b = this; b.firstElementChild;) b = b.firstElementChild;
				return b
			}).append(this)), this
		},
		wrapInner: function(b) {
			return n.isFunction(b) ? this.each(function(c) {
				n(this).wrapInner(b.call(this, c))
			}) : this.each(function() {
				var c = n(this),
					d = c.contents();
				d.length ? d.wrapAll(b) : c.append(b)
			})
		},
		wrap: function(b) {
			var c = n.isFunction(b);
			return this.each(function(d) {
				n(this).wrapAll(c ? b.call(this, d) : b)
			})
		},
		unwrap: function(b) {
			return this.parent(b).not("body").each(function() {
				n(this).replaceWith(this.childNodes)
			}), this
		}
	});
	n.expr.pseudos.hidden = function(b) {
		return !n.expr.pseudos.visible(b)
	};
	n.expr.pseudos.visible = function(b) {
		return !(!b.offsetWidth && !b.offsetHeight && !b.getClientRects().length)
	};
	n.ajaxSettings.xhr = function() {
		try {
			return new c.XMLHttpRequest
		} catch (b) {}
	};
	var Dd = {
			"0": 200,
			1223: 204
		},
		rb = n.ajaxSettings.xhr();
	V.cors = !!rb && "withCredentials" in rb;
	V.ajax = rb = !!rb;
	n.ajaxTransport(function(b) {
		var d, e;
		if (V.cors || rb && !b.crossDomain) return {
			send: function(f, j) {
				var g, l = b.xhr();
				if (l.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
					for (g in b.xhrFields) l[g] = b.xhrFields[g];
				b.mimeType &&
					l.overrideMimeType && l.overrideMimeType(b.mimeType);
				b.crossDomain || f["X-Requested-With"] || (f["X-Requested-With"] = "XMLHttpRequest");
				for (g in f) l.setRequestHeader(g, f[g]);
				d = function(b) {
					return function() {
						d && (d = e = l.onload = l.onerror = l.onabort = l.onreadystatechange = null, "abort" === b ? l.abort() : "error" === b ? "number" != typeof l.status ? j(0, "error") : j(l.status, l.statusText) : j(Dd[l.status] || l.status, l.statusText, "text" !== (l.responseType || "text") || "string" != typeof l.responseText ? {
								binary: l.response
							} : {
								text: l.responseText
							},
							l.getAllResponseHeaders()))
					}
				};
				l.onload = d();
				e = l.onerror = d("error");
				void 0 !== l.onabort ? l.onabort = e : l.onreadystatechange = function() {
					4 === l.readyState && c.setTimeout(function() {
						d && e()
					})
				};
				d = d("abort");
				try {
					l.send(b.hasContent && b.data || null)
				} catch (p) {
					if (d) throw p;
				}
			},
			abort: function() {
				d && d()
			}
		}
	});
	n.ajaxPrefilter(function(b) {
		b.crossDomain && (b.contents.script = !1)
	});
	n.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function(b) {
				return n.globalEval(b), b
			}
		}
	});
	n.ajaxPrefilter("script", function(b) {
		void 0 === b.cache && (b.cache = !1);
		b.crossDomain && (b.type = "GET")
	});
	n.ajaxTransport("script", function(b) {
		if (b.crossDomain) {
			var c, d;
			return {
				send: function(e, f) {
					c = n("<script>").prop({
						charset: b.scriptCharset,
						src: b.url
					}).on("load error", d = function(b) {
						c.remove();
						d = null;
						b && f("error" === b.type ? 404 : 200, b.type)
					});
					J.head.appendChild(c[0])
				},
				abort: function() {
					d && d()
				}
			}
		}
	});
	var Gc = [],
		Xb = /(=)\?(?=&|$)|\?\?/;
	n.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function() {
			var b = Gc.pop() || n.expando + "_" + Cc++;
			return this[b] = !0, b
		}
	});
	n.ajaxPrefilter("json jsonp", function(b, d, e) {
		var f, j, g, l = !1 !== b.jsonp && (Xb.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Xb.test(b.data) && "data");
		if (l || "jsonp" === b.dataTypes[0]) return f = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, l ? b[l] = b[l].replace(Xb, "$1" + f) : !1 !== b.jsonp && (b.url += (Vb.test(b.url) ? "&" : "?") + b.jsonp +
			"=" + f), b.converters["script json"] = function() {
			return g || n.error(f + " was not called"), g[0]
		}, b.dataTypes[0] = "json", j = c[f], c[f] = function() {
			g = arguments
		}, e.always(function() {
			void 0 === j ? n(c).removeProp(f) : c[f] = j;
			b[f] && (b.jsonpCallback = d.jsonpCallback, Gc.push(f));
			g && n.isFunction(j) && j(g[0]);
			g = j = void 0
		}), "script"
	});
	var Ed = V,
		Hc, Ic = J.implementation.createHTMLDocument("").body;
	Hc = (Ic.innerHTML = "<form></form><form></form>", 2 === Ic.childNodes.length);
	Ed.createHTMLDocument = Hc;
	n.parseHTML = function(b, c, d) {
		if ("string" !=
			typeof b) return [];
		"boolean" == typeof c && (d = c, c = !1);
		var e, f, j;
		return c || (V.createHTMLDocument ? (c = J.implementation.createHTMLDocument(""), e = c.createElement("base"), e.href = J.location.href, c.head.appendChild(e)) : c = J), f = oc.exec(b), j = !d && [], f ? [c.createElement(f[1])] : (f = v([b], c, j), j && j.length && n(j).remove(), n.merge([], f.childNodes))
	};
	n.fn.load = function(b, c, d) {
		var e, f, j, g = this,
			l = b.indexOf(" ");
		return -1 < l && (e = la(b.slice(l)), b = b.slice(0, l)), n.isFunction(c) ? (d = c, c = void 0) : c && "object" == typeof c && (f = "POST"), 0 <
			g.length && n.ajax({
				url: b,
				type: f || "GET",
				dataType: "html",
				data: c
			}).done(function(b) {
				j = arguments;
				g.html(e ? n("<div>").append(n.parseHTML(b)).find(e) : b)
			}).always(d && function(b, c) {
				g.each(function() {
					d.apply(this, j || [b.responseText, c, b])
				})
			}), this
	};
	n.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function(b, c) {
		n.fn[c] = function(b) {
			return this.on(c, b)
		}
	});
	n.expr.pseudos.animated = function(b) {
		return n.grep(n.timers, function(c) {
			return b === c.elem
		}).length
	};
	n.offset = {
		setOffset: function(b,
			c, d) {
			var e, f, j, g, l, p, m = n.css(b, "position"),
				r = n(b),
				s = {};
			"static" === m && (b.style.position = "relative");
			l = r.offset();
			j = n.css(b, "top");
			p = n.css(b, "left");
			("absolute" === m || "fixed" === m) && -1 < (j + p).indexOf("auto") ? (e = r.position(), g = e.top, f = e.left) : (g = parseFloat(j) || 0, f = parseFloat(p) || 0);
			n.isFunction(c) && (c = c.call(b, d, n.extend({}, l)));
			null != c.top && (s.top = c.top - l.top + g);
			null != c.left && (s.left = c.left - l.left + f);
			"using" in c ? c.using.call(b, s) : r.css(s)
		}
	};
	n.fn.extend({
		offset: function(b) {
			if (arguments.length) return void 0 ===
				b ? this : this.each(function(c) {
					n.offset.setOffset(this, b, c)
				});
			var c, d, e, f, j = this[0];
			if (j) return j.getClientRects().length ? (e = j.getBoundingClientRect(), c = j.ownerDocument, d = c.documentElement, f = c.defaultView, {
				top: e.top + f.pageYOffset - d.clientTop,
				left: e.left + f.pageXOffset - d.clientLeft
			}) : {
				top: 0,
				left: 0
			}
		},
		position: function() {
			if (this[0]) {
				var b, c, d = this[0],
					e = {
						top: 0,
						left: 0
					};
				return "fixed" === n.css(d, "position") ? c = d.getBoundingClientRect() : (b = this.offsetParent(), c = this.offset(), f(b[0], "html") || (e = b.offset()), e = {
					top: e.top +
						n.css(b[0], "borderTopWidth", !0),
					left: e.left + n.css(b[0], "borderLeftWidth", !0)
				}), {
					top: c.top - e.top - n.css(d, "marginTop", !0),
					left: c.left - e.left - n.css(d, "marginLeft", !0)
				}
			}
		},
		offsetParent: function() {
			return this.map(function() {
				for (var b = this.offsetParent; b && "static" === n.css(b, "position");) b = b.offsetParent;
				return b || Hb
			})
		}
	});
	n.each({
		scrollLeft: "pageXOffset",
		scrollTop: "pageYOffset"
	}, function(b, c) {
		var d = "pageYOffset" === c;
		n.fn[b] = function(e) {
			return Na(this, function(b, e, f) {
				var j;
				return n.isWindow(b) ? j = b : 9 === b.nodeType &&
					(j = b.defaultView), void 0 === f ? j ? j[c] : b[e] : void(j ? j.scrollTo(d ? j.pageXOffset : f, d ? f : j.pageYOffset) : b[e] = f)
			}, b, e, arguments.length)
		}
	});
	n.each(["top", "left"], function(b, c) {
		n.cssHooks[c] = W(V.pixelPosition, function(b, d) {
			if (d) return d = H(b, c), Qb.test(d) ? n(b).position()[c] + "px" : d
		})
	});
	n.each({
		Height: "height",
		Width: "width"
	}, function(b, c) {
		n.each({
			padding: "inner" + b,
			content: c,
			"": "outer" + b
		}, function(d, e) {
			n.fn[e] = function(f, j) {
				var g = arguments.length && (d || "boolean" != typeof f),
					l = d || (!0 === f || !0 === j ? "margin" : "border");
				return Na(this, function(c, d, f) {
					var j;
					return n.isWindow(c) ? 0 === e.indexOf("outer") ? c["inner" + b] : c.document.documentElement["client" + b] : 9 === c.nodeType ? (j = c.documentElement, Math.max(c.body["scroll" + b], j["scroll" + b], c.body["offset" + b], j["offset" + b], j["client" + b])) : void 0 === f ? n.css(c, d, l) : n.style(c, d, f, l)
				}, c, g ? f : void 0, g)
			}
		})
	});
	n.fn.extend({
		bind: function(b, c, d) {
			return this.on(b, null, c, d)
		},
		unbind: function(b, c) {
			return this.off(b, null, c)
		},
		delegate: function(b, c, d, e) {
			return this.on(c, b, d, e)
		},
		undelegate: function(b,
			c, d) {
			return 1 === arguments.length ? this.off(b, "**") : this.off(c, b || "**", d)
		}
	});
	n.holdReady = function(b) {
		b ? n.readyWait++ : n.ready(!0)
	};
	n.isArray = Array.isArray;
	n.parseJSON = JSON.parse;
	n.nodeName = f;
	"function" == typeof define && define.amd && define("jquery", [], function() {
		return n
	});
	var Fd = c.jQuery,
		Gd = c.$;
	return n.noConflict = function(b) {
		return c.$ === n && (c.$ = Gd), b && c.jQuery === n && (c.jQuery = Fd), n
	}, b || (c.jQuery = c.$ = n), n
});

function getInternetExplorerVersion() {
	var c = -1;
	"Microsoft Internet Explorer" == navigator.appName && null != /MSIE ([0-9]{1,}[.0-9]{0,})/.exec(navigator.userAgent) && (c = parseFloat(RegExp.$1));
	return c
}
var ie = getInternetExplorerVersion();

function getQueryVariable(c) {
	for (var b = window.location.search.substring(1).split("&"), e = 0; e < b.length; e++) {
		var d = b[e].split("=");
		if (decodeURIComponent(d[0]) == c) return decodeURIComponent(d[1])
	}
};
this.jukebox = {};
jukebox.Player = function(c, b) {
	this.id = ++jukebox.__jukeboxId;
	this.origin = b || null;
	this.settings = {};
	for (var e in this.defaults) this.settings[e] = this.defaults[e];
	if ("[object Object]" === Object.prototype.toString.call(c))
		for (var d in c) this.settings[d] = c[d];
	"[object Function]" === Object.prototype.toString.call(jukebox.Manager) && (jukebox.Manager = new jukebox.Manager);
	this.resource = this.isPlaying = null;
	this.resource = "[object Object]" === Object.prototype.toString.call(jukebox.Manager) ? jukebox.Manager.getPlayableResource(this.settings.resources) : this.settings.resources[0] ||
		null;
	if (null === this.resource) throw "Your browser can't playback the given resources - or you have missed to include jukebox.Manager";
	this.__init();
	return this
};
jukebox.__jukeboxId = 0;
jukebox.Player.prototype = {
	defaults: {
		resources: [],
		autoplay: !1,
		spritemap: {},
		flashMediaElement: "./swf/FlashMediaElement.swf",
		timeout: 1E3
	},
	__addToManager: function() {
		!0 !== this.__wasAddedToManager && (jukebox.Manager.add(this), this.__wasAddedToManager = !0)
	},
	__init: function() {
		var c = this,
			b = this.settings,
			e = {},
			d;
		jukebox.Manager && void 0 !== jukebox.Manager.features && (e = jukebox.Manager.features);
		if (!0 === e.html5audio) {
			this.context = new Audio;
			this.context.src = this.resource;
			if (null === this.origin) {
				var f = function(b) {
					c.__addToManager(b)
				};
				this.context.addEventListener("canplaythrough", f, !0);
				window.setTimeout(function() {
					c.context.removeEventListener("canplaythrough", f, !0);
					f("timeout")
				}, b.timeout)
			}
			this.context.autobuffer = !0;
			this.context.preload = !0;
			for (d in this.HTML5API) this[d] = this.HTML5API[d];
			1 < e.channels ? !0 === b.autoplay ? this.context.autoplay = !0 : void 0 !== b.spritemap[b.autoplay] && this.play(b.autoplay) : 1 === e.channels && void 0 !== b.spritemap[b.autoplay] && (this.backgroundMusic = b.spritemap[b.autoplay], this.backgroundMusic.started = Date.now ?
				Date.now() : +new Date, this.play(b.autoplay));
			1 == e.channels && !0 !== b.canPlayBackground && (window.addEventListener("pagehide", function() {
				null !== c.isPlaying && (c.pause(), c.__wasAutoPaused = !0)
			}), window.addEventListener("pageshow", function() {
				c.__wasAutoPaused && (c.resume(), delete c._wasAutoPaused)
			}))
		} else if (!0 === e.flashaudio) {
			for (d in this.FLASHAPI) this[d] = this.FLASHAPI[d];
			e = ["id=jukebox-flashstream-" + this.id, "autoplay=" + b.autoplay, "file=" + window.encodeURIComponent(this.resource)];
			this.__initFlashContext(e);
			!0 === b.autoplay ? this.play(0) : b.spritemap[b.autoplay] && this.play(b.autoplay)
		} else throw "Your Browser does not support Flash Audio or HTML5 Audio.";
	},
	__initFlashContext: function(c) {
		var b, e = this.settings.flashMediaElement,
			d, f = {
				flashvars: c.join("&"),
				quality: "high",
				bgcolor: "#000000",
				wmode: "transparent",
				allowscriptaccess: "always",
				allowfullscreen: "true"
			};
		if (navigator.userAgent.match(/MSIE/)) {
			b = document.createElement("div");
			document.getElementsByTagName("body")[0].appendChild(b);
			var g = document.createElement("object");
			g.id = "jukebox-flashstream-" + this.id;
			g.setAttribute("type", "application/x-shockwave-flash");
			g.setAttribute("classid", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000");
			g.setAttribute("width", "0");
			g.setAttribute("height", "0");
			f.movie = e + "?x=" + (Date.now ? Date.now() : +new Date);
			f.flashvars = c.join("&amp;");
			for (d in f) c = document.createElement("param"), c.setAttribute("name", d), c.setAttribute("value", f[d]), g.appendChild(c);
			b.outerHTML = g.outerHTML;
			this.context = document.getElementById("jukebox-flashstream-" + this.id)
		} else {
			b =
				document.createElement("embed");
			b.id = "jukebox-flashstream-" + this.id;
			b.setAttribute("type", "application/x-shockwave-flash");
			b.setAttribute("width", "100");
			b.setAttribute("height", "100");
			f.play = !1;
			f.loop = !1;
			f.src = e + "?x=" + (Date.now ? Date.now() : +new Date);
			for (d in f) b.setAttribute(d, f[d]);
			document.getElementsByTagName("body")[0].appendChild(b);
			this.context = b
		}
	},
	backgroundHackForiOS: function() {
		if (void 0 !== this.backgroundMusic) {
			var c = Date.now ? Date.now() : +new Date;
			void 0 === this.backgroundMusic.started ? (this.backgroundMusic.started =
				c, this.setCurrentTime(this.backgroundMusic.start)) : (this.backgroundMusic.lastPointer = (c - this.backgroundMusic.started) / 1E3 % (this.backgroundMusic.end - this.backgroundMusic.start) + this.backgroundMusic.start, this.play(this.backgroundMusic.lastPointer))
		}
	},
	play: function(c, b) {
		if (null !== this.isPlaying && !0 !== b) void 0 !== jukebox.Manager && jukebox.Manager.addToQueue(c, this.id);
		else {
			var e = this.settings.spritemap,
				d;
			if (void 0 !== e[c]) d = e[c].start;
			else if ("number" === typeof c) {
				d = c;
				for (var f in e)
					if (d >= e[f].start && d <=
						e[f].end) {
						c = f;
						break
					}
			}
			void 0 !== d && "[object Object]" === Object.prototype.toString.call(e[c]) && (this.isPlaying = this.settings.spritemap[c], this.context.play && this.context.play(), this.wasReady = this.setCurrentTime(d))
		}
	},
	stop: function() {
		this.__lastPosition = 0;
		this.isPlaying = null;
		this.backgroundMusic ? this.backgroundHackForiOS() : this.context.pause();
		return !0
	},
	pause: function() {
		this.isPlaying = null;
		this.__lastPosition = this.getCurrentTime();
		this.context.pause();
		return this.__lastPosition
	},
	resume: function(c) {
		c = "number" ===
			typeof c ? c : this.__lastPosition;
		if (null !== c) return this.play(c), this.__lastPosition = null, !0;
		this.context.play();
		return !1
	},
	HTML5API: {
		getVolume: function() {
			return this.context.volume || 1
		},
		setVolume: function(c) {
			this.context.volume = c;
			return 1E-4 > Math.abs(this.context.volume - c) ? !0 : !1
		},
		getCurrentTime: function() {
			return this.context.currentTime || 0
		},
		setCurrentTime: function(c) {
			try {
				return this.context.currentTime = c, !0
			} catch (b) {
				return !1
			}
		}
	},
	FLASHAPI: {
		getVolume: function() {
			return this.context && "function" === typeof this.context.getVolume ?
				this.context.getVolume() : 1
		},
		setVolume: function(c) {
			return this.context && "function" === typeof this.context.setVolume ? (this.context.setVolume(c), !0) : !1
		},
		getCurrentTime: function() {
			return this.context && "function" === typeof this.context.getCurrentTime ? this.context.getCurrentTime() : 0
		},
		setCurrentTime: function(c) {
			return this.context && "function" === typeof this.context.setCurrentTime ? this.context.setCurrentTime(c) : !1
		}
	}
};
if (void 0 === this.jukebox) throw "jukebox.Manager requires jukebox.Player (Player.js) to run properly.";
jukebox.Manager = function(c) {
	this.features = {};
	this.codecs = {};
	this.__players = {};
	this.__playersLength = 0;
	this.__clones = {};
	this.__queue = [];
	this.settings = {};
	for (var b in this.defaults) this.settings[b] = this.defaults[b];
	if ("[object Object]" === Object.prototype.toString.call(c))
		for (var e in c) this.settings[e] = c[e];
	this.__detectFeatures();
	jukebox.Manager.__initialized = !1 === this.settings.useGameLoop ? window.setInterval(function() {
		jukebox.Manager.loop()
	}, 20) : !0
};
jukebox.Manager.prototype = {
	defaults: {
		useFlash: !1,
		useGameLoop: !1
	},
	__detectFeatures: function() {
		var c = window.Audio && new Audio;
		if (c && c.canPlayType && !1 === this.settings.useFlash) {
			for (var b = [{
						e: "3gp",
						m: ["audio/3gpp", "audio/amr"]
					}, {
						e: "aac",
						m: ["audio/aac", "audio/aacp"]
					}, {
						e: "amr",
						m: ["audio/amr", "audio/3gpp"]
					}, {
						e: "caf",
						m: ["audio/IMA-ADPCM", "audio/x-adpcm", 'audio/x-aiff; codecs="IMA-ADPCM, ADPCM"']
					}, {
						e: "m4a",
						m: 'audio/mp4{audio/mp4; codecs="mp4a.40.2,avc1.42E01E"{audio/mpeg4{audio/mpeg4-generic{audio/mp4a-latm{audio/MP4A-LATM{audio/x-m4a'.split("{")
					}, {
						e: "mp3",
						m: ["audio/mp3", "audio/mpeg", 'audio/mpeg; codecs="mp3"', "audio/MPA", "audio/mpa-robust"]
					}, {
						e: "mpga",
						m: ["audio/MPA", "audio/mpa-robust", "audio/mpeg", "video/mpeg"]
					}, {
						e: "mp4",
						m: ["audio/mp4", "video/mp4"]
					}, {
						e: "ogg",
						m: ["application/ogg", "audio/ogg", 'audio/ogg; codecs="theora, vorbis"', "video/ogg", 'video/ogg; codecs="theora, vorbis"']
					}, {
						e: "wav",
						m: ["audio/wave", "audio/wav", 'audio/wav; codecs="1"', "audio/x-wav", "audio/x-pn-wav"]
					}, {
						e: "webm",
						m: ["audio/webm", 'audio/webm; codecs="vorbis"', "video/webm"]
					}],
					e, d, f = 0, g = b.length; f < g; f++)
				if (d = b[f].e, b[f].m.length && "object" === typeof b[f].m)
					for (var q = 0, m = b[f].m.length; q < m; q++)
						if (e = b[f].m[q], "" !== c.canPlayType(e)) {
							this.codecs[d] = e;
							break
						} else this.codecs[d] || (this.codecs[d] = !1);
			this.features.html5audio = !(!this.codecs.mp3 && !this.codecs.ogg && !this.codecs.webm && !this.codecs.wav);
			this.features.channels = 8;
			c.volume = 0.1337;
			this.features.volume = !!(1E-4 > Math.abs(c.volume - 0.1337));
			navigator.userAgent.match(/iPhone|iPod|iPad/i) && (this.features.channels = 1)
		}
		this.features.flashaudio = !!navigator.mimeTypes["application/x-shockwave-flash"] || !!navigator.plugins["Shockwave Flash"] || !1;
		if (window.ActiveXObject) try {
			new ActiveXObject("ShockwaveFlash.ShockwaveFlash.10"), this.features.flashaudio = !0
		} catch (j) {}!0 === this.settings.useFlash && (this.features.flashaudio = !0);
		!0 === this.features.flashaudio && !this.features.html5audio && (this.codecs.mp3 = "audio/mp3", this.codecs.mpga = "audio/mpeg", this.codecs.mp4 = "audio/mp4", this.codecs.m4a = "audio/mp4", this.codecs["3gp"] = "audio/3gpp", this.codecs.amr = "audio/amr",
			this.features.volume = !0, this.features.channels = 1)
	},
	__getPlayerById: function(c) {
		return this.__players && void 0 !== this.__players[c] ? this.__players[c] : null
	},
	__getClone: function(c, b) {
		for (var e in this.__clones) {
			var d = this.__clones[e];
			if (null === d.isPlaying && d.origin === c) return d
		}
		if ("[object Object]" === Object.prototype.toString.call(b)) {
			e = {};
			for (var f in b) e[f] = b[f];
			e.autoplay = !1;
			f = new jukebox.Player(e, c);
			f.isClone = !0;
			f.wasReady = !1;
			return this.__clones[f.id] = f
		}
		return null
	},
	loop: function() {
		if (0 !== this.__playersLength)
			if (this.__queue.length &&
				this.__playersLength < this.features.channels) {
				var c = this.__queue[0],
					b = this.__getPlayerById(c.origin);
				if (null !== b) {
					var e = this.__getClone(c.origin, b.settings);
					null !== e && (!0 === this.features.volume && (b = this.__players[c.origin]) && e.setVolume(b.getVolume()), this.add(e), e.play(c.pointer, !0))
				}
				this.__queue.splice(0, 1)
			} else
				for (e in this.__queue.length && 1 === this.features.channels && (c = this.__queue[0], b = this.__getPlayerById(c.origin), null !== b && b.play(c.pointer, !0), this.__queue.splice(0, 1)), this.__players) c = this.__players[e],
					b = c.getCurrentTime() || 0, c.isPlaying && !1 === c.wasReady ? c.wasReady = c.setCurrentTime(c.isPlaying.start) : c.isPlaying && !0 === c.wasReady ? b > c.isPlaying.end && (!0 === c.isPlaying.loop ? c.play(c.isPlaying.start, !0) : c.stop()) : c.isClone && null === c.isPlaying ? this.remove(c) : void 0 !== c.backgroundMusic && null === c.isPlaying && b > c.backgroundMusic.end && c.backgroundHackForiOS()
	},
	getPlayableResource: function(c) {
		"[object Array]" !== Object.prototype.toString.call(c) && (c = [c]);
		for (var b = 0, e = c.length; b < e; b++) {
			var d = c[b],
				f = d.match(/\.([^\.]*)$/)[1];
			if (f && this.codecs[f]) return d
		}
		return null
	},
	add: function(c) {
		return c instanceof jukebox.Player && void 0 === this.__players[c.id] ? (this.__playersLength++, this.__players[c.id] = c, !0) : !1
	},
	remove: function(c) {
		return c instanceof jukebox.Player && void 0 !== this.__players[c.id] ? (this.__playersLength--, delete this.__players[c.id], !0) : !1
	},
	addToQueue: function(c, b) {
		return ("string" === typeof c || "number" === typeof c) && void 0 !== this.__players[b] ? (this.__queue.push({
			pointer: c,
			origin: b
		}), !0) : !1
	}
};
(function() {
	var c = function() {
		this.init()
	};
	c.prototype = {
		init: function() {
			var c = this || b;
			c._counter = 1E3;
			c._codecs = {};
			c._howls = [];
			c._muted = !1;
			c._volume = 1;
			c._canPlayEvent = "canplaythrough";
			c._navigator = "undefined" !== typeof window && window.navigator ? window.navigator : null;
			c.masterGain = null;
			c.noAudio = !1;
			c.usingWebAudio = !0;
			c.autoSuspend = !0;
			c.ctx = null;
			c.mobileAutoEnable = !0;
			c._setup();
			return c
		},
		volume: function(c) {
			var d = this || b;
			c = parseFloat(c);
			d.ctx || m();
			if ("undefined" !== typeof c && 0 <= c && 1 >= c) {
				d._volume = c;
				if (d._muted) return d;
				d.usingWebAudio && d.masterGain.gain.setValueAtTime(c, b.ctx.currentTime);
				for (var e = 0; e < d._howls.length; e++)
					if (!d._howls[e]._webAudio)
						for (var f = d._howls[e]._getSoundIds(), g = 0; g < f.length; g++) {
							var q = d._howls[e]._soundById(f[g]);
							q && q._node && (q._node.volume = q._volume * c)
						}
				return d
			}
			return d._volume
		},
		mute: function(c) {
			var d = this || b;
			d.ctx || m();
			d._muted = c;
			d.usingWebAudio && d.masterGain.gain.setValueAtTime(c ? 0 : d._volume, b.ctx.currentTime);
			for (var e = 0; e < d._howls.length; e++)
				if (!d._howls[e]._webAudio)
					for (var f = d._howls[e]._getSoundIds(),
							g = 0; g < f.length; g++) {
						var q = d._howls[e]._soundById(f[g]);
						q && q._node && (q._node.muted = c ? !0 : q._muted)
					}
			return d
		},
		unload: function() {
			for (var c = this || b, d = c._howls.length - 1; 0 <= d; d--) c._howls[d].unload();
			c.usingWebAudio && (c.ctx && "undefined" !== typeof c.ctx.close) && (c.ctx.close(), c.ctx = null, m());
			return c
		},
		codecs: function(c) {
			return (this || b)._codecs[c.replace(/^x-/, "")]
		},
		_setup: function() {
			var c = this || b;
			c.state = c.ctx ? c.ctx.state || "running" : "running";
			c._autoSuspend();
			if (!c.usingWebAudio)
				if ("undefined" !== typeof Audio) try {
					var d =
						new Audio;
					"undefined" === typeof d.oncanplaythrough && (c._canPlayEvent = "canplay")
				} catch (e) {
					c.noAudio = !0
				} else c.noAudio = !0;
			try {
				d = new Audio, d.muted && (c.noAudio = !0)
			} catch (f) {}
			c.noAudio || c._setupCodecs();
			return c
		},
		_setupCodecs: function() {
			var c = this || b,
				d = null;
			try {
				d = "undefined" !== typeof Audio ? new Audio : null
			} catch (e) {
				return c
			}
			if (!d || "function" !== typeof d.canPlayType) return c;
			var f = d.canPlayType("audio/mpeg;").replace(/^no$/, ""),
				g = c._navigator && c._navigator.userAgent.match(/OPR\/([0-6].)/g),
				g = g && 33 > parseInt(g[0].split("/")[1],
					10);
			c._codecs = {
				mp3: !(g || !f && !d.canPlayType("audio/mp3;").replace(/^no$/, "")),
				mpeg: !!f,
				opus: !!d.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
				ogg: !!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
				oga: !!d.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
				wav: !!d.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
				aac: !!d.canPlayType("audio/aac;").replace(/^no$/, ""),
				caf: !!d.canPlayType("audio/x-caf;").replace(/^no$/, ""),
				m4a: !!(d.canPlayType("audio/x-m4a;") ||
					d.canPlayType("audio/m4a;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""),
				mp4: !!(d.canPlayType("audio/x-mp4;") || d.canPlayType("audio/mp4;") || d.canPlayType("audio/aac;")).replace(/^no$/, ""),
				weba: !!d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
				webm: !!d.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
				dolby: !!d.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
				flac: !!(d.canPlayType("audio/x-flac;") || d.canPlayType("audio/flac;")).replace(/^no$/, "")
			};
			return c
		},
		_enableMobileAudio: function() {
			var c = this || b,
				d = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(c._navigator && c._navigator.userAgent),
				e = !!("ontouchend" in window || c._navigator && 0 < c._navigator.maxTouchPoints || c._navigator && 0 < c._navigator.msMaxTouchPoints);
			if (!c._mobileEnabled && c.ctx && (d || e)) {
				c._mobileEnabled = !1;
				!c._mobileUnloaded && 44100 !== c.ctx.sampleRate && (c._mobileUnloaded = !0, c.unload());
				c._scratchBuffer = c.ctx.createBuffer(1, 1, 22050);
				var f = function() {
					b._autoResume();
					var d = c.ctx.createBufferSource();
					d.buffer = c._scratchBuffer;
					d.connect(c.ctx.destination);
					"undefined" === typeof d.start ? d.noteOn(0) : d.start(0);
					"function" === typeof c.ctx.resume && c.ctx.resume();
					d.onended = function() {
						d.disconnect(0);
						c._mobileEnabled = !0;
						c.mobileAutoEnable = !1;
						document.removeEventListener("touchstart", f, !0);
						document.removeEventListener("touchend", f, !0)
					}
				};
				document.addEventListener("touchstart", f, !0);
				document.addEventListener("touchend", f, !0);
				return c
			}
		},
		_autoSuspend: function() {
			var c = this;
			if (c.autoSuspend && c.ctx && "undefined" !==
				typeof c.ctx.suspend && b.usingWebAudio) {
				for (var d = 0; d < c._howls.length; d++)
					if (c._howls[d]._webAudio)
						for (var e = 0; e < c._howls[d]._sounds.length; e++)
							if (!c._howls[d]._sounds[e]._paused) return c;
				c._suspendTimer && clearTimeout(c._suspendTimer);
				c._suspendTimer = setTimeout(function() {
					c.autoSuspend && (c._suspendTimer = null, c.state = "suspending", c.ctx.suspend().then(function() {
						c.state = "suspended";
						c._resumeAfterSuspend && (delete c._resumeAfterSuspend, c._autoResume())
					}))
				}, 3E4);
				return c
			}
		},
		_autoResume: function() {
			var c =
				this;
			if (c.ctx && "undefined" !== typeof c.ctx.resume && b.usingWebAudio) return "running" === c.state && c._suspendTimer ? (clearTimeout(c._suspendTimer), c._suspendTimer = null) : "suspended" === c.state ? (c.ctx.resume().then(function() {
				c.state = "running";
				for (var b = 0; b < c._howls.length; b++) c._howls[b]._emit("resume")
			}), c._suspendTimer && (clearTimeout(c._suspendTimer), c._suspendTimer = null)) : "suspending" === c.state && (c._resumeAfterSuspend = !0), c
		}
	};
	var b = new c,
		e = function(b) {
			!b.src || 0 === b.src.length ? console.error("An array of source files must be passed with any new Howl.") :
				this.init(b)
		};
	e.prototype = {
		init: function(c) {
			var d = this;
			b.ctx || m();
			d._autoplay = c.autoplay || !1;
			d._format = "string" !== typeof c.format ? c.format : [c.format];
			d._html5 = c.html5 || !1;
			d._muted = c.mute || !1;
			d._loop = c.loop || !1;
			d._pool = c.pool || 5;
			d._preload = "boolean" === typeof c.preload ? c.preload : !0;
			d._rate = c.rate || 1;
			d._sprite = c.sprite || {};
			d._src = "string" !== typeof c.src ? c.src : [c.src];
			d._volume = void 0 !== c.volume ? c.volume : 1;
			d._xhrWithCredentials = c.xhrWithCredentials || !1;
			d._duration = 0;
			d._state = "unloaded";
			d._sounds = [];
			d._endTimers = {};
			d._queue = [];
			d._playLock = !1;
			d._onend = c.onend ? [{
				fn: c.onend
			}] : [];
			d._onfade = c.onfade ? [{
				fn: c.onfade
			}] : [];
			d._onload = c.onload ? [{
				fn: c.onload
			}] : [];
			d._onloaderror = c.onloaderror ? [{
				fn: c.onloaderror
			}] : [];
			d._onplayerror = c.onplayerror ? [{
				fn: c.onplayerror
			}] : [];
			d._onpause = c.onpause ? [{
				fn: c.onpause
			}] : [];
			d._onplay = c.onplay ? [{
				fn: c.onplay
			}] : [];
			d._onstop = c.onstop ? [{
				fn: c.onstop
			}] : [];
			d._onmute = c.onmute ? [{
				fn: c.onmute
			}] : [];
			d._onvolume = c.onvolume ? [{
				fn: c.onvolume
			}] : [];
			d._onrate = c.onrate ? [{
				fn: c.onrate
			}] : [];
			d._onseek = c.onseek ?
				[{
					fn: c.onseek
				}] : [];
			d._onresume = [];
			d._webAudio = b.usingWebAudio && !d._html5;
			"undefined" !== typeof b.ctx && (b.ctx && b.mobileAutoEnable) && b._enableMobileAudio();
			b._howls.push(d);
			d._autoplay && d._queue.push({
				event: "play",
				action: function() {
					d.play()
				}
			});
			d._preload && d.load();
			return d
		},
		load: function() {
			var c = null;
			if (b.noAudio) this._emit("loaderror", null, "No audio support.");
			else {
				"string" === typeof this._src && (this._src = [this._src]);
				for (var e = 0; e < this._src.length; e++) {
					var m, r;
					if (this._format && this._format[e]) m = this._format[e];
					else {
						r = this._src[e];
						if ("string" !== typeof r) {
							this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
							continue
						}(m = /^data:audio\/([^;,]+);/i.exec(r)) || (m = /\.([^.]+)$/.exec(r.split("?", 1)[0]));
						m && (m = m[1].toLowerCase())
					}
					m || console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
					if (m && b.codecs(m)) {
						c = this._src[e];
						break
					}
				}
				if (c) {
					this._src = c;
					this._state = "loading";
					"https:" === window.location.protocol && "http:" === c.slice(0, 5) && (this._html5 = !0, this._webAudio = !1);
					new d(this);
					if (this._webAudio) {
						var s = this,
							t = s._src;
						if (f[t]) s._duration = f[t].duration, q(s);
						else if (/^data:[^;]+;base64,/.test(t)) {
							c = atob(t.split(",")[1]);
							e = new Uint8Array(c.length);
							for (m = 0; m < c.length; ++m) e[m] = c.charCodeAt(m);
							g(e.buffer, s)
						} else {
							var u = new XMLHttpRequest;
							u.open("GET", t, !0);
							u.withCredentials = s._xhrWithCredentials;
							u.responseType = "arraybuffer";
							u.onload = function() {
								var b = (u.status + "")[0];
								"0" !== b && "2" !== b && "3" !== b ? s._emit("loaderror", null, "Failed loading audio file with status: " +
									u.status + ".") : g(u.response, s)
							};
							u.onerror = function() {
								s._webAudio && (s._html5 = !0, s._webAudio = !1, s._sounds = [], delete f[t], s.load())
							};
							try {
								u.send()
							} catch (x) {
								u.onerror()
							}
						}
					}
					return this
				}
				this._emit("loaderror", null, "No codec support for selected audio sources.")
			}
		},
		play: function(c, d) {
			var e = this,
				f = null;
			if ("number" === typeof c) f = c, c = null;
			else {
				if ("string" === typeof c && "loaded" === e._state && !e._sprite[c]) return null;
				if ("undefined" === typeof c) {
					c = "__default";
					for (var g = 0, m = 0; m < e._sounds.length; m++) e._sounds[m]._paused &&
						!e._sounds[m]._ended && (g++, f = e._sounds[m]._id);
					1 === g ? c = null : f = null
				}
			}
			var q = f ? e._soundById(f) : e._inactiveSound();
			if (!q) return null;
			f && !c && (c = q._sprite || "__default");
			if ("loaded" !== e._state) {
				q._sprite = c;
				q._ended = !1;
				var x = q._id;
				e._queue.push({
					event: "play",
					action: function() {
						e.play(x)
					}
				});
				return x
			}
			if (f && !q._paused) return d || e._loadQueue("play"), q._id;
			e._webAudio && b._autoResume();
			var z = Math.max(0, 0 < q._seek ? q._seek : e._sprite[c][0] / 1E3),
				v = Math.max(0, (e._sprite[c][0] + e._sprite[c][1]) / 1E3 - z),
				B = 1E3 * v / Math.abs(q._rate);
			q._paused = !1;
			q._ended = !1;
			q._sprite = c;
			q._seek = z;
			q._start = e._sprite[c][0] / 1E3;
			q._stop = (e._sprite[c][0] + e._sprite[c][1]) / 1E3;
			q._loop = !(!q._loop && !e._sprite[c][2]);
			var y = q._node;
			if (e._webAudio) f = function() {
				e._refreshBuffer(q);
				y.gain.setValueAtTime(q._muted || e._muted ? 0 : q._volume, b.ctx.currentTime);
				q._playStart = b.ctx.currentTime;
				"undefined" === typeof y.bufferSource.start ? q._loop ? y.bufferSource.noteGrainOn(0, z, 86400) : y.bufferSource.noteGrainOn(0, z, v) : q._loop ? y.bufferSource.start(0, z, 86400) : y.bufferSource.start(0,
					z, v);
				Infinity !== B && (e._endTimers[q._id] = setTimeout(e._ended.bind(e, q), B));
				d || setTimeout(function() {
					e._emit("play", q._id)
				}, 0)
			}, "running" === b.state ? f() : (e.once("resume", f), e._clearTimer(q._id));
			else {
				var A = function() {
						y.currentTime = z;
						y.muted = q._muted || e._muted || b._muted || y.muted;
						y.volume = q._volume * b.volume();
						y.playbackRate = q._rate;
						try {
							var f = y.play();
							if ("undefined" !== typeof Promise && f instanceof Promise) {
								e._playLock = !0;
								var g = function() {
									e._playLock = !1;
									d || e._emit("play", q._id)
								};
								f.then(g, g)
							} else d || e._emit("play",
								q._id);
							y.playbackRate = q._rate;
							y.paused ? e._emit("playerror", q._id, "Playback was unable to start. This is most commonly an issue on mobile devices where playback was not within a user interaction.") : "__default" !== c || q._loop ? e._endTimers[q._id] = setTimeout(e._ended.bind(e, q), B) : (e._endTimers[q._id] = function() {
								e._ended(q);
								y.removeEventListener("ended", e._endTimers[q._id], !1)
							}, y.addEventListener("ended", e._endTimers[q._id], !1))
						} catch (m) {
							e._emit("playerror", q._id, m)
						}
					},
					f = window && window.ejecta || !y.readyState &&
					b._navigator.isCocoonJS;
				if (3 <= y.readyState || f) A();
				else {
					var F = function() {
						A();
						y.removeEventListener(b._canPlayEvent, F, !1)
					};
					y.addEventListener(b._canPlayEvent, F, !1);
					e._clearTimer(q._id)
				}
			}
			return q._id
		},
		pause: function(b, c) {
			var d = this;
			if ("loaded" !== d._state || d._playLock) return d._queue.push({
				event: "pause",
				action: function() {
					d.pause(b)
				}
			}), d;
			for (var e = d._getSoundIds(b), f = 0; f < e.length; f++) {
				d._clearTimer(e[f]);
				var g = d._soundById(e[f]);
				if (g && !g._paused && (g._seek = d.seek(e[f]), g._rateSeek = 0, g._paused = !0, d._stopFade(e[f]),
						g._node))
					if (d._webAudio) {
						if (!g._node.bufferSource) continue;
						"undefined" === typeof g._node.bufferSource.stop ? g._node.bufferSource.noteOff(0) : g._node.bufferSource.stop(0);
						d._cleanBuffer(g._node)
					} else(!isNaN(g._node.duration) || Infinity === g._node.duration) && g._node.pause();
				c || d._emit("pause", g ? g._id : null)
			}
			return d
		},
		stop: function(b, c) {
			var d = this;
			if ("loaded" !== d._state) return d._queue.push({
				event: "stop",
				action: function() {
					d.stop(b)
				}
			}), d;
			for (var e = d._getSoundIds(b), f = 0; f < e.length; f++) {
				d._clearTimer(e[f]);
				var g =
					d._soundById(e[f]);
				if (g) {
					g._seek = g._start || 0;
					g._rateSeek = 0;
					g._paused = !0;
					g._ended = !0;
					d._stopFade(e[f]);
					if (g._node)
						if (d._webAudio) g._node.bufferSource && ("undefined" === typeof g._node.bufferSource.stop ? g._node.bufferSource.noteOff(0) : g._node.bufferSource.stop(0), d._cleanBuffer(g._node));
						else if (!isNaN(g._node.duration) || Infinity === g._node.duration) g._node.currentTime = g._start || 0, g._node.pause();
					c || d._emit("stop", g._id)
				}
			}
			return d
		},
		mute: function(c, d) {
			var e = this;
			if ("loaded" !== e._state) return e._queue.push({
				event: "mute",
				action: function() {
					e.mute(c, d)
				}
			}), e;
			if ("undefined" === typeof d)
				if ("boolean" === typeof c) e._muted = c;
				else return e._muted;
			for (var f = e._getSoundIds(d), g = 0; g < f.length; g++) {
				var m = e._soundById(f[g]);
				m && (m._muted = c, m._interval && e._stopFade(m._id), e._webAudio && m._node ? m._node.gain.setValueAtTime(c ? 0 : m._volume, b.ctx.currentTime) : m._node && (m._node.muted = b._muted ? !0 : c), e._emit("mute", m._id))
			}
			return e
		},
		volume: function() {
			var c = this,
				d = arguments,
				e, f;
			if (0 === d.length) return c._volume;
			1 === d.length || 2 === d.length && "undefined" ===
				typeof d[1] ? 0 <= c._getSoundIds().indexOf(d[0]) ? f = parseInt(d[0], 10) : e = parseFloat(d[0]) : 2 <= d.length && (e = parseFloat(d[0]), f = parseInt(d[1], 10));
			var g;
			if ("undefined" !== typeof e && 0 <= e && 1 >= e) {
				if ("loaded" !== c._state) return c._queue.push({
					event: "volume",
					action: function() {
						c.volume.apply(c, d)
					}
				}), c;
				"undefined" === typeof f && (c._volume = e);
				f = c._getSoundIds(f);
				for (var m = 0; m < f.length; m++)
					if (g = c._soundById(f[m])) g._volume = e, d[2] || c._stopFade(f[m]), c._webAudio && g._node && !g._muted ? g._node.gain.setValueAtTime(e, b.ctx.currentTime) :
						g._node && !g._muted && (g._node.volume = e * b.volume()), c._emit("volume", g._id)
			} else return (g = f ? c._soundById(f) : c._sounds[0]) ? g._volume : 0;
			return c
		},
		fade: function(c, d, e, f) {
			var g = this;
			if ("loaded" !== g._state) return g._queue.push({
				event: "fade",
				action: function() {
					g.fade(c, d, e, f)
				}
			}), g;
			g.volume(c, f);
			for (var m = g._getSoundIds(f), q = 0; q < m.length; q++) {
				var x = g._soundById(m[q]);
				if (x) {
					f || g._stopFade(m[q]);
					if (g._webAudio && !x._muted) {
						var z = b.ctx.currentTime,
							v = z + e / 1E3;
						x._volume = c;
						x._node.gain.setValueAtTime(c, z);
						x._node.gain.linearRampToValueAtTime(d,
							v)
					}
					g._startFadeInterval(x, c, d, e, m[q], "undefined" === typeof f)
				}
			}
			return g
		},
		_startFadeInterval: function(b, c, d, e, f, g) {
			var m = this,
				q = c,
				z = d - c;
			f = Math.abs(z / 0.01);
			f = Math.max(4, 0 < f ? e / f : e);
			var v = Date.now();
			b._fadeTo = d;
			b._interval = setInterval(function() {
				var f = (Date.now() - v) / e;
				v = Date.now();
				q += z * f;
				q = Math.max(0, q);
				q = Math.min(1, q);
				q = Math.round(100 * q) / 100;
				m._webAudio ? b._volume = q : m.volume(q, b._id, !0);
				g && (m._volume = q);
				if (d < c && q <= d || d > c && q >= d) clearInterval(b._interval), b._interval = null, b._fadeTo = null, m.volume(d, b._id),
					m._emit("fade", b._id)
			}, f)
		},
		_stopFade: function(c) {
			var d = this._soundById(c);
			d && d._interval && (this._webAudio && d._node.gain.cancelScheduledValues(b.ctx.currentTime), clearInterval(d._interval), d._interval = null, this.volume(d._fadeTo, c), d._fadeTo = null, this._emit("fade", c));
			return this
		},
		loop: function() {
			var b = arguments,
				c, d;
			if (0 === b.length) return this._loop;
			if (1 === b.length)
				if ("boolean" === typeof b[0]) this._loop = c = b[0];
				else return (b = this._soundById(parseInt(b[0], 10))) ? b._loop : !1;
			else 2 === b.length && (c = b[0], d =
				parseInt(b[1], 10));
			d = this._getSoundIds(d);
			for (var e = 0; e < d.length; e++)
				if (b = this._soundById(d[e]))
					if (b._loop = c, this._webAudio && (b._node && b._node.bufferSource) && (b._node.bufferSource.loop = c)) b._node.bufferSource.loopStart = b._start || 0, b._node.bufferSource.loopEnd = b._stop;
			return this
		},
		rate: function() {
			var c = this,
				d = arguments,
				e, f;
			0 === d.length ? f = c._sounds[0]._id : 1 === d.length ? 0 <= c._getSoundIds().indexOf(d[0]) ? f = parseInt(d[0], 10) : e = parseFloat(d[0]) : 2 === d.length && (e = parseFloat(d[0]), f = parseInt(d[1], 10));
			var g;
			if ("number" === typeof e) {
				if ("loaded" !== c._state) return c._queue.push({
					event: "rate",
					action: function() {
						c.rate.apply(c, d)
					}
				}), c;
				"undefined" === typeof f && (c._rate = e);
				f = c._getSoundIds(f);
				for (var m = 0; m < f.length; m++)
					if (g = c._soundById(f[m])) {
						g._rateSeek = c.seek(f[m]);
						g._playStart = c._webAudio ? b.ctx.currentTime : g._playStart;
						g._rate = e;
						c._webAudio && g._node && g._node.bufferSource ? g._node.bufferSource.playbackRate.setValueAtTime(e, b.ctx.currentTime) : g._node && (g._node.playbackRate = e);
						var q = c.seek(f[m]),
							q = 1E3 * ((c._sprite[g._sprite][0] +
								c._sprite[g._sprite][1]) / 1E3 - q) / Math.abs(g._rate);
						if (c._endTimers[f[m]] || !g._paused) c._clearTimer(f[m]), c._endTimers[f[m]] = setTimeout(c._ended.bind(c, g), q);
						c._emit("rate", g._id)
					}
			} else return (g = c._soundById(f)) ? g._rate : c._rate;
			return c
		},
		seek: function() {
			var c = this,
				d = arguments,
				e, f;
			0 === d.length ? f = c._sounds[0]._id : 1 === d.length ? 0 <= c._getSoundIds().indexOf(d[0]) ? f = parseInt(d[0], 10) : c._sounds.length && (f = c._sounds[0]._id, e = parseFloat(d[0])) : 2 === d.length && (e = parseFloat(d[0]), f = parseInt(d[1], 10));
			if ("undefined" ===
				typeof f) return c;
			if ("loaded" !== c._state) return c._queue.push({
				event: "seek",
				action: function() {
					c.seek.apply(c, d)
				}
			}), c;
			var g = c._soundById(f);
			if (g)
				if ("number" === typeof e && 0 <= e) {
					var m = c.playing(f);
					m && c.pause(f, !0);
					g._seek = e;
					g._ended = !1;
					c._clearTimer(f);
					m && c.play(f, !0);
					!c._webAudio && g._node && (g._node.currentTime = e);
					if (m && !c._webAudio) {
						var q = function() {
							c._playLock ? setTimeout(q, 0) : c._emit("seek", f)
						};
						setTimeout(q, 0)
					} else c._emit("seek", f)
				} else return c._webAudio ? (e = c.playing(f) ? b.ctx.currentTime - g._playStart :
					0, g._seek + ((g._rateSeek ? g._rateSeek - g._seek : 0) + e * Math.abs(g._rate))) : g._node.currentTime;
			return c
		},
		playing: function(b) {
			if ("number" === typeof b) return (b = this._soundById(b)) ? !b._paused : !1;
			for (b = 0; b < this._sounds.length; b++)
				if (!this._sounds[b]._paused) return !0;
			return !1
		},
		duration: function(b) {
			var c = this._duration;
			(b = this._soundById(b)) && (c = this._sprite[b._sprite][1] / 1E3);
			return c
		},
		state: function() {
			return this._state
		},
		unload: function() {
			for (var c = this._sounds, d = 0; d < c.length; d++) {
				c[d]._paused || this.stop(c[d]._id);
				this._webAudio || (/MSIE |Trident\//.test(b._navigator && b._navigator.userAgent) || (c[d]._node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"), c[d]._node.removeEventListener("error", c[d]._errorFn, !1), c[d]._node.removeEventListener(b._canPlayEvent, c[d]._loadFn, !1));
				delete c[d]._node;
				this._clearTimer(c[d]._id);
				var e = b._howls.indexOf(this);
				0 <= e && b._howls.splice(e, 1)
			}
			c = !0;
			for (d = 0; d < b._howls.length; d++)
				if (b._howls[d]._src === this._src) {
					c = !1;
					break
				}
			f && c && delete f[this._src];
			b.noAudio = !1;
			this._state = "unloaded";
			this._sounds = [];
			return null
		},
		on: function(b, c, d, e) {
			b = this["_on" + b];
			"function" === typeof c && b.push(e ? {
				id: d,
				fn: c,
				once: e
			} : {
				id: d,
				fn: c
			});
			return this
		},
		off: function(b, c, d) {
			var e = this["_on" + b],
				f = 0;
			"number" === typeof c && (d = c, c = null);
			if (c || d)
				for (f = 0; f < e.length; f++) {
					if (b = d === e[f].id, c === e[f].fn && b || !c && b) {
						e.splice(f, 1);
						break
					}
				} else if (b) this["_on" + b] = [];
				else {
					c = Object.keys(this);
					for (f = 0; f < c.length; f++) 0 === c[f].indexOf("_on") && Array.isArray(this[c[f]]) && (this[c[f]] = [])
				}
			return this
		},
		once: function(b, c, d) {
			this.on(b, c, d, 1);
			return this
		},
		_emit: function(b, c, d) {
			for (var e = this["_on" + b], f = e.length - 1; 0 <= f; f--)
				if (!e[f].id || e[f].id === c || "load" === b) setTimeout(function(b) {
					b.call(this, c, d)
				}.bind(this, e[f].fn), 0), e[f].once && this.off(b, e[f].fn, e[f].id);
			this._loadQueue(b);
			return this
		},
		_loadQueue: function(b) {
			if (0 < this._queue.length) {
				var c = this._queue[0];
				c.event === b && (this._queue.shift(), this._loadQueue());
				b || c.action()
			}
			return this
		},
		_ended: function(c) {
			var d = c._sprite;
			if (!this._webAudio && c._node &&
				!c._node.paused && !c._node.ended && c._node.currentTime < c._stop) return setTimeout(this._ended.bind(this, c), 100), this;
			d = !(!c._loop && !this._sprite[d][2]);
			this._emit("end", c._id);
			!this._webAudio && d && this.stop(c._id, !0).play(c._id);
			if (this._webAudio && d) {
				this._emit("play", c._id);
				c._seek = c._start || 0;
				c._rateSeek = 0;
				c._playStart = b.ctx.currentTime;
				var e = 1E3 * (c._stop - c._start) / Math.abs(c._rate);
				this._endTimers[c._id] = setTimeout(this._ended.bind(this, c), e)
			}
			this._webAudio && !d && (c._paused = !0, c._ended = !0, c._seek = c._start ||
				0, c._rateSeek = 0, this._clearTimer(c._id), this._cleanBuffer(c._node), b._autoSuspend());
			!this._webAudio && !d && this.stop(c._id);
			return this
		},
		_clearTimer: function(b) {
			if (this._endTimers[b]) {
				if ("function" !== typeof this._endTimers[b]) clearTimeout(this._endTimers[b]);
				else {
					var c = this._soundById(b);
					c && c._node && c._node.removeEventListener("ended", this._endTimers[b], !1)
				}
				delete this._endTimers[b]
			}
			return this
		},
		_soundById: function(b) {
			for (var c = 0; c < this._sounds.length; c++)
				if (b === this._sounds[c]._id) return this._sounds[c];
			return null
		},
		_inactiveSound: function() {
			this._drain();
			for (var b = 0; b < this._sounds.length; b++)
				if (this._sounds[b]._ended) return this._sounds[b].reset();
			return new d(this)
		},
		_drain: function() {
			var b = this._pool,
				c = 0,
				d = 0;
			if (!(this._sounds.length < b)) {
				for (d = 0; d < this._sounds.length; d++) this._sounds[d]._ended && c++;
				for (d = this._sounds.length - 1; 0 <= d && !(c <= b); d--) this._sounds[d]._ended && (this._webAudio && this._sounds[d]._node && this._sounds[d]._node.disconnect(0), this._sounds.splice(d, 1), c--)
			}
		},
		_getSoundIds: function(b) {
			if ("undefined" ===
				typeof b) {
				b = [];
				for (var c = 0; c < this._sounds.length; c++) b.push(this._sounds[c]._id);
				return b
			}
			return [b]
		},
		_refreshBuffer: function(c) {
			c._node.bufferSource = b.ctx.createBufferSource();
			c._node.bufferSource.buffer = f[this._src];
			c._panner ? c._node.bufferSource.connect(c._panner) : c._node.bufferSource.connect(c._node);
			if (c._node.bufferSource.loop = c._loop) c._node.bufferSource.loopStart = c._start || 0, c._node.bufferSource.loopEnd = c._stop;
			c._node.bufferSource.playbackRate.setValueAtTime(c._rate, b.ctx.currentTime);
			return this
		},
		_cleanBuffer: function(c) {
			if (b._scratchBuffer) {
				c.bufferSource.onended = null;
				c.bufferSource.disconnect(0);
				try {
					c.bufferSource.buffer = b._scratchBuffer
				} catch (d) {}
			}
			c.bufferSource = null;
			return this
		}
	};
	var d = function(b) {
		this._parent = b;
		this.init()
	};
	d.prototype = {
		init: function() {
			var c = this._parent;
			this._muted = c._muted;
			this._loop = c._loop;
			this._volume = c._volume;
			this._rate = c._rate;
			this._seek = 0;
			this._ended = this._paused = !0;
			this._sprite = "__default";
			this._id = ++b._counter;
			c._sounds.push(this);
			this.create();
			return this
		},
		create: function() {
			var c = this._parent,
				d = b._muted || this._muted || this._parent._muted ? 0 : this._volume;
			c._webAudio ? (this._node = "undefined" === typeof b.ctx.createGain ? b.ctx.createGainNode() : b.ctx.createGain(), this._node.gain.setValueAtTime(d, b.ctx.currentTime), this._node.paused = !0, this._node.connect(b.masterGain)) : (this._node = new Audio, this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, !1), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(b._canPlayEvent,
				this._loadFn, !1), this._node.src = c._src, this._node.preload = "auto", this._node.volume = d * b.volume(), this._node.load());
			return this
		},
		reset: function() {
			var c = this._parent;
			this._muted = c._muted;
			this._loop = c._loop;
			this._volume = c._volume;
			this._rate = c._rate;
			this._rateSeek = this._seek = 0;
			this._ended = this._paused = !0;
			this._sprite = "__default";
			this._id = ++b._counter;
			return this
		},
		_errorListener: function() {
			this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0);
			this._node.removeEventListener("error",
				this._errorFn, !1)
		},
		_loadListener: function() {
			var c = this._parent;
			c._duration = Math.ceil(10 * this._node.duration) / 10;
			0 === Object.keys(c._sprite).length && (c._sprite = {
				__default: [0, 1E3 * c._duration]
			});
			"loaded" !== c._state && (c._state = "loaded", c._emit("load"), c._loadQueue());
			this._node.removeEventListener(b._canPlayEvent, this._loadFn, !1)
		}
	};
	var f = {},
		g = function(c, d) {
			b.ctx.decodeAudioData(c, function(b) {
				b && 0 < d._sounds.length && (f[d._src] = b, q(d, b))
			}, function() {
				d._emit("loaderror", null, "Decoding audio data failed.")
			})
		},
		q = function(b, c) {
			c && !b._duration && (b._duration = c.duration);
			0 === Object.keys(b._sprite).length && (b._sprite = {
				__default: [0, 1E3 * b._duration]
			});
			"loaded" !== b._state && (b._state = "loaded", b._emit("load"), b._loadQueue())
		},
		m = function() {
			try {
				"undefined" !== typeof AudioContext ? b.ctx = new AudioContext : "undefined" !== typeof webkitAudioContext ? b.ctx = new webkitAudioContext : b.usingWebAudio = !1
			} catch (c) {
				b.usingWebAudio = !1
			}
			var d = /iP(hone|od|ad)/.test(b._navigator && b._navigator.platform),
				e = b._navigator && b._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
				e = e ? parseInt(e[1], 10) : null;
			if (d && (e && 9 > e) && (d = /safari/.test(b._navigator && b._navigator.userAgent.toLowerCase()), b._navigator && b._navigator.standalone && !d || b._navigator && !b._navigator.standalone && !d)) b.usingWebAudio = !1;
			b.usingWebAudio && (b.masterGain = "undefined" === typeof b.ctx.createGain ? b.ctx.createGainNode() : b.ctx.createGain(), b.masterGain.gain.setValueAtTime(b._muted ? 0 : 1, b.ctx.currentTime), b.masterGain.connect(b.ctx.destination));
			b._setup()
		};
	"function" === typeof define && define.amd && define([], function() {
		return {
			Howler: b,
			Howl: e
		}
	});
	"undefined" !== typeof exports && (exports.Howler = b, exports.Howl = e);
	"undefined" !== typeof window ? (window.HowlerGlobal = c, window.Howler = b, window.Howl = e, window.Sound = d) : "undefined" !== typeof global && (global.HowlerGlobal = c, global.Howler = b, global.Howl = e, global.Sound = d)
})();
(function() {
	HowlerGlobal.prototype._pos = [0, 0, 0];
	HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
	HowlerGlobal.prototype.stereo = function(b) {
		if (!this.ctx || !this.ctx.listener) return this;
		for (var c = this._howls.length - 1; 0 <= c; c--) this._howls[c].stereo(b);
		return this
	};
	HowlerGlobal.prototype.pos = function(b, c, d) {
		if (!this.ctx || !this.ctx.listener) return this;
		c = "number" !== typeof c ? this._pos[1] : c;
		d = "number" !== typeof d ? this._pos[2] : d;
		if ("number" === typeof b) this._pos = [b, c, d], "undefined" !== typeof this.ctx.listener.positionX ?
			(this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]);
		else return this._pos;
		return this
	};
	HowlerGlobal.prototype.orientation = function(b, c, d, e, j, l) {
		if (!this.ctx || !this.ctx.listener) return this;
		var p = this._orientation;
		c = "number" !==
			typeof c ? p[1] : c;
		d = "number" !== typeof d ? p[2] : d;
		e = "number" !== typeof e ? p[3] : e;
		j = "number" !== typeof j ? p[4] : j;
		l = "number" !== typeof l ? p[5] : l;
		if ("number" === typeof b) this._orientation = [b, c, d, e, j, l], "undefined" !== typeof this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(b, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardY.setTargetAtTime(c, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardZ.setTargetAtTime(d, Howler.ctx.currentTime, 0.1), this.ctx.listener.upX.setTargetAtTime(b, Howler.ctx.currentTime,
			0.1), this.ctx.listener.upY.setTargetAtTime(c, Howler.ctx.currentTime, 0.1), this.ctx.listener.upZ.setTargetAtTime(d, Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setOrientation(b, c, d, e, j, l);
		else return p;
		return this
	};
	var c = Howl.prototype.init;
	Howl.prototype.init = function(b) {
		this._orientation = b.orientation || [1, 0, 0];
		this._stereo = b.stereo || null;
		this._pos = b.pos || null;
		this._pannerAttr = {
			coneInnerAngle: "undefined" !== typeof b.coneInnerAngle ? b.coneInnerAngle : 360,
			coneOuterAngle: "undefined" !== typeof b.coneOuterAngle ?
				b.coneOuterAngle : 360,
			coneOuterGain: "undefined" !== typeof b.coneOuterGain ? b.coneOuterGain : 0,
			distanceModel: "undefined" !== typeof b.distanceModel ? b.distanceModel : "inverse",
			maxDistance: "undefined" !== typeof b.maxDistance ? b.maxDistance : 1E4,
			panningModel: "undefined" !== typeof b.panningModel ? b.panningModel : "HRTF",
			refDistance: "undefined" !== typeof b.refDistance ? b.refDistance : 1,
			rolloffFactor: "undefined" !== typeof b.rolloffFactor ? b.rolloffFactor : 1
		};
		this._onstereo = b.onstereo ? [{
			fn: b.onstereo
		}] : [];
		this._onpos = b.onpos ?
			[{
				fn: b.onpos
			}] : [];
		this._onorientation = b.onorientation ? [{
			fn: b.onorientation
		}] : [];
		return c.call(this, b)
	};
	Howl.prototype.stereo = function(b, c) {
		var e = this;
		if (!e._webAudio) return e;
		if ("loaded" !== e._state) return e._queue.push({
			event: "stereo",
			action: function() {
				e.stereo(b, c)
			}
		}), e;
		var m = "undefined" === typeof Howler.ctx.createStereoPanner ? "spatial" : "stereo";
		if ("undefined" === typeof c)
			if ("number" === typeof b) e._stereo = b, e._pos = [b, 0, 0];
			else return e._stereo;
		for (var j = e._getSoundIds(c), l = 0; l < j.length; l++) {
			var p = e._soundById(j[l]);
			if (p)
				if ("number" === typeof b) p._stereo = b, p._pos = [b, 0, 0], p._node && (p._pannerAttr.panningModel = "equalpower", (!p._panner || !p._panner.pan) && d(p, m), "spatial" === m ? (p._panner.positionX.setValueAtTime(b, Howler.ctx.currentTime), p._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), p._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : p._panner.pan.setValueAtTime(b, Howler.ctx.currentTime)), e._emit("stereo", p._id);
				else return p._stereo
		}
		return e
	};
	Howl.prototype.pos = function(b, c, e, m) {
		var j = this;
		if (!j._webAudio) return j;
		if ("loaded" !== j._state) return j._queue.push({
			event: "pos",
			action: function() {
				j.pos(b, c, e, m)
			}
		}), j;
		c = "number" !== typeof c ? 0 : c;
		e = "number" !== typeof e ? -0.5 : e;
		if ("undefined" === typeof m)
			if ("number" === typeof b) j._pos = [b, c, e];
			else return j._pos;
		for (var l = j._getSoundIds(m), p = 0; p < l.length; p++) {
			var r = j._soundById(l[p]);
			if (r)
				if ("number" === typeof b) r._pos = [b, c, e], r._node && ((!r._panner || r._panner.pan) && d(r, "spatial"), r._panner.positionX.setValueAtTime(b, Howler.ctx.currentTime), r._panner.positionY.setValueAtTime(c,
					Howler.ctx.currentTime), r._panner.positionZ.setValueAtTime(e, Howler.ctx.currentTime)), j._emit("pos", r._id);
				else return r._pos
		}
		return j
	};
	Howl.prototype.orientation = function(b, c, e, m) {
		var j = this;
		if (!j._webAudio) return j;
		if ("loaded" !== j._state) return j._queue.push({
			event: "orientation",
			action: function() {
				j.orientation(b, c, e, m)
			}
		}), j;
		c = "number" !== typeof c ? j._orientation[1] : c;
		e = "number" !== typeof e ? j._orientation[2] : e;
		if ("undefined" === typeof m)
			if ("number" === typeof b) j._orientation = [b, c, e];
			else return j._orientation;
		for (var l = j._getSoundIds(m), p = 0; p < l.length; p++) {
			var r = j._soundById(l[p]);
			if (r)
				if ("number" === typeof b) r._orientation = [b, c, e], r._node && (r._panner || (r._pos || (r._pos = j._pos || [0, 0, -0.5]), d(r, "spatial")), r._panner.orientationX.setValueAtTime(b, Howler.ctx.currentTime), r._panner.orientationY.setValueAtTime(c, Howler.ctx.currentTime), r._panner.orientationZ.setValueAtTime(e, Howler.ctx.currentTime)), j._emit("orientation", r._id);
				else return r._orientation
		}
		return j
	};
	Howl.prototype.pannerAttr = function() {
		var b = arguments,
			c, e;
		if (!this._webAudio) return this;
		if (0 === b.length) return this._pannerAttr;
		if (1 === b.length)
			if ("object" === typeof b[0]) c = b[0], "undefined" === typeof e && (c.pannerAttr || (c.pannerAttr = {
				coneInnerAngle: c.coneInnerAngle,
				coneOuterAngle: c.coneOuterAngle,
				coneOuterGain: c.coneOuterGain,
				distanceModel: c.distanceModel,
				maxDistance: c.maxDistance,
				refDistance: c.refDistance,
				rolloffFactor: c.rolloffFactor,
				panningModel: c.panningModel
			}), this._pannerAttr = {
				coneInnerAngle: "undefined" !== typeof c.pannerAttr.coneInnerAngle ? c.pannerAttr.coneInnerAngle : this._coneInnerAngle,
				coneOuterAngle: "undefined" !== typeof c.pannerAttr.coneOuterAngle ? c.pannerAttr.coneOuterAngle : this._coneOuterAngle,
				coneOuterGain: "undefined" !== typeof c.pannerAttr.coneOuterGain ? c.pannerAttr.coneOuterGain : this._coneOuterGain,
				distanceModel: "undefined" !== typeof c.pannerAttr.distanceModel ? c.pannerAttr.distanceModel : this._distanceModel,
				maxDistance: "undefined" !== typeof c.pannerAttr.maxDistance ? c.pannerAttr.maxDistance : this._maxDistance,
				refDistance: "undefined" !== typeof c.pannerAttr.refDistance ?
					c.pannerAttr.refDistance : this._refDistance,
				rolloffFactor: "undefined" !== typeof c.pannerAttr.rolloffFactor ? c.pannerAttr.rolloffFactor : this._rolloffFactor,
				panningModel: "undefined" !== typeof c.pannerAttr.panningModel ? c.pannerAttr.panningModel : this._panningModel
			});
			else return (b = this._soundById(parseInt(b[0], 10))) ? b._pannerAttr : this._pannerAttr;
		else 2 === b.length && (c = b[0], e = parseInt(b[1], 10));
		e = this._getSoundIds(e);
		for (var m = 0; m < e.length; m++)
			if (b = this._soundById(e[m])) {
				var j = b._pannerAttr,
					j = {
						coneInnerAngle: "undefined" !==
							typeof c.coneInnerAngle ? c.coneInnerAngle : j.coneInnerAngle,
						coneOuterAngle: "undefined" !== typeof c.coneOuterAngle ? c.coneOuterAngle : j.coneOuterAngle,
						coneOuterGain: "undefined" !== typeof c.coneOuterGain ? c.coneOuterGain : j.coneOuterGain,
						distanceModel: "undefined" !== typeof c.distanceModel ? c.distanceModel : j.distanceModel,
						maxDistance: "undefined" !== typeof c.maxDistance ? c.maxDistance : j.maxDistance,
						refDistance: "undefined" !== typeof c.refDistance ? c.refDistance : j.refDistance,
						rolloffFactor: "undefined" !== typeof c.rolloffFactor ?
							c.rolloffFactor : j.rolloffFactor,
						panningModel: "undefined" !== typeof c.panningModel ? c.panningModel : j.panningModel
					},
					l = b._panner;
				l ? (l.coneInnerAngle = j.coneInnerAngle, l.coneOuterAngle = j.coneOuterAngle, l.coneOuterGain = j.coneOuterGain, l.distanceModel = j.distanceModel, l.maxDistance = j.maxDistance, l.refDistance = j.refDistance, l.rolloffFactor = j.rolloffFactor, l.panningModel = j.panningModel) : (b._pos || (b._pos = this._pos || [0, 0, -0.5]), d(b, "spatial"))
			}
		return this
	};
	var b = Sound.prototype.init;
	Sound.prototype.init = function() {
		var c =
			this._parent;
		this._orientation = c._orientation;
		this._stereo = c._stereo;
		this._pos = c._pos;
		this._pannerAttr = c._pannerAttr;
		b.call(this);
		this._stereo ? c.stereo(this._stereo) : this._pos && c.pos(this._pos[0], this._pos[1], this._pos[2], this._id)
	};
	var e = Sound.prototype.reset;
	Sound.prototype.reset = function() {
		var b = this._parent;
		this._orientation = b._orientation;
		this._pos = b._pos;
		this._pannerAttr = b._pannerAttr;
		return e.call(this)
	};
	var d = function(b, c) {
		"spatial" === (c || "spatial") ? (b._panner = Howler.ctx.createPanner(), b._panner.coneInnerAngle =
			b._pannerAttr.coneInnerAngle, b._panner.coneOuterAngle = b._pannerAttr.coneOuterAngle, b._panner.coneOuterGain = b._pannerAttr.coneOuterGain, b._panner.distanceModel = b._pannerAttr.distanceModel, b._panner.maxDistance = b._pannerAttr.maxDistance, b._panner.refDistance = b._pannerAttr.refDistance, b._panner.rolloffFactor = b._pannerAttr.rolloffFactor, b._panner.panningModel = b._pannerAttr.panningModel, b._panner.positionX.setValueAtTime(b._pos[0], Howler.ctx.currentTime), b._panner.positionY.setValueAtTime(b._pos[1], Howler.ctx.currentTime),
			b._panner.positionZ.setValueAtTime(b._pos[2], Howler.ctx.currentTime), b._panner.orientationX.setValueAtTime(b._orientation[0], Howler.ctx.currentTime), b._panner.orientationY.setValueAtTime(b._orientation[1], Howler.ctx.currentTime), b._panner.orientationZ.setValueAtTime(b._orientation[2], Howler.ctx.currentTime)) : (b._panner = Howler.ctx.createStereoPanner(), b._panner.pan.setValueAtTime(b._stereo, Howler.ctx.currentTime));
		b._panner.connect(b._node);
		b._paused || b._parent.pause(b._id, !0).play(b._id, !0)
	}
})();
(function(c, b, e, d, f, g, q) {
	c.GoogleAnalyticsObject = f;
	c[f] = c[f] || function() {
		(c[f].q = c[f].q || []).push(arguments)
	};
	c[f].l = 1 * new Date;
	g = b.createElement(e);
	q = b.getElementsByTagName(e)[0];
	g.async = 1;
	g.src = d;
	q.parentNode.insertBefore(g, q)
})(window, document, "script", "", "ga");

(function(c) {
	Number.prototype.map = function(b, c, d, e) {
		return d + (e - d) * ((this - b) / (c - b))
	};
	Number.prototype.limit = function(b, c) {
		return Math.min(c, Math.max(b, this))
	};
	Number.prototype.round = function(b) {
		b = Math.pow(10, b || 0);
		return Math.round(this * b) / b
	};
	Number.prototype.floor = function() {
		return Math.floor(this)
	};
	Number.prototype.ceil = function() {
		return Math.ceil(this)
	};
	Number.prototype.toInt = function() {
		return this | 0
	};
	Number.prototype.toRad = function() {
		return this / 180 * Math.PI
	};
	Number.prototype.toDeg = function() {
		return 180 *
			this / Math.PI
	};
	Array.prototype.erase = function(b) {
		for (var c = this.length; c--;) this[c] === b && this.splice(c, 1);
		return this
	};
	Array.prototype.random = function() {
		return this[Math.floor(Math.random() * this.length)]
	};
	Function.prototype.bind = Function.prototype.bind || function(b) {
		if ("function" !== typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
		var c = Array.prototype.slice.call(arguments, 1),
			d = this,
			e = function() {},
			f = function() {
				return d.apply(this instanceof e && b ?
					this : b, c.concat(Array.prototype.slice.call(arguments)))
			};
		e.prototype = this.prototype;
		f.prototype = new e;
		return f
	};
	c.ig = {
		game: null,
		debug: null,
		version: "1.23",
		global: c,
		modules: {},
		resources: [],
		ready: !1,
		baked: !1,
		nocache: "",
		ua: {},
		prefix: c.ImpactPrefix || "",
		lib: "lib/",
		_current: null,
		_loadQueue: [],
		_waitForOnload: 0,
		$: function(b) {
			return "#" == b.charAt(0) ? document.getElementById(b.substr(1)) : document.getElementsByTagName(b)
		},
		$new: function(b) {
			return document.createElement(b)
		},
		copy: function(b) {
			if (!b || "object" != typeof b ||
				b instanceof HTMLElement || b instanceof ig.Class) return b;
			if (b instanceof Array)
				for (var c = [], d = 0, e = b.length; d < e; d++) c[d] = ig.copy(b[d]);
			else
				for (d in c = {}, b) c[d] = ig.copy(b[d]);
			return c
		},
		merge: function(b, c) {
			for (var d in c) {
				var e = c[d];
				if ("object" != typeof e || e instanceof HTMLElement || e instanceof ig.Class || null === e) b[d] = e;
				else {
					if (!b[d] || "object" != typeof b[d]) b[d] = e instanceof Array ? [] : {};
					ig.merge(b[d], e)
				}
			}
			return b
		},
		ksort: function(b) {
			if (!b || "object" != typeof b) return [];
			var c = [],
				d = [],
				e;
			for (e in b) c.push(e);
			c.sort();
			for (e = 0; e < c.length; e++) d.push(b[c[e]]);
			return d
		},
		setVendorAttribute: function(b, c, d) {
			var e = c.charAt(0).toUpperCase() + c.substr(1);
			b[c] = "undefined" !== typeof b.imageSmoothingEnabled ? b["ms" + e] = b["moz" + e] = b["o" + e] = d : b["ms" + e] = b["moz" + e] = b["webkit" + e] = b["o" + e] = d
		},
		getVendorAttribute: function(b, c) {
			var d = c.charAt(0).toUpperCase() + c.substr(1);
			return "undefined" !== typeof b.imageSmoothingEnabled ? b[c] || b["ms" + d] || b["moz" + d] || b["o" + d] : b[c] || b["ms" + d] || b["moz" + d] || b["webkit" + d] || b["o" + d]
		},
		normalizeVendorAttribute: function(b,
			c) {
			var d = ig.getVendorAttribute(b, c);
			!b[c] && d && (b[c] = d)
		},
		getImagePixels: function(b, c, d, e, f) {
			var g = ig.$new("canvas");
			g.width = b.width;
			g.height = b.height;
			var q = g.getContext("2d");
			ig.System.SCALE.CRISP(g, q);
			var u = ig.getVendorAttribute(q, "backingStorePixelRatio") || 1;
			ig.normalizeVendorAttribute(q, "getImageDataHD");
			var x = b.width / u,
				z = b.height / u;
			g.width = Math.ceil(x);
			g.height = Math.ceil(z);
			q.drawImage(b, 0, 0, x, z);
			return 1 === u ? q.getImageData(c, d, e, f) : q.getImageDataHD(c, d, e, f)
		},
		module: function(b) {
			if (ig._current) throw "Module '" +
				ig._current.name + "' defines nothing";
			if (ig.modules[b] && ig.modules[b].body) throw "Module '" + b + "' is already defined";
			ig._current = {
				name: b,
				requires: [],
				loaded: !1,
				body: null
			};
			ig.modules[b] = ig._current;
			ig._loadQueue.push(ig._current);
			return ig
		},
		requires: function() {
			ig._current.requires = Array.prototype.slice.call(arguments);
			return ig
		},
		defines: function(b) {
			ig._current.body = b;
			ig._current = null;
			ig._initDOMReady()
		},
		addResource: function(b) {
			ig.resources.push(b)
		},
		setNocache: function(b) {
			ig.nocache = b ? "?" + Date.now() : ""
		},
		log: function() {},
		assert: function() {},
		show: function() {},
		mark: function() {},
		_loadScript: function(b, c) {
			ig.modules[b] = {
				name: b,
				requires: [],
				loaded: !1,
				body: null
			};
			ig._waitForOnload++;
			var d = ig.prefix + ig.lib + b.replace(/\./g, "/") + ".js" + ig.nocache,
				e = ig.$new("script");
			e.type = "text/javascript";
			e.src = d;
			e.onload = function() {
				ig._waitForOnload--;
				ig._execModules()
			};
			e.onerror = function() {
				throw "Failed to load module " + b + " at " + d + " required from " + c;
			};
			ig.$("head")[0].appendChild(e)
		},
		_execModules: function() {
			for (var b = !1, c =
					0; c < ig._loadQueue.length; c++) {
				for (var d = ig._loadQueue[c], e = !0, f = 0; f < d.requires.length; f++) {
					var g = d.requires[f];
					ig.modules[g] ? ig.modules[g].loaded || (e = !1) : (e = !1, ig._loadScript(g, d.name))
				}
				e && d.body && (ig._loadQueue.splice(c, 1), d.loaded = !0, d.body(), b = !0, c--)
			}
			if (b) ig._execModules();
			else if (!ig.baked && 0 == ig._waitForOnload && 0 != ig._loadQueue.length) {
				b = [];
				for (c = 0; c < ig._loadQueue.length; c++) {
					e = [];
					g = ig._loadQueue[c].requires;
					for (f = 0; f < g.length; f++) d = ig.modules[g[f]], (!d || !d.loaded) && e.push(g[f]);
					b.push(ig._loadQueue[c].name +
						" (requires: " + e.join(", ") + ")")
				}
				throw "Unresolved (or circular?) dependencies. Most likely there's a name/path mismatch for one of the listed modules or a previous syntax error prevents a module from loading:\n" + b.join("\n");
			}
		},
		_DOMReady: function() {
			if (!ig.modules["dom.ready"].loaded) {
				if (!document.body) return setTimeout(ig._DOMReady, 13);
				ig.modules["dom.ready"].loaded = !0;
				ig._waitForOnload--;
				ig._execModules()
			}
			return 0
		},
		_boot: function() {
			document.location.href.match(/\?nocache/) && ig.setNocache(!0);
			ig.ua.pixelRatio =
				c.devicePixelRatio || 1;
			ig.ua.viewport = {
				width: c.innerWidth,
				height: c.innerHeight
			};
			ig.ua.screen = {
				width: c.screen.availWidth * ig.ua.pixelRatio,
				height: c.screen.availHeight * ig.ua.pixelRatio
			};
			ig.ua.iPhone = /iPhone/i.test(navigator.userAgent);
			ig.ua.iPhone4 = ig.ua.iPhone && 2 == ig.ua.pixelRatio;
			ig.ua.iPad = /iPad/i.test(navigator.userAgent);
			ig.ua.android = /android/i.test(navigator.userAgent);
			ig.ua.winPhone = /Windows Phone/i.test(navigator.userAgent);
			ig.ua.is_uiwebview = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
			ig.ua.is_safari_or_uiwebview = /(iPhone|iPod|iPad).*AppleWebKit/i.test(navigator.userAgent);
			ig.ua.iOS = ig.ua.iPhone || ig.ua.iPad;
			ig.ua.iOS6_tag = /OS 6_/i.test(navigator.userAgent);
			ig.ua.iOS6 = (ig.ua.iPhone || ig.ua.iPad) && ig.ua.iOS6_tag;
			ig.ua.iOSgt5 = ig.ua.iOS && 5 < parseInt(navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)[1]);
			ig.ua.HTCONE = /HTC_One/i.test(navigator.userAgent);
			ig.ua.winPhone = /Windows Phone/i.test(navigator.userAgent);
			ig.ua.Kindle = /Silk/i.test(navigator.userAgent);
			ig.ua.touchDevice = "ontouchstart" in
				c || c.navigator.msMaxTouchPoints;
			ig.ua.mobile = ig.ua.iOS || ig.ua.android || ig.ua.iOS6 || ig.ua.winPhone || ig.ua.Kindle || /mobile/i.test(navigator.userAgent)
		},
		_initDOMReady: function() {
			ig.modules["dom.ready"] ? ig._execModules() : (ig._boot(), ig.modules["dom.ready"] = {
				requires: [],
				loaded: !1,
				body: null
			}, ig._waitForOnload++, "complete" === document.readyState ? ig._DOMReady() : (document.addEventListener("DOMContentLoaded", ig._DOMReady, !1), c.addEventListener("load", ig._DOMReady, !1)))
		}
	};
	ig.normalizeVendorAttribute(c, "requestAnimationFrame");
	if (c.requestAnimationFrame) {
		var b = 1,
			e = {};
		c.ig.setAnimation = function(d, f) {
			var g = b++;
			e[g] = !0;
			var p = function() {
				e[g] && (c.requestAnimationFrame(p, f), d())
			};
			c.requestAnimationFrame(p, f);
			return g
		};
		c.ig.clearAnimation = function(b) {
			console.log(e);
			delete e[b]
		}
	} else c.ig.setAnimation = function(b) {
		return c.setInterval(b, 1E3 / 60)
	}, c.ig.clearAnimation = function(b) {
		c.clearInterval(b)
	};
	var d = !1,
		f = /xyz/.test(function() {
			xyz
		}) ? /\bparent\b/ : /.*/,
		g = 0;
	c.ig.Class = function() {};
	var q = function(b) {
		var c = this.prototype,
			d = {},
			e;
		for (e in b) "function" ==
			typeof b[e] && "function" == typeof c[e] && f.test(b[e]) ? (d[e] = c[e], c[e] = function(b, c) {
				return function() {
					var e = this.parent;
					this.parent = d[b];
					var f = c.apply(this, arguments);
					this.parent = e;
					return f
				}
			}(e, b[e])) : c[e] = b[e]
	};
	c.ig.Class.extend = function(b) {
		function e() {
			if (!d) {
				if (this.staticInstantiate) {
					var b = this.staticInstantiate.apply(this, arguments);
					if (b) return b
				}
				for (var c in this) "object" == typeof this[c] && (this[c] = ig.copy(this[c]));
				this.init && this.init.apply(this, arguments)
			}
			return this
		}
		var l = this.prototype;
		d = !0;
		var p = new this;
		d = !1;
		for (var r in b) p[r] = "function" == typeof b[r] && "function" == typeof l[r] && f.test(b[r]) ? function(b, c) {
			return function() {
				var d = this.parent;
				this.parent = l[b];
				var e = c.apply(this, arguments);
				this.parent = d;
				return e
			}
		}(r, b[r]) : b[r];
		e.prototype = p;
		e.prototype.constructor = e;
		e.extend = c.ig.Class.extend;
		e.inject = q;
		e.classId = p.classId = ++g;
		return e
	};
	c.ImpactMixin && ig.merge(ig, c.ImpactMixin)
})(window);
ig.baked = !0;
ig.module("impact.image").defines(function() {
	ig.Image = ig.Class.extend({
		data: null,
		width: 0,
		height: 0,
		loaded: !1,
		failed: !1,
		loadCallback: null,
		path: "",
		staticInstantiate: function(c) {
			return ig.Image.cache[c] || null
		},
		init: function(c) {
			this.path = c;
			this.load()
		},
		load: function(c) {
			this.loaded ? c && c(this.path, !0) : (!this.loaded && ig.ready ? (this.loadCallback = c || null, this.data = new Image, this.data.onload = this.onload.bind(this), this.data.onerror = this.onerror.bind(this), this.data.src = ig.prefix + this.path + ig.nocache) : ig.addResource(this),
				ig.Image.cache[this.path] = this)
		},
		reload: function() {
			this.loaded = !1;
			this.data = new Image;
			this.data.onload = this.onload.bind(this);
			this.data.src = this.path + "?" + Date.now()
		},
		onload: function() {
			this.width = this.data.width;
			this.height = this.data.height;
			this.loaded = !0;
			1 != ig.system.scale && this.resize(ig.system.scale);
			this.loadCallback && this.loadCallback(this.path, !0)
		},
		onerror: function() {
			this.failed = !0;
			this.loadCallback && this.loadCallback(this.path, !1)
		},
		resize: function(c) {
			var b = ig.getImagePixels(this.data, 0, 0, this.width,
					this.height),
				e = this.width * c,
				d = this.height * c,
				f = ig.$new("canvas");
			f.width = e;
			f.height = d;
			for (var g = f.getContext("2d"), q = g.getImageData(0, 0, e, d), m = 0; m < d; m++)
				for (var j = 0; j < e; j++) {
					var l = 4 * (Math.floor(m / c) * this.width + Math.floor(j / c)),
						p = 4 * (m * e + j);
					q.data[p] = b.data[l];
					q.data[p + 1] = b.data[l + 1];
					q.data[p + 2] = b.data[l + 2];
					q.data[p + 3] = b.data[l + 3]
				}
			g.putImageData(q, 0, 0);
			this.data = f
		},
		draw: function(c, b, e, d, f, g) {
			if (this.loaded) {
				var q = ig.system.scale;
				f = (f ? f : this.width) * q;
				g = (g ? g : this.height) * q;
				ig.system.context.drawImage(this.data,
					e ? e * q : 0, d ? d * q : 0, f, g, ig.system.getDrawPos(c), ig.system.getDrawPos(b), f, g);
				ig.Image.drawCount++
			}
		},
		drawTile: function(c, b, e, d, f, g, q) {
			f = f ? f : d;
			if (this.loaded && !(d > this.width || f > this.height)) {
				var m = ig.system.scale,
					j = Math.floor(d * m),
					l = Math.floor(f * m),
					p = g ? -1 : 1,
					r = q ? -1 : 1;
				if (g || q) ig.system.context.save(), ig.system.context.scale(p, r);
				ig.system.context.drawImage(this.data, Math.floor(e * d) % this.width * m, Math.floor(e * d / this.width) * f * m, j, l, ig.system.getDrawPos(c) * p - (g ? j : 0), ig.system.getDrawPos(b) * r - (q ? l : 0), j, l);
				(g ||
					q) && ig.system.context.restore();
				ig.Image.drawCount++
			}
		}
	});
	ig.Image.drawCount = 0;
	ig.Image.cache = {};
	ig.Image.reloadCache = function() {
		for (var c in ig.Image.cache) ig.Image.cache[c].reload()
	}
});
ig.baked = !0;
ig.module("impact.font").requires("impact.image").defines(function() {
	ig.Font = ig.Image.extend({
		widthMap: [],
		indices: [],
		firstChar: 32,
		alpha: 1,
		letterSpacing: 1,
		lineSpacing: 0,
		onload: function(c) {
			this._loadMetrics(this.data);
			this.parent(c)
		},
		widthForString: function(c) {
			if (-1 !== c.indexOf("\n")) {
				c = c.split("\n");
				for (var b = 0, e = 0; e < c.length; e++) b = Math.max(b, this._widthForLine(c[e]));
				return b
			}
			return this._widthForLine(c)
		},
		_widthForLine: function(c) {
			for (var b = 0, e = 0; e < c.length; e++) b += this.widthMap[c.charCodeAt(e) - this.firstChar] +
				this.letterSpacing;
			return b
		},
		heightForString: function(c) {
			return c.split("\n").length * (this.height + this.lineSpacing)
		},
		draw: function(c, b, e, d) {
			"string" != typeof c && (c = c.toString());
			if (-1 !== c.indexOf("\n")) {
				c = c.split("\n");
				for (var f = this.height + this.lineSpacing, g = 0; g < c.length; g++) this.draw(c[g], b, e + g * f, d)
			} else {
				if (d == ig.Font.ALIGN.RIGHT || d == ig.Font.ALIGN.CENTER) g = this._widthForLine(c), b -= d == ig.Font.ALIGN.CENTER ? g / 2 : g;
				1 !== this.alpha && (ig.system.context.globalAlpha = this.alpha);
				for (g = 0; g < c.length; g++) d = c.charCodeAt(g),
					b += this._drawChar(d - this.firstChar, b, e);
				1 !== this.alpha && (ig.system.context.globalAlpha = 1);
				ig.Image.drawCount += c.length
			}
		},
		_drawChar: function(c, b, e) {
			if (!this.loaded || 0 > c || c >= this.indices.length) return 0;
			var d = ig.system.scale,
				f = this.widthMap[c] * d,
				g = (this.height - 2) * d;
			ig.system.context.drawImage(this.data, this.indices[c] * d, 0, f, g, ig.system.getDrawPos(b), ig.system.getDrawPos(e), f, g);
			return this.widthMap[c] + this.letterSpacing
		},
		_loadMetrics: function(c) {
			this.height = c.height - 1;
			this.widthMap = [];
			this.indices =
				[];
			for (var b = ig.getImagePixels(c, 0, c.height - 1, c.width, 1), e = 0, d = 0, f = 0; f < c.width; f++) {
				var g = 4 * f + 3;
				127 < b.data[g] ? d++ : 128 > b.data[g] && d && (this.widthMap.push(d), this.indices.push(f - d), e++, d = 0)
			}
			this.widthMap.push(d);
			this.indices.push(f - d)
		}
	});
	ig.Font.ALIGN = {
		LEFT: 0,
		RIGHT: 1,
		CENTER: 2
	}
});
ig.baked = !0;
ig.module("impact.sound").defines(function() {
	ig.SoundManager = ig.Class.extend({
		clips: {},
		volume: 1,
		format: null,
		init: function() {
			if (!ig.Sound.enabled || !window.Audio) ig.Sound.enabled = !1;
			else {
				for (var c = new Audio, b = 0; b < ig.Sound.use.length; b++) {
					var e = ig.Sound.use[b];
					if (c.canPlayType(e.mime)) {
						this.format = e;
						break
					}
				}
				this.format || (ig.Sound.enabled = !1)
			}
		},
		load: function(c, b, e) {
			var d = ig.prefix + c.replace(/[^\.]+$/, this.format.ext) + ig.nocache;
			if (this.clips[c]) {
				if (b && this.clips[c].length < ig.Sound.channels)
					for (b = this.clips[c].length; b <
						ig.Sound.channels; b++) {
						var f = new Audio(d);
						f.load();
						this.clips[c].push(f)
					}
				return this.clips[c][0]
			}
			var g = new Audio(d);
			e && (g.addEventListener("canplaythrough", function m(b) {
				g.removeEventListener("canplaythrough", m, !1);
				e(c, !0, b)
			}, !1), g.addEventListener("error", function(b) {
				e(c, !1, b)
			}, !1));
			g.preload = "auto";
			g.load();
			this.clips[c] = [g];
			if (b)
				for (b = 1; b < ig.Sound.channels; b++) f = new Audio(d), f.load(), this.clips[c].push(f);
			return g
		},
		get: function(c) {
			c = this.clips[c];
			for (var b = 0, e; e = c[b++];)
				if (e.paused || e.ended) return e.ended &&
					(e.currentTime = 0), e;
			c[0].pause();
			c[0].currentTime = 0;
			return c[0]
		}
	});
	ig.Music = ig.Class.extend({
		tracks: [],
		namedTracks: {},
		currentTrack: null,
		currentIndex: 0,
		random: !1,
		_volume: 1,
		_loop: !1,
		_fadeInterval: 0,
		_fadeTimer: null,
		_endedCallbackBound: null,
		init: function() {
			this._endedCallbackBound = this._endedCallback.bind(this);
			Object.defineProperty ? (Object.defineProperty(this, "volume", {
					get: this.getVolume.bind(this),
					set: this.setVolume.bind(this)
				}), Object.defineProperty(this, "loop", {
					get: this.getLooping.bind(this),
					set: this.setLooping.bind(this)
				})) :
				this.__defineGetter__ && (this.__defineGetter__("volume", this.getVolume.bind(this)), this.__defineSetter__("volume", this.setVolume.bind(this)), this.__defineGetter__("loop", this.getLooping.bind(this)), this.__defineSetter__("loop", this.setLooping.bind(this)))
		},
		add: function(c, b) {
			if (ig.Sound.enabled) {
				var e = ig.soundManager.load(c instanceof ig.Sound ? c.path : c, !1);
				e.loop = this._loop;
				e.volume = this._volume;
				e.addEventListener("ended", this._endedCallbackBound, !1);
				this.tracks.push(e);
				b && (this.namedTracks[b] = e);
				this.currentTrack ||
					(this.currentTrack = e)
			}
		},
		next: function() {
			this.tracks.length && (this.stop(), this.currentIndex = this.random ? Math.floor(Math.random() * this.tracks.length) : (this.currentIndex + 1) % this.tracks.length, this.currentTrack = this.tracks[this.currentIndex], this.play())
		},
		pause: function() {
			this.currentTrack && this.currentTrack.pause()
		},
		stop: function() {
			this.currentTrack && (this.currentTrack.pause(), this.currentTrack.currentTime = 0)
		},
		play: function(c) {
			if (c && this.namedTracks[c]) c = this.namedTracks[c], c != this.currentTrack && (this.stop(),
				this.currentTrack = c);
			else if (!this.currentTrack) return;
			this.currentTrack.play()
		},
		getLooping: function() {
			return this._loop
		},
		setLooping: function(c) {
			this._loop = c;
			for (var b in this.tracks) this.tracks[b].loop = c
		},
		getVolume: function() {
			return this._volume
		},
		setVolume: function(c) {
			this._volume = c.limit(0, 1);
			for (var b in this.tracks) this.tracks[b].volume = this._volume
		},
		fadeOut: function(c) {
			this.currentTrack && (clearInterval(this._fadeInterval), this.fadeTimer = new ig.Timer(c), this._fadeInterval = setInterval(this._fadeStep.bind(this),
				50))
		},
		_fadeStep: function() {
			var c = this.fadeTimer.delta().map(-this.fadeTimer.target, 0, 1, 0).limit(0, 1) * this._volume;
			0.01 >= c ? (this.stop(), this.currentTrack.volume = this._volume, clearInterval(this._fadeInterval)) : this.currentTrack.volume = c
		},
		_endedCallback: function() {
			this._loop ? this.play() : this.next()
		}
	});
	ig.Sound = ig.Class.extend({
		path: "",
		volume: 1,
		currentClip: null,
		multiChannel: !0,
		init: function(c, b) {
			this.path = c;
			this.multiChannel = !1 !== b;
			this.load()
		},
		load: function(c) {
			ig.Sound.enabled ? ig.ready ? ig.soundManager.load(this.path,
				this.multiChannel, c) : ig.addResource(this) : c && c(this.path, !0)
		},
		play: function() {
			ig.Sound.enabled && (this.currentClip = ig.soundManager.get(this.path), this.currentClip.volume = ig.soundManager.volume * this.volume, this.currentClip.play())
		},
		stop: function() {
			this.currentClip && (this.currentClip.pause(), this.currentClip.currentTime = 0)
		}
	});
	ig.Sound.FORMAT = {
		MP3: {
			ext: "mp3",
			mime: "audio/mpeg"
		},
		M4A: {
			ext: "m4a",
			mime: "audio/mp4; codecs=mp4a"
		},
		OGG: {
			ext: "ogg",
			mime: "audio/ogg; codecs=vorbis"
		},
		WEBM: {
			ext: "webm",
			mime: "audio/webm; codecs=vorbis"
		},
		CAF: {
			ext: "caf",
			mime: "audio/x-caf"
		}
	};
	ig.Sound.use = [ig.Sound.FORMAT.OGG, ig.Sound.FORMAT.MP3];
	ig.Sound.channels = 4;
	ig.Sound.enabled = !0
});
ig.baked = !0;
ig.module("impact.loader").requires("impact.image", "impact.font", "impact.sound").defines(function() {
	ig.Loader = ig.Class.extend({
		resources: [],
		gameClass: null,
		status: 0,
		done: !1,
		_unloaded: [],
		_drawStatus: 0,
		_intervalId: 0,
		_loadCallbackBound: null,
		init: function(c, b) {
			this.gameClass = c;
			this.resources = b;
			this._loadCallbackBound = this._loadCallback.bind(this);
			for (var e = 0; e < this.resources.length; e++) this._unloaded.push(this.resources[e].path)
		},
		load: function() {
			ig.system.clear("#000");
			if (this.resources.length) {
				for (var c =
						0; c < this.resources.length; c++) this.loadResource(this.resources[c]);
				this._intervalId = setInterval(this.draw.bind(this), 16)
			} else this.end()
		},
		loadResource: function(c) {
			c.load(this._loadCallbackBound)
		},
		end: function() {
			this.done || (this.done = !0, clearInterval(this._intervalId))
		},
		draw: function() {},
		_loadCallback: function(c, b) {
			if (b) this._unloaded.erase(c);
			else throw "Failed to load resource: " + c;
			this.status = 1 - this._unloaded.length / this.resources.length;
			0 == this._unloaded.length && setTimeout(this.end.bind(this), 250)
		}
	})
});
ig.baked = !0;
ig.module("impact.timer").defines(function() {
	ig.Timer = ig.Class.extend({
		target: 0,
		base: 0,
		last: 0,
		pausedAt: 0,
		init: function(c) {
			this.last = this.base = ig.Timer.time;
			this.target = c || 0
		},
		set: function(c) {
			this.target = c || 0;
			this.base = ig.Timer.time;
			this.pausedAt = 0
		},
		reset: function() {
			this.base = ig.Timer.time;
			this.pausedAt = 0
		},
		tick: function() {
			var c = ig.Timer.time - this.last;
			this.last = ig.Timer.time;
			return this.pausedAt ? 0 : c
		},
		delta: function() {
			return (this.pausedAt || ig.Timer.time) - this.base - this.target
		},
		pause: function() {
			this.pausedAt || (this.pausedAt =
				ig.Timer.time)
		},
		unpause: function() {
			this.pausedAt && (this.base += ig.Timer.time - this.pausedAt, this.pausedAt = 0)
		}
	});
	ig.Timer._last = 0;
	ig.Timer.time = Number.MIN_VALUE;
	ig.Timer.timeScale = 1;
	ig.Timer.maxStep = 0.05;
	ig.Timer.step = function() {
		var c = Date.now();
		ig.Timer.time += Math.min((c - ig.Timer._last) / 1E3, ig.Timer.maxStep) * ig.Timer.timeScale;
		ig.Timer._last = c
	}
});
ig.baked = !0;
ig.module("impact.system").requires("impact.timer", "impact.image").defines(function() {
	ig.System = ig.Class.extend({
		fps: 30,
		width: 320,
		height: 240,
		realWidth: 320,
		realHeight: 240,
		scale: 1,
		tick: 0,
		animationId: 0,
		newGameClass: null,
		running: !1,
		delegate: null,
		clock: null,
		canvas: null,
		context: null,
		init: function(c, b, e, d, f) {
			this.fps = b;
			this.clock = new ig.Timer;
			this.canvas = ig.$(c);
			this.resize(e, d, f);
			this.context = this.canvas.getContext("2d");
			this.getDrawPos = ig.System.drawMode;
			1 != this.scale && (ig.System.scaleMode = ig.System.SCALE.CRISP);
			ig.System.scaleMode(this.canvas, this.context)
		},
		resize: function(c, b, e) {
			this.width = c;
			this.height = b;
			this.scale = e || this.scale;
			this.realWidth = this.width * this.scale;
			this.realHeight = this.height * this.scale;
			this.canvas.width = this.realWidth;
			this.canvas.height = this.realHeight
		},
		setGame: function(c) {
			this.running ? this.newGameClass = c : this.setGameNow(c)
		},
		setGameNow: function(c) {
			ig.game = new c;
			ig.system.setDelegate(ig.game)
		},
		setDelegate: function(c) {
			if ("function" == typeof c.run) this.delegate = c, this.startRunLoop();
			else throw "System.setDelegate: No run() function in object";
		},
		stopRunLoop: function() {
			ig.clearAnimation(this.animationId);
			this.running = !1
		},
		startRunLoop: function() {
			this.stopRunLoop();
			this.animationId = ig.setAnimation(this.run.bind(this), this.canvas);
			this.running = !0
		},
		clear: function(c) {
			this.context.fillStyle = c;
			this.context.fillRect(0, 0, this.realWidth, this.realHeight)
		},
		run: function() {
			ig.Timer.step();
			this.tick = this.clock.tick();
			this.delegate.run();
			ig.input.clearPressed();
			this.newGameClass && (this.setGameNow(this.newGameClass), this.newGameClass = null)
		},
		getDrawPos: null
	});
	ig.System.DRAW = {
		AUTHENTIC: function(c) {
			return Math.round(c) * this.scale
		},
		SMOOTH: function(c) {
			return Math.round(c * this.scale)
		},
		SUBPIXEL: function(c) {
			return c * this.scale
		}
	};
	ig.System.drawMode = ig.System.DRAW.SMOOTH;
	ig.System.SCALE = {
		CRISP: function(c, b) {
			ig.setVendorAttribute(b, "imageSmoothingEnabled", !1);
			c.style.imageRendering = "-moz-crisp-edges";
			c.style.imageRendering = "-o-crisp-edges";
			c.style.imageRendering = "-webkit-optimize-contrast";
			c.style.imageRendering = "crisp-edges";
			c.style.msInterpolationMode = "nearest-neighbor"
		},
		SMOOTH: function(c, b) {
			ig.setVendorAttribute(b, "imageSmoothingEnabled", !0);
			c.style.imageRendering = "";
			c.style.msInterpolationMode = ""
		}
	};
	ig.System.scaleMode = ig.System.SCALE.SMOOTH
});
ig.baked = !0;
ig.module("impact.input").defines(function() {
	ig.KEY = {
		MOUSE1: -1,
		MOUSE2: -3,
		MWHEEL_UP: -4,
		MWHEEL_DOWN: -5,
		BACKSPACE: 8,
		TAB: 9,
		ENTER: 13,
		PAUSE: 19,
		CAPS: 20,
		ESC: 27,
		SPACE: 32,
		PAGE_UP: 33,
		PAGE_DOWN: 34,
		END: 35,
		HOME: 36,
		LEFT_ARROW: 37,
		UP_ARROW: 38,
		RIGHT_ARROW: 39,
		DOWN_ARROW: 40,
		INSERT: 45,
		DELETE: 46,
		_0: 48,
		_1: 49,
		_2: 50,
		_3: 51,
		_4: 52,
		_5: 53,
		_6: 54,
		_7: 55,
		_8: 56,
		_9: 57,
		A: 65,
		B: 66,
		C: 67,
		D: 68,
		E: 69,
		F: 70,
		G: 71,
		H: 72,
		I: 73,
		J: 74,
		K: 75,
		L: 76,
		M: 77,
		N: 78,
		O: 79,
		P: 80,
		Q: 81,
		R: 82,
		S: 83,
		T: 84,
		U: 85,
		V: 86,
		W: 87,
		X: 88,
		Y: 89,
		Z: 90,
		NUMPAD_0: 96,
		NUMPAD_1: 97,
		NUMPAD_2: 98,
		NUMPAD_3: 99,
		NUMPAD_4: 100,
		NUMPAD_5: 101,
		NUMPAD_6: 102,
		NUMPAD_7: 103,
		NUMPAD_8: 104,
		NUMPAD_9: 105,
		MULTIPLY: 106,
		ADD: 107,
		SUBSTRACT: 109,
		DECIMAL: 110,
		DIVIDE: 111,
		F1: 112,
		F2: 113,
		F3: 114,
		F4: 115,
		F5: 116,
		F6: 117,
		F7: 118,
		F8: 119,
		F9: 120,
		F10: 121,
		F11: 122,
		F12: 123,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		PLUS: 187,
		COMMA: 188,
		MINUS: 189,
		PERIOD: 190
	};
	ig.Input = ig.Class.extend({
		bindings: {},
		actions: {},
		presses: {},
		locks: {},
		delayedKeyup: {},
		isUsingMouse: !1,
		isUsingKeyboard: !1,
		isUsingAccelerometer: !1,
		mouse: {
			x: 0,
			y: 0
		},
		accel: {
			x: 0,
			y: 0,
			z: 0
		},
		initMouse: function() {
			if (!this.isUsingMouse) {
				this.isUsingMouse = !0;
				var c = this.mousewheel.bind(this);
				ig.system.canvas.addEventListener("mousewheel", c, !1);
				ig.system.canvas.addEventListener("DOMMouseScroll", c, !1);
				ig.system.canvas.addEventListener("contextmenu", this.contextmenu.bind(this), !1);
				ig.system.canvas.addEventListener("mousedown", this.keydown.bind(this), !1);
				ig.system.canvas.addEventListener("mouseup", this.keyup.bind(this), !1);
				ig.system.canvas.addEventListener("mousemove", this.mousemove.bind(this), !1);
				ig.ua.touchDevice && (ig.system.canvas.addEventListener("touchstart",
					this.keydown.bind(this), !1), ig.system.canvas.addEventListener("touchend", this.keyup.bind(this), !1), ig.system.canvas.addEventListener("touchmove", this.mousemove.bind(this), !1), ig.system.canvas.addEventListener("MSPointerDown", this.keydown.bind(this), !1), ig.system.canvas.addEventListener("MSPointerUp", this.keyup.bind(this), !1), ig.system.canvas.addEventListener("MSPointerMove", this.mousemove.bind(this), !1), ig.system.canvas.style.msTouchAction = "none")
			}
		},
		initKeyboard: function() {
			this.isUsingKeyboard || (this.isUsingKeyboard = !0, window.addEventListener("keydown", this.keydown.bind(this), !1), window.addEventListener("keyup", this.keyup.bind(this), !1))
		},
		initAccelerometer: function() {
			this.isUsingAccelerometer || window.addEventListener("devicemotion", this.devicemotion.bind(this), !1)
		},
		mousewheel: function(c) {
			var b = this.bindings[0 < (c.wheelDelta ? c.wheelDelta : -1 * c.detail) ? ig.KEY.MWHEEL_UP : ig.KEY.MWHEEL_DOWN];
			b && (this.actions[b] = !0, this.presses[b] = !0, this.delayedKeyup[b] = !0, c.stopPropagation(), c.preventDefault())
		},
		mousemove: function(c) {
			var b =
				parseInt(ig.system.canvas.offsetWidth) || ig.system.realWidth;
			ig.ua.mobile && (b = ig.system.realWidth);
			var b = ig.system.scale * (b / ig.system.realWidth),
				e = {
					left: 0,
					top: 0
				};
			ig.system.canvas.getBoundingClientRect && (e = ig.system.canvas.getBoundingClientRect());
			c = c.touches ? c.touches[0] : c;
			this.mouse.x = (c.clientX - e.left) / b;
			this.mouse.y = (c.clientY - e.top) / b
		},
		contextmenu: function(c) {
			this.bindings[ig.KEY.MOUSE2] && (c.stopPropagation(), c.preventDefault())
		},
		keydown: function(c) {
			var b = c.target.tagName;
			"INPUT" == b || "TEXTAREA" ==
				b || (b = "keydown" == c.type ? c.keyCode : 2 == c.button ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1, ("touchstart" == c.type || "mousedown" == c.type) && this.mousemove(c), b = this.bindings[b], console.log(b), b && (this.actions[b] = !0, this.locks[b] || (this.presses[b] = !0, this.locks[b] = !0), c.stopPropagation(), c.preventDefault()))
		},
		keyup: function(c) {
			var b = c.target.tagName;
			if (!("INPUT" == b || "TEXTAREA" == b))
				if (b = this.bindings["keyup" == c.type ? c.keyCode : 2 == c.button ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1]) this.delayedKeyup[b] = !0, c.stopPropagation(), c.preventDefault()
		},
		devicemotion: function(c) {
			this.accel = c.accelerationIncludingGravity
		},
		bind: function(c, b) {
			0 > c ? this.initMouse() : 0 < c && this.initKeyboard();
			this.bindings[c] = b
		},
		bindTouch: function(c, b) {
			var e = ig.$(c),
				d = this;
			e.addEventListener("touchstart", function(c) {
				d.touchStart(c, b)
			}, !1);
			e.addEventListener("touchend", function(c) {
				d.touchEnd(c, b)
			}, !1);
			e.addEventListener("MSPointerDown", function(c) {
				d.touchStart(c, b)
			}, !1);
			e.addEventListener("MSPointerUp", function(c) {
				d.touchEnd(c, b)
			}, !1)
		},
		unbind: function(c) {
			this.delayedKeyup[this.bindings[c]] = !0;
			this.bindings[c] = null
		},
		unbindAll: function() {
			this.bindings = {};
			this.actions = {};
			this.presses = {};
			this.locks = {};
			this.delayedKeyup = {}
		},
		state: function(c) {
			return this.actions[c]
		},
		pressed: function(c) {
			return this.presses[c]
		},
		released: function(c) {
			return !!this.delayedKeyup[c]
		},
		clearPressed: function() {
			for (var c in this.delayedKeyup) this.actions[c] = !1, this.locks[c] = !1;
			this.delayedKeyup = {};
			this.presses = {}
		},
		touchStart: function(c, b) {
			this.actions[b] = !0;
			this.presses[b] = !0;
			c.stopPropagation();
			c.preventDefault();
			return !1
		},
		touchEnd: function(c, b) {
			this.delayedKeyup[b] = !0;
			c.stopPropagation();
			c.preventDefault();
			return !1
		}
	})
});
ig.baked = !0;
ig.module("impact.impact").requires("dom.ready", "impact.loader", "impact.system", "impact.input", "impact.sound").defines(function() {
	ig.main = function(c, b, e, d, f, g, q) {
		ig.system = new ig.System(c, e, d, f, g || 1);
		ig.input = new ig.Input;
		ig.soundManager = new ig.SoundManager;
		ig.music = new ig.Music;
		ig.ready = !0;
		(new(q || ig.Loader)(b, ig.resources)).load()
	}
});
ig.baked = !0;
ig.module("impact.animation").requires("impact.timer", "impact.image").defines(function() {
	ig.AnimationSheet = ig.Class.extend({
		width: 8,
		height: 8,
		image: null,
		init: function(c, b, e) {
			this.width = b;
			this.height = e;
			this.image = new ig.Image(c)
		}
	});
	ig.Animation = ig.Class.extend({
		sheet: null,
		timer: null,
		sequence: [],
		flip: {
			x: !1,
			y: !1
		},
		pivot: {
			x: 0,
			y: 0
		},
		frame: 0,
		tile: 0,
		loopCount: 0,
		alpha: 1,
		angle: 0,
		init: function(c, b, e, d) {
			this.sheet = c;
			this.pivot = {
				x: c.width / 2,
				y: c.height / 2
			};
			this.timer = new ig.Timer;
			this.frameTime = b;
			this.sequence = e;
			this.stop = !!d;
			this.tile = this.sequence[0]
		},
		rewind: function() {
			this.timer.set();
			this.frame = this.loopCount = 0;
			this.tile = this.sequence[0];
			return this
		},
		gotoFrame: function(c) {
			this.timer.set(this.frameTime * -c - 1E-4);
			this.update()
		},
		gotoRandomFrame: function() {
			this.gotoFrame(Math.floor(Math.random() * this.sequence.length))
		},
		update: function() {
			var c = Math.floor(this.timer.delta() / this.frameTime);
			this.loopCount = Math.floor(c / this.sequence.length);
			this.frame = this.stop && 0 < this.loopCount ? this.sequence.length - 1 : c % this.sequence.length;
			this.tile = this.sequence[this.frame]
		},
		draw: function(c, b) {
			var e = Math.max(this.sheet.width, this.sheet.height);
			c > ig.system.width || (b > ig.system.height || 0 > c + e || 0 > b + e) || (1 != this.alpha && (ig.system.context.globalAlpha = this.alpha), 0 == this.angle ? this.sheet.image.drawTile(c, b, this.tile, this.sheet.width, this.sheet.height, this.flip.x, this.flip.y) : (ig.system.context.save(), ig.system.context.translate(ig.system.getDrawPos(c + this.pivot.x), ig.system.getDrawPos(b + this.pivot.y)), ig.system.context.rotate(this.angle),
				this.sheet.image.drawTile(-this.pivot.x, -this.pivot.y, this.tile, this.sheet.width, this.sheet.height, this.flip.x, this.flip.y), ig.system.context.restore()), 1 != this.alpha && (ig.system.context.globalAlpha = 1))
		}
	})
});
ig.baked = !0;
ig.module("impact.entity").requires("impact.animation", "impact.impact").defines(function() {
	ig.Entity = ig.Class.extend({
		id: 0,
		settings: {},
		size: {
			x: 16,
			y: 16
		},
		offset: {
			x: 0,
			y: 0
		},
		pos: {
			x: 0,
			y: 0
		},
		last: {
			x: 0,
			y: 0
		},
		vel: {
			x: 0,
			y: 0
		},
		accel: {
			x: 0,
			y: 0
		},
		friction: {
			x: 0,
			y: 0
		},
		maxVel: {
			x: 100,
			y: 100
		},
		zIndex: 0,
		gravityFactor: 1,
		standing: !1,
		bounciness: 0,
		minBounceVelocity: 40,
		anims: {},
		animSheet: null,
		currentAnim: null,
		health: 10,
		type: 0,
		checkAgainst: 0,
		collides: 0,
		_killed: !1,
		slopeStanding: {
			min: (44).toRad(),
			max: (136).toRad()
		},
		init: function(c,
			b, e) {
			this.id = ++ig.Entity._lastId;
			this.pos.x = this.last.x = c;
			this.pos.y = this.last.y = b;
			ig.merge(this, e)
		},
		reset: function(c, b, e) {
			var d = this.constructor.prototype;
			this.pos.x = c;
			this.pos.y = b;
			this.last.x = c;
			this.last.y = b;
			this.vel.x = d.vel.x;
			this.vel.y = d.vel.y;
			this.accel.x = d.accel.x;
			this.accel.y = d.accel.y;
			this.health = d.health;
			this._killed = d._killed;
			this.standing = d.standing;
			this.type = d.type;
			this.checkAgainst = d.checkAgainst;
			this.collides = d.collides;
			ig.merge(this, e)
		},
		addAnim: function(c, b, e, d) {
			if (!this.animSheet) throw "No animSheet to add the animation " +
				c + " to.";
			b = new ig.Animation(this.animSheet, b, e, d);
			this.anims[c] = b;
			this.currentAnim || (this.currentAnim = b);
			return b
		},
		update: function() {
			this.last.x = this.pos.x;
			this.last.y = this.pos.y;
			this.vel.y += ig.game.gravity * ig.system.tick * this.gravityFactor;
			this.vel.x = this.getNewVelocity(this.vel.x, this.accel.x, this.friction.x, this.maxVel.x);
			this.vel.y = this.getNewVelocity(this.vel.y, this.accel.y, this.friction.y, this.maxVel.y);
			var c = ig.game.collisionMap.trace(this.pos.x, this.pos.y, this.vel.x * ig.system.tick, this.vel.y *
				ig.system.tick, this.size.x, this.size.y);
			this.handleMovementTrace(c);
			this.currentAnim && this.currentAnim.update()
		},
		getNewVelocity: function(c, b, e, d) {
			return b ? (c + b * ig.system.tick).limit(-d, d) : e ? (b = e * ig.system.tick, 0 < c - b ? c - b : 0 > c + b ? c + b : 0) : c.limit(-d, d)
		},
		handleMovementTrace: function(c) {
			this.standing = !1;
			c.collision.y && (0 < this.bounciness && Math.abs(this.vel.y) > this.minBounceVelocity ? this.vel.y *= -this.bounciness : (0 < this.vel.y && (this.standing = !0), this.vel.y = 0));
			c.collision.x && (this.vel.x = 0 < this.bounciness && Math.abs(this.vel.x) >
				this.minBounceVelocity ? this.vel.x * -this.bounciness : 0);
			if (c.collision.slope) {
				var b = c.collision.slope;
				if (0 < this.bounciness) {
					var e = this.vel.x * b.nx + this.vel.y * b.ny;
					this.vel.x = (this.vel.x - 2 * b.nx * e) * this.bounciness;
					this.vel.y = (this.vel.y - 2 * b.ny * e) * this.bounciness
				} else e = (this.vel.x * b.x + this.vel.y * b.y) / (b.x * b.x + b.y * b.y), this.vel.x = b.x * e, this.vel.y = b.y * e, b = Math.atan2(b.x, b.y), b > this.slopeStanding.min && b < this.slopeStanding.max && (this.standing = !0)
			}
			this.pos = c.pos
		},
		draw: function() {
			this.currentAnim && this.currentAnim.draw(this.pos.x -
				this.offset.x - ig.game._rscreen.x, this.pos.y - this.offset.y - ig.game._rscreen.y)
		},
		kill: function() {
			ig.game.removeEntity(this)
		},
		receiveDamage: function(c) {
			this.health -= c;
			0 >= this.health && this.kill()
		},
		touches: function(c) {
			return !(this.pos.x >= c.pos.x + c.size.x || this.pos.x + this.size.x <= c.pos.x || this.pos.y >= c.pos.y + c.size.y || this.pos.y + this.size.y <= c.pos.y)
		},
		distanceTo: function(c) {
			var b = this.pos.x + this.size.x / 2 - (c.pos.x + c.size.x / 2);
			c = this.pos.y + this.size.y / 2 - (c.pos.y + c.size.y / 2);
			return Math.sqrt(b * b + c * c)
		},
		angleTo: function(c) {
			return Math.atan2(c.pos.y +
				c.size.y / 2 - (this.pos.y + this.size.y / 2), c.pos.x + c.size.x / 2 - (this.pos.x + this.size.x / 2))
		},
		check: function() {},
		collideWith: function() {},
		ready: function() {},
		erase: function() {}
	});
	ig.Entity._lastId = 0;
	ig.Entity.COLLIDES = {
		NEVER: 0,
		LITE: 1,
		PASSIVE: 2,
		ACTIVE: 4,
		FIXED: 8
	};
	ig.Entity.TYPE = {
		NONE: 0,
		A: 1,
		B: 2,
		BOTH: 3
	};
	ig.Entity.checkPair = function(c, b) {
		c.checkAgainst & b.type && c.check(b);
		b.checkAgainst & c.type && b.check(c);
		c.collides && (b.collides && c.collides + b.collides > ig.Entity.COLLIDES.ACTIVE) && ig.Entity.solveCollision(c, b)
	};
	ig.Entity.solveCollision =
		function(c, b) {
			var e = null;
			if (c.collides == ig.Entity.COLLIDES.LITE || b.collides == ig.Entity.COLLIDES.FIXED) e = c;
			else if (b.collides == ig.Entity.COLLIDES.LITE || c.collides == ig.Entity.COLLIDES.FIXED) e = b;
			c.last.x + c.size.x > b.last.x && c.last.x < b.last.x + b.size.x ? (c.last.y < b.last.y ? ig.Entity.seperateOnYAxis(c, b, e) : ig.Entity.seperateOnYAxis(b, c, e), c.collideWith(b, "y"), b.collideWith(c, "y")) : c.last.y + c.size.y > b.last.y && c.last.y < b.last.y + b.size.y && (c.last.x < b.last.x ? ig.Entity.seperateOnXAxis(c, b, e) : ig.Entity.seperateOnXAxis(b,
				c, e), c.collideWith(b, "x"), b.collideWith(c, "x"))
		};
	ig.Entity.seperateOnXAxis = function(c, b, e) {
		var d = c.pos.x + c.size.x - b.pos.x;
		e ? (e.vel.x = -e.vel.x * e.bounciness + (c === e ? b : c).vel.x, b = ig.game.collisionMap.trace(e.pos.x, e.pos.y, e == c ? -d : d, 0, e.size.x, e.size.y), e.pos.x = b.pos.x) : (e = (c.vel.x - b.vel.x) / 2, c.vel.x = -e, b.vel.x = e, e = ig.game.collisionMap.trace(c.pos.x, c.pos.y, -d / 2, 0, c.size.x, c.size.y), c.pos.x = Math.floor(e.pos.x), c = ig.game.collisionMap.trace(b.pos.x, b.pos.y, d / 2, 0, b.size.x, b.size.y), b.pos.x = Math.ceil(c.pos.x))
	};
	ig.Entity.seperateOnYAxis = function(c, b, e) {
		var d = c.pos.y + c.size.y - b.pos.y;
		if (e) {
			b = c === e ? b : c;
			e.vel.y = -e.vel.y * e.bounciness + b.vel.y;
			var f = 0;
			e == c && Math.abs(e.vel.y - b.vel.y) < e.minBounceVelocity && (e.standing = !0, f = b.vel.x * ig.system.tick);
			c = ig.game.collisionMap.trace(e.pos.x, e.pos.y, f, e == c ? -d : d, e.size.x, e.size.y);
			e.pos.y = c.pos.y;
			e.pos.x = c.pos.x
		} else ig.game.gravity && (b.standing || 0 < c.vel.y) ? (e = ig.game.collisionMap.trace(c.pos.x, c.pos.y, 0, -(c.pos.y + c.size.y - b.pos.y), c.size.x, c.size.y), c.pos.y = e.pos.y, 0 < c.bounciness &&
			c.vel.y > c.minBounceVelocity ? c.vel.y *= -c.bounciness : (c.standing = !0, c.vel.y = 0)) : (e = (c.vel.y - b.vel.y) / 2, c.vel.y = -e, b.vel.y = e, f = b.vel.x * ig.system.tick, e = ig.game.collisionMap.trace(c.pos.x, c.pos.y, f, -d / 2, c.size.x, c.size.y), c.pos.y = e.pos.y, c = ig.game.collisionMap.trace(b.pos.x, b.pos.y, 0, d / 2, b.size.x, b.size.y), b.pos.y = c.pos.y)
	}
});
ig.baked = !0;
ig.module("impact.map").defines(function() {
	ig.Map = ig.Class.extend({
		tilesize: 8,
		width: 1,
		height: 1,
		data: [
			[]
		],
		name: null,
		init: function(c, b) {
			this.tilesize = c;
			this.data = b;
			this.height = b.length;
			this.width = b[0].length;
			this.pxWidth = this.width * this.tilesize;
			this.pxHeight = this.height * this.tilesize
		},
		getTile: function(c, b) {
			var e = Math.floor(c / this.tilesize),
				d = Math.floor(b / this.tilesize);
			return 0 <= e && e < this.width && 0 <= d && d < this.height ? this.data[d][e] : 0
		},
		setTile: function(c, b, e) {
			c = Math.floor(c / this.tilesize);
			b = Math.floor(b /
				this.tilesize);
			0 <= c && c < this.width && (0 <= b && b < this.height) && (this.data[b][c] = e)
		}
	})
});
ig.baked = !0;
ig.module("impact.collision-map").requires("impact.map").defines(function() {
	ig.CollisionMap = ig.Map.extend({
		lastSlope: 1,
		tiledef: null,
		init: function(b, c, f) {
			this.parent(b, c);
			this.tiledef = f || ig.CollisionMap.defaultTileDef;
			for (var g in this.tiledef) g | 0 > this.lastSlope && (this.lastSlope = g | 0)
		},
		trace: function(b, c, f, g, q, m) {
			var j = {
					collision: {
						x: !1,
						y: !1,
						slope: !1
					},
					pos: {
						x: b,
						y: c
					},
					tile: {
						x: 0,
						y: 0
					}
				},
				l = Math.ceil(Math.max(Math.abs(f), Math.abs(g)) / this.tilesize);
			if (1 < l)
				for (var p = f / l, r = g / l, s = 0; s < l && (p || r) && !(this._traceStep(j,
						b, c, p, r, q, m, f, g, s), b = j.pos.x, c = j.pos.y, j.collision.x && (f = p = 0), j.collision.y && (g = r = 0), j.collision.slope); s++);
			else this._traceStep(j, b, c, f, g, q, m, f, g, 0);
			return j
		},
		_traceStep: function(b, c, f, g, q, m, j, l, p, r) {
			b.pos.x += g;
			b.pos.y += q;
			var s = 0;
			if (g) {
				var t = 0 < g ? m : 0,
					u = 0 > g ? this.tilesize : 0,
					s = Math.max(Math.floor(f / this.tilesize), 0),
					x = Math.min(Math.ceil((f + j) / this.tilesize), this.height);
				g = Math.floor((b.pos.x + t) / this.tilesize);
				var z = Math.floor((c + t) / this.tilesize);
				if (0 < r || g == z || 0 > z || z >= this.width) z = -1;
				if (0 <= g && g < this.width)
					for (var v =
							s; v < x && !(-1 != z && (s = this.data[v][z], 1 < s && s <= this.lastSlope && this._checkTileDef(b, s, c, f, l, p, m, j, z, v))); v++)
						if (s = this.data[v][g], 1 == s || s > this.lastSlope || 1 < s && this._checkTileDef(b, s, c, f, l, p, m, j, g, v)) {
							if (1 < s && s <= this.lastSlope && b.collision.slope) break;
							b.collision.x = !0;
							b.tile.x = s;
							c = b.pos.x = g * this.tilesize - t + u;
							l = 0;
							break
						}
			}
			if (q) {
				t = 0 < q ? j : 0;
				q = 0 > q ? this.tilesize : 0;
				s = Math.max(Math.floor(b.pos.x / this.tilesize), 0);
				u = Math.min(Math.ceil((b.pos.x + m) / this.tilesize), this.width);
				v = Math.floor((b.pos.y + t) / this.tilesize);
				x = Math.floor((f + t) / this.tilesize);
				if (0 < r || v == x || 0 > x || x >= this.height) x = -1;
				if (0 <= v && v < this.height)
					for (g = s; g < u && !(-1 != x && (s = this.data[x][g], 1 < s && s <= this.lastSlope && this._checkTileDef(b, s, c, f, l, p, m, j, g, x))); g++)
						if (s = this.data[v][g], 1 == s || s > this.lastSlope || 1 < s && this._checkTileDef(b, s, c, f, l, p, m, j, g, v)) {
							if (1 < s && s <= this.lastSlope && b.collision.slope) break;
							b.collision.y = !0;
							b.tile.y = s;
							b.pos.y = v * this.tilesize - t + q;
							break
						}
			}
		},
		_checkTileDef: function(b, c, f, g, q, m, j, l, p, r) {
			var s = this.tiledef[c];
			if (!s) return !1;
			c = (s[2] -
				s[0]) * this.tilesize;
			var t = (s[3] - s[1]) * this.tilesize,
				u = s[4];
			j = f + q + (0 > t ? j : 0) - (p + s[0]) * this.tilesize;
			l = g + m + (0 < c ? l : 0) - (r + s[1]) * this.tilesize;
			if (0 < c * l - t * j) {
				if (0 > q * -t + m * c) return u;
				p = Math.sqrt(c * c + t * t);
				r = t / p;
				p = -c / p;
				var x = j * r + l * p,
					s = r * x,
					x = p * x;
				if (s * s + x * x >= q * q + m * m) return u || 0.5 > c * (l - m) - t * (j - q);
				b.pos.x = f + q - s;
				b.pos.y = g + m - x;
				b.collision.slope = {
					x: c,
					y: t,
					nx: r,
					ny: p
				};
				return !0
			}
			return !1
		}
	});
	var c = 1 / 3,
		b = 2 / 3;
	ig.CollisionMap.defaultTileDef = {
		5: [0, 1, 1, b, !0],
		6: [0, b, 1, c, !0],
		7: [0, c, 1, 0, !0],
		3: [0, 1, 1, 0.5, !0],
		4: [0, 0.5, 1, 0, !0],
		2: [0,
			1, 1, 0, !0
		],
		10: [0.5, 1, 1, 0, !0],
		21: [0, 1, 0.5, 0, !0],
		32: [b, 1, 1, 0, !0],
		43: [c, 1, b, 0, !0],
		54: [0, 1, c, 0, !0],
		27: [0, 0, 1, c, !0],
		28: [0, c, 1, b, !0],
		29: [0, b, 1, 1, !0],
		25: [0, 0, 1, 0.5, !0],
		26: [0, 0.5, 1, 1, !0],
		24: [0, 0, 1, 1, !0],
		11: [0, 0, 0.5, 1, !0],
		22: [0.5, 0, 1, 1, !0],
		33: [0, 0, c, 1, !0],
		44: [c, 0, b, 1, !0],
		55: [b, 0, 1, 1, !0],
		16: [1, c, 0, 0, !0],
		17: [1, b, 0, c, !0],
		18: [1, 1, 0, b, !0],
		14: [1, 0.5, 0, 0, !0],
		15: [1, 1, 0, 0.5, !0],
		13: [1, 1, 0, 0, !0],
		8: [0.5, 1, 0, 0, !0],
		19: [1, 1, 0.5, 0, !0],
		30: [c, 1, 0, 0, !0],
		41: [b, 1, c, 0, !0],
		52: [1, 1, b, 0, !0],
		38: [1, b, 0, 1, !0],
		39: [1, c, 0, b, !0],
		40: [1, 0,
			0, c, !0
		],
		36: [1, 0.5, 0, 1, !0],
		37: [1, 0, 0, 0.5, !0],
		35: [1, 0, 0, 1, !0],
		9: [1, 0, 0.5, 1, !0],
		20: [0.5, 0, 0, 1, !0],
		31: [1, 0, b, 1, !0],
		42: [b, 0, c, 1, !0],
		53: [c, 0, 0, 1, !0],
		12: [0, 0, 1, 0, !1],
		23: [1, 1, 0, 1, !1],
		34: [1, 0, 1, 1, !1],
		45: [0, 1, 0, 0, !1]
	};
	ig.CollisionMap.staticNoCollision = {
		trace: function(b, c, f, g) {
			return {
				collision: {
					x: !1,
					y: !1,
					slope: !1
				},
				pos: {
					x: b + f,
					y: c + g
				},
				tile: {
					x: 0,
					y: 0
				}
			}
		}
	}
});
ig.baked = !0;
ig.module("impact.background-map").requires("impact.map", "impact.image").defines(function() {
	ig.BackgroundMap = ig.Map.extend({
		tiles: null,
		scroll: {
			x: 0,
			y: 0
		},
		distance: 1,
		repeat: !1,
		tilesetName: "",
		foreground: !1,
		enabled: !0,
		preRender: !1,
		preRenderedChunks: null,
		chunkSize: 512,
		debugChunks: !1,
		anims: {},
		init: function(c, b, e) {
			this.parent(c, b);
			this.setTileset(e)
		},
		setTileset: function(c) {
			this.tilesetName = c instanceof ig.Image ? c.path : c;
			this.tiles = new ig.Image(this.tilesetName);
			this.preRenderedChunks = null
		},
		setScreenPos: function(c,
			b) {
			this.scroll.x = c / this.distance;
			this.scroll.y = b / this.distance
		},
		preRenderMapToChunks: function() {
			var c = this.width * this.tilesize * ig.system.scale,
				b = this.height * this.tilesize * ig.system.scale;
			this.chunkSize = Math.min(Math.max(c, b), this.chunkSize);
			var e = Math.ceil(c / this.chunkSize),
				d = Math.ceil(b / this.chunkSize);
			this.preRenderedChunks = [];
			for (var f = 0; f < d; f++) {
				this.preRenderedChunks[f] = [];
				for (var g = 0; g < e; g++) this.preRenderedChunks[f][g] = this.preRenderChunk(g, f, g == e - 1 ? c - g * this.chunkSize : this.chunkSize, f == d - 1 ?
					b - f * this.chunkSize : this.chunkSize)
			}
		},
		preRenderChunk: function(c, b, e, d) {
			var f = e / this.tilesize / ig.system.scale + 1,
				g = d / this.tilesize / ig.system.scale + 1,
				q = c * this.chunkSize / ig.system.scale % this.tilesize,
				m = b * this.chunkSize / ig.system.scale % this.tilesize;
			c = Math.floor(c * this.chunkSize / this.tilesize / ig.system.scale);
			b = Math.floor(b * this.chunkSize / this.tilesize / ig.system.scale);
			var j = ig.$new("canvas");
			j.width = e;
			j.height = d;
			j.retinaResolutionEnabled = !1;
			d = j.getContext("2d");
			ig.System.scaleMode(j, d);
			e = ig.system.context;
			ig.system.context = d;
			for (d = 0; d < f; d++)
				for (var l = 0; l < g; l++)
					if (d + c < this.width && l + b < this.height) {
						var p = this.data[l + b][d + c];
						p && this.tiles.drawTile(d * this.tilesize - q, l * this.tilesize - m, p - 1, this.tilesize)
					}
			ig.system.context = e;
			return j
		},
		draw: function() {
			this.tiles.loaded && this.enabled && (this.preRender ? this.drawPreRendered() : this.drawTiled())
		},
		drawPreRendered: function() {
			this.preRenderedChunks || this.preRenderMapToChunks();
			var c = ig.system.getDrawPos(this.scroll.x),
				b = ig.system.getDrawPos(this.scroll.y);
			if (this.repeat) var e =
				this.width * this.tilesize * ig.system.scale,
				c = (c % e + e) % e,
				e = this.height * this.tilesize * ig.system.scale,
				b = (b % e + e) % e;
			var e = Math.max(Math.floor(c / this.chunkSize), 0),
				d = Math.max(Math.floor(b / this.chunkSize), 0),
				f = Math.ceil((c + ig.system.realWidth) / this.chunkSize),
				g = Math.ceil((b + ig.system.realHeight) / this.chunkSize),
				q = this.preRenderedChunks[0].length,
				m = this.preRenderedChunks.length;
			this.repeat || (f = Math.min(f, q), g = Math.min(g, m));
			for (var j = 0; d < g; d++) {
				for (var l = 0, p = e; p < f; p++) {
					var r = this.preRenderedChunks[d % m][p % q],
						s = -c + p * this.chunkSize - l,
						t = -b + d * this.chunkSize - j;
					ig.system.context.drawImage(r, s, t);
					ig.Image.drawCount++;
					this.debugChunks && (ig.system.context.strokeStyle = "#f0f", ig.system.context.strokeRect(s, t, this.chunkSize, this.chunkSize));
					this.repeat && (r.width < this.chunkSize && s + r.width < ig.system.realWidth) && (l += this.chunkSize - r.width, f++)
				}
				this.repeat && (r.height < this.chunkSize && t + r.height < ig.system.realHeight) && (j += this.chunkSize - r.height, g++)
			}
		},
		drawTiled: function() {
			for (var c = 0, b = null, e = (this.scroll.x / this.tilesize).toInt(),
					d = (this.scroll.y / this.tilesize).toInt(), f = this.scroll.x % this.tilesize, g = this.scroll.y % this.tilesize, q = -f - this.tilesize, f = ig.system.width + this.tilesize - f, m = ig.system.height + this.tilesize - g, j = -1, g = -g - this.tilesize; g < m; j++, g += this.tilesize) {
				var l = j + d;
				if (l >= this.height || 0 > l) {
					if (!this.repeat) continue;
					l = (l % this.height + this.height) % this.height
				}
				for (var p = -1, r = q; r < f; p++, r += this.tilesize) {
					c = p + e;
					if (c >= this.width || 0 > c) {
						if (!this.repeat) continue;
						c = (c % this.width + this.width) % this.width
					}
					if (c = this.data[l][c])(b = this.anims[c -
						1]) ? b.draw(r, g) : this.tiles.drawTile(r, g, c - 1, this.tilesize)
				}
			}
		}
	})
});
ig.baked = !0;
ig.module("impact.game").requires("impact.impact", "impact.entity", "impact.collision-map", "impact.background-map").defines(function() {
	ig.Game = ig.Class.extend({
		clearColor: "#000000",
		gravity: 0,
		screen: {
			x: 0,
			y: 0
		},
		_rscreen: {
			x: 0,
			y: 0
		},
		entities: [],
		namedEntities: {},
		collisionMap: ig.CollisionMap.staticNoCollision,
		backgroundMaps: [],
		backgroundAnims: {},
		autoSort: !1,
		sortBy: null,
		cellSize: 64,
		_deferredKill: [],
		_levelToLoad: null,
		_doSortEntities: !1,
		staticInstantiate: function() {
			this.sortBy = this.sortBy || ig.Game.SORT.Z_INDEX;
			ig.game = this;
			return null
		},
		loadLevel: function(c) {
			this.screen = {
				x: 0,
				y: 0
			};
			this.entities = [];
			this.namedEntities = {};
			for (var b = 0; b < c.entities.length; b++) {
				var e = c.entities[b];
				this.spawnEntity(e.type, e.x, e.y, e.settings)
			}
			this.sortEntities();
			this.collisionMap = ig.CollisionMap.staticNoCollision;
			this.backgroundMaps = [];
			for (b = 0; b < c.layer.length; b++)
				if (e = c.layer[b], "collision" == e.name) this.collisionMap = new ig.CollisionMap(e.tilesize, e.data);
				else {
					var d = new ig.BackgroundMap(e.tilesize, e.data, e.tilesetName);
					d.anims = this.backgroundAnims[e.tilesetName] || {};
					d.repeat = e.repeat;
					d.distance = e.distance;
					d.foreground = !!e.foreground;
					d.preRender = !!e.preRender;
					d.name = e.name;
					this.backgroundMaps.push(d)
				}
			for (b = 0; b < this.entities.length; b++) this.entities[b].ready()
		},
		loadLevelDeferred: function(c) {
			this._levelToLoad = c
		},
		getMapByName: function(c) {
			if ("collision" == c) return this.collisionMap;
			for (var b = 0; b < this.backgroundMaps.length; b++)
				if (this.backgroundMaps[b].name == c) return this.backgroundMaps[b];
			return null
		},
		getEntityByName: function(c) {
			return this.namedEntities[c]
		},
		getEntitiesByType: function(c) {
			c =
				"string" === typeof c ? ig.global[c] : c;
			for (var b = [], e = 0; e < this.entities.length; e++) {
				var d = this.entities[e];
				d instanceof c && !d._killed && b.push(d)
			}
			return b
		},
		spawnEntity: function(c, b, e, d) {
			var f = "string" === typeof c ? ig.global[c] : c;
			if (!f) throw "Can't spawn entity of type " + c;
			c = new f(b, e, d || {});
			this.entities.push(c);
			c.name && (this.namedEntities[c.name] = c);
			return c
		},
		sortEntities: function() {
			this.entities.sort(this.sortBy)
		},
		sortEntitiesDeferred: function() {
			this._doSortEntities = !0
		},
		removeEntity: function(c) {
			c.name &&
				delete this.namedEntities[c.name];
			c._killed = !0;
			c.type = ig.Entity.TYPE.NONE;
			c.checkAgainst = ig.Entity.TYPE.NONE;
			c.collides = ig.Entity.COLLIDES.NEVER;
			this._deferredKill.push(c)
		},
		run: function() {
			this.update();
			this.draw()
		},
		update: function() {
			this._levelToLoad && (this.loadLevel(this._levelToLoad), this._levelToLoad = null);
			this.updateEntities();
			this.checkEntities();
			for (var c = 0; c < this._deferredKill.length; c++) this._deferredKill[c].erase(), this.entities.erase(this._deferredKill[c]);
			this._deferredKill = [];
			if (this._doSortEntities ||
				this.autoSort) this.sortEntities(), this._doSortEntities = !1;
			for (var b in this.backgroundAnims) {
				var c = this.backgroundAnims[b],
					e;
				for (e in c) c[e].update()
			}
		},
		updateEntities: function() {
			for (var c = 0; c < this.entities.length; c++) {
				var b = this.entities[c];
				b._killed || b.update()
			}
		},
		draw: function() {
			this.clearColor && ig.system.clear(this.clearColor);
			this._rscreen.x = ig.system.getDrawPos(this.screen.x) / ig.system.scale;
			this._rscreen.y = ig.system.getDrawPos(this.screen.y) / ig.system.scale;
			var c;
			for (c = 0; c < this.backgroundMaps.length; c++) {
				var b =
					this.backgroundMaps[c];
				if (b.foreground) break;
				b.setScreenPos(this.screen.x, this.screen.y);
				b.draw()
			}
			this.drawEntities();
			for (c; c < this.backgroundMaps.length; c++) b = this.backgroundMaps[c], b.setScreenPos(this.screen.x, this.screen.y), b.draw()
		},
		drawEntities: function() {
			for (var c = 0; c < this.entities.length; c++) this.entities[c].draw()
		},
		checkEntities: function() {
			for (var c = {}, b = 0; b < this.entities.length; b++) {
				var e = this.entities[b];
				if (!(e.type == ig.Entity.TYPE.NONE && e.checkAgainst == ig.Entity.TYPE.NONE && e.collides == ig.Entity.COLLIDES.NEVER))
					for (var d = {}, f = Math.floor(e.pos.y / this.cellSize), g = Math.floor((e.pos.x + e.size.x) / this.cellSize) + 1, q = Math.floor((e.pos.y + e.size.y) / this.cellSize) + 1, m = Math.floor(e.pos.x / this.cellSize); m < g; m++)
						for (var j = f; j < q; j++)
							if (c[m])
								if (c[m][j]) {
									for (var l = c[m][j], p = 0; p < l.length; p++) e.touches(l[p]) && !d[l[p].id] && (d[l[p].id] = !0, ig.Entity.checkPair(e, l[p]));
									l.push(e)
								} else c[m][j] = [e];
				else c[m] = {}, c[m][j] = [e]
			}
		}
	});
	ig.Game.SORT = {
		Z_INDEX: function(c, b) {
			return c.zIndex - b.zIndex
		},
		POS_X: function(c, b) {
			return c.pos.x + c.size.x - (b.pos.x +
				b.size.x)
		},
		POS_Y: function(c, b) {
			return c.pos.y + c.size.y - (b.pos.y + b.size.y)
		}
	}
});
ig.baked = !0;
ig.module("plugins.patches.webkit-image-smoothing-patch").defines(function() {
	ig.System && (ig.System.SCALE = {
		CRISP: function(c, b) {
			b.imageSmoothingEnabled = b.msImageSmoothingEnabled = b.mozImageSmoothingEnabled = b.oImageSmoothingEnabled = !1;
			c.style.imageRendering = "-moz-crisp-edges";
			c.style.imageRendering = "-o-crisp-edges";
			c.style.imageRendering = "-webkit-optimize-contrast";
			c.style.imageRendering = "crisp-edges";
			c.style.msInterpolationMode = "nearest-neighbor"
		},
		SMOOTH: function(c, b) {
			b.imageSmoothingEnabled = b.msImageSmoothingEnabled =
				b.mozImageSmoothingEnabled = b.oImageSmoothingEnabled = !0;
			c.style.imageRendering = "";
			c.style.msInterpolationMode = ""
		}
	}, ig.System.scaleMode = ig.System.SCALE.SMOOTH)
});
ig.baked = !0;
ig.module("plugins.patches.windowfocus-onMouseDown-patch").requires("impact.input").defines(function() {
	var c = !1;
	try {
		c = window.self !== window.top, !1 === c && (c = 0 < window.frames.length)
	} catch (b) {
		c = !0
	}
	ig.Input.inject({
		keydown: function(b) {
			var d = b.target.tagName;
			if (!("INPUT" == d || "TEXTAREA" == d))
				if (d = "keydown" == b.type ? b.keyCode : 2 == b.button ? ig.KEY.MOUSE2 : ig.KEY.MOUSE1, c && 0 > d && window.focus(), ("touchstart" == b.type || "mousedown" == b.type) && this.mousemove(b), d = this.bindings[d]) this.actions[d] = !0, this.locks[d] || (this.presses[d] = !0, this.locks[d] = !0), b.stopPropagation(), b.preventDefault()
		}
	})
});
ig.baked = !0;
ig.module("plugins.patches.mouse-move-patch").defines(function() {
	ig.Input.inject({
		move: new BABYLON.Vector2(0, 0),
		initMouse: function() {
			if (!this.isUsingMouse) {
				this.isUsingMouse = !0;
				var c = this.mousewheel.bind(this);
				ig.system.canvas.addEventListener("mousewheel", c, !1);
				ig.system.canvas.addEventListener("DOMMouseScroll", c, !1);
				ig.system.canvas.addEventListener("contextmenu", this.contextmenu.bind(this), !1);
				ig.system.canvas.addEventListener("mousedown", this.keydown.bind(this), !1);
				ig.system.canvas.addEventListener("mouseup",
					this.keyup.bind(this), !1);
				ig.system.canvas.addEventListener("mousemove", this.mousemove.bind(this), !1);
				ig.ua.touchDevice && (ig.system.canvas.addEventListener("touchstart", this.keydown.bind(this), !1), ig.system.canvas.addEventListener("touchend", this.keyup.bind(this), !1), ig.system.canvas.addEventListener("touchmove", this.mousemove.bind(this), !1), ig.system.canvas.addEventListener("MSPointerDown", this.keydown.bind(this), !1), ig.system.canvas.addEventListener("MSPointerUp", this.keyup.bind(this), !1), ig.system.canvas.addEventListener("MSPointerMove",
					this.mousemove.bind(this), !1), ig.system.canvas.style.msTouchAction = "none")
			}
		},
		mousemove: function(c) {
			var b = parseInt(wgl.system.canvas.offsetWidth);
			parseInt(wgl.system.canvas.offsetHeight);
			ig.ua.mobile && (b = ig.system.realWidth);
			var b = ig.system.scale * (b / ig.system.realWidth),
				e = {
					left: 0,
					top: 0
				};
			ig.system.canvas.getBoundingClientRect && (e = ig.system.canvas.getBoundingClientRect());
			var d = c.touches ? c.touches[0] : c;
			this.mouse.x = (d.clientX - e.left) / b;
			this.mouse.y = (d.clientY - e.top) / b;
			void 0 !== typeof c.movementX ? (this.move.x =
				c.movementX, this.move.y = c.movementY) : (this.move.x = 0, this.move.y = 0)
		}
	})
});
ig.baked = !0;
ig.module("plugins.gamedist").defines(function() {
	window.GD_OPTIONS = {
		gameId: "f1075595baab420f9a9aab3e0d62c71f",
		advertisementSettings: {
			debug: !1,
			autoplay: !1,
			locale: "en"
		},
		onEvent: function(b) {
			switch (b.name) {
				case "SDK_GAME_START":
					ig.gd.unfreez();
					if ("function" === typeof ig.gd.onAdClose) ig.gd.onAdClose();
					ig.gd.onAdClose = 0;
					break;
				case "SDK_GAME_PAUSE":
					ig.gd.freez()
			}
		}
	};
	var c, b = document.getElementsByTagName("script")[0];
	document.getElementById("gamedistribution-jssdk") || (c = document.createElement("script"), c.id =
		"gamedistribution-jssdk", c.src = "", b.parentNode.insertBefore(c, b));
	ig.Gd = ig.Class.extend({
		pausedMidplay: 0,
		prevMuted: {
			bgm: 0,
			sfx: 0
		},
		onAdClose: 0,
		adShowing: 0,
		createTestButton: function() {
			this.createDiv("Resume", 5, "green", "white", function() {
				ig.game && ig.gd && ig.gd.unfreez()
			});
			this.createDiv("Pause", 70, "red", "white", function() {
				ig.game && ig.gd && ig.gd.freez()
			})
		},
		createDiv: function(b, c, f, g, q) {
			var m = ig.$new("button");
			document.body.appendChild(m);
			m.textContent = b;
			m.style.position = "absolute";
			m.style.color = g;
			m.style.background = f;
			m.style.top = "5px";
			m.style.left = c + "px";
			m.style.padding = "5px";
			m.style.fontSize = "12px";
			m.style.fontFamily = "Arial";
			m.style.cursor = "pointer";
			m.style["z-index"] = 999999;
			m.onclick = q
		},
		freez: function() {
			// gdsdk && (this.adShowing = 1, ig.game && (ig.soundHandler.bgmPlayer.mute(!0), ig.game.pauseGame()))
		},
		unfreez: function() {
			// gdsdk && (this.adShowing = 0, ig.game && (ig.soundHandler.bgmPlayer.unmute(!0), ig.game.resumeGame()))
		},
		show: function(b) {
			// gdsdk ? this.adShowing ||
				// (this.adShowing = 1, this.onAdClose = b || 0, gdsdk.showBanner()) : 
				b()
		}
	});
	ig.gd = new ig.Gd
});
ig.baked = !0;
ig.module("plugins.handlers.dom-handler").defines(function() {
	ig.DomHandler = ig.Class.extend({
		JQUERYAVAILABLE: !1,
		init: function() {
			this.JQUERYAVAILABLE = this._jqueryAvailable()
		},
		_jqueryAvailable: function() {
			return "undefined" !== typeof jQuery
		},
		addEvent: function(c, b, e, d) {
			if (this.JQUERYAVAILABLE) c.on(b, e);
			else c.addEventListener(b, e, d)
		},
		create: function(c) {
			return this.JQUERYAVAILABLE ? $("<" + c + ">") : ig.$new(c)
		},
		getElementByClass: function(c) {
			return this.JQUERYAVAILABLE ? $("." + c) : document.getElementsByClassName(c)
		},
		getElementById: function(c) {
			return this.JQUERYAVAILABLE ? 0 < $(c).length ? $(c) : null : ig.$(c)
		},
		appendChild: function(c, b) {
			this.JQUERYAVAILABLE ? c.append(b) : c.appendChild(b)
		},
		appendToBody: function(c) {
			this.JQUERYAVAILABLE ? $("body").append(c) : document.body.appendChild(c)
		},
		resize: function(c, b, e) {
			if (this.JQUERYAVAILABLE) c.width(b.toFixed(2)), c.height(e.toFixed(2));
			else {
				var d = c.style.visibility;
				b = "width:" + b.toFixed(2) + "px; height:" + e.toFixed(2) + "px;";
				this.attr(c, "style", b);
				c.style.visibility = d
			}
		},
		resizeOffsetLeft: function(c,
			b, e, d) {
			if (this.JQUERYAVAILABLE) c.width(b.toFixed(2)), c.height(e.toFixed(2)), c.css("left", d);
			else {
				var f = c.style.visibility;
				b = "width:" + b.toFixed(2) + "px; height:" + e.toFixed(2) + "px; left: " + d.toFixed(2) + "px;";
				this.attr(c, "style", b);
				c.style.visibility = f
			}
		},
		css: function(c, b) {
			if (this.JQUERYAVAILABLE) c.css(b);
			else {
				var e = "",
					d;
				for (d in b) e += d + ":" + b[d] + ";";
				this.attr(c, "style", e)
			}
		},
		getOffsets: function(c) {
			return this.JQUERYAVAILABLE ? (c = c.offset(), {
				left: c.left,
				top: c.top
			}) : {
				left: c.offsetLeft,
				top: c.offsetTop
			}
		},
		attr: function(c,
			b, e) {
			if ("undefined" === typeof e) return this.JQUERYAVAILABLE ? c.attr(b) : c.getAttribute(b);
			this.JQUERYAVAILABLE ? c.attr(b, e) : c.setAttribute(b, e)
		},
		show: function(c) {
			this.JQUERYAVAILABLE ? (c.show(), c.css("visibility", "visible")) : c && (c.style ? c.style.visibility = "visible" : c[0] && (c[0].style.visibility = "visible"))
		},
		hide: function(c) {
			this.JQUERYAVAILABLE ? (c.hide(), c.css("visibility", "hidden")) : c && (c.style ? c.style.visibility = "hidden" : c[0] && (c[0].style.visibility = "hidden"))
		},
		getQueryVariable: function(c) {
			for (var b =
					window.location.search.substring(1).split("&"), e = 0; e < b.length; e++) {
				var d = b[e].split("=");
				if (decodeURIComponent(d[0]) == c) return decodeURIComponent(d[1])
			}
		},
		forcedDeviceDetection: function() {
			var c = this.getQueryVariable("device");
			if (c) switch (c) {
				case "mobile":
					console.log("serving mobile version ...");
					ig.ua.mobile = !0;
					break;
				case "desktop":
					console.log("serving desktop version ...");
					ig.ua.mobile = !1;
					break;
				default:
					console.log("serving universal version ...")
			} else console.log("serving universal version ...")
		},
		forcedDeviceRotation: function() {
			var c = this.getQueryVariable("force-rotate");
			if (c) switch (c) {
				case "portrait":
					console.log("force rotate to portrait");
					window.orientation = 0;
					break;
				case "landscape":
					console.log("force rotate to horizontal");
					window.orientation = 90;
					break;
				default:
					alert("wrong command/type in param force-rotate. Defaulting value to portrait"), window.orientation = 0
			}
		},
		setZIndex: function(c, b) {
			this.JQUERYAVAILABLE ? c.css("zIndex", b) : c && (c.style ? c.style.zIndex = b : c[0] && (c[0].style.zIndex = b))
		}
	})
});
ig.baked = !0;
ig.module("plugins.handlers.size-handler").defines(function() {
	ig.SizeHandler = ig.Class.extend({
		portraitMode: !1,
		desktop: {
			actualSize: new BABYLON.Vector2(window.innerWidth, window.innerHeight),
			actualResolution: new BABYLON.Vector2(960, 540)
		},
		mobile: {
			actualSize: new BABYLON.Vector2(window.innerWidth, window.innerHeight),
			actualResolution: new BABYLON.Vector2(960, 540)
		},
		windowSize: new BABYLON.Vector2(window.innerWidth, window.innerHeight),
		scaleRatioMultiplier: new BABYLON.Vector2(1, 1),
		sizeRatio: new BABYLON.Vector2(1, 1),
		scale: 1,
		domHandler: null,
		dynamicClickableEntityDivs: {},
		coreDivsToResize: ["#canvas", "#play", "#orientate", "#webglcanvas"],
		adsToResize: {
			MobileAdInGamePreroll: {
				"box-width": _SETTINGS.Ad.Mobile.Preroll.Width + 2,
				"box-height": _SETTINGS.Ad.Mobile.Preroll.Height + 20
			},
			MobileAdInGameEnd: {
				"box-width": _SETTINGS.Ad.Mobile.End.Width + 2,
				"box-height": _SETTINGS.Ad.Mobile.End.Height + 20
			},
			MobileAdInGamePreroll2: {
				"box-width": _SETTINGS.Ad.Mobile.Preroll.Width + 2,
				"box-height": _SETTINGS.Ad.Mobile.Preroll.Height + 20
			},
			MobileAdInGameEnd2: {
				"box-width": _SETTINGS.Ad.Mobile.End.Width +
					2,
				"box-height": _SETTINGS.Ad.Mobile.End.Height + 20
			},
			MobileAdInGamePreroll3: {
				"box-width": _SETTINGS.Ad.Mobile.Preroll.Width + 2,
				"box-height": _SETTINGS.Ad.Mobile.Preroll.Height + 20
			},
			MobileAdInGameEnd3: {
				"box-width": _SETTINGS.Ad.Mobile.End.Width + 2,
				"box-height": _SETTINGS.Ad.Mobile.End.Height + 20
			}
		},
		init: function(c) {
			this.domHandler = c;
			if ("undefined" === typeof c) throw "undefined Dom Handler for Size Handler";
			this.sizeCalcs();
			this.eventListenerSetup();
			this.samsungFix()
		},
		sizeCalcs: function() {
			this.windowSize = new BABYLON.Vector2(window.innerWidth,
				window.innerHeight);
			if (ig.ua.mobile) {
				this.mobile.actualSize = new BABYLON.Vector2(window.innerWidth, window.innerHeight);
				var c = new BABYLON.Vector2(this.mobile.actualResolution.x, this.mobile.actualResolution.y);
				this.scaleRatioMultiplier = new BABYLON.Vector2(this.mobile.actualSize.x / c.x, this.mobile.actualSize.y / c.y);
				var b = Math.min(this.scaleRatioMultiplier.x, this.scaleRatioMultiplier.y);
				this.mobile.actualSize.x = c.x * this.scaleRatioMultiplier.x;
				this.mobile.actualSize.y = c.y * this.scaleRatioMultiplier.y
			} else this.desktop.actualSize =
				new BABYLON.Vector2(window.innerWidth, window.innerHeight), c = new BABYLON.Vector2(this.desktop.actualResolution.x, this.desktop.actualResolution.y), this.scaleRatioMultiplier = new BABYLON.Vector2(this.desktop.actualSize.x / c.x, this.desktop.actualSize.y / c.y), b = Math.min(this.scaleRatioMultiplier.x, this.scaleRatioMultiplier.y), this.desktop.actualSize.x = c.x * b, this.desktop.actualSize.y = c.y * b;
			this.sizeRatio.x = window.innerWidth / this.mobile.actualResolution.x;
			this.sizeRatio.y = window.innerHeight / this.mobile.actualResolution.y
		},
		resizeLayers: function() {
			for (var c = 0; c < this.coreDivsToResize.length; c++) {
				var b = ig.domHandler.getElementById(this.coreDivsToResize[c]);
				b && (ig.ua.mobile ? ig.domHandler.resize(b, Math.floor(ig.sizeHandler.mobile.actualSize.x), Math.floor(ig.sizeHandler.mobile.actualSize.y)) : ig.domHandler.resizeOffsetLeft(b, Math.floor(ig.sizeHandler.desktop.actualSize.x), Math.floor(ig.sizeHandler.desktop.actualSize.y), Math.floor((ig.sizeHandler.windowSize.x >> 1) - (ig.sizeHandler.desktop.actualSize.x >> 1))))
			}
			for (var e in this.adsToResize) {
				var c =
					ig.domHandler.getElementById("#" + e),
					b = ig.domHandler.getElementById("#" + e + "-Box"),
					d = (window.innerWidth - this.adsToResize[e]["box-width"] >> 1) + "px",
					f = (window.innerHeight - this.adsToResize[e]["box-height"] >> 1) + "px";
				c && ig.domHandler.css(c, {
					width: window.innerWidth,
					height: window.innerHeight
				});
				b && ig.domHandler.css(b, {
					left: d,
					top: f
				})
			}
			for (e in this.dynamicClickableEntityDivs) {
				b = Math.min(ig.sizeHandler.scaleRatioMultiplier.x, ig.sizeHandler.scaleRatioMultiplier.y);
				c = ig.domHandler.getElementById("#" + e);
				if (ig.ua.mobile) var g =
					this.dynamicClickableEntityDivs[e].entity_pos_x,
					q = this.dynamicClickableEntityDivs[e].entity_pos_y,
					f = this.dynamicClickableEntityDivs[e].width,
					d = this.dynamicClickableEntityDivs[e].height,
					m = Math.floor(g * this.scaleRatioMultiplier.x) + "px",
					q = Math.floor(q * this.scaleRatioMultiplier.y) + "px",
					f = Math.floor(f * this.scaleRatioMultiplier.x) + "px",
					b = Math.floor(d * this.scaleRatioMultiplier.y) + "px";
				else var d = ig.domHandler.getElementById("#canvas"),
					d = ig.domHandler.getOffsets(d),
					m = d.left,
					j = d.top,
					g = this.dynamicClickableEntityDivs[e].entity_pos_x,
					q = this.dynamicClickableEntityDivs[e].entity_pos_y,
					f = this.dynamicClickableEntityDivs[e].width,
					d = this.dynamicClickableEntityDivs[e].height,
					m = Math.floor(m + g * b) + "px",
					q = Math.floor(j + q * b) + "px",
					f = Math.floor(f * b) + "px",
					b = Math.floor(d * b) + "px";
				ig.domHandler.css(c, {
					"float": "left",
					position: "absolute",
					left: m,
					top: q,
					width: f,
					height: b,
					"z-index": 3
				})
			}
		},
		resize: function() {
			this.sizeCalcs();
			this.resizeLayers()
		},
		reorient: function() {
			window.scrollTo(0, 1);
			if (ig.ua.mobile) {
				var c = BABYLON.Camera.FOVMODE_VERTICAL_FIXED,
					b = BABYLON.Camera.FOVMODE_VERTICAL_FIXED;
				if (this.portraitMode) var e = window.innerHeight < window.innerWidth,
					c = BABYLON.Camera.FOVMODE_VERTICAL_FIXED,
					b = BABYLON.Camera.FOVMODE_HORIZONTAL_FIXED;
				else e = window.innerHeight > window.innerWidth, c = BABYLON.Camera.FOVMODE_HORIZONTAL_FIXED, b = BABYLON.Camera.FOVMODE_VERTICAL_FIXED;
				var d = this.domHandler.getElementById("#orientate"),
					f = this.domHandler.getElementById("#game");
				if (e) {
					if (wgl.system && wgl.system.engine.scene && (e = wgl.system.engine.scene.activeCamera)) e.fovMode = b;
					this.domHandler.show(d);
					this.domHandler.hide(f)
				} else {
					if (wgl.system &&
						wgl.system.engine.scene && (e = wgl.system.engine.scene.activeCamera)) e.fovMode = c;
					this.domHandler.show(f);
					this.domHandler.hide(d)
				}
			}
			ig.ua.mobile ? (this.resize(), this.resizeAds()) : this.resize();
			wgl.system.engine.setSize(ig.system.width, ig.system.height);
			wgl.system.engine.resize()
		},
		resizeAds: function() {
			for (var c in this.adsToResize) {
				var b = ig.domHandler.getElementById("#" + c),
					e = ig.domHandler.getElementById("#" + c + "-Box"),
					d = (window.innerWidth - this.adsToResize[c]["box-width"] >> 1) + "px",
					f = (window.innerHeight - this.adsToResize[c]["box-height"] >>
						1) + "px";
				b && ig.domHandler.css(b, {
					width: window.innerWidth,
					height: window.innerHeight
				});
				e && ig.domHandler.css(e, {
					left: d,
					top: f
				})
			}
		},
		samsungFix: function() {
			ig.ua.android && (!(4.2 > parseFloat(navigator.userAgent.slice(navigator.userAgent.indexOf("Android") + 8, navigator.userAgent.indexOf("Android") + 11))) && !(0 > navigator.userAgent.indexOf("GT")) && !(0 < navigator.userAgent.indexOf("Chrome")) && !(0 < navigator.userAgent.indexOf("Firefox"))) && (document.addEventListener("touchstart", function(c) {
				c.preventDefault();
				return !1
			}, !1), document.addEventListener("touchmove", function(c) {
				c.preventDefault();
				return !1
			}, !1), document.addEventListener("touchend", function(c) {
				c.preventDefault();
				return !1
			}, !1))
		},
		orientationInterval: null,
		orientationTimeout: null,
		orientationHandler: function() {
			this.reorient()
		},
		orientationDelayHandler: function() {
			null == this.orientationInterval && (this.orientationInterval = window.setInterval(this.orientationHandler.bind(this), 100));
			null == this.orientationTimeout && (this.orientationTimeout = window.setTimeout(function() {
					this.clearAllIntervals()
				}.bind(this),
				2E3))
		},
		clearAllIntervals: function() {
			window.clearInterval(this.orientationInterval);
			this.orientationInterval = null;
			window.clearTimeout(this.orientationTimeout);
			this.orientationTimeout = null
		},
		eventListenerSetup: function() {
			ig.ua.iOS ? (window.addEventListener("orientationchange", this.orientationDelayHandler.bind(this)), window.addEventListener("resize", this.orientationDelayHandler.bind(this))) : (window.addEventListener("orientationchange", this.orientationHandler.bind(this)), window.addEventListener("resize",
				this.orientationHandler.bind(this)));
			document.ontouchmove = function(c) {
				window.scrollTo(0, 1);
				c.preventDefault()
			}
		}
	})
});
ig.baked = !0;
ig.module("plugins.handlers.api-handler").defines(function() {
	ig.ApiHandler = ig.Class.extend({
		apiAvailable: {
			MJSPreroll: function() {
				ig.ua.mobile && ig.domHandler.JQUERYAVAILABLE && _SETTINGS && _SETTINGS.Ad.Mobile.Preroll.Enabled && MobileAdInGamePreroll.Initialize()
			},
			MJSHeader: function() {
				ig.ua.mobile && ig.domHandler.JQUERYAVAILABLE && _SETTINGS.Ad.Mobile.Header.Enabled && MobileAdInGameHeader.Initialize()
			},
			MJSFooter: function() {
				ig.ua.mobile && ig.domHandler.JQUERYAVAILABLE && _SETTINGS.Ad.Mobile.Footer.Enabled && MobileAdInGameFooter.Initialize()
			},
			MJSEnd: function() {
				ig.ua.mobile && ig.domHandler.JQUERYAVAILABLE && _SETTINGS.Ad.Mobile.End.Enabled && MobileAdInGameEnd.Initialize()
			}
		},
		run: function(c, b) {
			if (this.apiAvailable[c]) this.apiAvailable[c](b)
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.sound-player").defines(function() {
	SoundPlayer = ig.Class.extend({
		tagName: "SoundPlayer",
		stayMuteFlag: !1,
		debug: !1,
		init: function() {
			this.debug && console.log(this.tagName)
		},
		play: function(c) {
			this.debug && console.log("play sound ", c)
		},
		stop: function() {
			this.debug && console.log("stop sound ")
		},
		volume: function() {
			this.debug && console.log("set volume")
		},
		mute: function(c) {
			this.debug && console.log("mute");
			"undefined" === typeof c ? this.stayMuteFlag = !0 : c && (this.stayMuteFlag = !0)
		},
		unmute: function(c) {
			this.debug &&
				console.log("unmute");
			"undefined" === typeof c ? this.stayMuteFlag = !1 : c && (this.stayMuteFlag = !1)
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.impact-music-player").requires("plugins.audio.sound-player").defines(function() {
	ImpactMusicPlayer = SoundPlayer.extend({
		tagName: "ImpactMusicPlayer",
		bgmPlaying: !1,
		soundList: {},
		init: function(c, b) {
			this.parent(c, b);
			for (var e in c) this.soundList[e] = e, ig.music.add(c[e].path + ".*", e);
			b && b.loop && (ig.music.loop = b.loop)
		},
		play: function(c) {
			this.stayMuteFlag || (this.bgmPlaying = !0, "undefined" === typeof c ? ig.music.play(c) : ig.music.play())
		},
		stop: function() {
			this.bgmPlaying = !1;
			ig.music.pause()
		},
		volume: function(c) {
			console.log("impactmusic:", c);
			ig.music.volume = 0 > c ? 0 : isNaN(c) ? 1 : 1 < c ? 1 : c
		},
		getVolume: function() {
			return ig.music.volume
		},
		mute: function(c) {
			this.parent(c);
			this.bgmPlaying && this.stop()
		},
		unmute: function(c) {
			this.parent(c);
			this.play()
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.impact-sound-player").requires("plugins.audio.sound-player").defines(function() {
	ImpactSoundPlayer = SoundPlayer.extend({
		tagName: "ImpactSoundPlayer",
		soundList: {},
		init: function(c, b) {
			this.parent(c, b);
			for (var e in c) {
				var d = new ig.Sound(c[e].path + ".*");
				this.soundList[e] = d
			}
		},
		play: function(c) {
			this.stayMuteFlag || ("object" === typeof c ? (console.log(c + " exists"), c.play()) : "string" === typeof c && this.soundList[c].play())
		},
		stop: function(c) {
			this.parent(c);
			c.stop()
		},
		volume: function(c) {
			ig.soundManager.volume =
				0 > c ? 0 : isNaN(c) ? 1 : 1 < c ? 1 : c
		},
		getVolume: function() {
			return ig.soundManager.volume
		},
		mute: function(c) {
			this.parent(c);
			ig.Sound.enabled = !1
		},
		unmute: function(c) {
			this.parent(c);
			ig.Sound.enabled = !0
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.howler-player").requires("plugins.audio.sound-player").defines(function() {
	HowlerPlayer = SoundPlayer.extend({
		tagName: "HowlerPlayer",
		soundList: {},
		init: function(c, b) {
			this.parent(c, b);
			for (var e in c) {
				var d = c[e].path,
					d = new Howl({
						src: [d + "." + ig.Sound.FORMAT.OGG.ext, d + "." + ig.Sound.FORMAT.MP3.ext]
					});
				this.soundList[e] = d
			}
		},
		play: function(c) {
			this.stayMuteFlag || ("object" === typeof c ? c.play() : "string" === typeof c && this.soundList[c].play())
		},
		stop: function(c) {
			this.parent(c);
			"object" === typeof c ?
				c.stop() : "string" === typeof c && this.soundList[c].stop()
		},
		volume: function(c) {
			for (var b in this.soundList) {
				if (0 > c) {
					this.soundList[b].volume(0);
					break
				}
				isNaN(c) ? this.soundList[b].volume(1) : 1 < c ? this.soundList[b].volume(1) : this.soundList[b].volume(c)
			}
		},
		getVolume: function() {
			for (var c in this.soundList) return this.soundList[c].volume()
		},
		mute: function(c) {
			this.parent(c);
			Howler.mute(!0)
		},
		unmute: function(c) {
			this.parent(c);
			Howler.mute(!1)
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.howler-music-player").requires("plugins.audio.sound-player").defines(function() {
	HowlerMusicPlayer = SoundPlayer.extend({
		tagName: "HowlerMusicPlayer",
		bgmPlaying: !1,
		soundList: {},
		init: function(c, b) {
			this.parent(c, b);
			for (var e in c) {
				var d = c[e].path,
					d = new Howl({
						src: [d + "." + ig.Sound.FORMAT.OGG.ext, d + "." + ig.Sound.FORMAT.MP3.ext],
						loop: !0,
						autoplay: !1,
						onend: function() {}.bind(this)
					});
				this.soundList[e] = d
			}
		},
		play: function(c) {
			if (!this.stayMuteFlag && !this.bgmPlaying)
				if ("object" === typeof c) this.bgmPlaying = !0, c.play();
				else if ("string" === typeof c) this.bgmPlaying = !0, this.soundList[c].play();
			else
				for (var b in this.soundList) {
					this.soundList[b].play();
					this.bgmPlaying = !0;
					break
				}
		},
		stop: function(c) {
			this.parent(c);
			if (this.bgmPlaying) {
				for (var b in this.soundList) this.soundList[b].stop();
				this.bgmPlaying = !1
			}
		},
		volume: function(c) {
			for (var b in this.soundList) {
				if (0 > c) {
					this.soundList[b].volume(0);
					break
				}
				isNaN(c) ? this.soundList[b].volume(1) : 1 < c ? this.soundList[b].volume(1) : this.soundList[b].volume(c)
			}
		},
		getVolume: function() {
			for (var c in this.soundList) return this.soundList[c].volume()
		},
		mute: function(c) {
			this.parent(c);
			Howler.mute(!0)
		},
		unmute: function(c) {
			this.parent(c);
			Howler.mute(!1)
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.jukebox-player").requires("plugins.audio.sound-player").defines(function() {
	JukeboxPlayer = SoundPlayer.extend({
		tagName: "JukeboxPlayer",
		bgmPlaying: !1,
		soundList: {},
		jukeboxPlayer: null,
		pausePosition: 0,
		premuteVolume: 0,
		minVolume: 0.001,
		init: function(c, b) {
			this.parent(c, b);
			for (var e in c) {
				this.soundList[e] = e;
				var d = c[e].path;
				this.jukeboxPlayer = new jukebox.Player({
					resources: [d + "." + ig.Sound.FORMAT.OGG.ext, d + "." + ig.Sound.FORMAT.MP3.ext],
					autoplay: !1,
					spritemap: {
						music: {
							start: c[e].startMp3,
							end: c[e].endMp3,
							loop: !0
						}
					}
				})
			}
		},
		play: function() {
			this.stayMuteFlag || (this.bgmPlaying = !0, this.pausePosition ? (console.log("resume"), this.jukeboxPlayer.resume(this.pausePosition)) : (console.log("play"), this.jukeboxPlayer.play(this.jukeboxPlayer.settings.spritemap.music.start, !0)), this.premuteVolume = this.getVolume())
		},
		stop: function() {
			this.bgmPlaying = !1;
			this.pausePosition = this.jukeboxPlayer.pause()
		},
		volume: function(c) {
			console.log("jukebox:", c);
			0 >= c ? this.jukeboxPlayer.setVolume(this.minVolume) : isNaN(c) ? this.jukeboxPlayer.setVolume(1) :
				1 < c ? this.jukeboxPlayer.setVolume(1) : this.jukeboxPlayer.setVolume(c)
		},
		getVolume: function() {
			return this.jukeboxPlayer.getVolume()
		},
		mute: function(c) {
			this.parent(c);
			this.bgmPlaying && (console.log("jukebox", this.premuteVolume), this.stayMuteFlag || (this.premuteVolume = this.getVolume()), this.jukeboxPlayer.pause(), this.jukeboxPlayer.setVolume(this.minVolume))
		},
		unmute: function(c) {
			this.parent(c);
			this.stayMuteFlag || (console.log("jukebox", this.premuteVolume), this.jukeboxPlayer.setVolume(this.premuteVolume), this.jukeboxPlayer.resume())
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.webaudio-music-player").requires("plugins.audio.sound-player").defines(function() {
	WebaudioMusicPlayer = SoundPlayer.extend({
		tagName: "WebaudioMusicPlayer",
		bgmPlaying: !1,
		isSupported: !1,
		muteFlag: !1,
		pausedTime: 0,
		webaudio: null,
		useHTML5Audio: !1,
		audio: null,
		inactiveAudio: null,
		codecs: null,
		reinitOnPlay: !1,
		inputList: null,
		_volume: 1,
		soundList: {},
		init: function(c) {
			this.webaudio = {
				compatibility: {},
				gainNode: null,
				buffer: null,
				source_loop: {},
				source_once: {}
			};
			try {
				Howler && Howler.ctx ? this.webaudio.context = Howler.ctx :
					ig && ig.webaudio_ctx ? this.webaudio.context = ig.webaudio_ctx : (this.AudioContext = window.AudioContext || window.webkitAudioContext, this.webaudio.context = new this.AudioContext, ig.webaudio_ctx = this.webaudio.context), this.isSupported = !0
			} catch (b) {
				console.log("Web Audio API not supported in this browser."), this.webaudio = null, this.useHTML5Audio = !0
			}
			if (this.useHTML5Audio)
				if ("undefined" !== typeof Audio) try {
					new Audio
				} catch (e) {
					this.useHTML5Audio = !1
				} else this.useHTML5Audio = !1;
			this.useHTML5Audio && (this.audio = new Audio,
				this.isSupported = !0, this.initHTML5Audio(c));
			if (!this.isSupported) return null;
			this.webaudio && (this.inputList = c, this.initWebAudio(c))
		},
		initWebAudio: function(c) {
			ig.ua.iOS && this.initIOSWebAudioUnlock();
			this.webaudio.gainNode = this.webaudio.context.createGain();
			this.webaudio.gainNode.connect(this.webaudio.context.destination);
			this.webaudio.gainNode.gain.value = this._volume;
			this.webaudio.buffer = null;
			var b = "start",
				e = "stop",
				d = this.webaudio.context.createBufferSource();
			"function" !== typeof d.start && (b = "noteOn");
			this.webaudio.compatibility.start = b;
			"function" !== typeof d.stop && (e = "noteOff");
			this.webaudio.compatibility.stop = e;
			for (var f in c) {
				this.soundList[f] = f;
				var e = c[f].path,
					b = e + "." + ig.Sound.FORMAT.MP3.ext,
					g = e + "." + ig.Sound.FORMAT.OGG.ext;
				ig.ua.mobile ? ig.ua.iOS && (g = b) : (e = navigator.userAgent.toLowerCase(), -1 != e.indexOf("safari") && -1 >= e.indexOf("chrome") && (g = b), e.indexOf("win64") && (g = b));
				var q = new XMLHttpRequest;
				q.open("GET", g, !0);
				q.responseType = "arraybuffer";
				q.onload = function() {
					this.webaudio.context.decodeAudioData(q.response,
						function(b) {
							this.webaudio.buffer = b;
							this.webaudio.source_loop = {};
							this.bgmPlaying ? this.play(null, !0) : this.stop()
						}.bind(this),
						function() {
							console.log('Error decoding audio "' + g + '".')
						})
				}.bind(this);
				q.send();
				if (4 == q.readyState && "undefined" !== typeof Audio) {
					this.useHTML5Audio = !0;
					try {
						new Audio
					} catch (m) {
						this.useHTML5Audio = !1
					}
					this.useHTML5Audio && (console.log("Using HTML5 Audio"), this.webaudio = null, this.audio = new Audio, this.isSupported = !0, this.initHTML5Audio(c))
				}
				break
			}
		},
		initIOSWebAudioUnlock: function() {
			if (this.webaudio) {
				webaudio =
					this.webaudio;
				var c = function() {
					var b = webaudio.context,
						e = b.createBuffer(1, 1, 22050),
						d = b.createBufferSource();
					d.buffer = e;
					d.connect(b.destination);
					"undefined" === typeof d.start ? d.noteOn(0) : d.start(0);
					setTimeout(function() {
						(d.playbackState === d.PLAYING_STATE || d.playbackState === d.FINISHED_STATE) && window.removeEventListener("touchend", c, !1)
					}.bind(this), 0)
				};
				window.addEventListener("touchend", c, !1)
			}
		},
		initHTML5Audio: function(c) {
			if (this.useHTML5Audio && this.audio) {
				var b = this.audio;
				this.codecs = {};
				this.codecs = {
					mp3: !!b.canPlayType("audio/mpeg;").replace(/^no$/,
						""),
					opus: !!b.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
					ogg: !!b.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
					wav: !!b.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
					aac: !!b.canPlayType("audio/aac;").replace(/^no$/, ""),
					m4a: !!(b.canPlayType("audio/x-m4a;") || b.canPlayType("audio/m4a;") || b.canPlayType("audio/aac;")).replace(/^no$/, ""),
					mp4: !!(b.canPlayType("audio/x-mp4;") || b.canPlayType("audio/mp4;") || b.canPlayType("audio/aac;")).replace(/^no$/, ""),
					weba: !!b.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,
						"")
				};
				this.is = {
					ff: Boolean(null != window.mozInnerScreenX && /firefox/.test(navigator.userAgent.toLowerCase())),
					ie: Boolean(document.all && !window.opera),
					opera: Boolean(window.opera),
					chrome: Boolean(window.chrome),
					safari: Boolean(!window.chrome && /safari/.test(navigator.userAgent.toLowerCase()) && window.getComputedStyle && !window.globalStorage && !window.opera)
				};
				this.playDelay = -60;
				this.stopDelay = 30;
				this.is.chrome && (this.playDelay = -25);
				this.is.chrome && (this.stopDelay = 25);
				this.is.ff && (this.playDelay = -25);
				this.is.ff &&
					(this.stopDelay = 85);
				this.is.opera && (this.playDelay = 5);
				this.is.opera && (this.stopDelay = 0);
				for (var e in c) {
					this.soundList[e] = e;
					var d = c[e].path,
						b = d + "." + ig.Sound.FORMAT.OGG.ext,
						d = d + "." + ig.Sound.FORMAT.MP3.ext,
						f = null;
					this.codecs[ig.Sound.FORMAT.OGG.ext.toLowerCase()] ? f = b : this.codecs[ig.Sound.FORMAT.MP3.ext.toLowerCase()] && (f = d);
					if (f) {
						ig.ua.mobile ? ig.ua.iOS && (f = d) : (c = navigator.userAgent.toLowerCase(), -1 != c.indexOf("safari") && -1 >= c.indexOf("chrome") && (f = d));
						this.audio.addEventListener("error", function() {
							this.audio.error &&
								4 === this.audio.error.code && (this.isSupported = !1)
						}, !1);
						this.audio.src = f;
						this.audio._pos = 0;
						this.audio.preload = "auto";
						this.audio.volume = this._volume;
						this.inactiveAudio = new Audio;
						this.inactiveAudio.src = f;
						this.inactiveAudio._pos = 0;
						this.inactiveAudio.preload = "auto";
						this.inactiveAudio.volume = this._volume;
						this.inactiveAudio.load();
						var g = function() {
							this._duration = this.audio.duration;
							this._loaded || (this._loaded = !0);
							this.bgmPlaying ? this.play(null, !0) : this.stop();
							this.audio.removeEventListener("canplaythrough",
								g, !1)
						}.bind(this);
						this.audio.addEventListener("canplaythrough", g, !1);
						this.audio.load();
						break
					}
				}
			}
		},
		play: function(c, b) {
			if (this.isSupported)
				if (this.bgmPlaying = !0, this.webaudio) {
					if (!b && this.reinitOnPlay && this.webaudio.source_loop.buffer == this.webaudio.buffer) {
						if (this.webaudio.source_loop._playing && (this.webaudio.source_loop[this.webaudio.compatibility.stop](0), this.webaudio.source_loop._playing = !1, this.pausedTime += this.webaudio.context.currentTime - this.webaudio.source_loop._startTime, this.pausedTime %=
								this.webaudio.source_loop.buffer.duration, this.webaudio.source_loop._startTime = 0, "noteOn" === this.webaudio.compatibility.start)) this.webaudio.source_once[this.webaudio.compatibility.stop](0);
						try {
							this.webaudio.context.close();
							this.webaudio.context = new this.AudioContext;
							this.webaudio.gainNode = this.webaudio.context.createGain();
							this.webaudio.gainNode.connect(this.webaudio.context.destination);
							this.webaudio.gainNode.gain.value = this._volume;
							var e = "start",
								d = "stop",
								f = this.webaudio.context.createBufferSource();
							"function" !== typeof f.start && (e = "noteOn");
							this.webaudio.compatibility.start = e;
							"function" !== typeof f.stop && (d = "noteOff");
							this.webaudio.compatibility.stop = d;
							this.webaudio.source_loop = {};
							this.play(null, !0)
						} catch (g) {}
					}
					if (this.webaudio.buffer) {
						if (!this.muteFlag && (this.bgmPlaying = !0, !this.webaudio.source_loop._playing)) {
							this.webaudio.source_loop = this.webaudio.context.createBufferSource();
							this.webaudio.source_loop.buffer = this.webaudio.buffer;
							this.webaudio.source_loop.loop = !0;
							this.webaudio.source_loop.connect(this.webaudio.gainNode);
							if (null == c || isNaN(c)) c = 0, this.pausedTime && (c = this.pausedTime);
							this.webaudio.source_loop._startTime = this.webaudio.context.currentTime;
							if ("noteOn" === this.webaudio.compatibility.start) this.webaudio.source_once = this.webaudio.context.createBufferSource(), this.webaudio.source_once.buffer = this.webaudio.buffer, this.webaudio.source_once.connect(this.webaudio.gainNode), this.webaudio.source_once.noteGrainOn(0, c, this.webaudio.buffer.duration - c), this.webaudio.source_loop[this.webaudio.compatibility.start](this.webaudio.context.currentTime +
								(this.webaudio.buffer.duration - c));
							else this.webaudio.source_loop[this.webaudio.compatibility.start](0, c);
							this.webaudio.source_loop._playing = !0
						}
					} else this.bgmPlaying = !0
				} else if (this.audio) {
				var q = this.audio;
				if (!this.muteFlag)
					if (this.bgmPlaying = !0, isNaN(c) && (c = 0, this.pausedTime && (c = this.pausedTime)), e = this._duration - c, this._onEndTimer && (clearTimeout(this._onEndTimer), this._onEndTimer = null), this._onEndTimer = setTimeout(function() {
							this.audio.currentTime = 0;
							this.audio.pause();
							this.pausedTime = 0;
							if (this.inactiveAudio) {
								var b =
									this.audio;
								this.audio = this.inactiveAudio;
								this.inactiveAudio = b
							}
							this.play()
						}.bind(this), 1E3 * e + this.playDelay), 4 === q.readyState || !q.readyState && navigator.isCocoonJS) q.readyState = 4, q.currentTime = c, q.muted = this.muteFlag || q.muted, q.volume = this._volume, setTimeout(function() {
						q.play()
					}, 0);
					else {
						clearTimeout(this._onEndTimer);
						this._onEndTimer = null;
						var m = function() {
							typeof("function" == this.play) && (this.play(), q.removeEventListener("canplaythrough", m, !1))
						}.bind(this);
						q.addEventListener("canplaythrough", m, !1)
					}
			}
		},
		stop: function() {
			this.bgmPlaying = !1;
			if (this.isSupported)
				if (this.webaudio) {
					if (this.webaudio.source_loop._playing && (this.webaudio.source_loop[this.webaudio.compatibility.stop](0), this.webaudio.source_loop._playing = !1, this.pausedTime += this.webaudio.context.currentTime - this.webaudio.source_loop._startTime, this.pausedTime %= this.webaudio.source_loop.buffer.duration, this.webaudio.source_loop._startTime = 0, "noteOn" === this.webaudio.compatibility.start)) this.webaudio.source_once[this.webaudio.compatibility.stop](0)
				} else if (this.audio) {
				var c =
					this.audio;
				4 == c.readyState && (this.pausedTime = c.currentTime, c.currentTime = 0, c.pause(), clearTimeout(this._onEndTimer), this._onEndTimer = null)
			}
		},
		volume: function(c) {
			if (isNaN(c) || null == c) return this.getVolume();
			this.isSupported && (this._volume = c, 0 > this._volume ? this._volume = 0 : 1 < this._volume && (this._volume = 1), this.webaudio ? this.webaudio.gainNode && (this.webaudio.gainNode.gain.value = this._volume) : this.audio && (this.audio.volume = this._volume, this.inactiveAudio && (this.inactiveAudio.volume = this._volume)))
		},
		getVolume: function() {
			return !this.isSupported ?
				0 : this._volume
		},
		mute: function(c) {
			this.parent(c);
			!1 == this.muteFlag && (this.muteFlag = !0, this.bgmPlaying && (this.stop(), this.bgmPlaying = !0))
		},
		unmute: function(c) {
			this.parent(c);
			!this.stayMuteFlag && !0 == this.muteFlag && (this.muteFlag = !1, this.bgmPlaying && this.play())
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.sound-info").defines(function() {
	SoundInfo = ig.Class.extend({
		FORMATS: {
			OGG: ".ogg",
			MP3: ".mp3"
		},
		sfx: {
			kittyopeningSound: {
				path: "media/audio/opening/kittyopening"
			},
			staticSound: {
				path: "media/audio/play/static"
			},
			openingSound: {
				path: "media/audio/opening/opening"
			},
			shooting: {
				path: "media/audio/game/shoot"
			},
			click: {
				path: "media/audio/game/click"
			},
			glassBreak1: {
				path: "media/audio/game/glass-break1"
			},
			glassBreak2: {
				path: "media/audio/game/glass-break2"
			},
			glassBreak3: {
				path: "media/audio/game/glass-break3"
			},
			glassBreak4: {
				path: "media/audio/game/glass-break4"
			},
			starOne: {
				path: "media/audio/game/starsix"
			}
		},
		bgm: {
			background: {
				path: "media/audio/bgm",
				startOgg: 0,
				endOgg: 10,
				startMp3: 0,
				endMp3: 10
			}
		}
	})
});
ig.baked = !0;
ig.module("plugins.audio.sound-handler").requires("plugins.audio.impact-music-player", "plugins.audio.impact-sound-player", "plugins.audio.howler-player", "plugins.audio.howler-music-player", "plugins.audio.jukebox-player", "plugins.audio.webaudio-music-player", "plugins.audio.sound-info").defines(function() {
	ig.SoundHandler = ig.Class.extend({
		bgmPlayer: null,
		sfxPlayer: null,
		focusBlurMute: !1,
		soundInfo: new SoundInfo,
		init: function() {
			console.log("Initiating sound handler");
			this.initWindowHandler();
			ig.ua.mobile ?
				(this.initPowerButtonFix(), this.bgmPlayer = new WebaudioMusicPlayer(this.soundInfo.bgm, {
					loop: !0
				}), this.bgmPlayer.isSupported || (this.bgmPlayer = new JukeboxPlayer(this.soundInfo.bgm, {
					loop: !0
				}))) : (this.bgmPlayer = new WebaudioMusicPlayer(this.soundInfo.bgm, {
					loop: !0
				}), this.bgmPlayer.isSupported || (this.bgmPlayer = new ImpactMusicPlayer(this.soundInfo.bgm, {
					loop: !0
				})));
			this.sfxPlayer = new HowlerPlayer(this.soundInfo.sfx)
		},
		checkBGM: function() {
			return this.bgmPlayer.stayMuteFlag
		},
		checkSFX: function() {
			return this.sfxPlayer.stayMuteFlag
		},
		muteSFX: function(c) {
			this.sfxPlayer && this.sfxPlayer.mute(c)
		},
		muteBGM: function(c) {
			this.bgmPlayer && this.bgmPlayer.mute(c)
		},
		unmuteSFX: function(c) {
			this.sfxPlayer && this.sfxPlayer.unmute(c)
		},
		unmuteBGM: function(c) {
			this.bgmPlayer && this.bgmPlayer.unmute(c)
		},
		muteAll: function(c) {
			this.muteSFX(c);
			this.muteBGM(c)
		},
		unmuteAll: function(c) {
			this.unmuteSFX(c);
			this.unmuteBGM(c)
		},
		forceMuteAll: function() {
			this.focusBlurMute || this.muteAll(!1);
			this.focusBlurMute = !0
		},
		forceUnMuteAll: function() {
			this.focusBlurMute && (this.unmuteAll(!1),
				this.focusBlurMute = !1)
		},
		initWindowHandler: function() {
			"true" === ig.domHandler.getQueryVariable("webview") ? ($(window).focus(function() {
				// wgl.system && !1 == ig.game.paused && wgl.system.startRender();
				ig.soundHandler && ig.soundHandler.forceUnMuteAll()
			}), $(window).blur(function() {
				ig.game && ig.game.control && ig.game.control.pauseGame();
				wgl.system && wgl.system.stopRender();
				ig.soundHandler && ig.soundHandler.forceMuteAll()
			})) : (window.onfocus = function() {
				// wgl.system && !1 == ig.game.paused && wgl.system.startRender();
				ig.soundHandler &&
					ig.soundHandler.forceUnMuteAll()
			}, window.onblur = function() {
				// ig.game && ig.game.control && ig.game.control.pauseGame();
				wgl.system && wgl.system.stopRender();
				ig.soundHandler && ig.soundHandler.forceMuteAll()
			})
		},
		initPowerButtonFix: function() {
			var c = this.getHiddenProp();
			c && (c = c.replace(/[H|h]idden/, "") + "visibilitychange", document.addEventListener(c, this.visChange));
			window.addEventListener("pagehide", function() {
				ig.soundHandler && ig.soundHandler.forceMuteAll()
			}, !1);
			window.addEventListener("pageshow", function() {
				ig.soundHandler &&
					ig.soundHandler.forceUnMuteAll()
			}, !1)
		},
		getHiddenProp: function() {
			var c = ["webkit", "moz", "ms", "o"];
			if ("hidden" in document) return "hidden";
			for (var b = 0; b < c.length; b++)
				if (c[b] + "Hidden" in document) return c[b] + "Hidden";
			return null
		},
		isHidden: function() {
			var c = this.getHiddenProp();
			return !c ? !1 : document[c]
		},
		visChange: function() {
			ig.soundHandler.isHidden() ? ig.soundHandler && ig.soundHandler.forceMuteAll() : ig.soundHandler && ig.soundHandler.forceUnMuteAll()
		},
		saveVolume: function() {
			this.sfxPlayer && ig.game.io.storageSet("soundVolume",
				this.sfxPlayer.getVolume());
			this.bgmPlayer && ig.game.io.storageSet("musicVolume", this.bgmPlayer.getVolume())
		},
		forceLoopBGM: function() {
			var c;
			if (!this.focusBlurMute && this.bgmPlayer.bgmPlaying && this.bgmPlayer) {
				var b = this.bgmPlayer.jukeboxPlayer;
				if (b) {
					null != window.mozInnerScreenX && /firefox/.test(navigator.userAgent.toLowerCase());
					c = Boolean(window.chrome);
					!window.chrome && /safari/.test(navigator.userAgent.toLowerCase());
					var e = 0.1;
					ig.ua.mobile && (e = 0.115, ig.ua.android && (e = 0.45, c && (e = 0.3)));
					b.settings.spritemap.music &&
						(c = b.settings.spritemap.music.end - e, b.getCurrentTime() >= c && (c = b.settings.spritemap.music.start, ig.ua.android ? this.forcelooped || (b.play(c, !0), this.forcelooped = !0, setTimeout(function() {
							ig.soundHandler.forcelooped = !1
						}, e)) : b.setCurrentTime(c)))
				} else "ImpactMusicPlayer" == this.bgmPlayer.tagName && (null != window.mozInnerScreenX && /firefox/.test(navigator.userAgent.toLowerCase()), c = Boolean(window.chrome), !window.chrome && /safari/.test(navigator.userAgent.toLowerCase()), e = 0.1, ig.ua.mobile && (e = 0.115, ig.ua.android &&
					(e = 0.45, c && (e = 0.3))), b = 0, "mp3" == ig.soundManager.format.ext && (b = 0.05), ig.music.currentTrack && (c = ig.music.currentTrack.duration - e, ig.music.currentTrack.currentTime >= c && (ig.ua.android ? this.forcelooped || (ig.music.currentTrack.pause(), ig.music.currentTrack.currentTime = b, ig.music.currentTrack.play(), this.forcelooped = !0, setTimeout(function() {
					ig.soundHandler.forcelooped = !1
				}, e)) : ig.music.currentTrack.currentTime = b)))
			}
		}
	})
});
ig.baked = !0;
ig.module("plugins.io.storage").defines(function() {
	ig.Storage = ig.Class.extend({
		staticInstantiate: function() {
			return !ig.Storage.instance ? null : ig.Storage.instance
		},
		init: function() {
			ig.Storage.instance = this
		},
		isCapable: function() {
			return "undefined" !== typeof window.localStorage
		},
		isSet: function(c) {
			return null !== this.get(c)
		},
		initUnset: function(c, b) {
			null === this.get(c) && this.set(c, b)
		},
		get: function(c) {
			if (!this.isCapable()) return null;
			try {
				return JSON.parse(localStorage.getItem(c))
			} catch (b) {
				return window.localStorage.getItem(c)
			}
		},
		getInt: function(c) {
			return ~~this.get(c)
		},
		getFloat: function(c) {
			return parseFloat(this.get(c))
		},
		getBool: function(c) {
			return !!this.get(c)
		},
		key: function(c) {
			return this.isCapable() ? window.localStorage.key(c) : null
		},
		set: function(c, b) {
			if (!this.isCapable()) return null;
			try {
				window.localStorage.setItem(c, JSON.stringify(b))
			} catch (e) {
				console.log(e)
			}
		},
		setHighest: function(c, b) {
			b > this.getFloat(c) && this.set(c, b)
		},
		remove: function(c) {
			if (!this.isCapable()) return null;
			window.localStorage.removeItem(c)
		},
		clear: function() {
			if (!this.isCapable()) return null;
			window.localStorage.clear()
		}
	})
});
ig.baked = !0;
ig.module("plugins.io.mouse").defines(function() {
	Mouse = ig.Class.extend({
		bindings: {
			click: [ig.KEY.MOUSE1]
		},
		last: new BABYLON.Vector2.Zero,
		init: function() {
			ig.input.initMouse();
			for (var c in this.bindings) {
				this[c] = c;
				for (var b = 0; b < this.bindings[c].length; b++) ig.input.bind(this.bindings[c][b], c)
			}
		},
		getLast: function() {
			return this.last
		},
		getWglPos: function() {
			var c = ig.sizeHandler.mobile.actualResolution.x,
				b = ig.sizeHandler.mobile.actualResolution.y,
				e = wgl.system.engine.getRenderWidth(),
				d = wgl.system.engine.getRenderHeight(),
				c = e / c,
				b = d / b,
				d = ig.game.io.getClickPos();
			ig.ua.mobile ? (c = d.x * ig.sizeHandler.sizeRatio.x, b = d.y * ig.sizeHandler.sizeRatio.y) : (c *= d.x, b *= d.y);
			return new BABYLON.Vector2(c, b)
		},
		getPos: function() {
			if (ig.ua.mobile) var c = ig.input.mouse.x / ig.sizeHandler.sizeRatio.x,
				b = ig.input.mouse.y / ig.sizeHandler.sizeRatio.y;
			else c = ig.input.mouse.x, b = ig.input.mouse.y;
			this.last = new BABYLON.Vector2(c, b);
			return this.last.clone()
		}
	})
});
ig.baked = !0;
ig.module("plugins.io.keyboard").defines(function() {
	Keyboard = ig.Class.extend({
		bindings: {
			jump: [ig.KEY.W, ig.KEY.UP_ARROW],
			moveright: [ig.KEY.D, ig.KEY.RIGHT_ARROW],
			moveleft: [ig.KEY.A, ig.KEY.LEFT_ARROW],
			shoot: [ig.KEY.S, ig.KEY.DOWN_ARROW, ig.KEY.SPACE]
		},
		init: function() {
			for (var c in this.bindings) {
				this[c] = c;
				for (var b = 0; b < this.bindings[c].length; b++) ig.input.bind(this.bindings[c][b], c)
			}
		}
	})
});
ig.baked = !0;
ig.module("plugins.io.gamepad-input").defines(function() {
	ig.PADKEY = {
		BUTTON_0: 0,
		PADBUTTON_1: 1,
		BUTTON_2: 2,
		BUTTON_3: 3,
		BUTTON_LEFT_BUMPER: 4,
		BUTTON_RIGHT_BUMPER: 5,
		BUTTON_LEFT_TRIGGER: 6,
		BUTTON_RIGHT_TRIGGER: 7,
		BUTTON_LEFT_JOYSTICK: 10,
		BUTTON_RIGHT_JOYSTICK: 11,
		BUTTON_DPAD_UP: 12,
		BUTTON_DPAD_DOWN: 13,
		BUTTON_DPAD_LEFT: 14,
		BUTTON_DPAD_RIGHT: 15,
		BUTTON_MENU: 16,
		AXIS_LEFT_JOYSTICK_X: 0,
		AXIS_LEFT_JOYSTICK_Y: 1,
		AXIS_RIGHT_JOYSTICK_X: 2,
		AXIS_RIGHT_JOYSTICK_Y: 3
	};
	ig.GamepadInput = ig.Class.extend({
		isInit: !1,
		isSupported: !1,
		list: [],
		bindings: {},
		states: {},
		presses: {},
		releases: {},
		downLocks: {},
		upLocks: {},
		leftStick: {
			x: 0,
			y: 0
		},
		rightStick: {
			x: 0,
			y: 0
		},
		start: function() {
			if (!this.isInit) {
				this.isInit = !0;
				var c = navigator.getGamepads || navigator.webkitGetGamepads;
				c && (!navigator.getGamepads && navigator.webkitGetGamepads && (navigator.getGamepads = navigator.webkitGetGamepads), this.list = navigator.getGamepads());
				this.isSupported = c
			}
		},
		isAvailable: function() {
			return this.isInit && this.isSupported
		},
		buttonPressed: function(c) {
			return "object" == typeof c ? c.pressed :
				1 == c
		},
		buttonDown: function(c) {
			if (c = this.bindings[c]) this.states[c] = !0, this.downLocks[c] || (this.presses[c] = !0, this.downLocks[c] = !0)
		},
		buttonUp: function(c) {
			if ((c = this.bindings[c]) && this.downLocks[c] && !this.upLocks[c]) this.states[c] = !1, this.releases[c] = !0, this.upLocks[c] = !0
		},
		clearPressed: function() {
			for (var c in this.releases) this.states[c] = !1, this.downLocks[c] = !1;
			this.releases = {};
			this.presses = {};
			this.upLocks = {}
		},
		bind: function(c, b) {
			this.bindings[c] = b
		},
		unbind: function(c) {
			this.releases[this.bindings[c]] = !0;
			this.bindings[c] = null
		},
		unbindAll: function() {
			this.bindings = {};
			this.states = {};
			this.presses = {};
			this.releases = {};
			this.downLocks = {};
			this.upLocks = {}
		},
		state: function(c) {
			return this.states[c]
		},
		pressed: function(c) {
			return this.presses[c]
		},
		released: function(c) {
			return this.releases[c]
		},
		clamp: function(c, b, e) {
			return c < b ? b : c > e ? e : c
		},
		pollGamepads: function() {
			if (this.isSupported) {
				this.leftStick.x = 0;
				this.leftStick.y = 0;
				this.rightStick.x = 0;
				this.rightStick.y = 0;
				this.list = navigator.getGamepads();
				for (var c in this.bindings) {
					for (var b = !1, e = 0; e < this.list.length; e++) {
						var d = this.list[e];
						if (d && d.buttons && this.buttonPressed(d.buttons[c])) {
							b = !0;
							break
						}
					}
					b ? this.buttonDown(c) : this.buttonUp(c)
				}
				for (e = 0; e < this.list.length; e++)
					if ((d = this.list[e]) && d.axes) {
						c = d.axes[ig.GAMEPADINPUT.AXIS_LEFT_JOYSTICK_X];
						var b = d.axes[ig.GAMEPADINPUT.AXIS_LEFT_JOYSTICK_Y],
							f = d.axes[ig.GAMEPADINPUT.AXIS_RIGHT_JOYSTICK_X],
							d = d.axes[ig.GAMEPADINPUT.AXIS_RIGHT_JOYSTICK_Y];
						this.leftStick.x += isNaN(c) ? 0 : c;
						this.leftStick.y += isNaN(b) ? 0 : b;
						this.rightStick.x += isNaN(f) ? 0 : f;
						this.rightStick.y +=
							isNaN(d) ? 0 : d
					}
				0 < this.list.length && (this.leftStick.x = this.clamp(this.leftStick.x, -1, 1), this.leftStick.y = this.clamp(this.leftStick.y, -1, 1), this.rightStick.x = this.clamp(this.rightStick.x, -1, 1), this.rightStick.y = this.clamp(this.rightStick.y, -1, 1))
			}
		}
	})
});
ig.baked = !0;
ig.module("plugins.io.gamepad").requires("plugins.io.gamepad-input").defines(function() {
	Gamepad = ig.Class.extend({
		bindings: {
			padJump: [ig.PADKEY.BUTTON_0]
		},
		init: function() {
			ig.gamepadInput.start();
			for (var c in this.bindings)
				for (var b = 0; b < this.bindings[c].length; b++) ig.gamepadInput.bind(this.bindings[c][b], c)
		},
		press: function() {},
		held: function() {},
		release: function() {}
	})
});
ig.baked = !0;
ig.module("plugins.io.multitouch-input").defines(function() {
	ig.MultitouchInput = ig.Class.extend({
		isStart: !1,
		touches: {},
		pressed: [],
		state: [],
		released: [],
		multitouchCapable: !1,
		lastEventUp: null,
		internalWidth: 1,
		internalHeight: 1,
		scaleX: 1,
		scaleY: 1,
		start: function() {
			this.isStart || (this.isStart = !0, navigator.maxTouchPoints && 1 < navigator.maxTouchPoints && (this.multitouchCapable = !0), ig.ua.touchDevice && (window.navigator.msPointerEnabled && (ig.system.canvas.addEventListener("MSPointerDown", this.touchdown.bind(this), !1), ig.system.canvas.addEventListener("MSPointerUp", this.touchup.bind(this), !1), ig.system.canvas.addEventListener("MSPointerMove", this.touchmove.bind(this), !1), ig.system.canvas.style.msContentZooming = "none", ig.system.canvas.style.msTouchAction = "none"), ig.system.canvas.addEventListener("touchstart", this.touchdown.bind(this), !1), ig.system.canvas.addEventListener("touchend", this.touchup.bind(this), !1), ig.system.canvas.addEventListener("touchmove", this.touchmove.bind(this), !1)))
		},
		touchdown: function(c) {
			if (ig.ua.touchDevice)
				if (this.updateSizeProperties(),
					window.navigator.msPointerEnabled) this.windowKeyDown(c);
				else if (c.touches) {
				this.pollMultitouch(c.touches.length);
				this.updateSizeProperties();
				var b = {
					left: 0,
					top: 0
				};
				ig.system.canvas.getBoundingClientRect && (b = ig.system.canvas.getBoundingClientRect());
				for (var e = [], d = 0; d < c.touches.length; d++) e.push(c.touches[d]);
				this.spliceFromArray(e, this.pressed);
				this.spliceFromArray(e, this.state);
				this.spliceFromArray(e, this.released);
				for (d = 0; d < e.length; d++) c = e[d], this.pressed.push({
					identifier: c.identifier,
					x: (c.clientX -
						b.left) / this.scaleX,
					y: (c.clientY - b.top) / this.scaleY
				})
			}
		},
		touchmove: function(c) {
			if (ig.ua.touchDevice)
				if (this.updateSizeProperties(), window.navigator.msPointerEnabled) this.windowMove(c);
				else if (c.touches) {
				this.pollMultitouch(c.touches.length);
				for (var b = 0; b < c.touches.length; b++) {
					var e = c.touches[b];
					this.upgrade(this.pressed, this.state, e);
					this.updateArray(this.state, e)
				}
			}
		},
		touchup: function(c) {
			if (ig.ua.touchDevice)
				if (this.updateSizeProperties(), window.navigator.msPointerEnabled) this.windowKeyUp(c);
				else if (this.lastEventUp =
				c, c.touches)
				for (var b = 0; b < c.changedTouches.length; b++) {
					var e = c.changedTouches[b];
					this.upgrade(this.state, this.released, e);
					this.upgrade(this.pressed, this.released, e)
				}
		},
		windowKeyDown: function(c) {
			c = c.changedTouches ? c.changedTouches : [c];
			this.pollMultitouch(c.length);
			this.updateSizeProperties();
			for (var b = [], e = 0; e < c.length; e++) b.push(c[e]);
			var d = {
				left: 0,
				top: 0
			};
			ig.system.canvas.getBoundingClientRect && (d = ig.system.canvas.getBoundingClientRect());
			this.spliceFromArray(b, this.pressed);
			this.spliceFromArray(b,
				this.state);
			this.spliceFromArray(b, this.released);
			for (e = 0; e < b.length; e++) {
				var f = c[e];
				this.pressed.push({
					identifier: "undefined" != typeof f.identifier ? f.identifier : "undefined" != typeof f.pointerId ? f.pointerId : 1,
					x: (f.clientX - d.left) / this.scaleX,
					y: (f.clientY - d.top) / this.scaleY
				})
			}
		},
		windowKeyUp: function(c) {
			this.lastEventUp = c;
			c = c.changedTouches ? c.changedTouches : [c];
			for (var b = 0; b < c.length; b++) {
				var e = c[b],
					e = {
						identifier: "undefined" != typeof e.identifier ? e.identifier : "undefined" != typeof e.pointerId ? e.pointerId : 1,
						clientX: e.clientX,
						clientY: e.clientY
					};
				this.upgrade(this.state, this.released, e);
				this.upgrade(this.pressed, this.released, e)
			}
		},
		windowMove: function(c) {
			c = c.changedTouches ? c.changedTouches : [c];
			this.pollMultitouch(c.length);
			for (var b = 0; b < c.length; b++) {
				var e = c[b],
					e = {
						identifier: e.pointerId,
						clientX: e.clientX,
						clientY: e.clientY
					};
				this.upgrade(this.pressed, this.state, e);
				this.updateArray(this.state, e)
			}
		},
		clear: function() {
			for (var c = 0; c < this.released.length; ++c) this.released[c] && (this.released.splice(c, 1), c--)
		},
		pollMultitouch: function(c) {
			!this.multitouchCapable &&
				1 < c && (this.multitouchCapable = !0)
		},
		spliceFromArray: function(c, b) {
			for (var e = 0; e < b.length; e++)
				for (var d = 0; d < c.length; d++) c[d].identifier === b[e].identifier && (c.splice(d, 1), d--)
		},
		updateSizeProperties: function() {
			var c = parseInt(ig.system.canvas.offsetWidth) || ig.system.realWidth,
				b = parseInt(ig.system.canvas.offsetHeight) || ig.system.realHeight;
			this.scaleX = ig.system.scale * (c / ig.system.realWidth);
			this.scaleY = ig.system.scale * (b / ig.system.realHeight)
		},
		upgrade: function(c, b, e) {
			var d = {
				left: 0,
				top: 0
			};
			ig.system.canvas.getBoundingClientRect &&
				(d = ig.system.canvas.getBoundingClientRect());
			for (var f = (e.clientX - d.left) / this.scaleX, d = (e.clientY - d.top) / this.scaleY, g = 0; g < c.length; g++)
				if (void 0 !== typeof c[g].identifier && void 0 !== typeof e.identifier && e.identifier === c[g].identifier) {
					c.splice(g, 1);
					b.push({
						identifier: e.identifier,
						x: f,
						y: d
					});
					break
				}
		},
		updateArray: function(c, b) {
			var e = {
				left: 0,
				top: 0
			};
			ig.system.canvas.getBoundingClientRect && (e = ig.system.canvas.getBoundingClientRect());
			for (var d = (b.clientX - e.left) / this.scaleX, e = (b.clientY - e.top) / this.scaleY,
					f = 0; f < c.length; f++)
				if (void 0 !== typeof c[f].identifier && void 0 !== typeof b.identifier && b.identifier === c[f].identifier) {
					c[f].x = d;
					c[f].y = e;
					break
				}
		}
	})
});
ig.baked = !0;
ig.module("plugins.fake-storage").requires("impact.game").defines(function() {
	ig.FakeStorage = ig.Class.extend({
		tempData: {},
		init: function() {
			ig.FakeStorage.instance = this
		},
		initUnset: function(c, b) {
			null === this.get(c) && this.set(c, b)
		},
		set: function(c, b) {
			this.tempData[c] = JSON.stringify(b)
		},
		setHighest: function(c, b) {
			b > this.getFloat(c) && this.set(c, b)
		},
		get: function(c) {
			return "undefined" == typeof this.tempData[c] ? null : JSON.parse(this.tempData[c])
		},
		getInt: function(c) {
			return ~~this.get(c)
		},
		getFloat: function(c) {
			return parseFloat(this.get(c))
		},
		getBool: function(c) {
			return !!this.get(c)
		},
		isSet: function(c) {
			return null !== this.get(c)
		},
		remove: function() {
			delete this.tempData.key
		},
		clear: function() {
			this.tempData = {}
		}
	})
});
ig.baked = !0;
ig.module("plugins.io.io-manager").requires("plugins.io.storage", "plugins.io.mouse", "plugins.io.keyboard", "plugins.io.gamepad", "plugins.io.multitouch-input", "plugins.io.gamepad-input", "plugins.fake-storage").defines(function() {
	IoManager = ig.Class.extend({
		storage: null,
		localStorageSupport: !1,
		gamekey: "3dshooter",
		mouse: null,
		keyboard: null,
		multitouch: null,
		gamepad: null,
		init: function() {
			ig.multitouchInput = new ig.MultitouchInput;
			ig.gamepadInput = new ig.GamepadInput;
			this.unbindAll();
			this.initStorage();
			this.initMouse();
			this.initKeyboard();
			this.initMultitouch()
		},
		unbindAll: function() {
			ig.input.unbindAll();
			ig.gamepadInput.unbindAll()
		},
		initStorage: function() {
			this._supportsLocalStorage() && (this.storage = new ig.Storage)
		},
		initMouse: function() {
			this.mouse = new Mouse
		},
		initKeyboard: function() {
			this.keyboard = new Keyboard
		},
		initMultitouch: function() {
			ig.multitouchInput.start()
		},
		initGamepad: function() {
			this.gamepad = new Gamepad
		},
		press: function(c) {
			return ig.input.pressed(c) || this.gamepad && this.gamepad.press(c) ? !0 : !1
		},
		held: function(c) {
			return ig.input.state(c) ||
				this.gamepad && this.gamepad.state(c) ? !0 : !1
		},
		release: function(c) {
			return ig.input.released(c) || this.gamepad && this.gamepad.released(c) ? !0 : !1
		},
		getClickPos: function() {
			return this.mouse.getPos()
		},
		getLastClickPos: function() {
			return this.mouse.getLast()
		},
		getTouchesPos: function() {
			return this.multitouch.getTouchesPos()
		},
		checkOverlap: function(c, b, e, d, f) {
			return c.x > b + d || c.x < b || c.y > e + f || c.y < e ? !1 : !0
		},
		clear: function() {
			ig.multitouchInput.clear()
		},
		_supportsLocalStorage: function() {
			try {
				return localStorage.setItem("test",
					"test"), localStorage.removeItem("test"), this.localStorageSupport = "localStorage" in window && null !== window.localStorage
			} catch (c) {
				return this.localStorageSupport
			}
		},
		storageIsSet: function(c) {
			return !this.localStorageSupport ? null : this.storage.isSet(c)
		},
		storageGet: function(c) {
			return !this.localStorageSupport ? null : this.storage.get(c)
		},
		storageSet: function(c, b) {
			if (!this.localStorageSupport) return null;
			this.storage.set(c, b)
		},
		assert: function(c, b, e) {
			if (b !== e) throw "actualValue:" + b + " not equal to testValue:" + e + " at " +
				c;
		}
	})
});
ig.baked = !0;
ig.module("plugins.splash-loader").requires("impact.loader", "impact.animation").defines(function() {
	ig.SplashLoader = ig.Loader.extend({
		desktopCoverDIVID: "play-desktop",
		splashDesktop: new ig.Image("media/graphics/splash/desktop/background.jpg"),
		splashMobile: new ig.Image("media/graphics/splash/mobile/background.jpg"),
		imgLoaderBG: new ig.Image("media/graphics/sprites/loadingbar-bg.png"),
		imgLoaderBar: new ig.Image("media/graphics/sprites/loadingbar-fill.png"),
		init: function(c, b) {
			this.parent(c, b);
			var e = ig.domHandler.getElementById("#game"),
				d = ig.domHandler.getElementById("#webgl");
			ig.domHandler.setZIndex(e, 1);
			ig.domHandler.setZIndex(d, 0);
			ig.apiHandler.run("MJSPreroll")
		},
		end: function() {
			this.parent();
			if (ig.ua.mobile) {
				var c = ig.domHandler.getElementById("#play");
				ig.domHandler.show(c);
				ig.system.setGame(MyGame)
			} else this.tapToStartDiv()
		},
		tapToStartDiv: function(c) {
			this.desktopCoverDIV = document.createElement("div");
			this.desktopCoverDIV.id = this.desktopCoverDIVID;
			this.desktopCoverDIV.setAttribute("class", "play");
			this.desktopCoverDIV.setAttribute("style",
				"position: absolute; display: block; z-index: 999999; background-color: rgba(23, 32, 53, 0.7); visibility: visible; font-size: 10vmin; text-align: center; vertical-align: middle; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;");
			this.desktopCoverDIV.innerHTML = "<div style='color:white;background-color: rgba(255, 255, 255, 0.3); border: 2px solid #fff; font-size:20px; border-radius: 5px; position: relative; float: left; top: 50%; left: 50%; transform: translate(-50%, -50%);'><div style='padding:20px 50px; font-family: Arial;'>" +
				_STRINGS.Splash.TapToStart + "</div></div>";
			(document.getElementById("play").parentNode || document.getElementById("ajaxbar")).appendChild(this.desktopCoverDIV);
			try {
				"undefined" !== typeof ig.sizeHandler ? "undefined" !== typeof ig.sizeHandler.coreDivsToResize && (ig.sizeHandler.coreDivsToResize.push("#" + this.desktopCoverDIVID), "function" === typeof ig.sizeHandler.reorient && ig.sizeHandler.reorient()) : "undefined" !== typeof coreDivsToResize && (coreDivsToResize.push(this.desktopCoverDIVID), "function" === typeof sizeHandler &&
					sizeHandler())
			} catch (b) {
				console.log(b)
			}
			this.desktopCoverDIV.addEventListener("click", function() {
				try {
					"undefined" !== typeof ig.soundHandler ? ("undefined" !== typeof ig.soundHandler.bgmPlayer ? "undefined" !== typeof ig.soundHandler.bgmPlayer.webaudio && "undefined" !== typeof ig.soundHandler.bgmPlayer.webaudio.context && ig.soundHandler.bgmPlayer.webaudio.context.resume() : (ig.soundHandler = null, ig.soundHandler = "undefined" !== typeof ig.soundList ? new ig.SoundHandler(ig.soundList) : new ig.SoundHandler), "undefined" !== typeof ig.soundHandler.sfxPlayer ?
							"function" === typeof ig.soundHandler.sfxPlayer.play && ig.soundHandler.sfxPlayer.play("staticSound") : "undefined" !== typeof ig.soundHandler.staticSound ? "function" === typeof ig.soundHandler.staticSound.play && ig.soundHandler.staticSound.play() : "function" === typeof ig.soundHandler.playSound && ig.soundHandler.playSound("staticSound")) : "undefined" !== typeof Howl ? (ig.global.staticSound = new Howl({
							src: ["media/audio/play/static.ogg", "media/audio/play/static.mp3"]
						}), ig.global.staticSound.play()) : "undefined" !== typeof createjs &&
						"undefined" !== typeof createjs.Sound && "function" === typeof createjs.Sound.play && createjs.Sound.play("opening")
				} catch (b) {
					console.log(b)
				}
				this.setAttribute("style", "visibility: hidden;");
				"function" === typeof c && c();
				ig.gd.show(function() {
					ig.system.setGame(MyGame);
					// gdsdk && "function" === typeof gdsdk.play && gdsdk.play()
				}.bind(this))
			})
		},
		setupCustomAnimation: function() {
			this.customAnim = new ig.Animation(this.customAnim, 0.05, [0, 1, 2, 3, 4, 5]);
			this.customAnim.currentFrame = 0;
			ig.loadingScreen = this;
			ig.loadingScreen.animationTimer =
				window.setInterval("ig.loadingScreen.animate()", 100)
		},
		animate: function() {
			this.customAnim.currentFrame < this.customAnim.sequence.length ? this.customAnim.currentFrame++ : this.customAnim.currentFrame = 0;
			this.customAnim.gotoFrame(this.customAnim.currentFrame)
		},
		draw: function() {
			this._drawStatus += (this.status - this._drawStatus) / 5;
			var c, b;
			ig.ua.mobile ? (c = 0.5 * ig.system.width - 90, b = 320, this.splashMobile.draw(0, 0)) : (c = 0.5 * ig.system.width - 125, b = 280, this.splashDesktop.draw(0, 0));
			var e = ig.system.context;
			e.drawImage(this.imgLoaderBG.data,
				0, 0, this.imgLoaderBG.width, this.imgLoaderBG.height, c, b, this.imgLoaderBG.width, this.imgLoaderBG.height);
			e.drawImage(this.imgLoaderBar.data, 0, 0, this.imgLoaderBar.width * this._drawStatus, this.imgLoaderBar.height, c, b, this.imgLoaderBar.width * this._drawStatus, this.imgLoaderBar.height)
		}
	})
});
ig.baked = !0;
ig.module("babylon.plugins.wgl-entity").defines(function() {
	wgl.Entity = ig.Class.extend({
		pos: null,
		vel: null,
		acc: null,
		meshes: [],
		_killed: !1,
		init: function(c, b, e, d) {
			ig.merge(this, d);
			this.pos = new BABYLON.Vector3(0, 0, 0);
			this.vel = new BABYLON.Vector3(0, 0, 0);
			this.acc = new BABYLON.Vector3(0, 0, 0);
			d && d.mesh && this.meshes.push(d.mesh);
			isNaN(c) || (this.pos.x = c);
			isNaN(b) || (this.pos.y = b);
			isNaN(e) || (this.pos.z = e)
		},
		update: function() {},
		render: function() {},
		kill: function() {
			for (var c = 0; c < this.meshes.length; c++) {
				var b = this.meshes[c];
				wgl.game.currentScene.stopAnimation(b);
				b.dispose();
				this.meshes.splice(c, 1);
				c--
			}
			this._killed = !0
		},
		reset: function() {},
		resize: function() {}
	})
});
ig.baked = !0;
ig.module("plugins.tween").requires("impact.entity", "babylon.plugins.wgl-entity").defines(function() {
	Array.prototype.indexOf || (Array.prototype.indexOf = function(c) {
		for (var b = 0; b < this.length; ++b)
			if (this[b] === c) return b;
		return -1
	});
	ig.Entity.prototype.tweens = [];
	ig.Entity.prototype._preTweenUpdate = ig.Entity.prototype.update;
	ig.Entity.prototype.update = function() {
		this._preTweenUpdate();
		if (0 < this.tweens.length) {
			for (var c = [], b = 0; b < this.tweens.length; b++) this.tweens[b].update(), this.tweens[b].complete || c.push(this.tweens[b]);
			this.tweens = c
		}
	};
	ig.Entity.prototype.tween = function(c, b, e) {
		c = new ig.Tween(this, c, b, e);
		this.tweens.push(c);
		return c
	};
	ig.Entity.prototype.pauseTweens = function() {
		for (var c = 0; c < this.tweens.length; c++) this.tweens[c].pause()
	};
	ig.Entity.prototype.resumeTweens = function() {
		for (var c = 0; c < this.tweens.length; c++) this.tweens[c].resume()
	};
	ig.Entity.prototype.stopTweens = function(c) {
		for (var b = 0; b < this.tweens.length; b++) this.tweens[b].stop(c)
	};
	wgl.Entity.prototype.tweens = [];
	wgl.Entity.prototype._preTweenUpdate = wgl.Entity.prototype.update;
	wgl.Entity.prototype.update = function() {
		this._preTweenUpdate();
		if (0 < this.tweens.length) {
			for (var c = [], b = 0; b < this.tweens.length; b++) this.tweens[b].update(), this.tweens[b].complete || c.push(this.tweens[b]);
			this.tweens = c
		}
	};
	wgl.Entity.prototype.tween = function(c, b, e) {
		c = new ig.Tween(this, c, b, e);
		this.tweens.push(c);
		return c
	};
	wgl.Entity.prototype.pauseTweens = function() {
		for (var c = 0; c < this.tweens.length; c++) this.tweens[c].pause()
	};
	wgl.Entity.prototype.resumeTweens = function() {
		for (var c = 0; c < this.tweens.length; c++) this.tweens[c].resume()
	};
	wgl.Entity.prototype.stopTweens = function(c) {
		for (var b = 0; b < this.tweens.length; b++) this.tweens[b].stop(c)
	};
	ig.Tween = function(c, b, e, d) {
		var f = {},
			g = {},
			q = {},
			m = 0,
			j = !1,
			l = !1,
			p = !1;
		this.duration = e;
		this.paused = this.complete = !1;
		this.easing = ig.Tween.Easing.Linear.EaseNone;
		this.onComplete = !1;
		this.loop = this.delay = 0;
		this.loopCount = -1;
		ig.merge(this, d);
		this.loopNum = this.loopCount;
		this.chain = function(b) {
			p = b
		};
		this.initEnd = function(b, c, d) {
			if ("object" !== typeof c[b]) d[b] = c[b];
			else
				for (subprop in c[b]) d[b] || (d[b] = {}), this.initEnd(subprop,
					c[b], d[b])
		};
		this.initStart = function(b, c, d, e) {
			if ("object" !== typeof d[b]) "undefined" !== typeof c[b] && (e[b] = d[b]);
			else
				for (subprop in d[b]) e[b] || (e[b] = {}), "undefined" !== typeof c[b] && this.initStart(subprop, c[b], d[b], e[b])
		};
		this.start = function() {
			this.paused = this.complete = !1;
			this.loopNum = this.loopCount;
			m = 0; - 1 == c.tweens.indexOf(this) && c.tweens.push(this);
			l = !0;
			j = new ig.Timer;
			for (var d in b) this.initEnd(d, b, g);
			for (d in g) this.initStart(d, g, c, f), this.initDelta(d, q, c, g)
		};
		this.initDelta = function(b, c, d, e) {
			if ("object" !==
				typeof e[b]) c[b] = e[b] - d[b];
			else
				for (subprop in e[b]) c[b] || (c[b] = {}), this.initDelta(subprop, c[b], d[b], e[b])
		};
		this.propUpdate = function(b, c, d, e, f) {
			if ("object" !== typeof d[b]) c[b] = "undefined" != typeof d[b] ? d[b] + e[b] * f : c[b];
			else
				for (subprop in d[b]) this.propUpdate(subprop, c[b], d[b], e[b], f)
		};
		this.propSet = function(b, c, d) {
			if ("object" !== typeof c[b]) d[b] = c[b];
			else
				for (subprop in c[b]) d[b] || (d[b] = {}), this.propSet(subprop, c[b], d[b])
		};
		this.update = function() {
			if (!l) return !1;
			if (this.delay) {
				if (j.delta() < this.delay) return;
				this.delay = 0;
				j.reset()
			}
			if (this.paused || this.complete) return !1;
			var b = (j.delta() + m) / this.duration,
				b = 1 < b ? 1 : b,
				d = this.easing(b);
			for (property in q) this.propUpdate(property, c, f, q, d);
			if (1 <= b) {
				if (0 == this.loopNum || !this.loop) {
					this.complete = !0;
					if (this.onComplete) this.onComplete();
					p && p.start();
					return !1
				}
				if (this.loop == ig.Tween.Loop.Revert) {
					for (property in f) this.propSet(property, f, c);
					m = 0;
					j.reset(); - 1 != this.loopNum && this.loopNum--
				} else if (this.loop == ig.Tween.Loop.Reverse) {
					b = {};
					d = {};
					ig.merge(b, g);
					ig.merge(d, f);
					ig.merge(f,
						b);
					ig.merge(g, d);
					for (property in g) this.initDelta(property, q, c, g);
					m = 0;
					j.reset(); - 1 != this.loopNum && this.loopNum--
				}
			}
		};
		this.pause = function() {
			this.paused = !0;
			m += j.delta()
		};
		this.resume = function() {
			this.paused = !1;
			j.reset()
		};
		this.stop = function(b) {
			b && (this.loop = this.complete = this.paused = !1, m += e, this.update());
			this.complete = !0
		}
	};
	ig.Tween.Loop = {
		Revert: 1,
		Reverse: 2
	};
	ig.Tween.Easing = {
		Linear: {},
		Quadratic: {},
		Cubic: {},
		Quartic: {},
		Quintic: {},
		Sinusoidal: {},
		Exponential: {},
		Circular: {},
		Elastic: {},
		Back: {},
		Bounce: {}
	};
	ig.Tween.Easing.Linear.EaseNone =
		function(c) {
			return c
		};
	ig.Tween.Easing.Quadratic.EaseIn = function(c) {
		return c * c
	};
	ig.Tween.Easing.Quadratic.EaseOut = function(c) {
		return -c * (c - 2)
	};
	ig.Tween.Easing.Quadratic.EaseInOut = function(c) {
		return 1 > (c *= 2) ? 0.5 * c * c : -0.5 * (--c * (c - 2) - 1)
	};
	ig.Tween.Easing.Cubic.EaseIn = function(c) {
		return c * c * c
	};
	ig.Tween.Easing.Cubic.EaseOut = function(c) {
		return --c * c * c + 1
	};
	ig.Tween.Easing.Cubic.EaseInOut = function(c) {
		return 1 > (c *= 2) ? 0.5 * c * c * c : 0.5 * ((c -= 2) * c * c + 2)
	};
	ig.Tween.Easing.Quartic.EaseIn = function(c) {
		return c * c * c * c
	};
	ig.Tween.Easing.Quartic.EaseOut =
		function(c) {
			return -(--c * c * c * c - 1)
		};
	ig.Tween.Easing.Quartic.EaseInOut = function(c) {
		return 1 > (c *= 2) ? 0.5 * c * c * c * c : -0.5 * ((c -= 2) * c * c * c - 2)
	};
	ig.Tween.Easing.Quintic.EaseIn = function(c) {
		return c * c * c * c * c
	};
	ig.Tween.Easing.Quintic.EaseOut = function(c) {
		return (c -= 1) * c * c * c * c + 1
	};
	ig.Tween.Easing.Quintic.EaseInOut = function(c) {
		return 1 > (c *= 2) ? 0.5 * c * c * c * c * c : 0.5 * ((c -= 2) * c * c * c * c + 2)
	};
	ig.Tween.Easing.Sinusoidal.EaseIn = function(c) {
		return -Math.cos(c * Math.PI / 2) + 1
	};
	ig.Tween.Easing.Sinusoidal.EaseOut = function(c) {
		return Math.sin(c *
			Math.PI / 2)
	};
	ig.Tween.Easing.Sinusoidal.EaseInOut = function(c) {
		return -0.5 * (Math.cos(Math.PI * c) - 1)
	};
	ig.Tween.Easing.Exponential.EaseIn = function(c) {
		return 0 == c ? 0 : Math.pow(2, 10 * (c - 1))
	};
	ig.Tween.Easing.Exponential.EaseOut = function(c) {
		return 1 == c ? 1 : -Math.pow(2, -10 * c) + 1
	};
	ig.Tween.Easing.Exponential.EaseInOut = function(c) {
		return 0 == c ? 0 : 1 == c ? 1 : 1 > (c *= 2) ? 0.5 * Math.pow(2, 10 * (c - 1)) : 0.5 * (-Math.pow(2, -10 * (c - 1)) + 2)
	};
	ig.Tween.Easing.Circular.EaseIn = function(c) {
		return -(Math.sqrt(1 - c * c) - 1)
	};
	ig.Tween.Easing.Circular.EaseOut =
		function(c) {
			return Math.sqrt(1 - --c * c)
		};
	ig.Tween.Easing.Circular.EaseInOut = function(c) {
		return 1 > (c /= 0.5) ? -0.5 * (Math.sqrt(1 - c * c) - 1) : 0.5 * (Math.sqrt(1 - (c -= 2) * c) + 1)
	};
	ig.Tween.Easing.Elastic.EaseIn = function(c) {
		var b, e = 0.1,
			d = 0.4;
		if (0 == c) return 0;
		if (1 == c) return 1;
		d || (d = 0.3);
		!e || 1 > e ? (e = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / e);
		return -(e * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - b) * 2 * Math.PI / d))
	};
	ig.Tween.Easing.Elastic.EaseOut = function(c) {
		var b, e = 0.1,
			d = 0.4;
		if (0 == c) return 0;
		if (1 == c) return 1;
		d || (d = 0.3);
		!e || 1 > e ? (e = 1,
			b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / e);
		return e * Math.pow(2, -10 * c) * Math.sin((c - b) * 2 * Math.PI / d) + 1
	};
	ig.Tween.Easing.Elastic.EaseInOut = function(c) {
		var b, e = 0.1,
			d = 0.4;
		if (0 == c) return 0;
		if (1 == c) return 1;
		d || (d = 0.3);
		!e || 1 > e ? (e = 1, b = d / 4) : b = d / (2 * Math.PI) * Math.asin(1 / e);
		return 1 > (c *= 2) ? -0.5 * e * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - b) * 2 * Math.PI / d) : 0.5 * e * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - b) * 2 * Math.PI / d) + 1
	};
	ig.Tween.Easing.Back.EaseIn = function(c) {
		return c * c * (2.70158 * c - 1.70158)
	};
	ig.Tween.Easing.Back.EaseOut = function(c) {
		return (c -=
			1) * c * (2.70158 * c + 1.70158) + 1
	};
	ig.Tween.Easing.Back.EaseInOut = function(c) {
		return 1 > (c *= 2) ? 0.5 * c * c * (3.5949095 * c - 2.5949095) : 0.5 * ((c -= 2) * c * (3.5949095 * c + 2.5949095) + 2)
	};
	ig.Tween.Easing.Bounce.EaseIn = function(c) {
		return 1 - ig.Tween.Easing.Bounce.EaseOut(1 - c)
	};
	ig.Tween.Easing.Bounce.EaseOut = function(c) {
		return (c /= 1) < 1 / 2.75 ? 7.5625 * c * c : c < 2 / 2.75 ? 7.5625 * (c -= 1.5 / 2.75) * c + 0.75 : c < 2.5 / 2.75 ? 7.5625 * (c -= 2.25 / 2.75) * c + 0.9375 : 7.5625 * (c -= 2.625 / 2.75) * c + 0.984375
	};
	ig.Tween.Easing.Bounce.EaseInOut = function(c) {
		return 0.5 > c ? 0.5 * ig.Tween.Easing.Bounce.EaseIn(2 *
			c) : 0.5 * ig.Tween.Easing.Bounce.EaseOut(2 * c - 1) + 0.5
	}
});
ig.baked = !0;
ig.module("plugins.url-parameters").defines(function() {
	ig.UrlParameters = ig.Class.extend({
		init: function() {
			switch (getQueryVariable("iphone")) {
				case "true":
					ig.ua.iPhone = !0, console.log("iPhone mode")
			}
			var c = getQueryVariable("webview");
			if (c) switch (c) {
				case "true":
					ig.ua.is_uiwebview = !0, console.log("webview mode")
			}
			if (c = getQueryVariable("debug")) switch (c) {
				case "true":
					ig.game.showDebugMenu(), console.log("debug mode")
			}
			if (c = getQueryVariable("debugwgl")) switch (c) {
				case "true":
					wgl.debug.debug = !0, console.log("wgl debug mode")
			}
			switch (getQueryVariable("view")) {
				case "stats":
					ig.game.resetPlayerStats(),
						ig.game.endGame()
			}
			getQueryVariable("ad")
		}
	})
});
ig.baked = !0;
ig.module("plugins.director").requires("impact.impact").defines(function() {
	ig.Director = ig.Class.extend({
		init: function(c, b) {
			this.game = c;
			this.levels = [];
			this.currentLevel = 0;
			this.append(b)
		},
		loadLevel: function(c) {
			for (var b in ig.sizeHandler.dynamicClickableEntityDivs) {
				var e = ig.domHandler.getElementById("#" + b);
				ig.domHandler.hide(e)
			}
			this.currentLevel = c;
			this.game.loadLevel(this.levels[c]);
			return !0
		},
		loadLevelWithoutEntities: function(c) {
			this.currentLevel = c;
			this.game.loadLevelWithoutEntities(this.levels[c]);
			return !0
		},
		append: function(c) {
			newLevels = [];
			return "object" === typeof c ? (c.constructor === [].constructor ? newLevels = c : newLevels[0] = c, this.levels = this.levels.concat(newLevels), !0) : !1
		},
		nextLevel: function() {
			return this.currentLevel + 1 < this.levels.length ? this.loadLevel(this.currentLevel + 1) : !1
		},
		previousLevel: function() {
			return 0 <= this.currentLevel - 1 ? this.loadLevel(this.currentLevel - 1) : !1
		},
		jumpTo: function(c) {
			var b = null;
			for (i = 0; i < this.levels.length; i++) this.levels[i] == c && (b = i);
			return 0 <= b ? this.loadLevel(b) : !1
		},
		firstLevel: function() {
			return this.loadLevel(0)
		},
		lastLevel: function() {
			return this.loadLevel(this.levels.length - 1)
		},
		reloadLevel: function() {
			return this.loadLevel(this.currentLevel)
		}
	})
});
ig.baked = !0;
ig.module("plugins.impact-storage").requires("impact.game").defines(function() {
	ig.Storage = ig.Class.extend({
		staticInstantiate: function() {
			return !ig.Storage.instance ? null : ig.Storage.instance
		},
		init: function() {
			ig.Storage.instance = this
		},
		isCapable: function() {
			return "undefined" !== typeof window.localStorage
		},
		isSet: function(c) {
			return null !== this.get(c)
		},
		initUnset: function(c, b) {
			null === this.get(c) && this.set(c, b)
		},
		get: function(c) {
			if (!this.isCapable()) return null;
			try {
				return JSON.parse(localStorage.getItem(c))
			} catch (b) {
				return window.localStorage.getItem(c)
			}
		},
		getInt: function(c) {
			return ~~this.get(c)
		},
		getFloat: function(c) {
			return parseFloat(this.get(c))
		},
		getBool: function(c) {
			return !!this.get(c)
		},
		key: function(c) {
			return this.isCapable() ? window.localStorage.key(c) : null
		},
		set: function(c, b) {
			if (!this.isCapable()) return null;
			try {
				window.localStorage.setItem(c, JSON.stringify(b))
			} catch (e) {
				console.log(e)
			}
		},
		setHighest: function(c, b) {
			b > this.getFloat(c) && this.set(c, b)
		},
		remove: function(c) {
			if (!this.isCapable()) return null;
			window.localStorage.removeItem(c)
		},
		clear: function() {
			if (!this.isCapable()) return null;
			window.localStorage.clear()
		}
	})
});
ig.baked = !0;
ig.module("babylon.plugins.Tree").requires("impact.entity", "babylon.plugins.wgl-entity").defines(function() {});
Tree = function(c, b, e, d, f) {
	BABYLON.Mesh.call(this, "tree", d);
	this._init(c);
	var g = randomColor({
			hue: "green",
			luminosity: "darl",
			format: "rgbArray"
		}),
		q = randomColor({
			hue: "orange",
			luminosity: "dark",
			format: "rgbArray"
		});
	this.material = new BABYLON.StandardMaterial("mat", d);
	this.material.diffuseColor = BABYLON.Color3.FromInts(g[0], g[1], g[2]);
	this.material.specularColor = BABYLON.Color3.Black();
	this.position.y = b + c / 2 - 2;
	e = BABYLON.Mesh.CreateCylinder("trunk", b, 1 > e - 2 ? 1 : e - 2, e, 7, 2, d);
	e.parent = this;
	e.position.y = -c / 2 + 2 - b / 2;
	e.material =
		new BABYLON.StandardMaterial("trunk", d);
	e.material.diffuseColor = BABYLON.Color3.FromInts(q[0], q[1], q[2]);
	e.material.specularColor = BABYLON.Color3.Black();
	e.convertToFlatShadedMesh();
	this.trunk = e;
	f.getShadowMap().renderList.push(this);
	f.getShadowMap().renderList.push(this.trunk)
};
Tree.prototype = Object.create(BABYLON.Mesh.prototype);
Tree.prototype.constructor = Tree;
Tree.prototype._init = function(c) {
	BABYLON.VertexData.CreateSphere({
		segments: 2,
		diameter: c
	}).applyToMesh(this, !1);
	for (var b = this.getVerticesData(BABYLON.VertexBuffer.PositionKind), e = this.getIndices(), d = b.length / 3, f = [], g = BABYLON.Vector3, q = [], m = 0; m < d; m++) {
		var j = new g(b[3 * m], b[3 * m + 1], b[3 * m + 2]);
		j.y >= c / 2 && q.push(j);
		for (var l = !1, p = 0; p < f.length && !l; p++) {
			var r = f[p],
				s = r[0];
			if (s.equals(j) || 0.01 > s.subtract(j).lengthSquared()) r.push(3 * m), l = !0
		}
		l || (r = [], r.push(j, 3 * m), f.push(r))
	}
	var t = function(b, c) {
		return b == c ? b : Math.random() *
			(c - b) + b
	};
	f.forEach(function(d) {
		var e;
		e = -c / 10;
		var f = c / 10,
			g = t(e, f),
			j = t(e, f),
			f = t(e, f);
		for (e = 1; e < d.length; e++) {
			var l = d[e];
			b[l] += g;
			b[l + 1] += j;
			b[l + 2] += f
		}
	});
	this.setVerticesData(BABYLON.VertexBuffer.PositionKind, b);
	d = [];
	BABYLON.VertexData.ComputeNormals(b, e, d);
	this.setVerticesData(BABYLON.VertexBuffer.NormalKind, d);
	this.convertToFlatShadedMesh()
};
ig.baked = !0;
ig.module("babylon.plugins.TreeGenerator").requires("impact.entity", "babylon.plugins.wgl-entity").defines(function() {});
TreeGenerator = function(c, b) {
	this.treeNumber = 15;
	this._trees = [];
	this.scene = c;
	this.minSizeBranch = 15;
	this.maxSizeBranch = 20;
	this.minSizeTrunk = 10;
	this.maxSizeTrunk = 15;
	this.minRadius = 1;
	this.maxRadius = 5;
	this.sd = b;
	this.generate()
};
TreeGenerator.prototype.generate = function() {
	this.clean();
	for (var c = function(b, c) {
			return b == c ? b : Math.random() * (c - b) + b
		}, b, e, d, f, g, q = 0; q < this.treeNumber; q++) b = c(this.minSizeBranch, this.maxSizeBranch), e = c(this.minSizeTrunk, this.maxSizeTrunk), g = c(this.minRadius, this.maxRadius), d = c(-100, 100), f = c(70, 150), b = new Tree(b, e, g, this.scene, this.sd), b.position.x = d, b.position.z = f, this._trees.push(b)
};
TreeGenerator.prototype.clean = function() {
	this._trees.forEach(function(c) {
		c.dispose()
	});
	this._trees = []
};
ig.baked = !0;
ig.module("babylon.plugins.randomColor").requires("impact.entity", "babylon.plugins.wgl-entity").defines(function() {});
(function(c, b) {
	if ("function" === typeof define && define.amd) define([], b);
	else if ("object" === typeof exports) {
		var e = b();
		"object" === typeof module && (module && module.exports) && (exports = module.exports = e);
		exports.randomColor = e
	} else c.randomColor = b()
})(this, function() {
	function c(b, c) {
		switch (c.format) {
			case "hsvArray":
				return b;
			case "hsv":
				return "hsv(" + b.join(", ") + ")";
			case "rgbArray":
				return f(b);
			case "rgb":
				return "rgb(" + f(b).join(", ") + ")";
			default:
				var d = function(b) {
						b = b.toString(16);
						return 1 == b.length ? "0" + b : b
					},
					e =
					f(b);
				return "#" + d(e[0]) + d(e[1]) + d(e[2])
		}
	}

	function b(b) {
		334 <= b && 360 >= b && (b -= 360);
		for (var c in g) {
			var d = g[c];
			if (d.hueRange && b >= d.hueRange[0] && b <= d.hueRange[1]) return g[c]
		}
		return "Color not found"
	}

	function e(b) {
		return Math.floor(b[0] + Math.random() * (b[1] + 1 - b[0]))
	}

	function d(b, c, d) {
		g[b] = {
			hueRange: c,
			lowerBounds: d,
			saturationRange: [d[0][0], d[d.length - 1][0]],
			brightnessRange: [d[d.length - 1][1], d[0][1]]
		}
	}

	function f(b) {
		var c = b[0];
		0 === c && (c = 1);
		360 === c && (c = 359);
		var c = c / 360,
			d = b[1] / 100;
		b = b[2] / 100;
		var e = Math.floor(6 *
				c),
			f = 6 * c - e,
			c = b * (1 - d),
			g = b * (1 - f * d),
			d = b * (1 - (1 - f) * d),
			q = f = 256,
			u = 256;
		switch (e) {
			case 0:
				f = b;
				q = d;
				u = c;
				break;
			case 1:
				f = g;
				q = b;
				u = c;
				break;
			case 2:
				f = c;
				q = b;
				u = d;
				break;
			case 3:
				f = c;
				q = g;
				u = b;
				break;
			case 4:
				f = d;
				q = c;
				u = b;
				break;
			case 5:
				f = b, q = c, u = g
		}
		return [Math.floor(255 * f), Math.floor(255 * q), Math.floor(255 * u)]
	}
	var g = {};
	d("monochrome", null, [
		[0, 0],
		[100, 0]
	]);
	d("red", [-26, 18], [
		[20, 100],
		[30, 92],
		[40, 89],
		[50, 85],
		[60, 78],
		[70, 70],
		[80, 60],
		[90, 55],
		[100, 50]
	]);
	d("orange", [19, 46], [
		[20, 100],
		[30, 93],
		[40, 88],
		[50, 86],
		[60, 85],
		[70, 70],
		[100, 70]
	]);
	d("yellow", [47, 62], [
		[25, 100],
		[40, 94],
		[50, 89],
		[60, 86],
		[70, 84],
		[80, 82],
		[90, 80],
		[100, 75]
	]);
	d("green", [63, 178], [
		[30, 100],
		[40, 90],
		[50, 85],
		[60, 81],
		[70, 74],
		[80, 64],
		[90, 50],
		[100, 40]
	]);
	d("blue", [179, 257], [
		[20, 100],
		[30, 86],
		[40, 80],
		[50, 74],
		[60, 60],
		[70, 52],
		[80, 44],
		[90, 39],
		[100, 35]
	]);
	d("purple", [258, 282], [
		[20, 100],
		[30, 87],
		[40, 79],
		[50, 70],
		[60, 65],
		[70, 59],
		[80, 52],
		[90, 45],
		[100, 42]
	]);
	d("pink", [283, 334], [
		[20, 100],
		[30, 90],
		[40, 86],
		[60, 84],
		[80, 80],
		[90, 75],
		[100, 73]
	]);
	var q = function(d) {
		d = d || {};
		var f, l, p;
		if (null != d.count) {
			f = d.count;
			l = [];
			for (d.count = null; f > l.length;) l.push(q(d));
			d.count = f;
			return l
		}
		a: {
			f = d.hue;
			if ("number" === typeof parseInt(f) && (l = parseInt(f), 360 > l && 0 < l)) {
				f = [l, l];
				break a
			}
			if ("string" === typeof f && g[f] && (f = g[f], f.hueRange)) {
				f = f.hueRange;
				break a
			}
			f = [0, 360]
		}
		f = e(f);
		0 > f && (f = 360 + f);
		l = d;
		if ("random" === l.luminosity) l = e([0, 100]);
		else if ("monochrome" === l.hue) l = 0;
		else {
			var r = b(f).saturationRange;
			p = r[0];
			r = r[1];
			switch (l.luminosity) {
				case "bright":
					p = 55;
					break;
				case "dark":
					p = r - 10;
					break;
				case "light":
					r = 55
			}
			l = e([p, r])
		}
		p = d;
		a: {
			for (var r = l,
					s = b(f).lowerBounds, t = 0; t < s.length - 1; t++) {
				var u = s[t][0],
					x = s[t][1],
					z = s[t + 1][0],
					v = s[t + 1][1];
				if (r >= u && r <= z) {
					s = (v - x) / (z - u);
					r = s * r + (x - s * u);
					break a
				}
			}
			r = 0
		}
		u = 100;
		switch (p.luminosity) {
			case "dark":
				u = r + 20;
				break;
			case "light":
				r = (u + r) / 2;
				break;
			case "random":
				r = 0, u = 100
		}
		p = e([r, u]);
		return c([f, l, p], d)
	};
	return q
});
this.START_BRANDING_SPLASH;
ig.baked = !0;
ig.module("plugins.branding.splash").requires("impact.impact", "impact.entity").defines(function() {
	ig.BrandingSplash = ig.Class.extend({
		init: function() {
			ig.game.spawnEntity(EntityBranding, 0, 0)
		}
	});
	EntityBranding = ig.Entity.extend({
		gravityFactor: 0,
		size: {
			x: 32,
			y: 32
		},
		splash: new ig.Image("branding/splash1.png"),
		init: function(c, b, e) {
			this.parent(c, b, e);
			320 >= ig.system.width ? (this.size.x = 320, this.size.y = 200) : (this.size.x = 480, this.size.y = 240);
			this.pos.x = (ig.system.width - this.size.x) / 2;
			this.pos.y = -this.size.y - 200;
			this.endPosY = (ig.system.height - this.size.y) / 2;
			c = this.tween({
				pos: {
					y: this.endPosY
				}
			}, 0.5, {
				easing: ig.Tween.Easing.Bounce.EaseIn
			});
			b = this.tween({}, 2.5, {
				onComplete: function() {
					ig.game.director.loadLevel(ig.game.director.currentLevel)
				}
			});
			c.chain(b);
			c.start();
			this.currentAnim = this.anims.idle
		},
		createClickableLayer: function() {
			console.log("Build clickable layer");
			this.checkClickableLayer("branding-splash", _SETTINGS.Branding.Logo.Link, _SETTINGS.Branding.Logo.NewWindow)
		},
		doesClickableLayerExist: function(c) {
			for (k in dynamicClickableEntityDivs)
				if (k ==
					c) return !0;
			return !1
		},
		checkClickableLayer: function(c, b, e) {
			"undefined" == typeof wm && (this.doesClickableLayerExist(c) ? (ig.game.showOverlay([c]), $("#" + c).find("[href]").attr("href", b)) : this.createClickableOutboundLayer(c, b, "media/graphics/misc/invisible.png", e))
		},
		createClickableOutboundLayer: function(c, b, e, d) {
			var f = ig.$new("div");
			f.id = c;
			document.body.appendChild(f);
			f = $("#" + f.id);
			f.css("float", "left");
			f.css("position", "absolute");
			if (ig.ua.mobile) {
				var g = window.innerHeight / mobileHeight,
					q = window.innerWidth /
					mobileWidth;
				f.css("left", this.pos.x * q);
				f.css("top", this.pos.y * g);
				f.css("width", this.size.x * q);
				f.css("height", this.size.y * g)
			} else g = w / 2 - destW / 2, q = h / 2 - destH / 2, console.log(g, q), f.css("left", g + this.pos.x * multiplier), f.css("top", q + this.pos.y * multiplier), f.css("width", this.size.x * multiplier), f.css("height", this.size.y * multiplier);
			d ? f.html("<a target='_blank' href='" + b + "'><img style='width:100%;height:100%' src='" + e + "'></a>") : f.html("<a href='" + b + "'><img style='width:100%;height:100%' src='" + e + "'></a>");
			dynamicClickableEntityDivs[c] = {};
			dynamicClickableEntityDivs[c].width = this.size.x * multiplier;
			dynamicClickableEntityDivs[c].height = this.size.y * multiplier;
			dynamicClickableEntityDivs[c].entity_pos_x = this.pos.x;
			dynamicClickableEntityDivs[c].entity_pos_y = this.pos.y
		},
		draw: function() {
			ig.system.context.fillStyle = "#ffffff";
			ig.system.context.fillRect(0, 0, ig.system.width, ig.system.height);
			ig.system.context.fillStyle = "#000";
			ig.system.context.font = "12px Arial";
			ig.system.context.textAlign = "left";
			320 >= ig.system.width ?
				ig.system.context.fillText("powered by MarketJS.com", ig.system.width - 150, ig.system.height - 15) : ig.system.context.fillText("powered by MarketJS.com", ig.system.width - 160, ig.system.height - 15);
			this.parent();
			this.splash && ig.system.context.drawImage(this.splash.data, 0, 0, this.splash.data.width, this.splash.data.height, this.pos.x, this.pos.y, this.size.x, this.size.y)
		}
	})
});
this.END_BRANDING_SPLASH;
ig.baked = !0;
ig.module("plugins.datastructure.binary-heap").defines(function() {
	BinaryHeap = ig.Class.extend({
		content: [],
		getValue: null,
		minHeap: !0,
		tagName: "BinaryHeap",
		init: function(c, b) {
			this.getValue = c;
			b && (this.minHeap = !1)
		},
		push: function(c) {
			this.content.push(c);
			this.sinkDown(this.content.length - 1)
		},
		pop: function() {
			var c = this.content[0],
				b = this.content.pop();
			0 < this.content.length && (this.content[0] = b, this.bubbleUp(0));
			return c
		},
		remove: function(c) {
			var b = this.content.indexOf(c),
				e = this.content.pop();
			b !== this.content.length -
				1 && (this.content[b] = e, this.minHeap ? this.getValue(e) < this.getValue(c) ? this.sinkDown(b) : this.bubbleUp(b) : this.getValue(e) > this.getValue(c) ? this.sinkDown(b) : this.bubbleUp(b))
		},
		size: function() {
			return this.content.length
		},
		rescoreElement: function(c) {
			this.sinkDown(this.content.indexOf(c))
		},
		sinkDown: function(c) {
			for (var b = this.content[c]; 0 < c;) {
				var e = (c + 1 >> 1) - 1,
					d = this.content[e];
				if (this.minHeap)
					if (this.getValue(b) < this.getValue(d)) this.content[e] = b, this.content[c] = d, c = e;
					else break;
				else if (this.getValue(b) >
					this.getValue(d)) this.content[e] = b, this.content[c] = d, c = e;
				else break
			}
		},
		bubbleUp: function(c) {
			for (var b = this.content.length, e = this.content[c], d = this.getValue(e);;) {
				var f = c + 1 << 1,
					g = f - 1,
					q = null,
					m;
				g < b && (m = this.getValue(this.content[g]), this.minHeap ? m < d && (q = g) : m > d && (q = g));
				if (f < b)
					if (g = this.getValue(this.content[f]), this.minHeap) {
						if (g < (null === q ? d : m)) q = f
					} else if (g > (null === q ? d : m)) q = f;
				if (null !== q) this.content[c] = this.content[q], this.content[q] = e, c = q;
				else break
			}
		},
		empty: function() {
			for (; 0 < this.content.length;) this.content.pop()
		}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button").requires("impact.entity").defines(function() {
	EntityButton = ig.Entity.extend({
		collides: ig.Entity.COLLIDES.NEVER,
		type: ig.Entity.TYPE.A,
		size: new BABYLON.Vector2(48, 48),
		fillColor: null,
		zIndex: 10100,
		pos: {
			x: 0,
			y: 0
		},
		name: "button",
		init: function(c, b, e) {
			this.parent(c, b, e);
			!ig.global.wm && (e && !isNaN(e.zIndex)) && (this.zIndex = e.zIndex);
			c = Math.floor(256 * Math.random());
			b = Math.floor(256 * Math.random());
			e = Math.floor(256 * Math.random());
			this.fillColor = "rgba(" + c + "," + e + "," + b + ",1)"
		},
		clicked: function() {
			throw "no implementation on clicked()";
		},
		clicking: function() {
			throw "no implementation on clicking()";
		},
		released: function() {
			throw "no implementation on released()";
		}
	})
});
ig.baked = !0;
ig.module("plugins.clickable-div-layer").defines(function() {
	ClickableDivLayer = ig.Class.extend({
		pos: new BABYLON.Vector2(0, 0),
		size: new BABYLON.Vector2(0, 0),
		identifier: null,
		invisImagePath: "media/graphics/misc/invisible.png",
		init: function(c) {
			this.pos = new BABYLON.Vector2(c.pos.x, c.pos.y);
			this.size = new BABYLON.Vector2(c.size.x, c.size.y);
			var b = "more-games",
				e = "www.google.com",
				d = !1;
			c.div_layer_name && (b = c.div_layer_name);
			c.link && (e = c.link);
			c.newWindow && (d = c.newWindow);
			this.createClickableLayer(b, e, d)
		},
		createClickableLayer: function(c,
			b, e) {
			this.identifier = c;
			var d = ig.domHandler.getElementById("#" + c);
			d ? (ig.domHandler.show(d), ig.domHandler.attr(d, "href", b)) : this.createClickableOutboundLayer(c, b, this.invisImagePath, e)
		},
		update: function(c, b) {
			this.pos.x === c && this.pos.y === b || (ig.sizeHandler.dynamicClickableEntityDivs[this.identifier] = {}, ig.sizeHandler.dynamicClickableEntityDivs[this.identifier].width = this.size.x, ig.sizeHandler.dynamicClickableEntityDivs[this.identifier].height = this.size.y, ig.sizeHandler.dynamicClickableEntityDivs[this.identifier].entity_pos_x =
				this.pos.x, ig.sizeHandler.dynamicClickableEntityDivs[this.identifier].entity_pos_y = this.pos.y)
		},
		createClickableOutboundLayer: function(c, b, e, d) {
			var f = ig.domHandler.create("div");
			ig.domHandler.attr(f, "id", c);
			var g = ig.domHandler.create("a");
			d ? (ig.domHandler.attr(g, "href", b), ig.domHandler.attr(g, "target", "_blank")) : ig.domHandler.attr(g, "href", b);
			b = ig.domHandler.create("img");
			ig.domHandler.css(b, {
				width: "100%",
				height: "100%"
			});
			ig.domHandler.attr(b, "src", e);
			e = Math.min(ig.sizeHandler.scaleRatioMultiplier.x,
				ig.sizeHandler.scaleRatioMultiplier.y);
			if (ig.ua.mobile) {
				d = Math.floor(this.pos.x * ig.sizeHandler.scaleRatioMultiplier.x) + "px";
				var q = Math.floor(this.pos.y * ig.sizeHandler.scaleRatioMultiplier.y) + "px",
					m = Math.floor(this.size.x * ig.sizeHandler.scaleRatioMultiplier.x) + "px";
				e = Math.floor(this.size.y * ig.sizeHandler.scaleRatioMultiplier.y) + "px"
			} else d = ig.domHandler.getElementById("#canvas"), d = ig.domHandler.getOffsets(d), q = d.top, d = Math.floor(d.left + this.pos.x * e) + "px", q = Math.floor(q + this.pos.y * e) + "px", m = Math.floor(this.size.x *
				e) + "px", e = Math.floor(this.size.y * e) + "px";
			ig.domHandler.css(f, {
				"float": "left",
				position: "absolute",
				left: d,
				top: q,
				width: m,
				height: e,
				"z-index": 3
			});
			ig.domHandler.addEvent(f, "mousemove", ig.input.mousemove.bind(ig.input), !1);
			ig.domHandler.appendChild(g, b);
			ig.domHandler.appendChild(f, g);
			ig.domHandler.appendToBody(f);
			ig.sizeHandler.dynamicClickableEntityDivs[c] = {};
			ig.sizeHandler.dynamicClickableEntityDivs[c].width = this.size.x;
			ig.sizeHandler.dynamicClickableEntityDivs[c].height = this.size.y;
			ig.sizeHandler.dynamicClickableEntityDivs[c].entity_pos_x =
				this.pos.x;
			ig.sizeHandler.dynamicClickableEntityDivs[c].entity_pos_y = this.pos.y
		}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-branding-logo").requires("game.entities.buttons.button", "plugins.clickable-div-layer").defines(function() {
	EntityButtonBrandingLogo = EntityButton.extend({
		type: ig.Entity.TYPE.A,
		gravityFactor: 0,
		logo: new ig.AnimationSheet("branding/logo.png", _SETTINGS.Branding.Logo.Width, _SETTINGS.Branding.Logo.Height),
		zIndex: 10001,
		size: {
			x: 64,
			y: 66
		},
		clickableLayer: null,
		link: null,
		newWindow: !1,
		div_layer_name: "branding-logo",
		name: "brandinglogo",
		init: function(c, b, e) {
			this.parent(c, b, e);
			if (!ig.global.wm) {
				if ("undefined" == typeof wm)
					if (_SETTINGS.Branding.Logo.Enabled) this.size.x = _SETTINGS.Branding.Logo.Width, this.size.y = _SETTINGS.Branding.Logo.Height, this.anims.idle = new ig.Animation(this.logo, 0, [0], !0), this.currentAnim = this.anims.idle, e && e.centralize && (this.pos.x = (ig.system.width >>> 1) - (this.size.x >>> 1), console.log("centralize true ... centering branded logo ...")), _SETTINGS.Branding.Logo.LinkEnabled && (this.link = _SETTINGS.Branding.Logo.Link, this.newWindow = _SETTINGS.Branding.Logo.NewWindow,
						this.clickableLayer = new ClickableDivLayer(this));
					else {
						this.kill();
						return
					}
				this.div_layer_name = e.div_layer_name ? e.div_layer_name : "branding-logo"
			}
		},
		show: function() {
			var c = ig.domHandler.getElementById("#" + this.div_layer_name);
			ig.domHandler.show(c)
		},
		hide: function() {
			var c = ig.domHandler.getElementById("#" + this.div_layer_name);
			ig.domHandler.hide(c)
		},
		clicked: function() {},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.branding-logo-placeholder").requires("impact.entity", "game.entities.buttons.button-branding-logo").defines(function() {
	EntityBrandingLogoPlaceholder = ig.Entity.extend({
		gravityFactor: 0,
		size: {
			x: 32,
			y: 32
		},
		_wmDrawBox: !0,
		_wmBoxColor: "rgba(0, 0, 255, 0.7)",
		init: function(c, b, e) {
			this.parent(c, b, e);
			if (e) switch (console.log("settings found ... using that div layer name"), c = e.div_layer_name, console.log("settings.centralize:", e.centralize), e.centralize) {
				case "true":
					console.log("centralize true");
					centralize = !0;
					break;
				case "false":
					console.log("centralize false");
					centralize = !1;
					break;
				default:
					console.log("default ... centralize false"), centralize = !1
			} else c = "branding-logo", centralize = !1;
			if ("undefined" == typeof wm) {
				if (_SETTINGS.Branding.Logo.Enabled) try {
					ig.game.spawnEntity(EntityButtonBrandingLogo, this.pos.x, this.pos.y, {
						div_layer_name: c,
						centralize: centralize
					})
				} catch (d) {
					console.log(d)
				}
				this.kill()
			}
		}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-more-games").requires("game.entities.buttons.button", "plugins.clickable-div-layer").defines(function() {
	EntityButtonMoreGames = EntityButton.extend({
		type: ig.Entity.TYPE.A,
		gravityFactor: 0,
		img: new ig.Image("media/graphics/sprites/btn_more_games.png", 285, 65),
		size: {
			x: 285,
			y: 65
		},
		zIndex: 750,
		clickableLayer: null,
		link: null,
		newWindow: !1,
		div_layer_name: "more-games",
		name: "moregames",
		ignorePause: !0,
		showing: !0,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.pos.x = c - 0.5 * this.size.x;
			ig.global.wm || (this.div_layer_name = e.div_layer_name ? e.div_layer_name : "more-games", _SETTINGS.MoreGames.Enabled ? (_SETTINGS.MoreGames.Link && (this.link = _SETTINGS.MoreGames.Link), _SETTINGS.MoreGames.NewWindow && (this.newWindow = _SETTINGS.MoreGames.NewWindow), this.clickableLayer = new ClickableDivLayer(this)) : this.kill())
		},
		show: function() {
			this.showing = !0;
			var c = ig.domHandler.getElementById("#" + this.div_layer_name);
			ig.domHandler.show(c)
		},
		hide: function() {
			this.showing = !1;
			var c = ig.domHandler.getElementById("#" +
				this.div_layer_name);
			ig.domHandler.hide(c)
		},
		clicked: function() {},
		clicking: function() {},
		released: function() {},
		draw: function() {
			this.parent();
			if (this.showing && ig.game.assetsReady) {
				this.img.draw(this.pos.x, this.pos.y);
				var c = ig.system.context;
				c.save();
				var b = _STRINGS.Game.More;
				c.font = "36px twcen";
				c.textAlign = "center";
				c.fillStyle = "white";
				c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.6 * this.img.height);
				c.restore()
			}
		}
	})
});
ig.baked = !0;
ig.module("game.entities.opening-shield").requires("impact.entity").defines(function() {
	EntityOpeningShield = ig.Entity.extend({
		size: {
			x: 48,
			y: 48
		},
		move: 0,
		mIconAnim: 0,
		shieldAnim: 0,
		titleAnim: 0,
		shieldImage: new ig.Image("media/graphics/opening/shield.png"),
		mIconImage: new ig.Image("media/graphics/opening/m_icon.png"),
		titleImage: new ig.Image("media/graphics/opening/title.png"),
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		ready: function() {
			if (!ig.wm)
				if (_SETTINGS.DeveloperBranding.Splash.Enabled) {
					this.initTimer = new ig.Timer(0.1);
					try {
						ig.soundHandler.playSound(ig.soundHandler.SOUNDID.openingSound)
					} catch (c) {
						console.log(c)
					}
				} else ig.game.director.nextLevel(), ig.system.context.globalAlpha = 1, this.kill()
		},
		update: function() {
			this.parent();
			this.updateOriginalShieldOpening()
		},
		draw: function() {
			this.parent();
			ig.global.wm || (this.nextLevelTimer && 0 > this.nextLevelTimer.delta() && (ig.system.context.globalAlpha = -this.nextLevelTimer.delta()), this.drawOriginalShieldOpening())
		},
		updateOriginalShieldOpening: function() {
			this.initTimer && 0 < this.initTimer.delta() &&
				(this.initTimer = null, this.sheildTimer = new ig.Timer(0.05));
			this.sheildTimer && 0 < this.sheildTimer.delta() && (3 > this.shieldAnim ? (this.shieldAnim++, this.sheildTimer.reset()) : (this.sheildTimer = null, this.moveTimer = new ig.Timer(0.001), this.mIconTimer = new ig.Timer(0.05), this.titleTimer = new ig.Timer(0.15)));
			this.moveTimer && 0 < this.moveTimer.delta() && (this.move += 0.3, this.moveTimer.reset());
			this.mIconTimer && 0 < this.mIconTimer.delta() && (12 > this.mIconAnim ? (this.mIconAnim++, this.moveTimer.reset()) : this.mIconTimer =
				null);
			this.titleTimer && 0 < this.titleTimer.delta() && (11 > this.titleAnim ? (this.titleAnim++, this.titleTimer.reset()) : (this.titleTimer = null, this.nextLevelTimer = new ig.Timer(1)));
			this.nextLevelTimer && 0 < this.nextLevelTimer.delta() && (this.nextLevelTimer = null, ig.game.director.nextLevel(), ig.system.context.globalAlpha = 1)
		},
		drawOriginalShieldOpening: function() {
			if (this.moveTimer) {
				var c = ig.system.context;
				c.save();
				var b = ig.system.width / 2,
					e = ig.system.height / 2;
				c.translate(b, e);
				c.rotate(this.move * Math.PI / 180);
				c.beginPath();
				c.moveTo(0, 0);
				for (var d = 0, f = 1; 48 >= f; f += 1) c.lineTo(0 + 800 * Math.cos(2 * f * Math.PI / 48), 0 + 800 * Math.sin(2 * f * Math.PI / 48)), d++, 2 == d && (d = 0, c.lineTo(0, 0));
				c.translate(-b, -e);
				b = c.createRadialGradient(b, e, 100, b, e, 250);
				b.addColorStop(0, "rgba(255,255,255,0.1)");
				b.addColorStop(1, "rgba(0,0,0,0)");
				c.fillStyle = b;
				c.fill();
				c.restore()
			}
			this.shieldImage.drawTile(ig.system.width / 2 - 91, 0 - (768 - ig.system.height) / 2, this.shieldAnim, 182, 768);
			this.moveTimer && (this.mIconImage.drawTile(ig.system.width / 2 - 96, ig.system.height / 2 - 70, this.mIconAnim,
				166, 160), this.titleImage.drawTile(ig.system.width / 2 - 204, ig.system.height / 2 + 100, this.titleAnim, 409, 76));
			ig.system.context.globalAlpha = 1
		}
	})
});
ig.baked = !0;
ig.module("game.entities.opening-kitty").requires("impact.entity").defines(function() {
	EntityOpeningKitty = ig.Entity.extend({
		size: {
			x: 48,
			y: 48
		},
		kittyAnim: -1,
		kittyImage: new ig.Image("media/graphics/opening/kitty.png"),
		kittyTitleImage: new ig.Image("media/graphics/opening/kittytitle.png"),
		soundKey: "kittyopeningSound",
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		ready: function() {
			if (!ig.wm)
				if (_SETTINGS.DeveloperBranding.Splash.Enabled) {
					this.initTimer = new ig.Timer(0.1);
					try {
						ig.soundHandler.sfxPlayer.play(this.soundKey)
					} catch (c) {
						console.log(c)
					}
				} else ig.game.director.nextLevel(),
					ig.system.context.globalAlpha = 1, this.kill()
		},
		update: function() {
			this.parent();
			this.updateKittyOpening()
		},
		draw: function() {
			this.parent();
			ig.global.wm || (this.nextLevelTimer && 0 > this.nextLevelTimer.delta() && (ig.system.context.globalAlpha = -this.nextLevelTimer.delta()), this.drawKittyOpening())
		},
		updateKittyOpening: function() {
			this.initTimer && 0 < this.initTimer.delta() && (this.initTimer = null, this.kittyTimer = new ig.Timer(0.15));
			this.kittyTimer && 0 < this.kittyTimer.delta() && (7 > this.kittyAnim ? (this.kittyAnim++, this.kittyTimer.reset()) :
				(this.kittyTimer = null, this.nextLevelTimer = new ig.Timer(2)));
			this.nextLevelTimer && 0 < this.nextLevelTimer.delta() && (this.nextLevelTimer = null, ig.game.director.nextLevel(), ig.system.context.globalAlpha = 1)
		},
		drawKittyOpening: function() {
			var c = ig.system.context.createLinearGradient(0, 0, 0, ig.system.height);
			c.addColorStop(0, "#ffed94");
			c.addColorStop(1, "#ffcd85");
			ig.system.context.fillStyle = c;
			ig.system.context.fillRect(0, 0, ig.system.width, ig.system.height);
			0 <= this.kittyAnim && (this.kittyImage.drawTile((ig.system.width >>>
				1) - (this.kittyImage.width >>> 3), (ig.system.height >>> 1) - (this.kittyImage.height >>> 2), this.kittyAnim, 218, 325), this.kittyTitleImage.drawTile((ig.system.width >>> 1) - (this.kittyTitleImage.width >>> 1), (ig.system.height >>> 1) + (this.kittyImage.height >>> 2) + 10, this.kittyAnim, 380, 37));
			ig.system.context.globalAlpha = 1
		}
	})
});
ig.baked = !0;
ig.module("game.entities.pointer").requires("impact.entity").defines(function() {
	EntityPointer = ig.Entity.extend({
		checkAgainst: ig.Entity.TYPE.BOTH,
		isFirstPressed: !1,
		isPressed: !1,
		isReleased: !1,
		isHovering: !1,
		hoveringItem: null,
		objectArray: [],
		clickedObjectList: [],
		ignorePause: !0,
		zIndex: 5E3,
		name: "pointer",
		check: function(c) {
			this.objectArray.push(c)
		},
		clickObject: function(c) {
			this.isFirstPressed && "function" == typeof c.clicked && (c.clicked(), this.addToClickedObjectList(c));
			this.isPressed && !this.isReleased && "function" ==
				typeof c.clicking && c.clicking();
			this.isReleased && "function" == typeof c.released && (c.released(), this.removeFromClickedObjectList(c))
		},
		refreshPos: function() {
			this.pos = ig.game.io.getClickPos()
		},
		update: function() {
			this.parent();
			this.refreshPos();
			var c = null,
				b = -1;
			for (a = this.objectArray.length - 1; - 1 < a; a--) this.objectArray[a].zIndex > b && (b = this.objectArray[a].zIndex, c = this.objectArray[a]);
			if (null != c) null != this.hoveringItem ? this.hoveringItem != c && ("function" == typeof this.hoveringItem.leave && this.hoveringItem.leave(),
				"function" == typeof c.over && c.over()) : "function" == typeof c.over && c.over(), this.hoveringItem = this.lastEnt = c, this.clickObject(c), this.objectArray = [];
			else if (null != this.hoveringItem && "function" == typeof this.hoveringItem.leave && (this.hoveringItem.leave(), this.hoveringItem = null), this.isReleased) {
				for (c = 0; c < this.clickedObjectList.length; c++) b = this.clickedObjectList[c], "function" == typeof b.releasedOutside && b.releasedOutside();
				this.lastEnt && (this.lastEnt.released && this.lastEnt.released(), this.lastEnt = null);
				this.clickedObjectList = []
			}
			this.isFirstPressed = ig.input.pressed("click");
			this.isReleased = ig.input.released("click");
			this.isPressed = ig.input.state("click")
		},
		addToClickedObjectList: function(c) {
			this.clickedObjectList.push(c)
		},
		removeFromClickedObjectList: function(c) {
			for (var b = [], e = 0; e < this.clickedObjectList.length; e++) {
				var d = this.clickedObjectList[e];
				d != c && b.push(d)
			}
			this.clickedObjectList = b
		}
	})
});
ig.baked = !0;
ig.module("game.entities.pointer-selector").requires("game.entities.pointer").defines(function() {
	EntityPointerSelector = EntityPointer.extend({
		zIndex: 1E3,
		_wmDrawBox: !0,
		_wmBoxColor: "rgba(0, 0, 255, 0.7)",
		size: {
			x: 12,
			y: 12
		},
		init: function(c, b, e) {
			this.parent(c, b, e)
		}
	})
});
ig.baked = !0;
ig.module("game.entities.select").requires("impact.entity").defines(function() {
	EntitySelect = ig.Entity.extend({
		type: ig.Entity.TYPE.B,
		checkAgainst: ig.Entity.TYPE.A,
		collides: ig.Entity.COLLIDES.NEVER,
		canSelect: !1,
		canSelectTimerDuration: 0.35,
		zIndex: 99999,
		isHovering: !1,
		isSelected: !1,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.canSelectTimer = new ig.Timer(this.canSelectTimerDuration)
		},
		doesClickableLayerExist: function(c) {
			for (k in dynamicClickableEntityDivs)
				if (k == c) return !0;
			return !1
		},
		checkClickableLayer: function(c,
			b, e) {
			"undefined" == typeof wm && (this.doesClickableLayerExist(c) ? (ig.game.showOverlay([c]), $("#" + c).find("[href]").attr("href", b)) : this.createClickableOutboundLayer(c, b, "media/graphics/misc/invisible.png", e))
		},
		createClickableOutboundLayer: function(c, b, e, d) {
			var f = ig.$new("div");
			f.id = c;
			document.body.appendChild(f);
			$("#" + f.id).css("float", "left");
			$("#" + f.id).css("width", this.size.x * multiplier);
			$("#" + f.id).css("height", this.size.y * multiplier);
			$("#" + f.id).css("position", "absolute");
			var g = w / 2 - destW / 2,
				q = h /
				2 - destH / 2;
			w == mobileWidth ? ($("#" + f.id).css("left", this.pos.x), $("#" + f.id).css("top", this.pos.y)) : ($("#" + f.id).css("left", g + this.pos.x * multiplier), $("#" + f.id).css("top", q + this.pos.y * multiplier));
			d ? $("#" + f.id).html("<a target='_blank' href='" + b + "'><img style='width:100%;height:100%' src='" + e + "'></a>") : $("#" + f.id).html("<a href='" + b + "'><img style='width:100%;height:100%' src='" + e + "'></a>");
			dynamicClickableEntityDivs[c] = {};
			dynamicClickableEntityDivs[c].width = $("#" + f.id).width();
			dynamicClickableEntityDivs[c].height =
				$("#" + f.id).height();
			dynamicClickableEntityDivs[c].entity_pos_x = this.pos.x;
			dynamicClickableEntityDivs[c].entity_pos_y = this.pos.y
		},
		hovered: function() {
			this.isHovering = !0;
			this.dehoverOthers()
		},
		dehoverOthers: function() {
			var c = ig.game.getEntitiesByType(EntitySelect);
			for (i = 0; i < c.length; i++) c[i] != this && (c[i].isHovering = !1)
		},
		deselectOthers: function() {
			var c = ig.game.getEntitiesByType(EntitySelect);
			for (i = 0; i < c.length; i++) c[i] != this && (c[i].isSelected = !1)
		},
		update: function() {
			this.parent();
			this.canSelectTimer && 0 <
				this.canSelectTimer.delta() && (this.canSelect = !0, this.canSelectTimer = null)
		}
	})
});
ig.baked = !0;
ig.module("game.levels.opening").requires("impact.image", "game.entities.opening-kitty").defines(function() {
	LevelOpening = {
		entities: [{
			type: "EntityOpeningKitty",
			x: 520,
			y: 212
		}],
		layer: []
	}
});
ig.baked = !0;
ig.module("game.entities.buttons.button-start").requires("game.entities.buttons.button").defines(function() {
	EntityButtonStart = EntityButton.extend({
		size: {
			x: 123,
			y: 65
		},
		offset: {
			x: 0,
			y: 0
		},
		img: new ig.Image("media/graphics/sprites/btn-play.png"),
		ignorePause: !0,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.pos.x = c - 0.5 * this.size.x
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			if (ig.game.assetsReady) {
				this.img.draw(this.pos.x, this.pos.y);
				var c = ig.system.context;
				c.save();
				var b = _STRINGS.Game.Play;
				c.font = "36px twcen";
				c.textAlign = "center";
				c.fillStyle = "white";
				c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.6 * this.img.height);
				c.restore()
			}
		},
		clicked: function() {
			this.control.levelSelect();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.levels.main-menu").requires("impact.image", "game.entities.branding-logo-placeholder", "game.entities.buttons.button-more-games", "game.entities.pointer", "game.entities.buttons.button-start").defines(function() {
	LevelMainMenu = {
		entities: [{
			type: "EntityBrandingLogoPlaceholder",
			x: 296,
			y: 396,
			settings: {
				div_layer_name: "layer_mainmenu",
				centralize: "true"
			}
		}, {
			type: "EntityButtonMoreGames",
			x: 432,
			y: 284,
			settings: {
				div_layer_name: "layer_moregames_mainmenu"
			}
		}, {
			type: "EntityPointer",
			x: 608,
			y: 120
		}, {
			type: "EntityButtonStart",
			x: 284,
			y: 312
		}],
		layer: [{
			name: "background",
			width: 40,
			height: 30,
			linkWithCollision: !1,
			visible: 1,
			tilesetName: "media/graphics/backgrounds/desktop/background.jpg",
			repeat: !1,
			preRender: !0,
			distance: "1",
			tilesize: 16,
			foreground: !1,
			data: [
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40],
				[41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80],
				[81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
					96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120
				],
				[121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160],
				[161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200],
				[201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
					221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240
				],
				[241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280],
				[281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320],
				[321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344,
					345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360
				],
				[361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400],
				[401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440],
				[441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468,
					469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480
				],
				[481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520],
				[521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560],
				[561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592,
					593, 594, 595, 596, 597, 598, 599, 600
				],
				[601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640],
				[641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680],
				[681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716,
					717, 718, 719, 720
				],
				[721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760],
				[761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800],
				[801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840],
				[841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880],
				[881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920],
				[921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960],
				[961, 962, 963, 964,
					965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1E3
				],
				[1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040],
				[1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071,
					1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080
				],
				[1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120],
				[1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160],
				[1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170,
					1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200
				]
			]
		}]
	};
	LevelMainMenuResources = [new ig.Image("media/graphics/backgrounds/desktop/background.jpg")]
});
ig.baked = !0;
ig.module("game.entities.buttons.button-pause").requires("game.entities.buttons.button").defines(function() {
	EntityButtonPause = EntityButton.extend({
		size: {
			x: 50,
			y: 50
		},
		img: new ig.Image("media/graphics/sprites/btn-pause.png"),
		zIndex: 10001,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			"game" == ig.game.control.stateMachine && this.img.draw(this.pos.x - 8, this.pos.y - 6);
			this.parent()
		},
		clicked: function() {
			"game" == ig.game.control.stateMachine && ig.soundHandler.sfxPlayer.play("click");
			this.control.pauseGame();
			ig.game.showCursor()
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-fire").requires("game.entities.buttons.button").defines(function() {
	EntityButtonFire = EntityButton.extend({
		oriColor: "rgba(0,255,0,1)",
		altColor: "rgba(50,125,50,1)",
		fillColor: "rgba(50,0,0,1)",
		textColor: "rgba(255,255,255,1)",
		ignorePause: !0,
		size: {
			x: 86,
			y: 86
		},
		text: "Fire",
		gun: null,
		img: new ig.Image("media/graphics/sprites/btn-shoot.png"),
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.gun = e.gun
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			var c = ig.system.context;
			c.save();
			"game" == this.control.stateMachine && (c.globalAlpha = 0.8, this.img.draw(this.pos.x, this.pos.y));
			c.restore()
		},
		clicked: function() {
			this.fillColor = this.altColor;
			this.gun.shoot()
		},
		clicking: function() {},
		released: function() {
			this.fillColor = this.oriColor
		}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-settings").requires("game.entities.buttons.button").defines(function() {
	EntityButtonSettings = EntityButton.extend({
		size: {
			x: 201,
			y: 65
		},
		offset: {
			x: 0,
			y: 0
		},
		img: new ig.Image("media/graphics/sprites/btn-settings.png"),
		ignorePause: !0,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.pos.x = c - 0.5 * this.size.x
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			if (ig.game.assetsReady) {
				this.img.draw(this.pos.x, this.pos.y);
				var c = ig.system.context;
				c.save();
				var b = _STRINGS.Game.Settings;
				c.font = "36px twcen";
				c.textAlign = "center";
				c.fillStyle = "white";
				c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.6 * this.img.height);
				c.restore()
			}
		},
		clicked: function() {
			this.control.settingsGame();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-home").requires("game.entities.buttons.button").defines(function() {
	EntityButtonHome = EntityButton.extend({
		size: {
			x: 48,
			y: 52
		},
		img: new ig.Image("media/graphics/sprites/btn-home.png"),
		zIndex: 10011,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.fillColor = "rgba(110,180,0,1)"
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		draw: function() {
			this.img.draw(this.pos.x - 0.5 * this.img.width + 0.5 * this.size.x, this.pos.y - 0.5 * this.img.height + 0.5 *
				this.size.y);
			this.parent()
		},
		clicked: function() {
			this.popup.homeButtonClick();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-retry").requires("game.entities.buttons.button").defines(function() {
	EntityButtonRetry = EntityButton.extend({
		size: {
			x: 48,
			y: 52
		},
		img: new ig.Image("media/graphics/sprites/btn-retry.png"),
		zIndex: 10011,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		draw: function() {
			this.img.draw(this.pos.x - 0.5 * this.img.width + 0.5 * this.size.x, this.pos.y - 0.5 * this.img.height + 0.5 * this.size.y);
			this.parent()
		},
		clicked: function() {
			ig.gd.show(function() {
				this.popup.retryButtonClick();
				ig.soundHandler.sfxPlayer.play("click")
			}.bind(this))
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-next").requires("game.entities.buttons.button").defines(function() {
	EntityButtonNext = EntityButton.extend({
		offset: {
			x: 0,
			y: 0
		},
		size: {
			x: 48,
			y: 52
		},
		img: new ig.Image("media/graphics/sprites/btn-next.png"),
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		draw: function() {
			this.img.draw(this.pos.x - 0.5 * this.img.width + 0.5 * this.size.x, this.pos.y - 0.5 * this.img.height + 0.5 * this.size.y);
			this.parent()
		},
		clicked: function() {
			ig.gd.show(function() {
				this.popup.nextButtonClick();
				ig.soundHandler.sfxPlayer.play("click")
			}.bind(this))
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-resume").requires("game.entities.buttons.button").defines(function() {
	EntityButtonResume = EntityButton.extend({
		size: {
			x: 48,
			y: 52
		},
		img: new ig.Image("media/graphics/sprites/btn-resume.png"),
		zIndex: 10011,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		draw: function() {
			this.img.draw(this.pos.x - 0.5 * this.img.width + 0.5 * this.size.x, this.pos.y - 0.5 * this.img.height + 0.5 * this.size.y);
			this.parent()
		},
		clicked: function() {
			this.popup.callUp();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-oke").requires("game.entities.buttons.button").defines(function() {
	EntityButtonOke = EntityButton.extend({
		size: {
			x: 98,
			y: 52
		},
		img: new ig.Image("media/graphics/sprites/btn-ok.png"),
		zIndex: 10011,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		draw: function() {
			this.img.draw(this.pos.x - 0.5 * this.img.width + 0.5 * this.size.x, this.pos.y - 0.5 * this.img.height + 0.5 * this.size.y);
			var c = ig.system.context;
			c.save();
			var b = _STRINGS.Game.Ok;
			c.font = "20px twcen";
			c.textAlign = "center";
			c.fillStyle = "white";
			c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.6 * this.img.height);
			c.restore();
			this.parent()
		},
		clicked: function() {
			this.popup.okeButtonClick();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-n-popup").requires("game.entities.buttons.button").defines(function() {
	EntityButtonNPopup = EntityButton.extend({
		size: {
			x: 20,
			y: 30
		},
		offset: {
			x: 0,
			y: 0
		},
		img: new ig.Image("media/graphics/sprites/btn-next-level.png"),
		ignorePause: !0,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			this.img.draw(this.pos.x, this.pos.y)
		},
		clicked: function() {
			this.popup.increaseLevelSelection();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-p-popup").requires("game.entities.buttons.button").defines(function() {
	EntityButtonPPopup = EntityButton.extend({
		size: {
			x: 20,
			y: 30
		},
		offset: {
			x: 0,
			y: 0
		},
		img: new ig.Image("media/graphics/sprites/btn-prev-level.png"),
		ignorePause: !0,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			this.img.draw(this.pos.x, this.pos.y)
		},
		clicked: function() {
			this.popup.decreaseLevelSelection();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-slider").requires("game.entities.buttons.button").defines(function() {
	EntityButtonSlider = EntityButton.extend({
		size: {
			x: 14,
			y: 26
		},
		img: new ig.Image("media/graphics/sprites/handle_slider.png"),
		zIndex: 10011,
		ignorePause: !0,
		useFor: "",
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent();
			if (this.popup.sliderLock == this && ig.game.control.pointer.isReleased) this.popup.sliderLock = null, ig.game.saveStorage();
			else if (this.popup.sliderLock == this && ig.game.control.pointer.isPressed)
				if (this.pos.x =
					ig.game.control.pointer.pos.x, 620 < this.pos.x ? this.pos.x = 620 : 390 > this.pos.x && (this.pos.x = 390), "sfx" == this.useFor) {
					var c = (this.pos.x - 390) / 230;
					ig.soundHandler.sfxPlayer.volume(c);
					ig.game.gameSettings.sound = c
				} else "music" == this.useFor ? (c = (this.pos.x - 390) / 230, ig.soundHandler.bgmPlayer.volume(c), ig.game.gameSettings.music = c) : "sensitivity" == this.useFor && (c = 5E3 - 15 * (this.pos.x - 390), ig.game.gameSettings.sensitivity = c, ig.game.control.cameraControl.angularSensibility = c)
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y =
				b
		},
		draw: function() {
			this.img.draw(this.pos.x, this.pos.y);
			this.parent()
		},
		clicked: function() {
			null == this.popup.sliderLock && (this.popup.sliderLock = this, ig.soundHandler.sfxPlayer.play("click"))
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.popup").requires("impact.entity").defines(function() {
	EntityPopup = ig.Entity.extend({
		img: new ig.Image("media/graphics/sprites/popup.png"),
		imgSound: new ig.Image("media/graphics/sprites/sound.png"),
		imgMusic: new ig.Image("media/graphics/sprites/music.png"),
		imgSensi: new ig.Image("media/graphics/sprites/aim_sensitivity.png"),
		imgSlider: new ig.Image("media/graphics/sprites/slider.png"),
		imgStarActive: new ig.Image("media/graphics/sprites/star_activ_big.png"),
		imgStarInactive: new ig.Image("media/graphics/sprites/star_no_activ_big.png"),
		imgAccuracy: new ig.Image("media/graphics/sprites/ui-accuracy.png"),
		imgTime: new ig.Image("media/graphics/sprites/ui-time.png"),
		imgBest: new ig.Image("media/graphics/sprites/ui-best.png"),
		homeBtn: null,
		retryBtn: null,
		nextBtn: null,
		resumeBtn: null,
		sliderMusic: null,
		sliderSfx: null,
		sliderSentifity: null,
		ignorePause: !0,
		statePopup: "game",
		zIndex: 10010,
		sliderFolow: !0,
		sliderLock: null,
		winningStars: 0,
		timeUsed: 0,
		bestTime: 0,
		isTweening: !1,
		starScale: {
			left: 0,
			middle: 0,
			right: 0
		},
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.pos.x =
				c - 0.5 * this.img.width;
			this.homeBtn = ig.game.spawnEntity(EntityButtonHome, this.pos.x, this.pos.y, {
				popup: this
			});
			this.retryBtn = ig.game.spawnEntity(EntityButtonRetry, this.pos.x, this.pos.y, {
				popup: this
			});
			this.nextBtn = ig.game.spawnEntity(EntityButtonNext, this.pos.x, this.pos.y, {
				popup: this
			});
			this.resumeBtn = ig.game.spawnEntity(EntityButtonResume, this.pos.x, this.pos.y, {
				popup: this
			});
			this.okeBtn = ig.game.spawnEntity(EntityButtonOke, this.pos.x, this.pos.y, {
				popup: this
			});
			this.sliderMusic = ig.game.spawnEntity(EntityButtonSlider,
				this.pos.x + 0.5 * this.img.width + 40, this.pos.y, {
					popup: this,
					useFor: "music"
				});
			this.sliderSfx = ig.game.spawnEntity(EntityButtonSlider, this.pos.x + 0.5 * this.img.width + 40, this.pos.y, {
				popup: this,
				useFor: "sfx"
			});
			this.sliderSentifity = ig.game.spawnEntity(EntityButtonSlider, this.pos.x + 0.5 * this.img.width + 40, this.pos.y, {
				popup: this,
				useFor: "sensitivity"
			})
		},
		update: function() {
			this.parent();
			"pause" == this.control.stateMachine ? (this.resumeBtn.pos.x = this.pos.x + 0.6 * this.img.width, this.resumeBtn.pos.y = this.pos.y + 0.8 * this.img.height,
				this.retryBtn.pos.x = this.pos.x + 0.475 * this.img.width, this.retryBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.homeBtn.pos.x = this.pos.x + 0.35 * this.img.width, this.homeBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.sliderFolow && (this.sliderSfx.pos.y = this.pos.y + 0.29 * this.img.height, this.sliderMusic.pos.y = this.pos.y + 0.46 * this.img.height, this.sliderSentifity.pos.y = this.pos.y + 0.64 * this.img.height)) : "settings" == this.control.stateMachine ? (this.okeBtn.pos.x = this.pos.x + 0.42 * this.img.width, this.okeBtn.pos.y = this.pos.y +
				0.8 * this.img.height, this.sliderFolow && (this.sliderSfx.pos.y = this.pos.y + 0.29 * this.img.height, this.sliderMusic.pos.y = this.pos.y + 0.46 * this.img.height, this.sliderSentifity.pos.y = this.pos.y + 0.64 * this.img.height)) : "win" == this.control.stateMachine ? (this.nextBtn.pos.x = this.pos.x + 0.6 * this.img.width, this.nextBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.retryBtn.pos.x = this.pos.x + 0.475 * this.img.width, this.retryBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.homeBtn.pos.x = this.pos.x + 0.35 * this.img.width, this.homeBtn.pos.y =
				this.pos.y + 0.8 * this.img.height, 19 == this.control.level && (this.retryBtn.pos.x = this.pos.x + 0.5 * this.img.width + 20, this.retryBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.homeBtn.pos.x = this.pos.x + 0.5 * this.img.width - this.homeBtn.size.x - 20, this.homeBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.nextBtn.pos.y = this.pos.y - 500)) : "lose" == this.control.stateMachine && (this.retryBtn.pos.x = this.pos.x + 0.5 * this.img.width + 20, this.retryBtn.pos.y = this.pos.y + 0.8 * this.img.height, this.homeBtn.pos.x = this.pos.x + 0.5 * this.img.width -
				this.homeBtn.size.x - 20, this.homeBtn.pos.y = this.pos.y + 0.8 * this.img.height)
		},
		callUp: function() {
			this.tween({
				pos: {
					x: 0.5 * ig.system.width - 0.5 * this.img.width,
					y: -500
				}
			}, 0.3, {
				onComplete: function() {
					this.control.resumeGame();
					this.control.popupDown = !1;
					ig.game.showCursor()
				}.bind(this)
			}).start()
		},
		callDown: function(c) {
			if (!this.control.popupDown) {
				if ("pause" == c) c = this.tween({
					pos: {
						x: 0.5 * ig.system.width - 0.5 * this.img.width,
						y: 0.5 * ig.system.height - 0.5 * this.img.height
					}
				}, 0.3, {
					onComplete: function() {
						this.control.stateMachine =
							"pause";
						ig.game.showCursor()
					}.bind(this)
				}), c.start(), this.statePopup = "pause", this.sliderMusic.pos.x = 230 * ig.game.gameSettings.music + 390, this.sliderSfx.pos.x = 230 * ig.game.gameSettings.sound + 390, this.sliderSentifity.pos.x = (5E3 - ig.game.gameSettings.sensitivity) / 15 + 390;
				else if ("win" == c) {
					this.statePopup = "win";
					c = this.control.level; - 1 == ig.game.gameSettings.level[c + 1] && (ig.game.gameSettings.level[c + 1] = 0);
					this.winningStars = this.control.starCount();
					ig.game.gameSettings.level[c] < this.winningStars && (ig.game.gameSettings.level[c] =
						this.winningStars);
					this.timeUsed = Math.floor(this.control.timeLevel[c] + this.control.uiBoard.gameTimer.delta());
					if (-1 == ig.game.gameSettings.best[c] || ig.game.gameSettings.best[c] > this.timeUsed) ig.game.gameSettings.best[c] = this.timeUsed;
					this.bestTime = ig.game.gameSettings.best[c];
					c = this.tween({
						pos: {
							x: 0.5 * ig.system.width - 0.5 * this.img.width,
							y: 0.5 * ig.system.height - 0.5 * this.img.height
						}
					}, 0.4, {
						onComplete: function() {
							this.control.stateMachine = "win";
							ig.game.showCursor();
							this.starTween(this.winningStars)
						}.bind(this)
					});
					c.start();
					ig.game.saveStorage()
				} else "settings" == c ? (c = this.tween({
					pos: {
						x: 0.5 * ig.system.width - 0.5 * this.img.width,
						y: 0.5 * ig.system.height - 0.5 * this.img.height
					}
				}, 0.4, {
					onComplete: function() {
						ig.game.showCursor()
					}.bind(this)
				}), c.start(), this.statePopup = "settings", this.sliderMusic.pos.x = 230 * ig.game.gameSettings.music + 390, this.sliderSfx.pos.x = 230 * ig.game.gameSettings.sound + 390, this.sliderSentifity.pos.x = (5E3 - ig.game.gameSettings.sensitivity) / 15 + 390) : "lose" == c && (c = this.tween({
					pos: {
						x: 0.5 * ig.system.width - 0.5 * this.img.width,
						y: 0.5 * ig.system.height - 0.5 * this.img.height
					}
				}, 0.2, {
					onComplete: function() {
						this.control.stateMachine = "lose";
						ig.game.showCursor()
					}.bind(this)
				}), c.start(), this.statePopup = "lose", c = this.control.level, this.bestTime = ig.game.gameSettings.best[c]);
				this.control.popupDown = !0
			}
		},
		playSoundStar: function() {
			0 == this.control.testSoundStar && ig.soundHandler.sfxPlayer.play("starOne")
		},
		starTween: function(c) {
			this.isTweening = !0;
			if (1 == c) this.tween({
					starScale: {
						left: 1
					}
				}, 0.3, {
					onComplete: function() {
						this.isTweening = !1
					}.bind(this)
				}).start(),
				this.playSoundStar();
			else if (2 == c) {
				c = this.tween({
					starScale: {
						left: 1
					}
				}, 0.3, {
					onComplete: function() {
						this.playSoundStar()
					}.bind(this)
				});
				var b = this.tween({
					starScale: {
						middle: 1
					}
				}, 0.3, {
					onComplete: function() {
						this.isTweening = !1
					}.bind(this)
				});
				c.chain(b);
				c.start();
				this.playSoundStar()
			} else if (3 == c) {
				c = this.tween({
					starScale: {
						left: 1
					}
				}, 0.3, {
					onComplete: function() {
						this.playSoundStar()
					}.bind(this)
				});
				var b = this.tween({
						starScale: {
							middle: 1
						}
					}, 0.3, {
						onComplete: function() {
							this.playSoundStar()
						}.bind(this)
					}),
					e = this.tween({
							starScale: {
								right: 1
							}
						},
						0.3, {
							onComplete: function() {
								this.isTweening = !1
							}.bind(this)
						});
				c.chain(b);
				b.chain(e);
				c.start();
				this.playSoundStar()
			}
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b;
			this.homeBtn.pos = this.pos;
			this.nextBtn.pos = this.pos;
			this.retryBtn.pos = this.pos;
			this.resumeBtn.pos = this.pos
		},
		nextButtonClick: function() {
			this.isTweening || (this.control.level++, this.changePos(this.pos.x, -500), this.control.transitionMenu(), this.control.popupDown = !1, this.starScale = {
					left: 0,
					middle: 0,
					right: 0
				}, this.control.bulletUsed = 0, this.control.bulletHit =
				0, ig.game.control.waitWinning = !1)
		},
		retryButtonClick: function() {
			this.control.fade.fadeRetry();
			this.changePos(this.pos.x, -500)
		},
		okeButtonClick: function() {
			this.isTweening || (this.isTweening = !0, this.tween({
				pos: {
					y: -500
				}
			}, 0.7, {
				easing: ig.Tween.Easing.Elastic.EaseInOut,
				onComplete: function() {
					this.control.stateMachine = "mainmenu";
					this.control.popupDown = !1;
					this.control.settingsClose();
					this.isTweening = !1
				}.bind(this)
			}).start())
		},
		homeButtonClick: function() {
			this.isTweening || (this.control.stateMachine = "mainmenu", this.changePos(this.pos.x, -500), this.sliderSfx.pos.y = this.pos.y + 0.29 * this.img.height, this.sliderMusic.pos.y = this.pos.y + 0.46 * this.img.height, this.sliderSentifity.pos.y = this.pos.y + 0.64 * this.img.height, this.control.playButton.pos.y = 0.5 * ig.system.height, this.control.settingsButton.pos.y = 0.64 * ig.system.height, _SETTINGS.MoreGames.Enabled && this.control.moreButton.show(), this.control.popupDown = !1, this.control.fade.fadeHome(), this.starScale = {
				left: 0,
				middle: 0,
				right: 0
			}, ig.game.control.waitWinning = !1)
		},
		resumeButtonClick: function() {
			this.isTweening ||
				(this.control.resumeGame(), this.changePos(this.pos.x, -500), this.control.popupDown = !1, this.sliderSfx.pos.y = this.pos.y + 0.29 * this.img.height, this.sliderMusic.pos.y = this.pos.y + 0.46 * this.img.height, this.sliderSentifity.pos.y = this.pos.y + 0.64 * this.img.height)
		},
		draw: function() {
			this.parent();
			var c = ig.system.context;
			c.save();
			this.img.draw(this.pos.x, this.pos.y);
			if ("settings" == this.statePopup || "pause" == this.statePopup) {
				this.imgSound.draw(this.pos.x + 0.19 * this.img.width, this.pos.y + 0.25 * this.img.height);
				this.imgSlider.draw(this.pos.x +
					0.35 * this.img.width, this.pos.y + 0.31 * this.img.height);
				this.imgMusic.draw(this.pos.x + 0.19 * this.img.width, this.pos.y + 0.42 * this.img.height);
				this.imgSlider.draw(this.pos.x + 0.35 * this.img.width, this.pos.y + 0.48 * this.img.height);
				this.imgSensi.draw(this.pos.x + 0.19 * this.img.width, this.pos.y + 0.6 * this.img.height);
				this.imgSlider.draw(this.pos.x + 0.35 * this.img.width, this.pos.y + 0.66 * this.img.height);
				var b = "pause" == this.statePopup ? _STRINGS.Game.Pause : _STRINGS.Game.Settings;
				c.font = "36px twcen";
				c.textAlign = "center";
				c.fillStyle = "white";
				c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.115 * this.img.height)
			} else if ("win" == this.statePopup) {
				b = _STRINGS.Game.Win;
				c.font = "36px twcen";
				c.textAlign = "center";
				c.fillStyle = "white";
				c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.115 * this.img.height);
				3 == this.winningStars ? (this.imgStarInactive.draw(this.pos.x + 0.27 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x + 0.42 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x +
					0.57 * this.img.width, this.pos.y + 0.25 * this.img.height), this.drawStarActiveScale(this.pos.x + 0.35 * this.img.width, this.pos.y + 0.37 * this.img.height, this.starScale.left), this.drawStarActiveScale(this.pos.x + 0.5 * this.img.width, this.pos.y + 0.37 * this.img.height, this.starScale.middle), this.drawStarActiveScale(this.pos.x + 0.65 * this.img.width, this.pos.y + 0.37 * this.img.height, this.starScale.right)) : 2 == this.winningStars ? (this.imgStarInactive.draw(this.pos.x + 0.27 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x +
					0.42 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x + 0.57 * this.img.width, this.pos.y + 0.25 * this.img.height), this.drawStarActiveScale(this.pos.x + 0.35 * this.img.width, this.pos.y + 0.37 * this.img.height, this.starScale.left), this.drawStarActiveScale(this.pos.x + 0.5 * this.img.width, this.pos.y + 0.37 * this.img.height, this.starScale.middle)) : 1 == this.winningStars && (this.imgStarActive.draw(this.pos.x + 0.27 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x +
					0.42 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x + 0.57 * this.img.width, this.pos.y + 0.25 * this.img.height), this.drawStarActiveScale(this.pos.x + 0.35 * this.img.width, this.pos.y + 0.37 * this.img.height, this.starScale.left));
				var b = Math.floor(100 * (this.control.bulletHit / this.control.bulletUsed)),
					b = _STRINGS.Game.Accuracy + b + "%",
					e = _STRINGS.Game.Time + this.timeUsed,
					d = _STRINGS.Game.Best + this.bestTime;
				c.font = "20px twcen";
				c.textAlign = "left";
				c.fillStyle = "white";
				c.fillText(b, this.pos.x +
					0.4 * this.img.width, this.pos.y + 0.55 * this.img.height);
				c.fillText(e, this.pos.x + 0.4 * this.img.width, this.pos.y + 0.64 * this.img.height);
				c.fillText(d, this.pos.x + 0.4 * this.img.width, this.pos.y + 0.73 * this.img.height);
				this.imgAccuracy.draw(this.pos.x + 0.32 * this.img.width, this.pos.y + 0.495 * this.img.height);
				this.imgTime.draw(this.pos.x + 0.32 * this.img.width, this.pos.y + 0.58 * this.img.height);
				this.imgBest.draw(this.pos.x + 0.315 * this.img.width, this.pos.y + 0.67 * this.img.height)
			} else "lose" == this.statePopup && (b = _STRINGS.Game.Timeout,
				c.font = "36px twcen", c.textAlign = "center", c.fillStyle = "white", c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.115 * this.img.height), this.imgStarInactive.draw(this.pos.x + 0.27 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x + 0.42 * this.img.width, this.pos.y + 0.25 * this.img.height), this.imgStarInactive.draw(this.pos.x + 0.57 * this.img.width, this.pos.y + 0.25 * this.img.height), b = Math.floor(100 * (this.control.bulletHit / this.control.bulletUsed)), isNaN(b) && (b = 0), b = _STRINGS.Game.Accuracy +
				b + "%", d = _STRINGS.Game.Best + this.bestTime, 0 >= this.bestTime && (d = _STRINGS.Game.Best + " - "), c.font = "20px twcen", c.textAlign = "left", c.fillStyle = "white", c.fillText(b, this.pos.x + 0.4 * this.img.width, this.pos.y + 0.6 * this.img.height), c.fillText(d, this.pos.x + 0.4 * this.img.width, this.pos.y + 0.7 * this.img.height), this.imgAccuracy.draw(this.pos.x + 0.32 * this.img.width, this.pos.y + 0.545 * this.img.height), this.imgBest.draw(this.pos.x + 0.315 * this.img.width, this.pos.y + 0.64 * this.img.height));
			c.restore()
		},
		drawStarActiveScale: function(c,
			b, e) {
			var d = ig.system.context;
			d.save();
			b -= 0.5 * this.imgStarActive.height * e;
			d.translate(ig.system.getDrawPos(c - 0.5 * this.imgStarActive.width * e - ig.game.screen.x), ig.system.getDrawPos(b - ig.game.screen.y));
			d.scale(e, e);
			d.drawImage(this.imgStarActive.data, 0, 0, this.imgStarActive.width, this.imgStarActive.height, 0, 0, this.imgStarActive.width, this.imgStarActive.height);
			d.restore()
		}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-level").requires("game.entities.buttons.button").defines(function() {
	EntityButtonLevel = EntityButton.extend({
		size: {
			x: 48,
			y: 52
		},
		levelText: "",
		levelChoose: 0,
		isLocked: !1,
		lockImg: new ig.Image("media/graphics/sprites/locked.png"),
		img: new ig.Image("media/graphics/sprites/btn-small-polos.png"),
		starsImg: new ig.Image("media/graphics/sprites/start-active-small.png"),
		starsInactiveImg: new ig.Image("media/graphics/sprites/start-inactive-small.png"),
		starsBackImg: new ig.Image("media/graphics/sprites/star-back.png"),
		stars: 0,
		alpha: 1,
		ignorePause: !0,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		refreshLevel: function() {
			this.levelChoose += 10;
			19 < this.levelChoose && (this.levelChoose -= 20);
			this.levelText = "" + (this.levelChoose + 1);
			this.stars = ig.game.gameSettings.level[this.levelChoose];
			this.isLocked = 0 > this.stars ? !0 : !1
		},
		tweenAlpha: function() {
			var c = this.tween({
					alpha: 0
				}, 0.5, {
					easing: ig.Tween.Easing.Linear.EaseNone,
					onComplete: function() {
						this.refreshLevel()
					}.bind(this)
				}),
				b = this.tween({
					alpha: 1
				}, 0.5, {
					easing: ig.Tween.Easing.Linear.EaseNone,
					onComplete: function() {
						this.popup.isTweening && (this.popup.isTweening = !1)
					}.bind(this)
				});
			c.chain(b);
			c.start()
		},
		draw: function() {
			var c = ig.system.context;
			c.save();
			c.globalAlpha = this.alpha;
			this.isLocked ? (this.img.draw(this.pos.x, this.pos.y), this.lockImg.draw(this.pos.x - 0.5 * this.lockImg.width + 0.5 * this.size.x, this.pos.y - 0.5 * this.lockImg.height + 0.5 * this.size.y)) : (this.img.draw(this.pos.x, this.pos.y), c.font = "22px twcen", c.textAlign = "center",
				c.fillStyle = "white", c.fillText(this.levelText, this.pos.x + 0.5 * this.size.x, this.pos.y + 0.44 * this.size.y), 3 == this.stars ? (this.starsImg.draw(this.pos.x + 5, this.pos.y + 29), this.starsImg.draw(this.pos.x + 5 + this.starsImg.width, this.pos.y + 29), this.starsImg.draw(this.pos.x + 5 + 2 * this.starsImg.width, this.pos.y + 29)) : 2 == this.stars ? (this.starsImg.draw(this.pos.x + 5, this.pos.y + 29), this.starsImg.draw(this.pos.x + 5 + this.starsImg.width, this.pos.y + 29), this.starsInactiveImg.draw(this.pos.x + 5 + 2 * this.starsImg.width, this.pos.y +
					29)) : 1 == this.stars ? (this.starsImg.draw(this.pos.x + 5, this.pos.y + 29), this.starsInactiveImg.draw(this.pos.x + 5 + 2 * this.starsImg.width, this.pos.y + 29), this.starsInactiveImg.draw(this.pos.x + 5 + this.starsImg.width, this.pos.y + 29)) : 0 == this.stars && (this.starsInactiveImg.draw(this.pos.x + 5, this.pos.y + 29), this.starsInactiveImg.draw(this.pos.x + 5 + 2 * this.starsImg.width, this.pos.y + 29), this.starsInactiveImg.draw(this.pos.x + 5 + this.starsImg.width, this.pos.y + 29)));
			c.restore();
			this.parent()
		},
		clicked: function() {
			this.isLocked ||
				(this.popup.buttonLevel(this.levelChoose), ig.soundHandler.sfxPlayer.play("click"))
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.buttons.button-close").requires("game.entities.buttons.button").defines(function() {
	EntityButtonClose = EntityButton.extend({
		oriColor: "rgba(255,255,0,1)",
		altColor: "rgba(255,255,0,1)",
		fillColor: "rgba(255,0,0,1)",
		textColor: "rgba(255,255,255,1)",
		size: {
			x: 45,
			y: 45
		},
		offset: {
			x: 16,
			y: 8
		},
		img: new ig.Image("media/graphics/sprites/close.png"),
		zIndex: 10011,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		draw: function() {
			this.img.draw(this.pos.x -
				this.offset.x, this.pos.y - this.offset.y);
			this.parent()
		},
		clicked: function() {
			this.popup.callUp();
			ig.soundHandler.sfxPlayer.play("click")
		},
		clicking: function() {},
		released: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.popup-level").requires("impact.entity", "game.entities.buttons.button-level", "game.entities.buttons.button-close").defines(function() {
	EntityPopupLevel = ig.Entity.extend({
		img: new ig.Image("media/graphics/sprites/popup.png"),
		zIndex: 10010,
		levelBtn: [],
		ignorePause: !0,
		isTweening: !1,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.pos.x = c - 0.5 * this.img.width;
			this.nextPopupBtn = ig.game.spawnEntity(EntityButtonNPopup, this.pos.x, this.pos.y, {
				popup: this
			});
			this.prevPopupBtn = ig.game.spawnEntity(EntityButtonPPopup,
				this.pos.x, this.pos.y, {
					popup: this
				});
			for (b = c = 0; 2 > b; b++)
				for (e = 0; 5 > e; e++) {
					var d = ig.game.spawnEntity(EntityButtonLevel, this.pos.x + 50 * e, this.pos.y + 15 + 60 * b, {
						popup: this
					});
					d.levelText = "" + (c + 1);
					d.levelChoose = c;
					d.stars = ig.game.gameSettings.level[c];
					c++; - 1 == ig.game.gameSettings.level[c - 1] && (d.isLocked = !0);
					this.levelBtn.push(d)
				}
			this.closeBtn = ig.game.spawnEntity(EntityButtonClose, this.pos.x + this.img.width - 50, this.pos.y, {
				popup: this
			})
		},
		update: function() {
			this.parent();
			for (var c = 0, b = 0; 2 > b; b++)
				for (var e = 0; 5 > e; e++) {
					var d =
						this.levelBtn[c];
					d.pos.x = this.pos.x + 132 + 65 * e;
					d.pos.y = this.pos.y + 140 + 70 * b;
					c++
				}
			this.closeBtn.pos.x = this.pos.x + this.img.width - 50;
			this.closeBtn.pos.y = this.pos.y;
			this.nextPopupBtn.pos.x = this.pos.x + 0.8 * this.img.width;
			this.nextPopupBtn.pos.y = this.pos.y + 0.45 * this.img.height;
			this.prevPopupBtn.pos.x = this.pos.x + 0.17 * this.img.width;
			this.prevPopupBtn.pos.y = this.pos.y + 0.45 * this.img.height
		},
		callDown: function() {
			this.tween({
				pos: {
					y: 0.5 * ig.system.height - 0.5 * this.img.height
				}
			}, 0.7, {
				easing: ig.Tween.Easing.Elastic.EaseInOut
			}).start();
			for (var c = 0; c < this.levelBtn.length; c++)
				if (0 <= ig.game.gameSettings.level[c]) {
					var b = this.levelBtn[c];
					b.levelText = "" + (c + 1);
					b.levelChoose = c;
					b.isLocked = !1;
					b.stars = ig.game.gameSettings.level[c]
				}
		},
		callUp: function() {
			this.isTweening || (this.isTweening = !0, this.tween({
				pos: {
					y: -500
				}
			}, 0.7, {
				easing: ig.Tween.Easing.Elastic.EaseInOut,
				onComplete: function() {
					this.control.playButton.pos.y = 0.5 * ig.system.height;
					this.control.settingsButton.pos.y = 0.64 * ig.system.height;
					this.control.moreButton.show();
					this.isTweening = this.control.popupDown = !1
				}.bind(this)
			}).start())
		},
		changePos: function(c, b) {
			this.pos.x = c;
			this.pos.y = b
		},
		increaseLevelSelection: function() {
			if (!this.isTweening) {
				this.isTweening = !0;
				for (var c = 0; c < this.levelBtn.length; c++) this.levelBtn[c].tweenAlpha()
			}
		},
		decreaseLevelSelection: function() {
			if (!this.isTweening) {
				this.isTweening = !0;
				for (var c = 0; c < this.levelBtn.length; c++) this.levelBtn[c].tweenAlpha()
			}
		},
		buttonLevel: function(c) {
			this.control.level = c;
			this.control.killAllBottles();
			this.control.popupDown = !1;
			this.changePos(this.pos.x, -500);
			0 == c ? this.control.startTutorial() : this.control.tutorial.endTutorial();
			this.control.transitionMenu();
			this.control.bulletUsed = 0;
			this.control.bulletHit = 0
		},
		draw: function() {
			this.parent();
			this.img.draw(this.pos.x, this.pos.y);
			var c = ig.system.context;
			c.save();
			var b = _STRINGS.Game.LevelSelect;
			c.font = "36px twcen";
			c.textAlign = "center";
			c.fillStyle = "white";
			c.fillText(b, this.pos.x + 0.5 * this.img.width, this.pos.y + 0.115 * this.img.height);
			c.restore()
		}
	})
});
ig.baked = !0;
ig.module("game.entities.fadescreen").requires("impact.entity").defines(function() {
	EntityFadescreen = ig.Entity.extend({
		collides: ig.Entity.COLLIDES.NEVER,
		size: new BABYLON.Vector2(10, 10),
		zIndex: 10005,
		pos: {
			x: 0,
			y: 0
		},
		alpha: 0,
		colorFade: "#ffffff",
		WHITEColor: "#ffffff",
		BLACKColor: "#000000",
		control: null,
		ignorePause: !0,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		fadeStart: function() {
			var c = this.tween({
					alpha: 1
				}, 0.3, {
					onComplete: function() {
						wgl.system.startRender();
						this.control.spawnMeshByLevel();
						this.control.stateMachine = "game";
						ig.game.breakGlassParticle.changePos(0, -10, 0)
					}.bind(this)
				}),
				b = this.tween({
					alpha: 0
				}, 0.3, {
					onComplete: function() {
						this.control.resumeGame();
						99 == this.control.tutorial.tutorialStep && (this.control.uiBoard.showRedBar = !0)
					}.bind(this)
				});
			c.chain(b);
			c.start()
		},
		fadeHome: function() {
			this.alpha = 0.8;
			var c = this.tween({
					alpha: 1
				}, 0.3, {
					onComplete: function() {
						ig.game.control.objectReset();
						wgl.system.startRender()
					}.bind(this)
				}),
				b = this.tween({
					alpha: 0
				}, 0.3, {
					onComplete: function() {
						wgl.system.stopRender();
						this.control.uiBoard.showRedBar = !1
					}.bind(this)
				});
			c.chain(b);
			c.start();
			ig.system.context.fillRect(0, 0, ig.system.width, ig.system.height)
		},
		fadeRetry: function() {
			this.alpha = 0.8;
			var c = this.tween({
					alpha: 1
				}, 0.3, {
					onComplete: function() {
						wgl.system.startRender();
						ig.game.control.killAllBottles();
						ig.game.control.spawnMeshByLevel();
						ig.game.breakGlassParticle.changePos(0, -10, 0);
						this.control.stateMachine = "game";
						ig.game.control.bulletUsed = 0;
						ig.game.control.bulletHit = 0;
						ig.game.starScale = {
							left: 0,
							middle: 0,
							right: 0
						};
						ig.game.control.waitWinning = !1
					}.bind(this)
				}),
				b = this.tween({
					alpha: 0
				}, 0.3, {
					onComplete: function() {
						ig.game.control.resumeGame();
						ig.game.control.popupDown = !1;
						ig.game.control.tutorial.endTutorial();
						0 == ig.game.control.level ? ig.game.control.startTutorial() : ig.game.control.tutorial.endTutorial()
					}.bind(this)
				});
			c.chain(b);
			c.start();
			ig.system.context.fillRect(0, 0, ig.system.width, ig.system.height)
		},
		draw: function() {
			this.parent();
			var c = ig.system.context;
			c.save();
			c.globalAlpha = this.alpha;
			c.fillStyle = this.colorAlpha;
			c.fillRect(0, 0, ig.system.width,
				ig.system.height);
			c.restore()
		}
	})
});
ig.baked = !0;
ig.module("game.entities.tutorial").requires("impact.entity").defines(function() {
	EntityTutorial = ig.Entity.extend({
		tutorialStep: 0,
		zIndex: 10001,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.control = e.control;
			ig.ua.mobile ? (this.tutorialControl = ig.game.spawnEntity(EntityPointerHandTutorial, 0, 0, {
				parentControl: this
			}), this.tutorialControl.hideHand()) : (this.tutorialControl = ig.game.spawnEntity(EntityPointerMouseTutorial, 0, 0, {
				parentControl: this
			}), this.tutorialControl.hideMouse())
		},
		ready: function() {
			this.uiBoard =
				this.control.uiBoard
		},
		startTutorial: function() {
			this.tutorialStep = 0;
			this.uiBoard.resetTimerClick();
			this.uiBoard.pauseTimerClick();
			this.uiBoard.showRedBar = !1;
			this.tutorialControl.tutorialTweenOne()
		},
		endTutorial: function() {
			this.tutorialStep = 99;
			ig.ua.mobile ? (this.tutorialControl.tweens && this.tutorialControl.stopTweens(!1), this.tutorialControl.hideHand()) : (this.tutorialControl.tweens && this.tutorialControl.stopTweens(!1), this.tutorialControl.hideMouse());
			this.uiBoard.resumeTime()
		},
		update: function() {
			this.parent();
			0 == this.tutorialStep && (this.control.gun && this.control.gun.checkBottles()) && (this.tutorialStep = 1, this.tutorialControl.stopTweens(!0), this.tutorialControl.tutorialTweenTwo(), this.uiBoard.showRedBar = !0, this.uiBoard.timerClick.reset())
		},
		textWraper: function(c, b, e, d) {
			b = b.split(" ");
			var f = "";
			c.font = "28px twcen";
			c.textAlign = "center";
			c.fillStyle = "#FFF";
			c.lineWidth = 4;
			for (var g = 0; g < b.length; g++) {
				var q = f + b[g] + " ";
				700 < c.measureText(q).width && 0 < g ? (c.strokeText(f, e, d), c.fillText(f, e, d), f = b[g] + " ", d += 20) : f = q
			}
			c.strokeText(f,
				e, d);
			c.fillText(f, e, d)
		},
		draw: function() {
			this.parent();
			if ("game" == this.control.stateMachine) {
				var c = ig.system.context;
				c.save();
				c.font = "28px twcen";
				c.strokeStyle = "#ff8830";
				c.lineWidth = 5;
				c.fillStyle = "white";
				if (ig.ua.mobile)
					if (0 == this.tutorialStep) {
						var b = _STRINGS.Game.TutorialM1;
						c.strokeStyle = "#ff8830";
						c.textAlign = "center";
						c.strokeText(b, 0.5 * ig.system.width, 120);
						c.fillText(b, 0.5 * ig.system.width, 120)
					} else 1 == this.tutorialStep && (b = _STRINGS.Game.TutorialM2, c.strokeStyle = "#ff8830", c.textAlign = "center", c.strokeText(b,
						0.5 * ig.system.width, 120), c.fillText(b, 0.5 * ig.system.width, 120));
				else 0 == this.tutorialStep ? (b = _STRINGS.Game.TutorialD1, c.strokeStyle = "#ff8830", this.textWraper(c, b, 0.5 * ig.system.width, 120)) : 1 == this.tutorialStep && (b = _STRINGS.Game.TutorialD2, c.strokeStyle = "#ff8830", this.textWraper(c, b, 0.5 * ig.system.width, 120));
				c.restore()
			}
		}
	});
	EntityPointerMouseTutorial = ig.Entity.extend({
		imgMouseClick: new ig.Image("media/graphics/sprites/mouse-click.png"),
		imgMouseIdle: new ig.Image("media/graphics/sprites/mouse-idle.png"),
		pointerClick: {
			x: 62,
			y: 0,
			w: 62,
			h: 62
		},
		pointerRelease: {
			x: 0,
			y: 0,
			w: 62,
			h: 62
		},
		offsetClick: {
			x: 51,
			y: 47
		},
		offsetIdle: {
			x: 29,
			y: 20
		},
		isClicking: !1,
		zIndex: 10001,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		update: function() {
			this.parent()
		},
		tutorialTweenOne: function() {
			this.isClicking = !1;
			this.pos = {
				x: 120,
				y: 400
			};
			var c = this.tween({}, 0.4),
				b = this.tween({}, 0.4, {
					onComplete: function() {
						this.isClicking = !0
					}.bind(this)
				}),
				e = this.tween({}, 0.4),
				d = this.tween({
					pos: {
						x: 800,
						y: 400
					}
				}, 0.7, {
					onComplete: function() {
						1 == this.parentControl.tutorialStep ?
							this.hideMouse() : this.tutorialTweenOne()
					}.bind(this)
				});
			c.chain(b);
			b.chain(e);
			e.chain(d);
			c.start()
		},
		hideMouse: function() {
			this.pos = {
				x: -200,
				y: 0
			}
		},
		tutorialTweenTwo: function() {
			this.isClicking = !0;
			this.pos.x = 0.5 * ig.system.width;
			this.pos.y = 400;
			var c = this.tween({}, 0.4, {
					onComplete: function() {
						this.isClicking = !1
					}.bind(this)
				}),
				b = this.tween({}, 0.4, {
					onComplete: function() {
						1 == this.parentControl.tutorialStep && this.tutorialTweenTwo()
					}.bind(this)
				});
			c.chain(b);
			c.start()
		},
		draw: function() {
			this.parent();
			this.isClicking ?
				this.imgMouseClick.draw(this.pos.x - this.offsetClick.x, this.pos.y - this.offsetClick.y) : this.imgMouseIdle.draw(this.pos.x - this.offsetIdle.x, this.pos.y - this.offsetIdle.y)
		}
	});
	EntityPointerHandTutorial = ig.Entity.extend({
		imgPointerGame: new ig.Image("media/graphics/sprites/touch-idle.png"),
		pointer: {
			x: 0,
			y: 62,
			w: 62,
			h: 62
		},
		zIndex: 10001,
		init: function(c, b, e) {
			this.parent(c, b, e)
		},
		tutorialTweenOne: function() {
			this.pos = {
				x: 200,
				y: 300
			};
			var c = this.tween({}, 0.4),
				b = this.tween({
					pos: {
						x: 800,
						y: 300
					}
				}, 0.7),
				e = this.tween({}, 0.4, {
					onComplete: function() {
						1 ==
							this.parentControl.tutorialStep ? this.hideHand() : this.tutorialTweenOne()
					}.bind(this)
				});
			c.chain(b);
			b.chain(e);
			c.start()
		},
		hideHand: function() {
			this.pos.x = -200
		},
		tutorialTweenTwo: function() {
			this.hideHand()
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			this.imgPointerGame.draw(this.pos.x, this.pos.y)
		}
	})
});
ig.baked = !0;
ig.module("game.entities.ui-board").requires("impact.entity").defines(function() {
	EntityUiBoard = ig.Entity.extend({
		collides: ig.Entity.COLLIDES.NEVER,
		size: new BABYLON.Vector2(10, 10),
		zIndex: 10001,
		pos: {
			x: 0,
			y: 0
		},
		gameTimer: null,
		timerClick: null,
		showRedBar: !1,
		imgBar: new ig.Image("media/graphics/sprites/ui-bar.png"),
		imgBottle: new ig.Image("media/graphics/sprites/ui-bottle.png"),
		imgBullets: new ig.Image("media/graphics/sprites/ui-bullet.png"),
		imgTimes: new ig.Image("media/graphics/sprites/ui-clock.png"),
		imgHoldBG: new ig.Image("media/graphics/sprites/reload-bar-bg.png"),
		imgHoldBar: new ig.Image("media/graphics/sprites/reload-bar-white.png"),
		maxHold: 0.3,
		cooldown: 0.1,
		clickReset: !1,
		name: "ui board",
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.gameTimer = new ig.Timer;
			this.timerClick = new ig.Timer;
			this.timerCooldown = new ig.Timer;
			e.timeGame && this.setTime(e.timeGame);
			this.bulletDrawPos = {
				x: 0.125 * ig.system.width,
				y: 0.1 * ig.system.height
			};
			this.bottlesDrawPos = {
				x: 0.285 * ig.system.width,
				y: 0.1 * ig.system.height
			};
			this.timesDrawPos = {
				x: 0.44 * ig.system.width,
				y: 0.1 * ig.system.height
			};
			this.levelDrawPos = {
				x: 0.565 * ig.system.width,
				y: 0.1 * ig.system.height
			}
		},
		update: function() {
			this.parent();
			0 < this.gameTimer.delta() && (this.pauseTime(), this.control.loseLevel());
			this.timerCooldown.delta() > this.cooldown && !this.clickReset && (this.clickReset = !0, this.resetTimerClick())
		},
		resetTimerCooldown: function() {
			this.timerCooldown.reset();
			this.clickReset = !1;
			this.timerClick.reset()
		},
		resetTimerClick: function() {
			this.timerClick.reset()
		},
		pauseTimerClick: function() {
			this.timerClick.pause()
		},
		resumeTimerClick: function() {
			this.timerClick.unpause()
		},
		checkTimeRelease: function() {
			return this.timerClick.delta() > this.maxHold && this.showRedBar
		},
		setTime: function(c) {
			this.gameTimer.set(c)
		},
		resetTime: function() {
			this.gameTimer.reset()
		},
		pauseTime: function() {
			this.gameTimer.pause()
		},
		resumeTime: function() {
			this.gameTimer.unpause()
		},
		draw: function() {
			this.parent();
			if ("game" == ig.game.control.stateMachine) {
				this.imgBullets.draw(0.03 * ig.system.width, 0.055 * ig.system.height);
				this.imgBottle.draw(0.195 * ig.system.width, 0.052 * ig.system.height);
				this.imgTimes.draw(0.36 * ig.system.width,
					0.052 * ig.system.height);
				var c = Math.abs(Math.floor(this.gameTimer.delta())),
					b = "" + this.control.bulletUsed,
					e = "" + this.control.bottles.length,
					d = ig.system.context,
					f = _STRINGS.Game.Level + (this.control.level + 1);
				d.save();
				d.font = "26px twcen";
				d.textAlign = "center";
				d.fillStyle = "white";
				d.strokeStyle = "#7a2b20";
				d.lineWidth = 5;
				d.strokeText(c, this.timesDrawPos.x, this.timesDrawPos.y);
				d.strokeText(b, this.bulletDrawPos.x, this.bulletDrawPos.y);
				d.strokeText(e, this.bottlesDrawPos.x, this.bottlesDrawPos.y);
				d.strokeText(f, this.levelDrawPos.x,
					this.levelDrawPos.y);
				d.fillText(c, this.timesDrawPos.x, this.timesDrawPos.y);
				d.fillText(b, this.bulletDrawPos.x, this.bulletDrawPos.y);
				d.fillText(e, this.bottlesDrawPos.x, this.bottlesDrawPos.y);
				d.fillText(f, this.levelDrawPos.x, this.levelDrawPos.y);
				d.restore();
				!ig.ua.mobile && ("game" == this.control.stateMachine && ig.input.state("click") && this.showRedBar) && (d.save(), this.timerCooldown.delta() > this.cooldown && (this.timerClick.delta() > this.maxHold ? (d.font = "36px twcen", d.strokeStyle = "#ff8830", d.lineWidth = 5, d.fillStyle =
						"#ffffff", d.textAlign = "center", d.strokeText(_STRINGS.Game.ReadyShoot, 0.5 * ig.system.width, 0.4 * ig.system.height), d.fillText(_STRINGS.Game.ReadyShoot, 0.5 * ig.system.width, 0.4 * ig.system.height)) : (this.imgHoldBG.draw(0.5 * ig.system.width - 0.5 * this.imgHoldBG.width, 0.4 * ig.system.height - this.imgHoldBG.height), c = this.imgHoldBar.width * (1 - this.timerClick.delta() / this.maxHold), this.imgHoldBar.draw(0.5 * ig.system.width - 0.5 * this.imgHoldBG.width + 8, 0.4 * ig.system.height - this.imgHoldBG.height + 8, 0, 0, c, this.imgHoldBar.height))),
					d.restore())
			}
		}
	})
});
ig.baked = !0;
ig.module("plugins.handlers.webgl-mouse-handler").defines(function() {
	ig.WebglMouseHandler = ig.Class.extend({
		camera: null,
		angularSensibility: 2200,
		gun: null,
		control: null,
		init: function(c) {
			this.camera = c
		},
		update: function() {
			ig.input.pressed("click") && (ig.game.io.getClickPos(), this.control.uiBoard.resetTimerCooldown(), ig.game.hideCursor());
			if (ig.input.state("click")) {
				var c = ig.game.io.getLastClickPos(),
					b = ig.game.io.getClickPos(),
					e = b.y - c.y;
				this.camera.cameraRotation.y += (b.x - c.x) / this.angularSensibility;
				this.camera.cameraRotation.x +=
					e / this.angularSensibility
			}
			ig.input.released("click") && this.control.uiBoard.checkTimeRelease() && this.gun && ("game" == this.control.stateMachine && !ig.game.control.waitWinning) && this.gun.shoot();
			0.75 < this.camera.rotation.y && (this.camera.rotation.y = 0.75); - 0.75 > this.camera.rotation.y && (this.camera.rotation.y = -0.75);
			ig.ua.mobile || ig.input.released("click") && ig.game.showCursor()
		},
		draw: function() {}
	})
});
ig.baked = !0;
ig.module("game.entities.webgl.webgl-control-game").requires("impact.entity", "game.entities.buttons.button-pause", "game.entities.buttons.button-fire", "game.entities.buttons.button-start", "game.entities.buttons.button-settings", "game.entities.buttons.button-home", "game.entities.buttons.button-retry", "game.entities.buttons.button-next", "game.entities.buttons.button-resume", "game.entities.buttons.button-oke", "game.entities.buttons.button-n-popup", "game.entities.buttons.button-p-popup", "game.entities.buttons.button-slider",
	"game.entities.popup", "game.entities.popup-level", "game.entities.pointer", "game.entities.fadescreen", "game.entities.tutorial", "game.entities.ui-board", "plugins.handlers.webgl-mouse-handler").defines(function() {
	EntityWebglControlGame = ig.Entity.extend({
		alpha: 0,
		dAlpha: 0.05,
		size: {
			x: 10,
			y: 10
		},
		pos: {
			x: 0,
			y: 0
		},
		name: "webgl control game",
		control: null,
		laserSpawner: null,
		camera: null,
		menuButton: null,
		pointer: null,
		ignorePause: !0,
		collidedColor: "rgba(255,0,0,0.5)",
		metricColor: "rgba(0,255,255,0.8)",
		metricText: {
			time: "Time left:",
			score: "Score:"
		},
		bottles: [],
		buffObject: [],
		obstacles: [],
		bullets: [5, 6, 6, 7, 5, 6, 11, 12, 13, 14, 14, 10, 15, 15, 18, 8, 12, 15, 18, 22],
		timeLevel: [60, 60, 60, 60, 60, 60, 70, 75, 75, 60, 60, 60, 75, 75, 120, 60, 75, 90, 105, 120],
		startTime: [20, 20, 20, 20, 20, 20, 22, 25, 25, 20, 20, 18, 25, 25, 36, 20, 25, 27, 35, 40],
		popupDown: !1,
		addingbreakglass: !0,
		titleGame: new ig.Image("media/graphics/sprites/title-game.png"),
		crosshair: new ig.Image("media/graphics/sprites/crosshair.png"),
		level: 0,
		bulletGun: 0,
		bulletUsed: 0,
		bulletHit: 0,
		treeInGame: 0,
		stateMachine: "mainmenu",
		cameraControl: null,
		recheckAfterLastBullet: null,
		recheckLevelCondition: !1,
		waitWinning: !1,
		testSoundStar: 0,
		init: function(c, b, e) {
			this.parent(c, b, e);
			this.createScene();
			this.createLightSource();
			this.createSkybox();
			this.spawnCamera();
			this.createMesh();
			this.createUI();
			ig.game.control = this;
			this.recheckAfterLastBullet = new ig.Timer;
			ig.soundHandler.bgmPlayer.play(ig.soundHandler.bgmPlayer.soundList.background)
		},
		createUI: function() {
			this.pauseButton = ig.game.spawnEntity(EntityButtonPause, 0.92 * ig.system.width, 0.05 *
				ig.system.height, {
					control: this
				});
			this.playButton = ig.game.spawnEntity(EntityButtonStart, 0.5 * ig.system.width, 0.5 * ig.system.height, {
				control: this
			});
			this.settingsButton = ig.game.spawnEntity(EntityButtonSettings, 0.5 * ig.system.width, 0.64 * ig.system.height, {
				control: this
			});
			this.moreButton = ig.game.spawnEntity(EntityButtonMoreGames, 0.5 * ig.system.width, 0.78 * ig.system.height, {
				control: this
			});
			this.popupResult = ig.game.spawnEntity(EntityPopup, 0.5 * ig.system.width, -500, {
				control: this
			});
			this.popupLevel = ig.game.spawnEntity(EntityPopupLevel,
				0.5 * ig.system.width, -500, {
					control: this
				});
			this.fade = ig.game.spawnEntity(EntityFadescreen, 580, 920, {
				control: this
			});
			this.uiBoard = ig.game.spawnEntity(EntityUiBoard, 20, 20, {
				control: this,
				timeGame: 20
			});
			this.uiBoard.pauseTime();
			ig.ua.mobile && (this.fireButton = ig.game.spawnEntity(EntityButtonFire, 0.85 * ig.system.width, 0.76 * ig.system.height, {
				control: this,
				gun: this.gun
			}));
			this.tutorial = ig.game.spawnEntity(EntityTutorial, 0, 0, {
				control: this
			})
		},
		ready: function() {
			this.parent()
		},
		createScene: function() {
			this.scene = new BABYLON.Scene(wgl.system.engine);
			this.scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);
			wgl.game.currentScene = this.scene;
			wgl.system.registerBeforeRender();
			this.scene.enablePhysics(new BABYLON.Vector3(0, -5, 0), new BABYLON.CannonJSPlugin);
			this.scene._physicsEngine.setTimeStep(0.05);
			this.scene.collisionsEnabled = !0
		},
		createLightSource: function() {
			var c = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(-1, 1, 0), this.scene);
			c.intensity = 0.5;
			c.diffuse = new BABYLON.Color3(0.54, 0.78, 0.9);
			c = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(0, -1, -1), this.scene);
			c.position = new BABYLON.Vector3(-300, 300, 600);
			(new BABYLON.PointLight("pointLight", new BABYLON.Vector3(1, 1, 1), this.scene)).intensity = 0.5;
			this.shadowGenerator = new BABYLON.ShadowGenerator(1024, c);
			this.shadowGenerator.usePoissonSampling = !0;
			this.shadowGenerator.useBlurVarianceShadowMap = !0
		},
		createSkybox: function() {
			this.skybox = BABYLON.Mesh.CreateSphere("skyBox", 100, 1E3, this.scene);
			BABYLON.Engine.ShadersRepository = "media/shaders/";
			this.shader = new BABYLON.ShaderMaterial("gradient", this.scene,
				"gradient", {});
			this.shader.setFloat("offset", 10);
			this.shader.setColor3("topColor", BABYLON.Color3.FromInts(0, 119, 255));
			this.shader.setColor3("bottomColor", BABYLON.Color3.FromInts(240, 240, 255));
			this.shader.backFaceCulling = !1;
			this.skybox.material = this.shader
		},
		createGround: function() {
			var c = this.getEntitiesName("terrain_green_flat");
			if (!(0 >= c.length)) {
				this.scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
				this.scene.fogDensity = 0.005;
				this.scene.fogColor = new BABYLON.Color3(1, 1, 1);
				this.ground = c[0];
				this.ground.scaling =
					new BABYLON.Vector3(50, 50, 50);
				this.ground.position = new BABYLON.Vector3(0, 0, 50);
				this.ground.isVisible = !0;
				this.ground.receiveShadows = !0;
				c = this.getEntitiesName("Terrain4")[0];
				c.scaling = new BABYLON.Vector3(8, 8, 8);
				c.position = new BABYLON.Vector3(75, 0, 35);
				c.isVisible = !0;
				c = this.getEntitiesName("Terrain2")[0];
				c.scaling = new BABYLON.Vector3(15, 15, 13);
				c.position = new BABYLON.Vector3(30, 0, 95);
				c.isVisible = !0;
				c = this.getEntitiesName("Terrain3")[0];
				c.scaling = new BABYLON.Vector3(8, 8, 8);
				c.position = new BABYLON.Vector3(-50,
					0, 65);
				c.isVisible = !0;
				c = this.getEntitiesName("mountai-flat")[0];
				if (null != c || void 0 != c) c.isVisible = !0, c.position = new BABYLON.Vector3(0, 3, 200), c.scaling = new BABYLON.Vector3(4, 4, 4);
				var b = c.clone("mtflat1");
				if (null != b || void 0 != b) b.isVisible = !0, b.position = new BABYLON.Vector3(100, 3, 180), b.scaling = new BABYLON.Vector3(1.18, 1.18, 1.18);
				b = c.clone("mtflat2");
				if (null != b || void 0 != b) b.isVisible = !0, b.position = new BABYLON.Vector3(-90, 3, 120), b.scaling = new BABYLON.Vector3(1.7, 1.7, 1.7);
				b = c.clone("mtflat3");
				if (null != b ||
					void 0 != b) b.isVisible = !0, b.position = new BABYLON.Vector3(-120, 3, 60), b.scaling = new BABYLON.Vector3(1.3, 1.3, 1.3);
				c = c.clone("mtflat4");
				if (null != c || void 0 != c) c.isVisible = !0, c.position = new BABYLON.Vector3(140, 2, 80), c.scaling = new BABYLON.Vector3(2, 2, 2)
			}
		},
		getEntitiesName: function(c) {
			for (var b = [], e = 0; e < ig.game.reslAllModels.length; e++) ig.game.reslAllModels[e].name === c && b.push(ig.game.reslAllModels[e]);
			return b
		},
		spawnCamera: function() {
			this.camera = wgl.game.spawnEntity(wgl.modules.Camera, 0, 0, 0, {
				main: this,
				zoom: 10
			})
		},
		createMesh: function() {
			ig.game.breakGlassParticle = wgl.game.spawnEntity(wgl.modules.Breakglass, 0, 0, 0, {
				main: this
			});
			BABYLON.SceneLoader.ImportMesh("", "media/models/lowpoly-assets/", "lowpoly_assets1.babylon", this.scene, function(c) {
				for (var b = 0; b < c.length; b++) {
					var e = c[b];
					"Bottle1" == e.name ? ig.game.bottleModels.push(e) : "Tree2" == e.name ? ig.game.treeModels.push(e) : ig.game.reslAllModels.push(e);
					e.material && (e.material.diffuseColor = new BABYLON.Color3(1, 1, 1), e.convertToFlatShadedMesh());
					e.isVisible = !1
				}
				ig.game.assetsReady = !0
			});
			this.gun = wgl.game.spawnEntity(wgl.modules.Shotgun, 0, 0, 0, {
				main: this
			});
			this.spawnMeshByLevel()
		},
		treeGeneratorArea: function(c, b, e, d, f) {
			if (!(0 >= ig.game.treeModels.length))
				for (var g = 0; g < f; g++) {
					var q = ig.game.treeModels[0],
						m = q.clone("tree" + g);
					m.isVisible = !0;
					var j = this.randomMinMax(c - d, c + 2 * d),
						l = this.randomMinMax(e - d, e + 2 * d);
					m.scaling = new BABYLON.Vector3(4, 4, 4);
					"Tree3" == q.name && (m.scaling = new BABYLON.Vector3(8, 8, 8));
					m.position.x = j;
					m.position.y = b;
					m.position.z = l
				}
		},
		randomMinMax: function(c, b) {
			return c == b ?
				c : Math.random() * (b - c) + c
		},
		addingTree: function(c, b) {
			if (!(0 >= ig.game.treeModels.length)) {
				var e = ig.game.treeModels[0],
					d = e.clone("tree" + this.treeInGame);
				this.treeInGame++;
				"Tree3" == e.name ? d.scaling = new BABYLON.Vector3(8, 8, 8) : (d.scaling = new BABYLON.Vector3(4, 4, 4), "Tree1" == e.name && (d.rotation.y = this.randomMinMax(0, 1)));
				d.isVisible = !0;
				d.position.x = b.x;
				d.position.y = b.y - 1.5;
				d.position.z = b.z;
				this.shadowGenerator.getShadowMap().renderList.push(d)
			}
		},
		grassGeneratorAllArea: function(c) {
			var b = this.getEntitiesName("Plant1")[0];
			if (b)
				for (var e = 0; e < c; e++) {
					var d = b.clone("grass");
					this.randomMinMax(0, 3);
					d.isVisible = !0;
					var f = this.randomMinMax(-50, 50),
						g = this.randomMinMax(0, 100);
					d.scaling = new BABYLON.Vector3(5, 5, 5);
					d.position.x = f;
					d.position.y = 1;
					d.position.z = g;
					d.rotation.y = this.randomMinMax(0, 3.14)
				}
		},
		grassGeneratorScope: function(c, b, e) {
			var d = this.getEntitiesName("Plant1")[0];
			if (d)
				for (var f = 0; f < c; f++)
					for (var g = 0; g < c; g++) {
						var q = d.clone("grass");
						q.scaling = new BABYLON.Vector3(5, 5, 5);
						q.rotation.y = this.randomMinMax(0, 3.14);
						q.isVisible = !0;
						q.position.x = b.x + f * e;
						q.position.y = 1;
						q.position.z = b.z + g * e
					}
		},
		killAllBottles: function() {
			for (; 0 < this.bottles.length;) this.bottles[0].kill(), this.bottles.shift()
		},
		objectReset: function() {
			this.killAllBottles();
			this.tutorial.endTutorial();
			null != this.table && this.table.dispose();
			if (0 < this.buffObject.length)
				for (; 0 < this.buffObject.length;) this.buffObject[0].dispose(), this.buffObject.shift();
			if (0 < this.obstacles.length)
				for (; 0 < this.obstacles.length;) this.obstacles[0].kill(), this.obstacles.shift();
			var c = this.getEntitiesName("plank")[0];
			null != c && (c.isVisible = !1);
			ig.game.camera.rotation = new BABYLON.Vector3(0, -0.07353018465453931, 0)
		},
		spawnMeshByLevel: function() {
			null != this.table && this.table.dispose();
			if (0 < this.buffObject.length)
				for (; 0 < this.buffObject.length;) {
					var c = this.buffObject[0];
					c.dispose();
					this.buffObject.shift()
				}
			if (0 < this.obstacles.length)
				for (; 0 < this.obstacles.length;) c = this.obstacles[0], c.kill(), this.obstacles.shift();
			var b = this.getEntitiesName("Bench")[0],
				e = this.getEntitiesName("plank")[0],
				d = this.getEntitiesName("crate")[0];
			null != e && (e.isVisible = !0, e.position = new BABYLON.Vector3(0, 0, 32), e.scaling = new BABYLON.Vector3(10, 10, 10));
			if (0 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 24), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				if (ig.ua.mobile)
					for (var f = 0; 2 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -1.5 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					});
				else
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					});
				e && (e.isVisible = !1)
			} else if (1 == this.level) {
				null != b && (b.scaling = new BABYLON.Vector3(10, 10, 10), this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 24), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				if (ig.ua.mobile)
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					});
				else
					for (f = 0; 4 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -4.5 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					});
				e && (e.isVisible = !1)
			} else if (2 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 24), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				if (ig.ua.mobile)
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, -1.5 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					}), 1 == f && (c.move = !0);
				else
					for (f = 0; 3 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					}), 2 == f && (c.move = !0);
				e && (e.isVisible = !1)
			} else if (3 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 24), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 12), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				if (ig.ua.mobile)
					for (f = 0; 3 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					}), 0 < f && (c.move = !0);
				else
					for (f = 0; 4 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, -4.5 + 3 * f, 3.5, 24, {
						main: this,
						addingPhysic: !0
					}), 1 < f && (c.move = !0);
				e && (e.isVisible = !1)
			} else if (4 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 32), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10,
					10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 32, {
					main: this,
					addingPhysic: !0
				});
				e && (e.isVisible = !1)
			} else if (5 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 32), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				for (f = 0; 4 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -4.5 + 3 * f, 3.5, 32, {
					main: this,
					addingPhysic: !0
				});
				e && (e.isVisible = !1)
			} else if (6 == this.level)
				if (null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(-6, 0, 32), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table)), ig.ua.mobile) {
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -9.2 + 3 * f, 3.5, 32, {
						main: this,
						addingPhysic: !0
					});
					null != d && (f = d.clone(d.name),
						f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 2 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, 6.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					})
				} else {
					for (f =
						0; 4 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -10.5 + 3 * f, 3.5, 32, {
						main: this,
						addingPhysic: !0
					});
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c),
						this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, 5.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					})
				}
			else if (7 == this.level)
				if (null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(-6, 0, 32), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 12), this.shadowGenerator.getShadowMap().renderList.push(this.table)), ig.ua.mobile) {
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -9.2 + 3 * f, 3.5, 32, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 2 == f) c.move = !0;
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 2 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, 6.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					})
				} else {
					for (f = 0; 4 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -10.5 + 3 * f, 3.5, 32, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 3 == f) c.move = !0;
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation =
						new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, 5.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					})
				}
			else if (8 == this.level)
				if (null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(-6, 0, 36), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0),
						this.table.scaling = new BABYLON.Vector3(10, 10, 12)), ig.ua.mobile) {
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -9.2 + 3 * f, 3.5, 36, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 2 == f) c.move = !0;
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c),
						this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, 6.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					}), 1 == f && (c.upDown = !0, c.pb.y = 7.5)
				} else {
					for (f = 0; 4 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -10.5 + 3 * f, 3.5, 36, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 3 == f) c.move = !0, 3 == f && (c.spMove = -0.025, c.spMoveHolder = 0.025);
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5,
						2.5), f.position = new BABYLON.Vector3(7, 3.2, 36), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 36), e.position = new BABYLON.Vector3(11, 0.7, 31), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 3 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, 5.5 + 2 * f, 6, 36, {
							main: this,
							addingPhysic: !0
						}),
						1 == f && (c.upDown = !0, c.pb.y = 7.5)
				}
			else if (9 == this.level)
				if (null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(-6, 0, 36), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table)), ig.ua.mobile) {
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -9.2 + 3 * f, 3.5, 36, {
						main: this,
						addingPhysic: !0
					});
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, -5, 2.2, 31, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					});
					c.pb.y = 3.5;
					this.obstacles.push(c);
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, 6.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					}), 1 == f && (c.upDown = !0, c.pb.y = 7.5)
				} else {
					for (f = 0; 4 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -10.5 + 3 * f, 3.5, 36, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Obstacle, -6.5 + 3 * f, 2.2, 31, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					}), c.pb.y = 3.5, this.obstacles.push(c);
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7,
						3.2, 36), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 36), e.position = new BABYLON.Vector3(11, 0.7, 31), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 3 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, 5.5 + 2 * f, 6, 36, {
						main: this,
						addingPhysic: !0
					}), 1 == f && (c.upDown = !0, c.pb.y =
						7.5)
				}
			else if (10 == this.level)
				if (null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(-6, 0, 36), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 13), this.shadowGenerator.getShadowMap().renderList.push(this.table)), ig.ua.mobile) {
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -8.2 + 3 * f, 3.5, 36, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 2 == f) c.move = !0, 2 == f && (c.spMove = -0.025, c.spMoveHolder = 0.025);
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, -4.3, 2.2, 31, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					});
					c.pb.y = 3.5;
					this.obstacles.push(c);
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 32), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 32), e.position = new BABYLON.Vector3(11, 0.7, 28), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, 6.5 + 2 * f, 6, 32, {
						main: this,
						addingPhysic: !0
					}), 1 == f && (c.upDown = !0, c.pb.y = 7.5)
				} else {
					for (f = 0; 4 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -10.5 + 3 * f, 3.5, 36, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 3 == f) c.move = !0, 3 == f && (c.spMove = -0.025, c.spMoveHolder = 0.025);
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Obstacle, -6.5 + 3 * f, 2.2, 31, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					}), c.pb.y = 3.5, this.obstacles.push(c);
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(7, 3.2, 36), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(11, 1.3, 36), e.position = new BABYLON.Vector3(11, 0.7, 31), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (f = 0; 3 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle,
						5.5 + 2 * f, 6, 36, {
							main: this,
							addingPhysic: !0
						}), 1 == f && (c.upDown = !0, c.pb.y = 7.5)
				}
			else if (11 == this.level) {
				var d = 6,
					g = -15;
				ig.ua.mobile && (d = 4, g = -10);
				b = this.getEntitiesName("barrel_closed")[0];
				for (f = 0; f < d; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(g + 5 * f, 0, 36), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, g + 5 * f, 3.5, 36, {
					main: this,
					addingPhysic: !0
				});
				e.position = new BABYLON.Vector3(11,
					0, 40);
				e.rotation = new BABYLON.Vector3(0, 1.2, 0)
			} else if (12 == this.level)
				if (ig.ua.mobile) {
					e.isVisible = !1;
					b = this.getEntitiesName("barrel_closed")[0];
					for (f = 0; 2 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(-10 + 5 * f, 0, 30), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, -10 + 5 * f, 3.5, 30, {
						main: this,
						addingPhysic: !0
					});
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling =
						new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(3, 3.2, 30), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(7.5, 1.3, 30), c.rotation = new BABYLON.Vector3(0, 1.2, 0), e.position = new BABYLON.Vector3(8, 0.7, 35), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e), e = d.clone(d.name),
						e.isVisible = !0, e.scaling = new BABYLON.Vector3(4.5, 4.5, 4.5), e.position = new BABYLON.Vector3(-10, 4, 50), this.buffObject.push(e), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (e = 0; 2 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, 2 + 3 * e, 6, 30, {
						main: this,
						addingPhysic: !0
					});
					for (e = 0; 2 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, -13 + 6 * e, 9, 47, {
						main: this,
						addingPhysic: !0,
						bottleType: 1
					})
				} else {
					e.isVisible = !1;
					b = this.getEntitiesName("barrel_closed")[0];
					for (f = 0; 3 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(-15 + 5 * f, 0, 30), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, -15 + 5 * f, 3.5, 30, {
						main: this,
						addingPhysic: !0
					});
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2.5, 2.5, 2.5), f.position = new BABYLON.Vector3(3, 3.2, 30), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.position = new BABYLON.Vector3(7.5, 1.3, 30), c.rotation = new BABYLON.Vector3(0,
						1.2, 0), e.position = new BABYLON.Vector3(8, 0.7, 35), e.rotation = new BABYLON.Vector3(0, 1.2, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e), e = d.clone(d.name), e.isVisible = !0, e.scaling = new BABYLON.Vector3(4.5, 4.5, 4.5), e.position = new BABYLON.Vector3(-10, 4, 50), this.buffObject.push(e), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (e = 0; 3 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle,
						1 + 2 * e, 6, 30, {
							main: this,
							addingPhysic: !0
						});
					for (e = 0; 3 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, -14 + 4 * e, 9, 47, {
						main: this,
						addingPhysic: !0,
						bottleType: 1
					})
				}
			else if (13 == this.level)
				if (ig.ua.mobile) {
					b = this.getEntitiesName("barrel_closed")[0];
					for (f = 0; 2 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(-12 + 4 * f, 0, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, -12 +
						4 * f, 3.5, 40, {
							main: this,
							addingPhysic: !0
						});
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, 1.5, 2.2, 35, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					});
					this.obstacles.push(c);
					c.pb.y = 3;
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(-4, 1, 40), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(1, 1, 1), c.position = new BABYLON.Vector3(5, 1, 40), e.position = new BABYLON.Vector3(0.2, 2.5, 40), e.rotation = new BABYLON.Vector3(0,
						1.57, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (e = 0; 2 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, -2 + 4 * e, 2.9, 40, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 2 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(9 + 4 * f, 0, 40), this.buffObject.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle,
						9 + 4 * f, 3.5, 40, {
							main: this,
							addingPhysic: !0
						})
				} else {
					b = this.getEntitiesName("barrel_closed")[0];
					for (f = 0; 3 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(-15 + 4 * f, 0, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, -15 + 4 * f, 3.5, 40, {
						main: this,
						addingPhysic: !0
					});
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, 2, 2.2, 35, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					});
					this.obstacles.push(c);
					c.pb.y = 3;
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(-2, 1, 40), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(1, 1, 1), c.position = new BABYLON.Vector3(7, 1, 40), e.position = new BABYLON.Vector3(2.2, 2.5, 40), e.rotation = new BABYLON.Vector3(0, 1.57, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c),
						this.shadowGenerator.getShadowMap().renderList.push(e));
					for (e = 0; 3 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, -1 + 3 * e, 2.9, 40, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 3 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(12 + 4 * f, 0, 40), this.buffObject.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, 12 + 4 * f, 3.5, 40, {
						main: this,
						addingPhysic: !0
					})
				}
			else if (14 == this.level)
				if (ig.ua.mobile) {
					b = this.getEntitiesName("barrel_closed")[0];
					for (f = 0; 2 > f; f++) null !=
						b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(-12 + 4 * f, 0, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, -12 + 4 * f, 3.5, 40, {
							main: this,
							addingPhysic: !0
						});
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, 1.5, 2.2, 35, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1.1
					});
					this.obstacles.push(c);
					c.pb.y = 3;
					null != d && (f = null, f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1,
						1, 1), f.position = new BABYLON.Vector3(-4, 1, 40), this.buffObject.push(f), this.shadowGenerator.getShadowMap().renderList.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(1, 1, 1), c.position = new BABYLON.Vector3(5, 1, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c), f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(5, 4, 40), this.buffObject.push(f), f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1,
						1, 1), f.position = new BABYLON.Vector3(-4, 4, 40), this.buffObject.push(f), e.position = new BABYLON.Vector3(0.2, 2.5, 40), e.rotation = new BABYLON.Vector3(0, 1.57, 0), d = e.clone("plank"), d.position = new BABYLON.Vector3(0.2, 5.4, 40), this.buffObject.push(d), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (e = 0; 2 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, -2 + 4 * e, 2.9, 40, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 2 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position =
						new BABYLON.Vector3(9 + 4 * f, 0, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, 9 + 4 * f, 3.5, 40, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -1.5 + 2.5 * f, 5.6, 40, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 2 == f) c.move = !0, c.spMoveHolder = 0.025, 2 == f && (c.spMove = -0.025)
				} else {
					b = this.getEntitiesName("barrel_closed")[0];
					for (f = 0; 3 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2,
						2, 2), c.position = new BABYLON.Vector3(-15 + 4 * f, 0, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, -15 + 4 * f, 3.5, 40, {
						main: this,
						addingPhysic: !0
					});
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, 2, 3, 35, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1
					});
					this.obstacles.push(c);
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(-2, 1, 40), this.buffObject.push(f), this.shadowGenerator.getShadowMap().renderList.push(f),
						c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(1, 1, 1), c.position = new BABYLON.Vector3(7, 1, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c), f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(7, 4, 40), this.buffObject.push(f), this.shadowGenerator.getShadowMap().renderList.push(f), f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(-2, 4, 40), this.shadowGenerator.getShadowMap().renderList.push(f),
						this.buffObject.push(f), e.position = new BABYLON.Vector3(2.2, 2.5, 40), e.rotation = new BABYLON.Vector3(0, 1.57, 0), d = e.clone("plank"), d.position = new BABYLON.Vector3(2.2, 5.4, 40), this.buffObject.push(d), this.shadowGenerator.getShadowMap().renderList.push(d), this.shadowGenerator.getShadowMap().renderList.push(e));
					for (e = 0; 3 > e; e++) wgl.game.spawnEntity(wgl.modules.Bottle, 0 + 2.5 * e, 2.9, 40, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, 0 + 2.5 * f, 5.6, 40, {
								main: this,
								addingPhysic: !0
							}),
							0 == f || 2 == f) c.move = !0, c.spMoveHolder = 0.025, 2 == f && (c.spMove = -0.025);
					for (f = 0; 3 > f; f++) null != b && (c = b.clone("barrel"), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(12 + 4 * f, 0, 40), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c)), wgl.game.spawnEntity(wgl.modules.Bottle, 12 + 4 * f, 3.5, 40, {
						main: this,
						addingPhysic: !0
					})
				}
			else if (15 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(-7, 0,
					50), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -10 + 3 * f, 3.5, 50, {
					main: this,
					addingPhysic: !0
				});
				b = wgl.game.spawnEntity(wgl.modules.Windmill, 30, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, 0.6, 0);
				b.changeRotation(f);
				this.obstacles.push(b);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				wgl.game.spawnEntity(wgl.modules.Bottle,
					27, 12.8, 54.8, {
						main: this,
						addingPhysic: !0
					});
				null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(3.1, 1, 54), f.rotation = new BABYLON.Vector3(0, 0.6, 0), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(6.5, 2, 50), c.rotation = new BABYLON.Vector3(0, 0.6, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(f));
				wgl.game.spawnEntity(wgl.modules.Bottle, 6.5, 4.2, 50, {
					main: this,
					addingPhysic: !0
				});
				null != e && (e.isVisible = !1)
			} else if (16 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(2, 0, 50), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				if (ig.ua.mobile)
					for (f = 0; 2 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, 0 + 4 * f, 3.5, 50, {
						main: this,
						addingPhysic: !0
					});
				else
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -1 + 3 * f, 3.5, 50, {
						main: this,
						addingPhysic: !0
					});
				b = this.getEntitiesName("bigstone1")[0];
				null != b && (b.isVisible = !1);
				b = wgl.game.spawnEntity(wgl.modules.Windmill, 30, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, 0.6, 0);
				b.changeRotation(f);
				this.obstacles.push(b);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				wgl.game.spawnEntity(wgl.modules.Bottle, 27, 12.8, 54.8, {
					main: this,
					addingPhysic: !0
				});
				b = wgl.game.spawnEntity(wgl.modules.Windmill, -27, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, -0.6, 0);
				b.changeRotation(f);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				this.obstacles.push(b);
				wgl.game.spawnEntity(wgl.modules.Bottle, -23, 12.8, 54.8, {
					main: this,
					addingPhysic: !0
				});
				null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(15, 1, 47), f.rotation = new BABYLON.Vector3(0, 0.6, 0), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2),
					c.position = new BABYLON.Vector3(12.5, 2, 50), c.rotation = new BABYLON.Vector3(0, 0.6, 0), this.shadowGenerator.getShadowMap().renderList.push(c), this.buffObject.push(c), f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(1, 1, 1), f.position = new BABYLON.Vector3(-11.6, 1, 50), f.rotation = new BABYLON.Vector3(0, 0.6, 0), this.buffObject.push(f), f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2, 2, 2), f.position = new BABYLON.Vector3(-7.2, 2, 47), f.rotation = new BABYLON.Vector3(0, 0.6, 0), this.shadowGenerator.getShadowMap().renderList.push(f),
					this.buffObject.push(f));
				d = wgl.game.spawnEntity(wgl.modules.Bottle, 12, 4.2, 50, {
					main: this,
					addingPhysic: !0
				});
				wgl.game.spawnEntity(wgl.modules.Bottle, -8, 4.15, 50, {
					main: this,
					addingPhysic: !0
				});
				null != e && (e.isVisible = !1)
			} else if (17 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(1, 0, 50), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 10), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				b = this.getEntitiesName("bigstone1")[0];
				null != b && (b.isVisible = !1);
				b = wgl.game.spawnEntity(wgl.modules.Windmill, 30, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, 0.6, 0);
				b.changeRotation(f);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				this.obstacles.push(b);
				wgl.game.spawnEntity(wgl.modules.Bottle, 27, 12.8, 54.8, {
					main: this,
					addingPhysic: !0
				});
				b = wgl.game.spawnEntity(wgl.modules.Windmill, -27, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, -0.6, 0);
				b.changeRotation(f);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				this.obstacles.push(b);
				wgl.game.spawnEntity(wgl.modules.Bottle, -23, 12.8, 54.8, {
					main: this,
					addingPhysic: !0
				});
				null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(2, 2, 2), f.position = new BABYLON.Vector3(-10, 2, 47), f.rotation = new BABYLON.Vector3(0, 0.6, 0), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(2, 2, 2), c.position = new BABYLON.Vector3(12.5, 2, 50), c.rotation = new BABYLON.Vector3(0, 0.6, 0), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f),
					this.shadowGenerator.getShadowMap().renderList.push(c));
				d = wgl.game.spawnEntity(wgl.modules.Bottle, -10, 4.2, 50, {
					main: this,
					addingPhysic: !0
				});
				wgl.game.spawnEntity(wgl.modules.Bottle, 12.5, 4.2, 50, {
					main: this,
					addingPhysic: !0
				}).move = !0;
				d.spMoveHolder = 0.025;
				d.spMove = -0.025;
				d.move = !0;
				if (ig.ua.mobile)
					for (f = 0; 2 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -0.5 + 4 * f, 3.5, 50, {
						main: this,
						addingPhysic: !0
					});
				else
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -1.5 + 3 * f, 3.5, 50, {
						main: this,
						addingPhysic: !0
					});
				null !=
					e && (e.isVisible = !1)
			} else if (18 == this.level)
				if (ig.ua.mobile) {
					null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 60), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 13), this.shadowGenerator.getShadowMap().renderList.push(this.table));
					b = this.getEntitiesName("bigstone1")[0];
					null != b && (b.isVisible = !1);
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 60, {
						main: this,
						addingPhysic: !0
					});
					null !=
						d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(3, 3, 3), f.position = new BABYLON.Vector3(-11, 3, 63), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(3, 3, 3), c.position = new BABYLON.Vector3(11, 3, 63), e.position = new BABYLON.Vector3(-0.5, 6.3, 63), e.rotation = new BABYLON.Vector3(0, 1.57, 0), e.scaling = new BABYLON.Vector3(10, 7, 18), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(f),
							this.shadowGenerator.getShadowMap().renderList.push(e));
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, 0, 3.5, 53, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1
					});
					this.obstacles.push(c);
					b = wgl.game.spawnEntity(wgl.modules.Windmill, 30, 8, 60, {
						main: this
					});
					f = new BABYLON.Vector3(0, 0.6, 0);
					b.changeRotation(f);
					this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
					this.obstacles.push(b);
					wgl.game.spawnEntity(wgl.modules.Bottle, 27, 12.8, 54.8, {
						main: this,
						addingPhysic: !0
					});
					b = wgl.game.spawnEntity(wgl.modules.Windmill, -27, 8, 60, {
						main: this
					});
					f = new BABYLON.Vector3(0, -0.6, 0);
					this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
					b.changeRotation(f);
					this.obstacles.push(b);
					wgl.game.spawnEntity(wgl.modules.Bottle, -23, 12.8, 54.8, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -4 + 5 * f, 6.5, 63, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 2 == f) c.move = !0, c.spMoveHolder = 0.025, 2 == f && (c.spMove = -0.025)
				} else {
					null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position =
						new BABYLON.Vector3(0, 0, 60), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10, 13), this.shadowGenerator.getShadowMap().renderList.push(this.table));
					b = this.getEntitiesName("bigstone1")[0];
					null != b && (b.isVisible = !1);
					for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 60, {
						main: this,
						addingPhysic: !0
					});
					null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(3, 3, 3), f.position = new BABYLON.Vector3(-11, 3, 63), this.buffObject.push(f), c =
						d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(3, 3, 3), c.position = new BABYLON.Vector3(11, 3, 63), e.position = new BABYLON.Vector3(-0.5, 6.3, 63), e.rotation = new BABYLON.Vector3(0, 1.57, 0), e.scaling = new BABYLON.Vector3(10, 7, 18), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(e));
					c = wgl.game.spawnEntity(wgl.modules.Obstacle, 0, 3.5, 53, {
						main: this,
						addingPhysic: !1,
						upDown: !0,
						maxMove: 1
					});
					this.obstacles.push(c);
					b = wgl.game.spawnEntity(wgl.modules.Windmill, 30, 8, 60, {
						main: this
					});
					f = new BABYLON.Vector3(0, 0.6, 0);
					b.changeRotation(f);
					this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
					this.obstacles.push(b);
					wgl.game.spawnEntity(wgl.modules.Bottle, 27, 12.8, 54.8, {
						main: this,
						addingPhysic: !0
					});
					b = wgl.game.spawnEntity(wgl.modules.Windmill, -27, 8, 60, {
						main: this
					});
					f = new BABYLON.Vector3(0, -0.6, 0);
					this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
					b.changeRotation(f);
					this.obstacles.push(b);
					wgl.game.spawnEntity(wgl.modules.Bottle, -23, 12.8, 54.8, {
						main: this,
						addingPhysic: !0
					});
					for (f = 0; 5 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -7 + 3 * f, 6.5, 63, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 4 == f) c.move = !0, c.spMoveHolder = 0.025, 4 == f && (c.spMove = -0.025)
				}
			else if (19 == this.level) {
				null != b && (this.table = b.clone(b.name), this.table.isVisible = !0, this.table.position = new BABYLON.Vector3(0, 0, 60), this.table.rotation = new BABYLON.Vector3(0, 1.5, 0), this.table.scaling = new BABYLON.Vector3(10, 10,
					13), this.shadowGenerator.getShadowMap().renderList.push(this.table));
				b = this.getEntitiesName("bigstone1")[0];
				null != b && (b.isVisible = !1);
				for (f = 0; 3 > f; f++) wgl.game.spawnEntity(wgl.modules.Bottle, -3 + 3 * f, 3.5, 60, {
					main: this,
					addingPhysic: !0
				});
				null != d && (f = d.clone(d.name), f.isVisible = !0, f.scaling = new BABYLON.Vector3(3, 3, 3), f.position = new BABYLON.Vector3(-11, 3, 63), this.buffObject.push(f), c = d.clone(d.name), c.isVisible = !0, c.scaling = new BABYLON.Vector3(3, 3, 3), c.position = new BABYLON.Vector3(11, 3, 63), e.position = new BABYLON.Vector3(-0.5,
					6.3, 63), e.rotation = new BABYLON.Vector3(0, 1.57, 0), e.scaling = new BABYLON.Vector3(10, 7, 18), this.buffObject.push(c), this.shadowGenerator.getShadowMap().renderList.push(f), this.shadowGenerator.getShadowMap().renderList.push(c), this.shadowGenerator.getShadowMap().renderList.push(e));
				c = wgl.game.spawnEntity(wgl.modules.Obstacle, 0, 3.5, 53, {
					main: this,
					addingPhysic: !1,
					upDown: !0,
					maxMove: 1
				});
				this.obstacles.push(c);
				b = wgl.game.spawnEntity(wgl.modules.Windmill, 30, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, 0.6, 0);
				b.changeRotation(f);
				this.obstacles.push(b);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				wgl.game.spawnEntity(wgl.modules.Bottle, 27, 12.8, 54.8, {
					main: this,
					addingPhysic: !0
				});
				b = wgl.game.spawnEntity(wgl.modules.Windmill, -27, 8, 60, {
					main: this
				});
				f = new BABYLON.Vector3(0, -0.6, 0);
				b.changeRotation(f);
				this.obstacles.push(b);
				this.shadowGenerator.getShadowMap().renderList.push(b.windMillMesh);
				wgl.game.spawnEntity(wgl.modules.Bottle, -23, 12.8, 54.8, {
					main: this,
					addingPhysic: !0
				});
				if (ig.ua.mobile) {
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, -12 + 24 * f, 6.5, 63, {
						main: this,
						addingPhysic: !0
					}), c.upDown = !0, c.pb.y = 7.5;
					for (f = 0; 3 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -4 + 5 * f, 6.5, 63, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 2 == f) c.move = !0, c.spMoveHolder = 0.025, 2 == f && (c.spMove = -0.025)
				} else {
					for (f = 0; 5 > f; f++)
						if (c = wgl.game.spawnEntity(wgl.modules.Bottle, -7 + 3 * f, 6.5, 63, {
								main: this,
								addingPhysic: !0
							}), 0 == f || 4 == f) c.move = !0, c.spMoveHolder = 0.025, 4 == f && (c.spMove = -0.025);
					for (f = 0; 2 > f; f++) c = wgl.game.spawnEntity(wgl.modules.Bottle, -12 + 24 * f, 6.5, 63, {
							main: this,
							addingPhysic: !0
						}),
						c.upDown = !0, c.pb.y = 7.5
				}
			}
			this.bulletGun = this.bullets[this.level];
			this.uiBoard && this.uiBoard.setTime(this.timeLevel[this.level]);
			ig.game.camera.rotation = new BABYLON.Vector3(0, -0.07353018465453931, 0);
			this.recheckLevelCondition = !1
		},
		update: function() {
			this.parent();
			if (null == this.cameraControl) ig.ua.mobile ? (this.cameraControl = new ig.WebglMouseHandler(wgl.game.currentScene.activeCamera), this.cameraControl.angularSensibility = ig.game.gameSettings.sensitivity, this.cameraControl.control = this) : (this.cameraControl =
				new ig.WebglMouseHandler(wgl.game.currentScene.activeCamera), this.cameraControl.angularSensibility = ig.game.gameSettings.sensitivity, this.cameraControl.gun = this.gun, this.cameraControl.control = this, this.uiBoard.pauseTimerClick());
			else {
				ig.game.paused || this.cameraControl.update();
				if (null == this.ground && ig.game.assetsReady) {
					this.createGround();
					this.addingTree(2, {
						x: -20,
						y: 1,
						z: 80
					});
					this.addingTree(1, {
						x: -30,
						y: 1,
						z: 90
					});
					this.addingTree(0, {
						x: -50,
						y: 1,
						z: 20
					});
					this.addingTree(1, {
						x: -45,
						y: 1,
						z: 30
					});
					this.addingTree(0, {
						x: -30,
						y: 1,
						z: 30
					});
					this.addingTree(1, {
						x: -40,
						y: 1,
						z: 22
					});
					this.addingTree(0, {
						x: 70,
						y: 1,
						z: 80
					});
					this.addingTree(1, {
						x: 72,
						y: 1,
						z: 70
					});
					this.addingTree(2, {
						x: 55,
						y: 1,
						z: 60
					});
					this.addingTree(1, {
						x: 25,
						y: 1,
						z: 40
					});
					this.addingTree(0, {
						x: 25,
						y: 1,
						z: 25
					});
					this.addingTree(1, {
						x: 33,
						y: 1,
						z: 22
					});
					this.addingTree(2, {
						x: 22,
						y: 1,
						z: 20
					});
					var c = this.getEntitiesName("stones")[0].clone("smallstone");
					c.position = new BABYLON.Vector3(-20, 1, 40);
					c.isVisible = !0;
					c.scaling = new BABYLON.Vector3(5, 5, 5);
					var c = this.getEntitiesName("Stone3")[0],
						b = c.clone("bigstone1");
					b.isVisible = !0;
					b.position = new BABYLON.Vector3(-23, -0.5, 50);
					b.scaling = new BABYLON.Vector3(5, 5, 5);
					this.shadowGenerator.getShadowMap().renderList.push(b);
					ig.game.reslAllModels.push(b);
					this.getEntitiesName("Stone2");
					c = c.clone("bigstone2");
					c.isVisible = !0;
					c.position = new BABYLON.Vector3(-30, -0.5, 40);
					c.scaling = new BABYLON.Vector3(5, 5, 5);
					this.shadowGenerator.getShadowMap().renderList.push(c);
					ig.game.reslAllModels.push(c);
					c = ig.game.getEntitiesByType(EntityPointerSelector);
					this.pointer = 0 < c.length ? c[0] : ig.game.spawnEntity(EntityPointerSelector,
						10, 10)
				}
				"game" != this.stateMachine && !ig.game.paused && (ig.game.paused = !0)
			}
		},
		checkTarget: function() {
			return this.bottles.length
		},
		recheckLevel: function() {
			this.recheckAfterLastBullet.set(1);
			this.recheckLevelCondition = !0
		},
		winLevel: function() {
			this.popupDown || (this.popupResult.callDown("win"), this.uiBoard.pauseTimerClick(), this.uiBoard.pauseTime())
		},
		loseLevel: function() {
			this.popupDown || (this.tutorial.endTutorial(), this.popupResult.callDown("lose"), this.uiBoard.pauseTimerClick(), this.uiBoard.pauseTime())
		},
		endGame: function() {
			this.camera.camera.detachControl(window);
			this.gameover = !0;
			ig.game.director.jumpTo(LevelEnd);
			this.uiBoard.pauseTime()
		},
		openLevel: function() {
			ig.game.gameSettings.level = [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
		},
		pauseGame: function() {
			if (!this.popupDown && !("mainmenu" == this.stateMachine || this.waitWinning)) ig.game.paused = !0, this.uiBoard.resetTimerClick(), wgl.system.stopRender(), this.stateMachine = "pause", this.uiBoard.pauseTime(), this.popupResult.callDown(this.stateMachine), this.recheckAfterLastBullet.pause()
		},
		settingsGame: function() {
			this.settingsButton.pos.y = -400;
			this.playButton.pos.y = -400;
			_SETTINGS.MoreGames.Enabled && this.moreButton.hide();
			this.stateMachine = "settings";
			this.popupResult.callDown(this.stateMachine)
		},
		settingsClose: function() {
			this.settingsButton.pos.y = 0.64 * ig.system.height;
			this.playButton.pos.y = 0.5 * ig.system.height;
			_SETTINGS.MoreGames.Enabled && this.moreButton.show()
		},
		resumeGame: function() {
			ig.game.paused = !1;
			this.stateMachine = "game";
			this.uiBoard.resumeTime();
			this.uiBoard.resumeTimerClick();
			this.uiBoard.resetTimerClick();
			wgl.system.startRender();
			this.recheckAfterLastBullet.unpause()
		},
		starCount: function() {
			var c = 0;
			this.bulletUsed <= this.bullets[this.level] && c++;
			return c = this.timeLevel[this.level] + this.uiBoard.gameTimer.delta() <= this.startTime[this.level] ? c + 2 : c + 1
		},
		transitionMenu: function() {
			this.fade.fadeStart()
		},
		levelSelect: function() {
			!1 == this.popupDown && (this.popupLevel.callDown(), this.popupDown = !0, this.playButton.pos.y = -200, this.settingsButton.pos.y = -300, _SETTINGS.MoreGames.Enabled && this.moreButton.hide())
		},
		changeSoundStar: function() {
			this.testSoundStar++;
			2 < this.testSoundStar && (this.testSoundStar = 0)
		},
		startTutorial: function() {
			this.tutorial.startTutorial()
		},
		draw: function() {
			this.parent();
			if (!ig.global.wm) {
				var c = ig.system.context;
				c.save();
				ig.game.assetsReady ? c.clearRect(0, 0, ig.system.width, ig.system.height) : (c.font = "36px twcen", c.textAlign = "center", c.fillStyle = "white", c.fillText("Preparing assets", 0.5 * ig.system.width, 0.5 * ig.system.height), c.textAlign = "left");
				if ("mainmenu" == this.stateMachine) c.drawImage(this.titleGame.data, 0, 0, this.titleGame.width, this.titleGame.height,
					ig.system.width / 2 - this.titleGame.width / 2, 0.25 * ig.system.height - 0.5 * this.titleGame.height, this.titleGame.width, this.titleGame.height);
				else if ("game" == this.stateMachine) this.gun.readyToShoot ? this.crosshair.draw(0.5 * ig.system.width - 0.25 * this.crosshair.width, 0.5 * ig.system.height - 0.5 * this.crosshair.height, 0, 0, 42, 42) : this.crosshair.draw(0.5 * ig.system.width - 0.25 * this.crosshair.width, 0.5 * ig.system.height - 0.5 * this.crosshair.height, 42, 0, 42, 42);
				else if ("win" == this.stateMachine || "lose" == this.stateMachine || "pause" ==
					this.stateMachine) c.fillStyle = "#000000", c.globalAlpha = 0.8, c.fillRect(0, 0, ig.system.width, ig.system.height), c.globalAlpha = 1;
				c.restore()
			}
		}
	})
});
ig.baked = !0;
ig.module("game.levels.webgl-game").requires("impact.image", "game.entities.webgl.webgl-control-game").defines(function() {
	LevelWebglGame = {
		entities: [{
			type: "EntityWebglControlGame",
			x: 0,
			y: 0
		}],
		layer: []
	}
});
ig.baked = !0;
ig.module("game.entities.controllers.level-end-controller").requires("impact.entity").defines(function() {
	EntityLevelEndController = ig.Entity.extend({
		size: {
			x: 40,
			y: 40
		},
		pos: {
			x: 1,
			y: 1
		},
		name: "LevelEndController",
		endText: "Thank you for playing",
		fontSetting: "Arial 20px",
		endColor: "rgba(255,255,255,1)",
		init: function(c, b, e) {
			this.parent(c, b, e);
			c = ig.game.score;
			null === ig.game.scorelist ? ig.game.scorelist = new BinaryHeap(function(b) {
				return b.val
			}, !0) : 3 > ig.game.scorelist.size() || ig.game.scorelist.content.pop();
			ig.game.scorelist.push({
				val: c
			})
		},
		update: function() {
			this.parent()
		},
		draw: function() {
			this.parent();
			ig.global.wm || (ig.system.context.clearRect(0, 0, ig.system.width, ig.system.height), this.drawEnd(ig.system.context))
		},
		drawEnd: function(c) {
			var b = c.font + "";
			c.font = this.fontSetting;
			c.fillStyle = this.endColor;
			c.textAlign = "center";
			var e = ig.system.width >>> 1,
				d = ig.system.height >>> 1;
			c.fillText("High Score Board", e, d - (d >>> 1) - 20);
			for (var f = 0; f < ig.game.scorelist.size(); f++) c.fillText(ig.game.scorelist.content[f].val, e, d - (d >>> 1) + 20 * f);
			c.fillText(this.endText,
				e, d);
			c.fillText(ig.game.score, e, d + 20);
			c.textAlign = "start";
			c.font = b
		}
	})
});
ig.baked = !0;
ig.module("game.levels.end").requires("impact.image", "game.entities.controllers.level-end-controller", "game.entities.pointer", "game.entities.buttons.button-retry").defines(function() {
	LevelEnd = {
		entities: [{
			type: "EntityLevelEndController",
			x: 0,
			y: 0
		}, {
			type: "EntityPointer",
			x: 316,
			y: 80
		}, {
			type: "EntityButtonRetry",
			x: 296,
			y: 296
		}],
		layer: []
	}
});
ig.baked = !0;
ig.module("babylon.plugins.wgl-game").defines(function() {
	wgl.Game = ig.Class.extend({
		entities: [],
		ready: !1,
		init: function() {},
		update: function() {
			this.entitiesIndexToKill = [];
			for (var c = 0; c < this.entities.length; c++) this.entities[c] && (this.entities[c].update(), this.entities[c]._killed && this.entitiesIndexToKill.push(c));
			for (c = this.entitiesIndexToKill.length - 1; 0 <= c; c--) this.entities.splice(this.entitiesIndexToKill[c], 1)
		},
		render: function() {
			this.currentScene && this.currentScene.render()
		},
		spawnEntity: function(c,
			b, e, d, f) {
			c = new c(b, e, d, f);
			this.entities.push(c);
			return c
		},
		getEntityByName: function(c) {
			for (var b = [], e = 0; e < this.entities.length; e++) this.entities[e].name === c && b.push(this.entities[e]);
			return b
		},
		getMeshByName: function(c) {
			for (var b = 0; b < this.currentScene.meshes.length; b++)
				if (this.currentScene.meshes[b].name === c) return this.currentScene.meshes[b];
			return null
		},
		resizeAll: function() {
			for (var c = 0; c < this.entities.length; c++) this.entities[c].resize()
		}
	})
});
ig.baked = !0;
ig.module("babylon.plugins.wgl-timer").defines(function() {
	wgl.Timer = ig.Class.extend({
		target: 0,
		base: 0,
		last: 0,
		pausedAt: 0,
		init: function(c) {
			this.last = this.base = wgl.Timer.time;
			this.target = c || 0
		},
		set: function(c) {
			this.target = c || 0;
			this.base = wgl.Timer.time;
			this.pausedAt = 0
		},
		reset: function() {
			this.base = wgl.Timer.time;
			this.pausedAt = 0
		},
		tick: function() {
			var c = wgl.Timer.time - this.last;
			this.last = wgl.Timer.time;
			return this.pausedAt ? 0 : c
		},
		delta: function() {
			return (this.pausedAt || wgl.Timer.time) - this.base - this.target
		},
		pause: function() {
			this.pausedAt ||
				(this.pausedAt = wgl.Timer.time)
		},
		unpause: function() {
			this.pausedAt && (this.base += wgl.Timer.time - this.pausedAt, this.pausedAt = 0)
		}
	});
	wgl.Timer._last = 0;
	wgl.Timer.time = Number.MIN_VALUE;
	wgl.Timer.timeScale = 1;
	wgl.Timer.maxStep = 0.05;
	wgl.Timer.step = function() {
		var c = Date.now();
		wgl.Timer.time += Math.min((c - wgl.Timer._last) / 1E3, wgl.Timer.maxStep) * wgl.Timer.timeScale;
		wgl.Timer._last = c
	}
});
ig.baked = !0;
ig.module("babylon.plugins.wgl-system").requires("babylon.plugins.wgl-timer").defines(function() {
	wgl.System = ig.Class.extend({
		fps: null,
		tick: 0,
		loader: null,
		assets: {},
		canvas: null,
		engine: null,
		progress: 0,
		babylonJSSupport: !1,
		finishLoadFunctions: [],
		finishSceneReadyFunctions: [],
		tempNewScene: null,
		canvas: null,
		started: !1,
		isrendering: !1,
		init: function(c, b) {
			this.fps = b;
			this.canvas = ig.$(c);
			if (BABYLON.Engine.isSupported()) this.engine = new BABYLON.Engine(this.canvas, !1), this.babylonJSSupport = !0;
			else throw "BabylonJS not supported";
		},
		loadScene: function(c, b) {
			wgl.game.ready = !1;
			if (this.babylonJSSupport) BABYLON.SceneLoader.Load(c, b, this.engine, this.onLoadSuccess.bind(this), this.progressCallback.bind(this), this.onLoadError.bind(this));
			else throw "Unable to load scene because BabylonJS is not supported";
		},
		progressCallback: function(c) {
			this.progress = c;
			console.log("Progress:", c.loaded, "out of: " + c.total)
		},
		onLoadSuccess: function(c) {
			console.log("load scene success");
			wgl.game.currentScene && wgl.game.currentScene.dispose();
			wgl.game.currentScene =
				c;
			for (c = 0; c < this.finishLoadFunctions.length; c++) this.finishLoadFunctions[c]();
			this.loader = new BABYLON.AssetsManager(wgl.game.currentScene);
			wgl.game.currentScene.executeWhenReady(this.onSceneReady.bind(this))
		},
		onLoadError: function(c) {
			console.log("ERROR:" + c)
		},
		onSceneReady: function() {
			wgl.debug.debug && wgl.debug.enableDebug();
			this.loadCameras();
			this.loadMeshes();
			this.registerBeforeRender();
			for (var c = 0; c < this.finishSceneReadyFunctions.length; c++) this.finishSceneReadyFunctions[c]();
			wgl.system.engine.hideLoadingUI();
			wgl.game.ready = !0
		},
		registerBeforeRender: function() {
			wgl.game.currentScene.registerBeforeRender(this.advanceTime.bind(this));
			wgl.game.currentScene.registerBeforeRender(wgl.game.update.bind(wgl.game));
			this.startRender()
		},
		startRender: function() {
			this.isrendering || (this.engine.runRenderLoop(wgl.game.render.bind(wgl.game)), this.isrendering = !0)
		},
		stopRender: function() {
			this.isrendering && (this.engine.stopRenderLoop(), this.isrendering = !1)
		},
		unregisterBeforeRender: function() {
			wgl.game.currentScene && (wgl.game.currentScene.unregisterBeforeRender(this.advanceTime.bind(this)),
				wgl.game.currentScene.unregisterBeforeRender(wgl.game.update.bind(wgl.game)), wgl.game.currentScene.onBeforeRenderObservable.clear(), this.stopRender())
		},
		loadMeshes: function() {
			for (var c = wgl.game.currentScene.meshes, b = 0; b < c.length; b++) {
				var e = c[b].name.split(":");
				if (1 < e.length) {
					c[b].id = e[0];
					c[b].name = e[0];
					for (var d = "", e = e[1].split("."), e = e[0].split("-"), f = 0; f < e.length; f++) var g = "" + e[f],
						g = g.charAt(0).toUpperCase() + g.slice(1),
						d = d + g;
					0 < d.length && wgl.game.entities.push(new wgl.modules[d](c[b].position.x, c[b].position.y,
						c[b].position.z, {
							mesh: c[b]
						}))
				}
			}
		},
		loadCameras: function() {
			for (var c = wgl.game.currentScene.cameras, b = 0; b < c.length; b++) {
				var e = c[b].name.split(":");
				if (1 < e.length) {
					c[b].id = e[0];
					c[b].name = e[0];
					for (var d = "", e = e[1].split("."), e = e[0].split("-"), f = 0; f < e.length; f++) var g = "" + e[f],
						g = g.charAt(0).toUpperCase() + g.slice(1),
						d = d + g;
					wgl.game.entities.push(new wgl.modules[d](c[b].position.x, c[b].position.y, c[b].position.z, {
						camera: c[b]
					}))
				}
			}
		},
		advanceTime: function() {
			wgl.Timer.step();
			this.tick = this.engine.getDeltaTime()
		}
	})
});
ig.baked = !0;
ig.module("babylon.plugins.wgl-debug").defines(function() {
	wgl.Debug = ig.Class.extend({
		debug: !1,
		init: function() {},
		enableDebug: function() {
			wgl.game.currentScene.debugLayer.show()
		},
		axis2: function(c, b) {
			var e = BABYLON.Mesh.CreateCylinder("x", b, 0.1, 0.1, 6, 4, c, !1);
			e.material = new BABYLON.StandardMaterial("xColor", c);
			e.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
			e.position = new BABYLON.Vector3(b / 2, 0, 0);
			e.rotation.z = Math.PI >>> 1;
			e = BABYLON.Mesh.CreateCylinder("y", b, 0.1, 0.1, 6, 4, c, !1);
			e.material = new BABYLON.StandardMaterial("yColor", c);
			e.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
			e.position = new BABYLON.Vector3(0, b / 2, 0);
			e = BABYLON.Mesh.CreateCylinder("z", b, 0.1, 0.1, 6, 4, c, !1);
			e.material = new BABYLON.StandardMaterial("zColor", c);
			e.material.diffuseColor = new BABYLON.Color3(0, 0, 1);
			e.position = new BABYLON.Vector3(0, 0, b / 2);
			e.rotation.x = Math.PI >>> 1
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.camera").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Camera = wgl.Entity.extend({
		size: {
			x: 0,
			y: 0,
			z: 0
		},
		material: null,
		mesh: null,
		accelerometerController: !1,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			this.createFreeCamera()
		},
		update: function() {
			this.parent();
			if (this.accelerometerController) {
				var c = ig.system.context;
				c.font = "20px Arial";
				c.fillStyle = "#000000";
				c.fillText("x:" + this.xValue + ",y:" + this.yValue + ",rotation:" + this.Rotation, 10, 30)
			}
		},
		createFreeCamera: function() {
			ig.ua.mobile ?
				ig.game.camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5.3, 10), this.main.scene) : (ig.game.camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5.3, 10), this.main.scene), ig.game.camera.inputs.removeByType("FreeCameraKeyboardMoveInput"), ig.game.camera.angularSensibility = 800);
			ig.game.camera.rotation.y = -0.07353018465453931;
			ig.game.camera.attachControl(window)
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.shotgun").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Shotgun = wgl.Entity.extend({
		gunInitPos: {
			x: 1,
			y: 0.8,
			z: -7
		},
		gunPos: {
			x: 0,
			y: 0,
			z: 0
		},
		gunRot: {
			x: -1.5708,
			y: 1.5708,
			z: 0
		},
		meshColor: {
			R: 252 / 255,
			G: 183 / 255,
			B: 109 / 255
		},
		readyToShoot: !0,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			this.loadMesh()
		},
		update: function() {
			this.parent();
			ig.game.shotgun && (ig.game.shotgun.position.z = ig.game.camera.position.z + this.gunInitPos.z + this.gunPos.z, ig.game.shotgun.position.x = ig.game.camera.position.x +
				this.gunInitPos.x + this.gunPos.x, ig.game.shotgun.position.y = -this.gunInitPos.y + this.gunPos.y)
		},
		shoot: function() {
			if (this.readyToShoot && 0 < this.main.bulletGun) {
				var c = ig.game.barrelPoint._absolutePosition.x,
					b = ig.game.barrelPoint._absolutePosition.y,
					e = ig.game.barrelPoint._absolutePosition.z,
					d = c - ig.game.stock._absolutePosition.x,
					f = b - ig.game.stock._absolutePosition.y,
					g = e - ig.game.stock._absolutePosition.z;
				Math.sqrt(d * d + f * f + g * g);
				this.recoilTween();
				this.readyToShoot = !1;
				ig.game.particles && (this.particles = wgl.game.spawnEntity(wgl.modules.Firesparks,
					c, b, e, {
						main: this
					}));
				this.main.scene.getEngine().getRenderWidth();
				this.main.scene.getEngine().getRenderHeight();
				this.main.bulletUsed += 1;
				c = ig.game.camera.position;
				b = new BABYLON.Vector3(0, 0, 1);
				e = ig.game.camera.getWorldMatrix();
				b = BABYLON.Vector3.TransformCoordinates(b, e);
				b = b.subtract(c);
				b = BABYLON.Vector3.Normalize(b);
				c = new BABYLON.Ray(c, b, 500);
				c = this.main.scene.pickWithRay(c);
				if (c.hit)
					if ("bottle" == c.pickedMesh.name)
						for (b = 0; b < this.main.bottles.length; b++) {
							if (e = this.main.bottles[b], c.pickedMesh == e.mesh) {
								e.getShoot();
								this.main.bulletHit += 1;
								break
							}
						} else 0 >= this.main.bulletGun && this.main.loseLevel();
				1 == ig.game.control.tutorial.tutorialStep && ig.game.control.tutorial.endTutorial();
				ig.soundHandler.sfxPlayer.play("shooting")
			}
		},
		checkBottles: function() {
			var c = ig.game.camera.position,
				b = new BABYLON.Vector3(0, 0, 1),
				e = ig.game.camera.getWorldMatrix(),
				b = BABYLON.Vector3.TransformCoordinates(b, e),
				b = b.subtract(c),
				b = BABYLON.Vector3.Normalize(b),
				c = new BABYLON.Ray(c, b, 500),
				c = this.main.scene.pickWithRay(c);
			return c.hit && "bottle" == c.pickedMesh.name ?
				!0 : !1
		},
		recoilTween: function() {
			this.gunIdle && this.gunIdle.stop();
			this.tween({
				gunPos: {
					x: 0,
					y: 0,
					z: -1
				},
				gunRot: {
					x: -1.5708,
					y: 1.5708,
					z: 0
				}
			}, 0.1, {
				delay: 0,
				easing: ig.Tween.Easing.Linear.EaseNone,
				onComplete: function() {
					this.readyToShoot = !0;
					this.tween({
						gunPos: {
							x: 0,
							y: 0,
							z: 0
						},
						gunRot: {
							x: -1.5708,
							y: 1.5708,
							z: 0
						}
					}, 0.3, {
						delay: 0,
						easing: ig.Tween.Easing.Linear.EaseNone,
						onComplete: function() {
							this.idleAnimation()
						}.bind(this)
					}).start()
				}.bind(this)
			}).start()
		},
		idleAnimation: function() {
			this.gunIdle = this.tween({
				gunPos: {
					x: 0,
					y: 0.03,
					z: 0
				}
			}, 1, {
				loop: 2,
				delay: 0,
				easing: ig.Tween.Easing.Sinusoidal.EaseInOut,
				onComplete: function() {}.bind(this)
			});
			this.gunIdle.start()
		},
		loadMesh: function() {
			var c = this.gunInitPos,
				b = this.main.scene;
			BABYLON.SceneLoader.ImportMesh("Shotgun", "media/models/", "shotgun.babylon", b, function(e) {
				ig.game.shotgun = e[0];
				ig.game.shotgun.parent = ig.game.camera;
				for (var d = 0; d < e.length; d++) {
					var f = e[d];
					f.material && (f.material.diffuseColor = new BABYLON.Color3(1, 1, 1), f.convertToFlatShadedMesh())
				}
				ig.game.shotgun.position.z = ig.game.camera.position.z +
					c.z;
				ig.game.shotgun.position.x = ig.game.camera.position.x + c.x;
				ig.game.shotgun.position.y = c.y;
				ig.game.mesh = ig.game.shotgun;
				ig.game.barrelPoint = BABYLON.Mesh.CreateBox("barrel", 0.35, b);
				ig.game.barrelPoint.parent = ig.game.mesh;
				ig.game.barrelPoint.material = new BABYLON.StandardMaterial("material01", b);
				ig.game.barrelPoint.material.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
				ig.game.barrelPoint.visibility = 0;
				ig.game.stock = BABYLON.Mesh.CreateBox("stock", 0.35, b);
				ig.game.stock.parent = ig.game.mesh;
				ig.game.stock.material =
					new BABYLON.StandardMaterial("material01", b);
				ig.game.stock.material.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
				ig.game.stock.position.x -= 0.7;
				ig.game.stock.visibility = 0;
				ig.game.stock.isPickable = !1;
				ig.game.barrelPoint.isPickable = !1
			})
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.bullet").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Bullet = wgl.Entity.extend({
		speed: 50,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			d.velocityFactor && (this.vel.x = d.velocityFactor.x * this.speed, this.vel.y = d.velocityFactor.y * this.speed, this.vel.z = d.velocityFactor.z * this.speed);
			d = BABYLON.Mesh.CreateSphere("sphere", 4, 0.4, this.main.scene);
			d.material = new BABYLON.StandardMaterial("material01", this.main.scene);
			d.material.diffuseColor = new BABYLON.Color3(1,
				0.2, 0.2);
			d.position = new BABYLON.Vector3(c, b, e);
			d.visibility = 1;
			this.mesh = d;
			this.mesh.body = new BABYLON.PhysicsImpostor(this.mesh, BABYLON.PhysicsImpostor.SphereImpostor, {
				mass: 1,
				restitution: 0.6
			}, this.main.scene);
			this.targets = this.main.bottles;
			this.checkNextButton = this.main.scene.getMeshByName("next")
		},
		update: function() {
			this.parent();
			this.pos.x -= this.vel.x * wgl.system.tick / 1E3;
			this.pos.y -= this.vel.y * wgl.system.tick / 1E3;
			this.pos.z -= this.vel.z * wgl.system.tick / 1E3;
			this.mesh && (this.mesh.position.x = this.pos.x,
				this.mesh.position.y = this.pos.y, this.mesh.position.z = this.pos.z);
			for (var c = 0; c < this.targets.length; c++) {
				var b = this.targets[c];
				this.mesh.intersectsMesh(b.mesh, !1) && (this.kill(), b.kill(), this.targets.splice(c, 1), 0 >= this.main.checkTarget() && this.main.winLevel())
			}
			this.checkNextButton && this.mesh.intersectsMesh(this.checkNextButton, !1) && (this.checkNextButton.dispose(), this.kill(), this.main.level++, this.main.spawnMeshByLevel());
			if (250 < this.pos.x || -250 > this.pos.x || 250 < this.pos.z || -250 > this.pos.z) this._killed ||
				this.kill()
		},
		kill: function() {
			this.mesh.dispose();
			this.parent()
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.firesparks").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Firesparks = wgl.Entity.extend({
		size: {
			x: 0,
			y: 0,
			z: 0
		},
		time: 0.1,
		meshColor: new BABYLON.Color3(1, 1, 1),
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			this.createParticles()
		},
		createParticles: function() {
			this.particleSystem = new BABYLON.ParticleSystem("particles", 100, this.main.main.scene);
			this.particleSystem.particleTexture = new BABYLON.Texture("media/graphics/sprites/sparks.png", this.main.main.scene);
			this.particleSystem.emitter =
				ig.game.shotgun;
			this.particleSystem.minEmitBox = new BABYLON.Vector3(-1.5, 0, 0);
			this.particleSystem.maxEmitBox = new BABYLON.Vector3(-1.5, 0, 0);
			this.particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1, 1);
			this.particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1, 1);
			this.particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0);
			this.particleSystem.minSize = 0.08;
			this.particleSystem.maxSize = 0.15;
			this.particleSystem.minLifeTime = 0.05;
			this.particleSystem.maxLifeTime = 0.1;
			this.particleSystem.emitRate = 500;
			ig.ua.mobile &&
				(this.particleSystem.emitRate = 175);
			this.particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
			this.particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);
			this.particleSystem.direction1 = new BABYLON.Vector3(-8, -1, -1);
			this.particleSystem.direction2 = new BABYLON.Vector3(-6, 1, 1);
			this.particleSystem.minAngularSpeed = 0;
			this.particleSystem.maxAngularSpeed = Math.PI;
			this.particleSystem.minEmitPower = 30;
			this.particleSystem.maxEmitPower = 50;
			this.particleSystem.updateSpeed = 0.005;
			this.particleSystem.start()
		},
		update: function() {
			this.parent();
			0 < this.time ? this.time -= ig.system.tick : this.killed || (this.kill(), this.killed = !0)
		},
		kill: function() {
			this.parent();
			this.particleSystem.stop()
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.bottle").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Bottle = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "bottle",
		scene: null,
		pb: null,
		move: !1,
		upDown: !1,
		moveRotate: !1,
		spMove: 0.05,
		spMoveHolder: 0.025,
		maxMove: 1.5,
		cirRot: 0,
		cMove: {
			x: 0,
			y: 0,
			z: 0
		},
		specialKill: !1,
		bottleType: 0,
		updownMesh: null,
		bottleBreakPart: [],
		waitWiningLevel: null,
		endTrigger: !1,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), d.addingPhysic &&
				this.createImposter(), this.mesh && (this.main.bottles.push(this), this.mesh.position = new BABYLON.Vector3(c, b, e), this.pb = new BABYLON.Vector3(c, b, e), this.updownMesh.position = new BABYLON.Vector3(c, b - 1.5, e)), this.spMove = this.spMoveHolder)
		},
		createMesh: function() {
			0 < ig.game.bottleModels.length && (this.mesh = ig.game.bottleModels[0].clone("bottle"), this.mesh.isVisible = !0, this.mesh.position = new BABYLON.Vector3(0, 5.7, 32));
			this.createMaterial();
			this.updownMesh = BABYLON.Mesh.CreateBox("boxUpDown", 3, this.scene);
			this.updownMesh.material =
				this.material;
			this.updownMesh.isVisible = !1;
			this.updownMesh.scaling = new BABYLON.Vector3(0.3, 1, 0.2)
		},
		createMaterial: function() {
			this.material = new BABYLON.StandardMaterial("material1", this.scene);
			this.material.diffuseColor = new BABYLON.Color3(0.556, 0.243, 0.1)
		},
		createImposter: function() {},
		update: function() {
			this.parent();
			this.move && (this.mesh || 0 < this.meshes.length) ? this.leftRightMove() : this.upDown && (this.mesh || 0 < this.meshes.length) ? this.upDownMove() : this.moveRotate && (this.mesh || 0 < this.meshes.length) && this.moveCircle(this.cMove.x,
				this.cMove.y, this.cMove.z);
			this.addingPhysic && (this.mesh && -4 >= this.mesh.position.y) && (this.specialKill = !0, this.killImposter(), this.mesh.dispose(), this.kill());
			this.waitWiningLevel && (0 < this.waitWiningLevel.delta() && !1 == this.endTrigger) && (this.main.winLevel(), this.endTrigger = !0)
		},
		leftRightMove: function() {
			this.mesh.position.x += this.spMove;
			this.mesh.position.x > this.pb.x + this.maxMove ? this.spMove = -this.spMoveHolder : this.mesh.position.x < this.pb.x - this.maxMove && (this.spMove = this.spMoveHolder)
		},
		upDownMove: function() {
			this.updownMesh.isVisible ||
				(this.updownMesh.isVisible = !0);
			this.mesh.position.y += this.spMove;
			this.updownMesh.position.y += this.spMove;
			this.mesh.position.y > this.pb.y + this.maxMove ? this.spMove = -this.spMoveHolder : this.mesh.position.y < this.pb.y - this.maxMove && (this.spMove = this.spMoveHolder, this.mesh.isDisposed() && this.updownMesh.dispose())
		},
		followingMovement: function(c, b, e) {
			this.mesh.position.x += c;
			this.mesh.position.y += b;
			this.mesh.position.z += e
		},
		moveCircle: function(c, b, e) {
			0 != c && (this.mesh.position.x = this.pb.x + Math.cos(this.cirRot) *
				this.maxMove);
			0 != b && (this.mesh.position.y = this.pb.y + Math.sin(this.cirRot) * this.maxMove);
			0 != e && (this.mesh.position.z = this.pb.z + Math.sin(this.cirRot) * this.maxMove);
			this.cirRot += 0.01
		},
		killImposter: function() {
			this.mesh.body && this.mesh.body.dispose()
		},
		flyingShoot: function() {
			this.mesh.body && (this.mesh.body.wakeUp(), this.mesh.body.setLinearVelocity(new BABYLON.Vector3(1, 10, 4)), this.mesh.body.setAngularVelocity(new BABYLON.Quaternion(1, 0, 1, 0)))
		},
		getShoot: function() {
			if (this.mesh) {
				this.mesh.dispose();
				for (var c =
						0; c < this.main.bottles.length; c++)
					if (this.main.bottles[c] == this) {
						this.main.bottles.splice(c, 1);
						break
					}
				0 >= this.main.bottles.length && (this.waitWiningLevel = new ig.Timer, this.waitWiningLevel.set(1), this.main.uiBoard.pauseTime(), ig.game.control.waitWinning = !0, ig.game.control.uiBoard.showRedBar = !1);
				this.addingPhysic || (this.mesh.dispose(), this.kill())
			}
			this.main.addingbreakglass && ig.game.breakGlassParticle.activeParticle(this.mesh.position.x, this.mesh.position.y + 1.1, this.mesh.position.z);
			c = "glassBreak" + Math.floor(4 *
				Math.random() + 1);
			ig.soundHandler.sfxPlayer.play(c)
		},
		kill: function() {
			this.parent();
			this.mesh && this.mesh.dispose();
			this.updownMesh.isVisible && this.updownMesh.dispose();
			if (this.specialKill) {
				for (var c = 0; c < this.main.bottles.length; c++)
					if (this.main.bottles[c] == this) {
						this.main.bottles.splice(c, 1);
						break
					}
				0 >= this.main.bottles.length && this.main.winLevel()
			}
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.bottle-break").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.BottleBreak = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "bottle-break",
		scene: null,
		pb: null,
		move: !0,
		upDown: !1,
		cirRot: 0,
		specialKill: !1,
		bottleType: 0,
		bottleBreakPart: [],
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), d.addingPhysic && this.createImposter(), this.mesh && (this.mesh.position = new BABYLON.Vector3(c, b, e), this.pb = new BABYLON.Vector3(c,
				b, e)))
		},
		createMesh: function() {
			if (0 < ig.game.bottleModels.length) {
				this.mesh = ig.game.bottleModels[0].clone("bottle");
				this.mesh.position = new BABYLON.Vector3(0, 5.7, 32);
				for (var c = this.mesh.getChildren(), b = 0; b < c.length; b++) this.bottleBreakPart[b] = c[b], this.bottleBreakPart[b].isVisible = !0
			}
			this.createMaterial()
		},
		createMaterial: function() {
			this.material = new BABYLON.StandardMaterial("material1", this.scene);
			this.material.diffuseColor = new BABYLON.Color3(0.556, 0.243, 0.1)
		},
		createImposter: function() {
			for (var c = 0; c <
				this.bottleBreakPart.length; c++) {
				var b = this.bottleBreakPart[c];
				b.body = new BABYLON.PhysicsImpostor(b, BABYLON.PhysicsImpostor.CylinderImpostor, {
					mass: 0.2,
					restitution: 0
				}, this.scene)
			}
		},
		update: function() {
			this.parent();
			this.move && (this.bottleBreakPart[2].body.setLinearVelocity(new BABYLON.Vector3(1, 10, 4)), this.move = !1, console.log("as"))
		},
		killImposter: function() {
			this.mesh.body && this.mesh.body.dispose()
		},
		kill: function() {
			this.parent();
			this.mesh && this.mesh.dispose()
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.next").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Next = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "next",
		scene: null,
		zIndex: 10001,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), this.createMaterial(), d.addingPhysic && this.createImposter(), this.mesh.position = new BABYLON.Vector3(c, b, e))
		},
		createMesh: function() {
			this.mesh = BABYLON.Mesh.CreatePlane(this.name, 2, this.scene)
		},
		createMaterial: function() {
			this.material =
				new BABYLON.StandardMaterial("materialNext", this.scene);
			this.material.diffuseColor = new BABYLON.Color3(1, 0, 1);
			this.mesh && (this.mesh.material = this.material)
		},
		createImposter: function() {
			this.mesh.body = new BABYLON.PhysicsImpostor(this.mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
				mass: 1E3,
				restitution: 0
			}, this.scene);
			this.mesh.body.sleep()
		},
		killImposter: function() {
			this.mesh.body && (this.mesh.body.dispose(), this.mesh.body = null())
		},
		kill: function() {
			this.mesh && (this.mesh.dispose(), this.killImposter());
			this.parent()
		},
		update: function() {}
	})
});
ig.baked = !0;
ig.module("babylon.entities.obstacle").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Obstacle = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "obstacle",
		scene: null,
		pb: null,
		move: !1,
		upDown: !1,
		spMove: 0.035,
		maxMove: 1.5,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), this.createMaterial(), d.addingPhysic && this.createImposter(), this.mesh.position = new BABYLON.Vector3(c, b, e), this.pb = new BABYLON.Vector3(c, b, e))
		},
		createMesh: function() {
			this.mesh =
				BABYLON.Mesh.CreatePlane(this.name, 2, this.scene)
		},
		createMaterial: function() {
			this.material = new BABYLON.StandardMaterial("material1", this.scene);
			this.material.diffuseColor = new BABYLON.Color3(0.66, 0.43, 0.18);
			this.mesh && (this.mesh.material = this.material)
		},
		createImposter: function() {
			this.mesh.body = new BABYLON.PhysicsImpostor(this.mesh, BABYLON.PhysicsImpostor.CylinderImpostor, {
				mass: 0.1,
				restitution: 0
			}, this.scene)
		},
		update: function() {
			this.parent();
			this.move && (this.mesh || 0 < this.meshes.length) ? this.leftRightMove() :
				this.upDown && (this.mesh || 0 < this.meshes.length) && this.upDownMove()
		},
		leftRightMove: function() {
			this.mesh.position.x += this.spMove;
			this.mesh.position.x > this.pb.x + this.maxMove ? this.spMove = -0.035 : this.mesh.position.x < this.pb.x - this.maxMove && (this.spMove = 0.035)
		},
		upDownMove: function() {
			this.mesh.position.y += this.spMove;
			this.mesh.position.y > this.pb.y + this.maxMove ? this.spMove = -0.035 : this.mesh.position.y < this.pb.y - this.maxMove && (this.spMove = 0.035)
		},
		killImposter: function() {
			this.mesh.body && (this.mesh.body.dispose(),
				this.mesh.body = null())
		},
		kill: function() {
			this.mesh && (this.mesh.dispose(), this.killImposter());
			this.parent()
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.barel").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Barel = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "barel",
		scene: null,
		move: !1,
		scalingMesh: {
			x: 1,
			y: 1,
			z: 1
		},
		pb: null,
		spMove: 0.05,
		maxMove: 25,
		constMovement: 0.07,
		follow: [],
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), d.addingPhysic && this.createImposter(), this.mesh && (this.mesh.position = new BABYLON.Vector3(c, b - 0.4, e), this.pb = new BABYLON.Vector3(c,
				b, e)))
		},
		createMesh: function() {
			if (null != ig.game.barelModel || void 0 != ig.game.barelModel) this.mesh = ig.game.barelModel.clone(ig.game.barelModel.name), this.mesh.isVisible = !0, this.mesh.position = new BABYLON.Vector3(0, 5.7, 32), this.mesh.name = "barel"
		},
		createMaterial: function() {
			this.material = new BABYLON.StandardMaterial("material1", this.scene);
			this.material.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
			this.mesh && (this.mesh.material = this.material)
		},
		createImposter: function() {
			this.mesh.body = new BABYLON.PhysicsImpostor(this.mesh,
				BABYLON.PhysicsImpostor.BoxImpostor, {
					mass: 1E3,
					restitution: 0
				}, this.scene);
			this.mesh.body.sleep()
		},
		killImposter: function() {
			this.mesh.body && (this.mesh.body.dispose(), this.mesh.body = null())
		},
		kill: function() {
			this.mesh && (this.mesh.dispose(), this.killImposter());
			this.parent()
		},
		update: function() {
			if (this.move && (this.leftRightMove(), 0 < this.follow.length))
				for (var c = 0; c < this.follow.length; c++) this.follow[c].followingMovement(this.spMove, 0, 0)
		},
		leftRightMove: function() {
			this.mesh.position.x += this.spMove;
			this.mesh.position.x >
				this.pb.x + this.maxMove ? this.spMove = -this.constMovement : this.mesh.position.x < this.pb.x - this.maxMove && (this.spMove = this.constMovement)
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.barelrotate").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Barelrotate = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "barelrotate",
		scene: null,
		move: !1,
		scalingMesh: {
			x: 1,
			y: 1,
			z: 1
		},
		pb: null,
		spMove: 0.05,
		maxMove: 25,
		constMovement: 0.07,
		meshHolder: [],
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), this.createMaterial(), d.addingPhysic && this.createImposter(), this.mesh.position = new BABYLON.Vector3(c, b, e),
				this.pb = new BABYLON.Vector3(c, b, e))
		},
		createMesh: function() {
			this.mesh = BABYLON.Mesh.CreateCylinder(this.name, 8, 6, 6, 8, 1, this.scene);
			this.mesh.scaling.x = this.scalingMesh.x;
			this.mesh.scaling.y = this.scalingMesh.y
		},
		createTableMeshHolder: function(c, b, e) {
			var d = BABYLON.MeshBuilder.CreateBox("holderBox", {
				width: 3,
				height: 0.3,
				depth: 2
			}, this.scene);
			d.position.x = c;
			d.position.y = b - 1.2;
			d.position.z = e;
			d.material = this.material;
			d.parent = this.mesh;
			this.meshHolder.push(d)
		},
		createMaterial: function() {
			this.material = new BABYLON.StandardMaterial("material1",
				this.scene);
			this.material.diffuseColor = new BABYLON.Color3(0.84, 0.4, 0.1);
			this.material.specularColor = BABYLON.Color3.Black();
			this.mesh && (this.mesh.material = this.material)
		},
		createImposter: function() {
			this.mesh.body = new BABYLON.PhysicsImpostor(this.mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
				mass: 1E3,
				restitution: 0
			}, this.scene);
			this.mesh.body.sleep()
		},
		killImposter: function() {
			this.mesh.body && (this.mesh.body.dispose(), this.mesh.body = null())
		},
		kill: function() {
			this.mesh && (this.mesh.dispose(), this.killImposter());
			this.parent()
		},
		update: function() {
			this.move && this.rotating()
		},
		rotating: function() {
			this.mesh.rotation.y += 0.01
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.smallbox").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Smallbox = wgl.Entity.extend({
		mesh: null,
		material: null,
		name: "sbox",
		scene: null,
		move: !1,
		scalingMesh: {
			x: 1,
			y: 1,
			z: 1
		},
		pb: null,
		spMove: 0.05,
		maxMove: 25,
		constMovement: 0.07,
		follow: [],
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = d.main.scene, this.createMesh(), this.createMaterial(), d.addingPhysic && this.createImposter(), this.mesh.position = new BABYLON.Vector3(c, b, e), this.pb = new BABYLON.Vector3(c,
				b, e))
		},
		createMesh: function() {
			this.mesh = BABYLON.Mesh.CreateBox(this.name, 2, this.scene);
			this.mesh.scaling.x = this.scalingMesh.x;
			this.mesh.scaling.y = this.scalingMesh.y
		},
		createMaterial: function() {
			this.material = new BABYLON.StandardMaterial("material1", this.scene);
			this.material.diffuseColor = new BABYLON.Color3(75, 75, 75);
			this.mesh && (this.mesh.material = this.material)
		},
		createImposter: function() {
			this.mesh.body = new BABYLON.PhysicsImpostor(this.mesh, BABYLON.PhysicsImpostor.BoxImpostor, {
					mass: 1E3,
					restitution: 0
				},
				this.scene);
			this.mesh.body.sleep()
		},
		killImposter: function() {
			this.mesh.body && (this.mesh.body.dispose(), this.mesh.body = null())
		},
		kill: function() {
			this.mesh && (this.mesh.dispose(), this.killImposter());
			this.parent()
		},
		update: function() {
			if (this.move && (this.leftRightMove(), 0 < this.follow.length))
				for (var c = 0; c < this.follow.length; c++) this.follow[c].followingMovement(this.spMove, 0, 0)
		},
		leftRightMove: function() {
			this.mesh.position.x += this.spMove;
			this.mesh.position.x > this.pb.x + this.maxMove ? this.spMove = -this.constMovement :
				this.mesh.position.x < this.pb.x - this.maxMove && (this.spMove = this.constMovement)
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.breakglass").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Breakglass = wgl.Entity.extend({
		mesh: null,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			d = d.main.scene;
			this.mesh = BABYLON.Mesh.CreateBox("breakglass", {
				width: 1,
				height: 4,
				depth: 1
			}, d);
			this.mesh.position = new BABYLON.Vector3(c, b, e);
			this.mesh.visibility = 1;
			this.timer = 0;
			this.particleSystem = new BABYLON.ParticleSystem("breakPart", 1E3, d);
			this.particleSystem.particleTexture = new BABYLON.Texture("media/graphics/sprites/particle-glass.png",
				d);
			this.particleSystem.emitter = this.mesh;
			this.particleSystem.minEmitBox = new BABYLON.Vector3(-0.1, -1.2, 0);
			this.particleSystem.maxEmitBox = new BABYLON.Vector3(0.1, 0, 0);
			this.particleSystem.color1 = new BABYLON.Color4(0.37, 0.65, 0.79, 1);
			this.particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1, 1);
			this.particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0);
			this.particleSystem.minSize = 0.1;
			this.particleSystem.maxSize = 0.4;
			this.particleSystem.minLifeTime = 0.4;
			this.particleSystem.maxLifeTime = 1;
			this.particleSystem.emitRate =
				800;
			ig.ua.mobile && (this.particleSystem.emitRate = 250);
			this.particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;
			this.particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);
			this.particleSystem.direction1 = new BABYLON.Vector3(2, 2, 1);
			this.particleSystem.direction2 = new BABYLON.Vector3(-2, -2, -1);
			this.particleSystem.minAngularSpeed = 0;
			this.particleSystem.maxAngularSpeed = Math.PI;
			this.particleSystem.minEmitPower = 1;
			this.particleSystem.maxEmitPower = 3;
			this.particleSystem.updateSpeed = 0.025
		},
		update: function() {
			this.parent();
			0 < this.timer ? this.timer -= ig.system.tick : 0 >= this.timer && this.particleSystem.stop()
		},
		changePos: function(c, b, e) {
			this.mesh.position.x = c;
			this.mesh.position.y = b;
			this.mesh.position.z = e
		},
		activeParticle: function(c, b, e) {
			this.mesh.position.x = c;
			this.mesh.position.y = b;
			this.mesh.position.z = e;
			this.particleSystem.start();
			this.timer = 0.2
		}
	})
});
ig.baked = !0;
ig.module("babylon.entities.windmill").requires("babylon.plugins.wgl-entity").defines(function() {
	wgl.modules.Windmill = wgl.Entity.extend({
		material: null,
		name: "windmill",
		scene: null,
		windMillMesh: null,
		fanWindMillMesh: null,
		main: null,
		init: function(c, b, e, d) {
			this.parent(c, b, e, d);
			ig.global.wm || (this.scene = this.main.scene, this.createMesh(), d.addingPhysic && this.createImposter())
		},
		createMesh: function() {
			if (this.scene) {
				var c = this.scene.getMeshByName("windmill 1 base");
				if (c) {
					this.windMillMesh = c.clone("windMill");
					this.windMillMesh.isVisible = !0;
					this.windMillMesh.scaling = new BABYLON.Vector3(5, 5, 5);
					for (var c = this.windMillMesh.getChildren(), b = 0; b < c.length; b++) this.fanWindMillMesh = c[b], this.fanWindMillMesh.isVisible = !0;
					this.windMillMesh.position = this.pos
				}
			}
			this.createMaterial()
		},
		createMaterial: function() {},
		createImposter: function() {},
		changeRotation: function(c) {
			this.windMillMesh.rotation = c
		},
		update: function() {
			this.parent();
			this.fanWindMillMesh && (this.fanWindMillMesh.rotation.z += 0.02)
		},
		killImposter: function() {
			this.windMillMesh.body &&
				this.windMillMesh.body.dispose()
		},
		kill: function() {
			this.parent();
			this.killImposter();
			this.windMillMesh && this.windMillMesh.dispose()
		}
	})
});
ig.baked = !0;
ig.module("babylon.game.wgl-main").requires("babylon.plugins.wgl-game", "babylon.plugins.wgl-system", "babylon.plugins.wgl-debug", "babylon.plugins.wgl-game", "babylon.entities.camera", "babylon.entities.shotgun", "babylon.entities.bullet", "babylon.entities.firesparks", "babylon.entities.bottle", "babylon.entities.bottle-break", "babylon.entities.next", "babylon.entities.obstacle", "babylon.entities.barel", "babylon.entities.barelrotate", "babylon.entities.smallbox", "babylon.entities.breakglass", "babylon.entities.windmill").defines(function() {
	MyWGLGame =
		wgl.Game.extend({
			gameover: !1,
			score: 0,
			debug: !1,
			levels: {
				game: "lowpoly_assets1.babylon"
			},
			root: "media/scenes/",
			init: function() {},
			reloadLevel: function() {
				for (wgl.system.unregisterBeforeRender(); 0 < this.entities.length;) this.entities.pop();
				this.gameover = !1
			}
		});
	wgl.webglmain = function(c, b) {
		wgl.debug = new wgl.Debug;
		wgl.system = new wgl.System(c, b);
		wgl.game = new MyWGLGame
	}
});
ig.baked = !0;
ig.module("game.main").requires("impact.game", "plugins.patches.webkit-image-smoothing-patch", "plugins.patches.windowfocus-onMouseDown-patch", "plugins.patches.mouse-move-patch", "plugins.gamedist", "plugins.handlers.dom-handler", "plugins.handlers.size-handler", "plugins.handlers.api-handler", "plugins.audio.sound-handler", "plugins.io.io-manager", "plugins.splash-loader", "plugins.tween", "plugins.url-parameters", "plugins.director", "plugins.impact-storage", "babylon.plugins.Tree", "babylon.plugins.TreeGenerator",
	"babylon.plugins.randomColor", "plugins.branding.splash", "plugins.datastructure.binary-heap", "game.entities.branding-logo-placeholder", "game.entities.buttons.button-more-games", "game.entities.opening-shield", "game.entities.opening-kitty", "game.entities.pointer", "game.entities.pointer-selector", "game.entities.select", "game.levels.opening", "game.levels.main-menu", "game.levels.webgl-game", "game.levels.end", "babylon.game.wgl-main").defines(function() {
	U211.Q7 = function() {
		return typeof U211.H7.q7 === 'function' ? U211.H7.q7.apply(U211.H7, arguments) : U211.H7.q7;
	};
	U211.C4 = function() {
		var Z4 = 2;
		while (Z4 !== 1) {
			switch (Z4) {
				case 2:
					return {
						W1: function() {
							var m4 = 2;
							while (m4 !== 9) {
								switch (m4) {
									case 2:
										var U1 = 2;
										m4 = 1;
										break;
									case 5:
										m4 = U1 === 2 ? 4 : 1;
										break;
									case 4:
										(function() {
											var R4 = 2;
											while (R4 !== 73) {
												switch (R4) {
													case 5:
														R4 = z1 === 2 ? 4 : 8;
														break;
													case 33:
														R4 = z1 === 42 ? 32 : 29;
														break;
													case 16:
														a1 += u1;
														a1 += H1;
														a1 += Q1;
														a1 += T1;
														R4 = 25;
														break;
													case 21:
														R4 = z1 === 5 ? 35 : 33;
														break;
													case 22:
														z1 = 16;
														R4 = 1;
														break;
													case 28:
														var T1 = "f";
														var Q1 = "e";
														var H1 = "d";
														var u1 = "n";
														R4 = 41;
														break;
													case 64:
														N1 += M4;
														R4 = 63;
														break;
													case 41:
														var D1 = "u";
														var N1 = D1;
														N1 += u1;
														R4 = 38;
														break;
													case 29:
														R4 = z1 === 16 ? 28 : 37;
														break;
													case 7:
														var d4 = "l";
														R4 = 6;
														break;
													case 37:
														R4 = z1 === 13 ? 36 : 47;
														break;
													case 61:
														N1 += u1;
														N1 += Q1;
														N1 += H1;
														R4 = 58;
														break;
													case 32:
														a1 += M4;
														a1 += u1;
														R4 = 30;
														break;
													case 25:
														z1 = 42;
														R4 = 1;
														break;
													case 19:
														var P4 = "m";
														R4 = 18;
														break;
													case 51:
														var O4 = "L";
														var B4 = "_";
														var j4 = null;
														R4 = 48;
														break;
													case 62:
														R4 = z1 === 33 ? 61 : 56;
														break;
													case 1:
														R4 = z1 !== 36 ? 5 : 73;
														break;
													case 36:
														var F4 = "G";
														var o1 = "0";
														var n4 = "H";
														var p1 = "V";
														R4 = 51;
														break;
													case 35:
														var L4 = "w";
														R4 = 34;
														break;
													case 8:
														R4 = z1 === 4 ? 7 : 14;
														break;
													case 48:
														z1 = 17;
														R4 = 1;
														break;
													case 56:
														R4 = z1 === 40 ? 55 : 1;
														break;
													case 2:
														var z1 = 2;
														R4 = 1;
														break;
													case 57:
														z1 = 29;
														R4 = 1;
														break;
													case 23:
														var M4 = "i";
														R4 = 22;
														break;
													case 38:
														z1 = 22;
														R4 = 1;
														break;
													case 11:
														var e1 = "Z";
														var Y1 = "q";
														var E1 = "C";
														R4 = 19;
														break;
													case 6:
														z1 = 3;
														R4 = 1;
														break;
													case 46:
														N1 += H1;
														N1 += Q1;
														N1 += T1;
														R4 = 64;
														break;
													case 17:
														R4 = z1 === 29 ? 16 : 24;
														break;
													case 13:
														var i4 = "J";
														var g4 = "3";
														R4 = 11;
														break;
													case 63:
														z1 = 33;
														R4 = 1;
														break;
													case 34:
														z1 = 4;
														R4 = 1;
														break;
													case 74:
														z1 = 36;
														R4 = 1;
														break;
													case 18:
														z1 = 13;
														R4 = 1;
														break;
													case 14:
														R4 = z1 === 3 ? 13 : 17;
														break;
													case 58:
														var a1 = D1;
														R4 = 57;
														break;
													case 47:
														R4 = z1 === 22 ? 46 : 62;
														break;
													case 4:
														var w4 = "a";
														var J4 = "b";
														R4 = 9;
														break;
													case 30:
														z1 = 40;
														R4 = 1;
														break;
													case 55:
														a1 += Q1;
														a1 += H1;
														var y4 = typeof window !== a1 ? window : typeof global !== N1 ? global : j4;
														try {
															var G4 = 2;
															while (G4 !== 62) {
																switch (G4) {
																	case 42:
																		r1 = 14;
																		G4 = 1;
																		break;
																	case 44:
																		f1 += P4;
																		f1 += E1;
																		G4 = 42;
																		break;
																	case 53:
																		c1 += w4;
																		G4 = 52;
																		break;
																	case 5:
																		G4 = r1 === 3 ? 4 : 7;
																		break;
																	case 65:
																		window[c1][I1]();
																		y4[b1] = function() {};
																		G4 = 63;
																		break;
																	case 20:
																		b1 += p1;
																		b1 += n4;
																		b1 += o1;
																		b1 += F4;
																		b1 += Q1;
																		b1 += P4;
																		G4 = 27;
																		break;
																	case 40:
																		var I1 = H1;
																		I1 += d4;
																		I1 += L4;
																		I1 += T1;
																		var c1 = H1;
																		c1 += J4;
																		G4 = 53;
																		break;
																	case 33:
																		r1 = 35;
																		G4 = 1;
																		break;
																	case 26:
																		G4 = r1 === 10 ? 25 : 24;
																		break;
																	case 31:
																		var b1 = B4;
																		b1 += O4;
																		G4 = 29;
																		break;
																	case 41:
																		G4 = r1 === 35 ? 40 : 51;
																		break;
																	case 24:
																		G4 = r1 === 25 ? 23 : 32;
																		break;
																	case 32:
																		G4 = r1 === 20 ? 31 : 28;
																		break;
																	case 8:
																		r1 = 7;
																		G4 = 1;
																		break;
																	case 10:
																		G4 = r1 === 18 ? 20 : 26;
																		break;
																	case 50:
																		f1 += Y1;
																		f1 += e1;
																		f1 += g4;
																		f1 += i4;
																		G4 = 46;
																		break;
																	case 11:
																		r1 = 3;
																		G4 = 1;
																		break;
																	case 51:
																		G4 = r1 === 14 ? 50 : 45;
																		break;
																	case 28:
																		G4 = r1 === 7 ? 44 : 41;
																		break;
																	case 2:
																		var r1 = 2;
																		G4 = 1;
																		break;
																	case 23:
																		b1 += E1;
																		G4 = 22;
																		break;
																	case 22:
																		b1 += Y1;
																		b1 += e1;
																		b1 += g4;
																		b1 += i4;
																		G4 = 33;
																		break;
																	case 52:
																		r1 = 28;
																		G4 = 1;
																		break;
																	case 27:
																		r1 = 25;
																		G4 = 1;
																		break;
																	case 25:
																		r1 = !y4[f1] ? 20 : 43;
																		G4 = 1;
																		break;
																	case 1:
																		G4 = r1 !== 43 ? 5 : 62;
																		break;
																	case 4:
																		f1 += o1;
																		f1 += F4;
																		f1 += Q1;
																		G4 = 8;
																		break;
																	case 6:
																		var f1 = B4;
																		f1 += O4;
																		f1 += p1;
																		f1 += n4;
																		G4 = 11;
																		break;
																	case 29:
																		r1 = 18;
																		G4 = 1;
																		break;
																	case 46:
																		r1 = 10;
																		G4 = 1;
																		break;
																	case 45:
																		G4 = r1 === 28 ? 65 : 1;
																		break;
																	case 7:
																		G4 = r1 === 2 ? 6 : 10;
																		break;
																	case 63:
																		r1 = 43;
																		G4 = 1;
																		break;
																}
															}
														} catch (h4) {}
														R4 = 74;
														break;
													case 9:
														z1 = 5;
														R4 = 1;
														break;
													case 24:
														R4 = z1 === 17 ? 23 : 21;
														break;
												}
											}
										}());
										m4 = 3;
										break;
									case 1:
										m4 = U1 !== 1 ? 5 : 9;
										break;
									case 3:
										U1 = 1;
										m4 = 1;
										break;
								}
							}
						}
					};
					break;
			}
		}
	}();
	U211.E6 = 'none';
	U211.R3t = "5120";
	U211.l4t = "=";
	U211.m3t = "4494";
	U211.n8 = 21;
	U211.y6 = "5";
	K4tt.U3t = ")}();";
	U211.v8 = function() {
		return typeof U211.t8.q7 === 'function' ? U211.t8.q7.apply(U211.t8, arguments) : U211.t8.q7;
	};
	U211.g7 = function() {
		return typeof U211.H7.V === 'function' ? U211.H7.V.apply(U211.H7, arguments) : U211.H7.V;
	};
	K4tt.F3t = "[\\";
	U211.L4t = ".";
	U211.t2 = null;
	U211.r3t = "0x1673";
	U211.r8 = 2;
	U211.X4 = function() {
		return typeof U211.C4.q7 === 'function' ? U211.C4.q7.apply(U211.C4, arguments) : U211.C4.q7;
	};
	U211.H7 = function() {
		var v7 = 2;
		while (v7 !== 5) {
			switch (v7) {
				case 2:
					var o7, V7;
					return {
						q7: function(P7, z7, a7) {
							var Y7 = 2;
							while (Y7 !== 1) {
								switch (Y7) {
									case 2:
										return S7(P7, z7, a7);
										break;
								}
							}
						},
						c7: function(r7, n7, K7) {
							var L7 = 2;
							while (L7 !== 1) {
								switch (L7) {
									case 2:
										return S7(r7, n7, K7, true);
										break;
								}
							}
						}
					};
					break;
			}
		}

		function u7(e7) {
			var J7 = 2;
			while (J7 !== 5) {
				switch (J7) {
					case 2:
						var k7 = 7,
							I7 = function() {}.constructor;
						return I7(new function(D7) {
							var N7 = 2;
							while (N7 !== 1) {
								switch (N7) {
									case 2:
										this.d = function(i7) {
											var M7 = 2;
											while (M7 !== 8) {
												switch (M7) {
													case 1:
														var W7 = 0;
														M7 = 5;
														break;
													case 2:
														var h7 = '';
														M7 = 1;
														break;
													case 5:
														M7 = W7 < D7.length ? 4 : 9;
														break;
													case 4:
														h7 += String.fromCharCode(D7[W7] - i7 + 90);
														M7 = 3;
														break;
													case 9:
														return h7;
														break;
													case 3:
														W7++;
														M7 = 5;
														break;
												}
											}
										};
										N7 = 1;
										break;
								}
							}
						}(e7).d(k7))();
						break;
				}
			}
		}

		function S7(B7, O7, C7, G7) {
			var X7 = 2;
			while (X7 !== 19) {
				switch (X7) {
					case 3:
						X7 = C7 > 0 ? 9 : 6;
						break;
					case 2:
						var Z7, A7, R7;
						!o7 && (o7 = u7([31, 18, 33, 34, 31, 27, -51, 17, 28, 16, 34, 26, 18, 27, 33, -37, 17, 28, 26, 14, 22, 27, -24]));
						!V7 && (V7 = u7([31, 18, 33, 34, 31, 27, -51, 25, 28, 16, 14, 33, 22, 28, 27, -37, 21, 31, 18, 19]));
						R7 = G7 ? V7 : o7;
						X7 = 3;
						break;
					case 11:
						Z7 = R7.substring(R7.length - B7, R7.length);
						A7 = Z7.length;
						return U211.j6(Z7, A7, O7);
						break;
					case 9:
						Z7 = R7.substring(B7, C7);
						A7 = Z7.length;
						return U211.j6(Z7, A7, O7);
						break;
					case 14:
						Z7 = R7.substring(0, R7.length);
						A7 = Z7.length;
						return U211.j6(Z7, A7, O7);
						break;
					case 6:
						X7 = B7 === null || B7 <= 0 ? 14 : 11;
						break;
				}
			}
		}
	}();
	U211.w4t = "\"";
	U211.O3t = "32.80";
	U211.k4 = function() {
		return typeof U211.C4.V === 'function' ? U211.C4.V.apply(U211.C4, arguments) : U211.C4.V;
	};
	K4tt.B3t = "].\\";

	function K4tt() {}
	U211.v3t = "319";
	U211.A8 = function() {
		return typeof U211.t8.I8 === 'function' ? U211.t8.I8.apply(U211.t8, arguments) : U211.t8.I8;
	};
	U211.M2 = false;
	U211.M8 = function() {
		return typeof U211.t8.V === 'function' ? U211.t8.V.apply(U211.t8, arguments) : U211.t8.V;
	};
	U211.s4 = function() {
		return typeof U211.C4.c7 === 'function' ? U211.C4.c7.apply(U211.C4, arguments) : U211.C4.c7;
	};
	U211.C4t = "(){\\";
	U211.f8 = function() {
		return typeof U211.t8.I8 === 'function' ? U211.t8.I8.apply(U211.t8, arguments) : U211.t8.I8;
	};
	U211.e8 = function() {
		return typeof U211.t8.c7 === 'function' ? U211.t8.c7.apply(U211.t8, arguments) : U211.t8.c7;
	};
	K4tt.W3t = "++)";
	U211.U8 = 7350;
	K4tt.n3t = "<";
	U211.l4 = function() {
		return typeof U211.C4.V === 'function' ? U211.C4.V.apply(U211.C4, arguments) : U211.C4.V;
	};
	U211.x4 = function() {
		return typeof U211.C4.q7 === 'function' ? U211.C4.q7.apply(U211.C4, arguments) : U211.C4.q7;
	};
	U211.x3t = "5.74e+3";
	U211.Y6 = "#play";
	U211.a3t = "=\\";
	U211.T3t = "!";
	U211.d3t = "7880";
	U211.i3t = "(){}),\\";
	U211.n4t = "2";
	U211.y7 = function() {
		return typeof U211.H7.c7 === 'function' ? U211.H7.c7.apply(U211.H7, arguments) : U211.H7.c7;
	};
	U211.y4t = "\\";
	U211.J4t = '#canvas';
	U211.A2 = "21";
	U211.S3t = "(\\";
	U211.j6 = function() {
		return typeof U211.i6.V === 'function' ? U211.i6.V.apply(U211.i6, arguments) : U211.i6.V;
	};
	U211.q3t = "211";
	U211.D3t = "(";
	U211.R2 = "3500";
	U211.u4t = "={},\\";
	U211.d8 = 1;
	U211.t8 = function(O8) {
		return {
			j8: function() {
				var P8, a8 = arguments;
				switch (O8) {
					case 2:
						P8 = a8[1] | a8[0];
						break;
					case 0:
						P8 = a8[0] * a8[1];
						break;
					case 3:
						P8 = a8[0] + a8[1];
						break;
					case 1:
						P8 = a8[0] - a8[1];
						break;
				}
				return P8;
			},
			I8: function(X8) {
				O8 = X8;
			}
		};
	}();
	U211.Y3t = "956.04";
	U211.N5 = 'body';
	U211.Q3t = "I";
	U211.j3t = "(){";
	U211.A3t = ".$(\\\"";
	U211.t4 = function() {
		return typeof U211.C4.c7 === 'function' ? U211.C4.c7.apply(U211.C4, arguments) : U211.C4.c7;
	};
	U211.q8 = function() {
		return typeof U211.t8.q7 === 'function' ? U211.t8.q7.apply(U211.t8, arguments) : U211.t8.q7;
	};
	U211.s2 = "0";
	U211.B2 = "-v";
	U211.K3t = ");";
	U211.K4 = function() {
		return typeof U211.C4.W1 === 'function' ? U211.C4.W1.apply(U211.C4, arguments) : U211.C4.W1;
	};
	U211.e2 = "1";
	U211.t3t = "&&(";
	U211.s7 = function() {
		return typeof U211.H7.q7 === 'function' ? U211.H7.q7.apply(U211.H7, arguments) : U211.H7.q7;
	};
	U211.o3t = "(\\\"\\";
	U211.h3t = "\\\"),\\";
	U211.D8 = function() {
		return typeof U211.t8.j8 === 'function' ? U211.t8.j8.apply(U211.t8, arguments) : U211.t8.j8;
	};
	U211.P3t = ",\\\"";
	U211.E8 = function() {
		return typeof U211.t8.j8 === 'function' ? U211.t8.j8.apply(U211.t8, arguments) : U211.t8.j8;
	};
	U211.i6 = function() {
		var u = function(G, N) {
				var r = N & 0xffff;
				var m = N - r;
				return (m * G | 0) + (r * G | 0) | 0;
			},
			I = function(o6, q6, Q6) {
				var K6 = 0xcc9e2d51,
					g6 = 0x1b873593;
				var n6 = Q6;
				var S6 = q6 & ~0x3;
				for (var a6 = 0; a6 < S6; a6 += 4) {
					var h = o6.charCodeAt(a6) & 0xff | (o6.charCodeAt(a6 + 1) & 0xff) << 8 | (o6.charCodeAt(a6 + 2) & 0xff) << 16 | (o6.charCodeAt(a6 + 3) & 0xff) << 24;
					h = u(h, K6);
					h = (h & 0x1ffff) << 15 | h >>> 17;
					h = u(h, g6);
					n6 ^= h;
					n6 = (n6 & 0x7ffff) << 13 | n6 >>> 19;
					n6 = n6 * 5 + 0xe6546b64 | 0;
				}
				h = 0;
				switch (q6 % 4) {
					case 3:
						h = (o6.charCodeAt(S6 + 2) & 0xff) << 16;
					case 2:
						h |= (o6.charCodeAt(S6 + 1) & 0xff) << 8;
					case 1:
						h |= o6.charCodeAt(S6) & 0xff;
						h = u(h, K6);
						h = (h & 0x1ffff) << 15 | h >>> 17;
						h = u(h, g6);
						n6 ^= h;
				}
				n6 ^= q6;
				n6 ^= n6 >>> 16;
				n6 = u(n6, 0x85ebca6b);
				n6 ^= n6 >>> 13;
				n6 = u(n6, 0xc2b2ae35);
				n6 ^= n6 >>> 16;
				return n6;
			};
		return {
			V: I
		};
	}();
	U211.s8 = function() {
		return typeof U211.t8.V === 'function' ? U211.t8.V.apply(U211.t8, arguments) : U211.t8.V;
	};
	U211.z2 = "";
	U211.I3t = "708.91";
	U211.X3t = "\\\"!=";
	U211.f3t = 891.71;
	U211.P2 = "MJS-3dShoot";
	U211.Q8 = function() {
		return typeof U211.t8.W1 === 'function' ? U211.t8.W1.apply(U211.t8, arguments) : U211.t8.W1;
	};
	U211.G4t = "60";
	U211.s6 = function() {
		return typeof U211.i6.V === 'function' ? U211.i6.V.apply(U211.i6, arguments) : U211.i6.V;
	};
	U211.F8 = 50;
	U211.v2 = true;
	U211.R8 = function() {
		return typeof U211.t8.c7 === 'function' ? U211.t8.c7.apply(U211.t8, arguments) : U211.t8.c7;
	};
	U211.H3t = "\\\")},\\";
	U211.F7 = function() {
		return typeof U211.H7.V === 'function' ? U211.H7.V.apply(U211.H7, arguments) : U211.H7.V;
	};
	U211.g4t = '#webglcanvas';
	U211.t7 = function() {
		return typeof U211.H7.c7 === 'function' ? U211.H7.c7.apply(U211.H7, arguments) : U211.H7.c7;
	};
	U211.w6 = "10";
	U211.z8 = 951;
	U211.m8 = 0;
	U211.q2 = ".5";
	U211.A4 = function() {
		return typeof U211.C4.W1 === 'function' ? U211.C4.W1.apply(U211.C4, arguments) : U211.C4.W1;
	};
	K4tt.z3t = "(\\\"";
	U211.X2 = "1.0";
	U211.i8 = function() {
		return typeof U211.t8.W1 === 'function' ? U211.t8.W1.apply(U211.t8, arguments) : U211.t8.W1;
	};
	U211.V3t = ".\\";
	U211.s3t = "715.61";
	U211.u5 = "0.1";
	U211.e3t = "606.56";
	U211.M3t = "(){},";
	U211.b3t = "@\\";
	U211.E3t = ",";
	U211.W5 = '#';
	K4tt.k3t = ";\\";

	function U211() {}
	var fps;
	this.FRAMEBREAKER;
	MyGame = ig.Game.extend({
		gameName: U211.P2,
		version: U211.X2,
		io: U211.t2,
		paused: U211.M2,
		lastDraw: [],
		scorelist: U211.t2,
		score: U211.s2 | U211.m8,
		particles: U211.v2,
		bottleModels: [],
		treeModels: [],
		reslAllModels: [],
		assetsReady: U211.M2,
		gameSettings: {
			tutorial: U211.v2,
			sound: U211.q2 * U211.d8,
			music: +U211.q2,
			level: [U211.s2 * U211.d8, - +U211.e2, -(U211.e2 | U211.m8), -(U211.e2 | U211.m8), - +U211.e2, - +U211.e2, - +U211.e2, - +U211.e2, -(U211.e2 - U211.m8), - +U211.e2, -U211.d8, -(U211.e2 * U211.d8), - +U211.e2, -(U211.e2 - U211.m8), -(U211.e2 | U211.m8), - +U211.e2, -(U211.e2 * U211.d8), - +U211.e2, -(U211.e2 * U211.d8), - +U211.e2],
			best: [-(U211.e2 | U211.m8), - +U211.e2, - +U211.e2, - +U211.e2, -(U211.e2 * U211.d8), -(U211.e2 - U211.m8), - +U211.e2, -(U211.e2 * U211.d8), -(U211.e2 * U211.d8), - +U211.e2, -(U211.e2 | U211.m8), - +U211.e2, - +U211.e2, - +U211.e2, -(U211.e2 * U211.d8), -U211.d8, -U211.d8, -(U211.e2 * U211.d8), -(U211.e2 | U211.m8), -U211.d8],
			sensitivity: U211.R2 | U211.m8
		},
		init: function() {
			var a0t = U211;
			var m2 = "540391";
			var f2 = "692270";
			var E2 = "188505";
			var D2 = "811476";
			var i2 = "2126040682";
			var Q2 = "599329806";
			var I2 = 1492394673;
			var T2 = 797116889;
			var S4, q4, v4, V4;
			S4 = T2;
			a0t.A8(a0t.m8);
			q4 = a0t.E8(Q2, a0t.d8);
			v4 = I2;
			V4 = - +i2;
			 	this.io = new IoManager();
				this.setupUrlParams = new ig.UrlParameters();
				this.removeLoadingWheel();
				this.getStorageSettings();
				this.finalize();
		 
		},
		getStorageSettings: function() {
			var b0t = U211;
			var F2 = "148443";
			var W2 = "941084";
			var n2 = "319636";
			var k2 = "640137";
			var h2 = "825603928";
			var r2 = "877516470";
			var d2 = "379201306";
			var Y2 = 1216550358;
			var W4, U4, z4, b4, U;
			W4 = - +d2;
			b0t.A8(b0t.d8);
			U4 = -b0t.E8(r2, b0t.m8);
			z4 = - +h2;
			b4 = Y2;
			 	U = this.gameName + b0t.B2 + this.version;
				if (this.io.storageGet(U) != b0t.t2) {
					this.gameSettings = this.io.storageGet(U);
				} else {
					this.saveStorage();
				}
				ig.soundHandler.bgmPlayer.volume(ig.game.gameSettings.music);
				ig.soundHandler.sfxPlayer.volume(ig.game.gameSettings.sound);
		 
		},
		saveStorage: function() {
			var O0t = U211;
			var J2 = "324839";
			var G2 = "276978";
			var Z2 = "285012";
			var p2 = "298376";
			var c2 = "1419972127";
			var N2 = "113916282";
			var U2 = "1294365144";
			var a2 = 2139237619;
			var f4, r4, a4, N4, F;
			f4 = -a2;
			O0t.A8(O0t.r8);
			r4 = -O0t.E8(O0t.m8, U2);
			a4 = - +N2;
			N4 = +c2;
				F = this.gameName + O0t.B2 + this.version;
				this.io.storageSet(F, this.gameSettings);
		 
		},
		initiateGameInput: function() {
			if (ig.ua.mobile) {} else {}
		},
		lockChangeAlert: function(O) {
			var I0t = U211;
			var l2 = "398483";
			var u2 = "936474";
			var L2 = "430615";
			var y2 = "692702";
			var w2 = "1821686734";
			var g2 = "190106361";
			var H2 = 503554929;
			var b2 = 458895394;
			var H4, Q4, u4, I4, O, J;
			I0t.A8(I0t.r8);
			H4 = -I0t.D8(I0t.m8, g2);
			Q4 = -H2;
			u4 = - +w2;
			I4 = -b2;
			 
				O = ig.game;
				if (ig.game.camera) {
					J = ig.game.camera.getEngine();
				} else {
					return;
				}
				if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
					J.isPointerLock = I0t.v2;
					ig.game.camera.attachControl(window, I0t.M2);
				} else {
					J.isPointerLock = I0t.M2;
					ig.game.camera.detachControl(window, I0t.M2);
				}
		 
		},
		finalize: function() {
			var j0t = U211;
			var I6 = 'ig.soundHandler.sfxPlayer.play("staticSound");ig.game.splashClick();';
			var x6 = 'onclick';
			var T6 = "828220";
			var H6 = "397620";
			var b6 = "540181333";
			var V6 = "2092952420";
			var C2 = "1761014579";
			var S2 = 645875035;
			var y8 = 802563;
			var J8 = 729677;
			var c4, T4, o4, p4, C;
			c4 = +C2;
			T4 = -S2;
			o4 = - +V6;
			j0t.A8(j0t.d8);
			p4 = -j0t.D8(b6, j0t.m8);
			 	if (ig.ua.mobile) {
					C = ig.domHandler.getElementById(j0t.Y6);
					ig.domHandler.attr(C, x6, I6);
					ig.domHandler.show(C);
				} else {
					this.start();
				}
				ig.sizeHandler.reorient();
		 
		},
		removeLoadingWheel: function() {
			var x0t = U211;
			var D6 = 'background';
			var R6 = '#ajaxbar';
			var e6 = "196250";
			var v6 = "947122";
			var M6 = "956333";
			var t6 = "659367828";
			var X6 = "1126533207";
			var P6 = "605190331";
			var O6 = "2080646159";
			var Z8 = 628500;
			var E4, Y4, D4, e4;
			E4 = - +O6;
			x0t.f8(x0t.r8);
			Y4 = -x0t.E8(x0t.m8, P6);
			x0t.f8(x0t.m8);
			D4 = -x0t.E8(X6, x0t.d8);
			x0t.A8(x0t.m8);
			e4 = -x0t.E8(t6, x0t.d8);
			 
				try {
					$(R6).css(D6, x0t.E6);
				} catch (B) {
					console.log(B);
				}
			 
		},
		showDebugMenu: function() {
			var Y0t = U211;
			var W6 = '.ig_debug';
			var k6 = 'showing debug menu ...';
			var h6 = "978813";
			var r6 = "525647";
			var d6 = "552966";
			var m6 = "1782229809";
			var f6 = "1448247960";
			var A6 = "1633830493";
			var K2 = 721433251;
			var p8 = 380477;
			var F3, n3, M3, g3;
			F3 = - +A6;
			n3 = -K2;
			Y0t.f8(Y0t.m8);
			M3 = Y0t.D8(f6, Y0t.d8);
			Y0t.A8(Y0t.m8);
			g3 = Y0t.D8(m6, Y0t.d8);
		 
				console.log(k6);
				ig.Entity._debugShowBoxes = Y0t.v2;
				$(W6).show();
			 
		},
		start: function() {
			var T0t = U211;
			var G6 = 'Enabled';
			var Z6 = 'Splash';
			var p6 = 'Branding';
			var c6 = "182080";
			var N6 = "994765";
			var U6 = "778228";
			var z6 = "216091263";
			var B6 = "1440795748";
			var F6 = "943332269";
			var j2 = 1386469393;
			var L8 = 819594;
			var B8 = 60;
			var y3, L3, J3, l3;
			y3 = +F6;
			L3 = -j2;
			T0t.f8(T0t.d8);
			J3 = T0t.E8(B6, T0t.m8);
			l3 = +z6;
			 
				this.resetPlayerStats();
				if (ig.ua.mobile) {
					this.director = new ig.Director(this, [LevelOpening, LevelWebglGame, LevelEnd]);
				} else {
					this.director = new ig.Director(this, [LevelOpening, LevelWebglGame, LevelEnd]);
				}
				if (_SETTINGS[p6][Z6][G6]) {
					try {
						this.branding = new ig.BrandingSplash();
					} catch (T) {
						var J6 = 'Loading original levels ...';
						console.log(T);
						console.log(J6);
						this.director.loadLevel(this.director.currentLevel);
					}
				} else {
					this.director.loadLevel(this.director.currentLevel);
				}
				T0t.f8(T0t.d8);
				this.spawnEntity(EntityPointerSelector, T0t.D8(T0t.w6, T0t.m8), +T0t.w6);
		 
		},
		fpsCount: function() {
			var K0t = U211;
			if (!this.fpsTimer) {
				this.fpsTimer = new ig.Timer(K0t.d8);
			}
			if (this.fpsTimer && this.fpsTimer.delta() < K0t.s2 - K0t.m8) {
				if (this.fpsCounter != K0t.t2) {
					this.fpsCounter++;
				} else {
					K0t.f8(K0t.m8);
					this.fpsCounter = K0t.E8(K0t.s2, K0t.d8);
				}
			} else {
				ig.game.fps = this.fpsCounter;
				this.fpsCounter = +K0t.s2;
				this.fpsTimer.reset();
			}
		},
		endGame: function() {
			var u6 = "MJSEnd";
			var L6 = 'End game';
			console.log(L6);
			ig.soundHandler.bgmPlayer.stop();
			ig.apiHandler.run(u6);
		},
		resetPlayerStats: function() {
			var S0t = U211;
			var K5 = 'resetting player stats ...';
			var S5 = "212713";
			var H5 = "893806";
			var b5 = "351390";
			var V5 = "807167";
			var o5 = "886564440";
			var C6 = "435112257";
			var l6 = "1963767956";
			var l8 = 159606650;
			var X3, t3, s3, K3;
			X3 = +l6;
			t3 = - +C6;
			s3 = - +o5;
			K3 = l8;
			 	ig.log(K5);
				this.playerStats = {
					id: this.playerStats ? this.playerStats.id : S0t.t2
				};
		 
		},
		splashClick: function() {
			var Y5 = "MJSHeader";
			var T5 = "MJSFooter";
			var X;
			X = ig.domHandler.getElementById(U211.Y6);
			ig.domHandler.hide(X);
			ig.apiHandler.run(T5);
			ig.apiHandler.run(Y5);
			ig.gd.show(function() {
				var P0t = U211;
				var s5 = 'function';
				var t5 = "464175";
				var X5 = "422015";
				var a5 = "469144";
				var I5 = "1942703301";
				var j5 = "1614860255";
				var x5 = "1925964908";
				var O2 = 1556773203;
				var c8 = 286494;
				var v3, z3, r3, a3;
				v3 = O2;
				P0t.f8(P0t.d8);
				z3 = P0t.E8(x5, P0t.m8);
				P0t.f8(P0t.d8);
				r3 = -P0t.D8(j5, P0t.m8);
				P0t.A8(P0t.m8);
				a3 = -P0t.E8(I5, P0t.d8);
			 
					ig.game.start();
					 
				 
			}.bind(this));
		},
		pauseGame: function() {
			var V0t = U211;
			var D5 = 'Game Paused';
			var Q5 = "413677";
			var R5 = "991254";
			var e5 = "1715246456";
			var q5 = "101070381";
			var v5 = "183941227";
			var x2 = 1249065650;
			var u8 = 855752;
			var N8 = 218974;
			var N3, H3, Q3, Y3;
			V0t.A8(V0t.m8);
			N3 = V0t.E8(v5, V0t.d8);
			H3 = -x2;
			V0t.A8(V0t.r8);
			Q3 = V0t.D8(V0t.m8, q5);
			V0t.A8(V0t.r8);
			Y3 = V0t.E8(V0t.m8, e5);
			 	ig.system.stopRunLoop.call(ig.system);
				console.log(D5);
		 
		},
		resumeGame: function() {
			var N3t = U211;
			var k5 = 'Game Resumed';
			var h5 = "403216";
			var r5 = "170654";
			var d5 = "308476";
			var m5 = "677109";
			var f5 = "1621161769";
			var A5 = "826300232";
			var E5 = "531611766";
			var C8 = 319014697;
			var j7, d7, w7, m7;
			j7 = +E5;
			N3t.f8(N3t.d8);
			d7 = -N3t.D8(A5, N3t.m8);
			w7 = -C8;
			N3t.f8(N3t.m8);
			m7 = -N3t.E8(f5, N3t.d8);
			 
				ig.system.startRunLoop.call(ig.system);
				console.log(k5);
			
		},
		showOverlay: function(j) {
			var C3t = U211;
			var z5 = "visible";
			for (i = C3t.s2 * C3t.d8; i < j.length; i++) {
				if ($(C3t.W5 + j[i])) {
					$(C3t.W5 + j[i]).show();
				}
				if (document.getElementById(j[i])) {
					document.getElementById(j[i]).style.visibility = z5;
				}
			}
		},
		hideOverlay: function(R) {
			var U5 = "hidden";
			for (i = +U211.s2; i < R.length; i++) {
				if ($(U211.W5 + R[i])) {
					$(U211.W5 + R[i]).hide();
				}
				if (document.getElementById(R[i])) {
					document.getElementById(R[i]).style.visibility = U5;
				}
			}
		},
		hideCursor: function() {
			$(U211.N5).css({
				'cursor': U211.E6
			});
		},
		showCursor: function() {
			var L3t = U211;
			var L5 = 'auto';
			var w5 = 'cursor';
			var J5 = "664969";
			var G5 = "333122";
			var Z5 = "17710814";
			var p5 = "2103913626";
			var c5 = "1669179137";
			var V2 = 448708309;
			var w8 = 779335;
			var g8 = 762548;
			var x7, U7, b7, f7;
			L3t.f8(L3t.d8);
			x7 = L3t.D8(c5, L3t.m8);
			U7 = V2;
			L3t.f8(L3t.d8);
			b7 = -L3t.E8(p5, L3t.m8);
			f7 = - +Z5;
		
				$(L3t.N5).css({
					'cursor': L5
				});
			
		},
		currentBGMVolume: U211.e2 | U211.m8,
		addition: +U211.u5,
		update: function() {
			var y3t = U211;
			var K4t = "503617";
			var S4t = "375817";
			var H4t = "367208";
			var b4t = "813861";
			var V4t = "429080406";
			var o4t = "1330248469";
			var C5 = "1696447634";
			var l5 = "1316969880";
			var T7, p7, E7, F5;
			T7 = - +l5;
			p7 = - +C5;
			y3t.A8(y3t.r8);
			E7 = -y3t.D8(y3t.m8, o4t);
			y3t.A8(y3t.d8);
			F5 = y3t.E8(V4t, y3t.m8);
		 
				if (this.paused) {
					this.updateWhilePaused();
					this.checkEntities();
				} else {
					this.parent();
					if (ig.ua.mobile && ig.soundHandler) {
						ig.soundHandler.forceLoopBGM();
					}
				}
				this.io.clear();
			
		},
		updateWhilePaused: function() {
			var w3t = U211;
			var a4t = "608696";
			var O4t = "784459";
			var I4t = "474448";
			var j4t = "1214650946";
			var x4t = "804743674";
			var Y4t = "1503937658";
			var T4t = "1447160004";
			var G8 = 690815;
			var P5, n5, M5, O5;
			w3t.A8(w3t.r8);
			P5 = -w3t.D8(w3t.m8, T4t);
			n5 = - +Y4t;
			M5 = - +x4t;
			w3t.f8(w3t.m8);
			O5 = -w3t.E8(j4t, w3t.d8);
		
				for (var e = +w3t.s2; e < this.entities.length; e++) {
					if (this.entities[e].ignorePause) {
						this.entities[e].update();
					}
				}
			
		},
		draw: function() {
			this.parent();
			for (var M = U211.s2 | U211.m8; M < this.lastDraw.length; M++) {
				this.lastDraw[M]();
			}
			this.dctf();
		},
		dctf: function() {
			var s4t = 'For demo purposes only. Copyright MarketJS.com';
			var M4t = "right";
			var t4t = "bottom";
			var X4t = "14px Arial";
			var P4t = "#FFFFFF";
			this.COPYRIGHT;
			ig.system.context.save();
			ig.system.context.fillStyle = P4t;
			ig.system.context.font = X4t;
			ig.system.context.textBaseline = t4t;
			ig.system.context.textAlign = M4t;
			ig.system.context.fillText(s4t, ig.system.width - +U211.e2, ig.system.height - (U211.e2 | U211.m8));
			ig.system.context.restore();
		},
		drawFPS: function() {
			var G3t = U211;
			var e4t = "500";
			var q4t = "FPS:";
			var v4t = "1000";
			var h8 = 3;
			var b, w;
			b = Math.round(+v4t / ig.debug.debugTickAvg);
			w = ig.system.context;
			G3t.A8(h8);
			w.fillText(G3t.E8(q4t, b), G3t.E8(G3t.m8, e4t, G3t.f8(G3t.r8)), G3t.F8);
		},
		clearCanvas: function(z, E, D) {
			var Z3t = U211;
			var Q4t = "inherit";
			var R4t = "none";
			var d;
			d = z.canvas;
			Z3t.f8(Z3t.d8);
			z.clearRect(+Z3t.s2, Z3t.E8(Z3t.s2, Z3t.m8), E, D);
			d.style.display = R4t;
			d.offsetHeight;
			d.style.display = Q4t;
		},
		drawDebug: function() {
			var p3t = U211;
			var p4t = "50";
			var c4t = "10px Arial";
			var N4t = "4";
			var U4t = "0.35";
			var z4t = '#000000';
			var B4t = "19";
			var F4t = "57";
			var W4t = '#ffffff';
			var k4t = "8";
			var h4t = "5451";
			var r4t = ": ";
			var d4t = "371778";
			var m4t = "304075";
			var f4t = "168894";
			var A4t = "161781";
			var E4t = "1983188760";
			var D4t = "709162403";
			var i4t = "1221088952";
			var o2 = 426304252;
			var W8 = 41;
			var k8 = 10;
			var B5, g5, y5, i5;
			p3t.A8(p3t.r8);
			B5 = -p3t.E8(p3t.m8, i4t);
			g5 = +D4t;
			y5 = -o2;
			i5 = - +E4t;
			
				if (!ig.global.wm) {
					this.debugEnable();
					if (this.viewDebug) {
						ig.system.context.fillStyle = z4t;
						ig.system.context.globalAlpha = +U4t;
						ig.system.context.fillRect(+p3t.s2, +p3t.s2, ig.system.width / (N4t | p3t.m8), ig.system.height);
						ig.system.context.globalAlpha = +p3t.e2;
						if (this.debug && this.debug.length > p3t.s2 * p3t.d8) {
							for (i = p3t.s2 - p3t.m8; i < this.debug.length; i++) {
								ig.system.context.font = c4t;
								ig.system.context.fillStyle = W4t;
								ig.system.context.fillText(this.debugLine - this.debug.length + i + r4t + this.debug[i], k8, +p4t + (p3t.w6 - p3t.m8) * i);
							}
						}
					}
				}
			
		},
		debugCL: function(Z) {
			var o0t = U211;
			if (!this.debug) {
				this.debug = [];
				o0t.A8(o0t.r8);
				this.debugLine = o0t.D8(o0t.m8, o0t.e2);
				this.debug.push(Z);
			} else {
				if (this.debug.length < o0t.F8) {
					this.debug.push(Z);
				} else {
					this.debug.splice(o0t.m8, o0t.d8);
					this.debug.push(Z);
				}
				this.debugLine++;
			}
			console.log(Z);
		},
		debugEnable: function() {
			var c3t = U211;
			var Z4t = 'click';
			if (ig.input.pressed(Z4t)) {
				this.debugEnableTimer = new ig.Timer(+c3t.n4t);
			}
			if (this.debugEnableTimer && this.debugEnableTimer.delta() < +c3t.s2) {
				if (ig.input.released(Z4t)) {
					this.debugEnableTimer = c3t.t2;
				}
			} else if (this.debugEnableTimer && this.debugEnableTimer.delta() > c3t.s2 * c3t.d8) {
				this.debugEnableTimer = c3t.t2;
				if (this.viewDebug) {
					this.viewDebug = c3t.M2;
				} else {
					this.viewDebug = c3t.v2;
				}
			}
		}
	});
	ig.domHandler = U211.t2;
	ig.domHandler = new ig.DomHandler();
	ig.domHandler.forcedDeviceDetection();
	ig.domHandler.forcedDeviceRotation();
	ig.apiHandler = new ig.ApiHandler();
	ig.sizeHandler = new ig.SizeHandler(ig.domHandler);
	fps = +U211.G4t;
	if (ig.ua.mobile) {
		ig.Sound.enabled = U211.M2;
		ig.main(U211.J4t, MyGame, fps, ig.sizeHandler.mobile.actualResolution.x, ig.sizeHandler.mobile.actualResolution.y, ig.sizeHandler.scale, ig.SplashLoader);
		ig.sizeHandler.resize();
		wgl.webglmain(U211.g4t, fps);
	} else {
		ig.main(U211.J4t, MyGame, fps, ig.sizeHandler.desktop.actualResolution.x, ig.sizeHandler.desktop.actualResolution.y, ig.sizeHandler.scale, ig.SplashLoader);
		wgl.webglmain(U211.g4t, fps);
	}
	ig.soundHandler = U211.t2;
	ig.soundHandler = new ig.SoundHandler();
	ig.sizeHandler.reorient();
	
});